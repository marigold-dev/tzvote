{"version":3,"sources":["EphemeralState.ts","TaqError.ts","Base.ts"],"sourcesContent":["import {\n\tCommand,\n\tConfig,\n\tInstalledPlugin,\n\tNonEmptyString,\n\tOption,\n\tParsedOperation,\n\tParsedTemplate,\n\tPluginInfo,\n\tPluginResponseEncoding,\n\tTask,\n\tVerb,\n} from '@taqueria/protocol';\nimport createType from './Base';\nimport type { i18n } from './i18n';\nimport { E_TaqError, TaqError } from './TaqError';\nimport { attemptP, FutureInstance as Future, mapRej, promise } from 'fluture';\nimport { z } from 'zod';\n\nconst eager = <T>(f: Future<TaqError, T>) =>\n\tpromise(\n\t\tmapRej((err: TaqError) => new E_TaqError(err))(f),\n\t);\n\nconst taskToPluginMap = z.record(\n\tz.union([\n\t\tInstalledPlugin.schemas.schema,\n\t\tTask.schemas.schema,\n\t], { description: 'Task/Plugin Mapping' }),\n);\nconst operationToPluginMap = z.record(\n\tz.union([\n\t\tInstalledPlugin.schemas.schema,\n\t\tParsedOperation.schemas.schema,\n\t], { description: 'Operation/Plugin Mapping' }),\n);\n\nconst templateToPluginMap = z.record(\n\tz.union([\n\t\tInstalledPlugin.schemas.schema,\n\t\tParsedTemplate.schemas.schema,\n\t]),\n);\n\nconst rawSchema = z.object({\n\tbuild: z.string({ description: 'cache.build' }),\n\tconfigHash: z.string({ description: 'cache.configHash' }),\n\ttasks: taskToPluginMap,\n\toperations: operationToPluginMap,\n\ttemplates: templateToPluginMap,\n\tplugins: z.array(PluginInfo.schemas.schema, { description: 'cache.plugins' }),\n}).describe('Ephemeral State');\n\ntype RawInput = z.infer<typeof rawSchema>;\n\nexport const { schemas: generatedSchemas, factory } = createType<RawInput, RawInput>({\n\trawSchema,\n\tparseErrMsg: (value: unknown) => `${value} is not a valid representation of ephemeral state`,\n\tunknownErrMsg: 'Something went wrong when parsing the ephemeral state',\n});\n\nexport type EphemeralState = z.infer<typeof generatedSchemas.schema>;\nexport type t = EphemeralState;\nexport type TaskToPluginMap = z.infer<typeof taskToPluginMap>;\nexport type OpToPluginMap = z.infer<typeof operationToPluginMap>;\nexport type TemplateToPluginMap = z.infer<typeof templateToPluginMap>;\n\nexport const { create, of, make } = factory;\n\nexport const schemas = {\n\t...generatedSchemas,\n\tschema: generatedSchemas.schema.transform(val => val as EphemeralState),\n};\n\n/**\n * Private functions\n */\ntype Counts = Record<Verb.t, PluginInfo.t[]>;\nconst getTaskCounts = (pluginInfo: PluginInfo.t[]): Counts => {\n\treturn pluginInfo.reduce(\n\t\t(retval, pluginInfo) =>\n\t\t\tpluginInfo.tasks === undefined\n\t\t\t\t? {}\n\t\t\t\t: pluginInfo.tasks.reduce(\n\t\t\t\t\t(retval: Counts, task: Task.t) => {\n\t\t\t\t\t\tconst taskName = task.task;\n\t\t\t\t\t\tconst providers: PluginInfo.t[] = retval[taskName]\n\t\t\t\t\t\t\t? [...retval[taskName], pluginInfo]\n\t\t\t\t\t\t\t: [pluginInfo];\n\t\t\t\t\t\tconst mapping: Counts = {};\n\t\t\t\t\t\tmapping[taskName] = providers.filter(provider => provider !== undefined);\n\t\t\t\t\t\treturn { ...retval, ...mapping };\n\t\t\t\t\t},\n\t\t\t\t\tretval,\n\t\t\t\t),\n\t\t{} as Counts,\n\t);\n};\n\nconst getTemplateCounts = (pluginInfo: PluginInfo.t[]): Counts => {\n\treturn pluginInfo.reduce(\n\t\t(retval, pluginInfo) =>\n\t\t\t!pluginInfo.templates\n\t\t\t\t? retval\n\t\t\t\t: pluginInfo.templates.reduce(\n\t\t\t\t\t(retval: Counts, template: ParsedTemplate.t) => {\n\t\t\t\t\t\tconst templateName = template.template;\n\t\t\t\t\t\tconst providers = retval[templateName]\n\t\t\t\t\t\t\t? [...retval[templateName], pluginInfo]\n\t\t\t\t\t\t\t: [pluginInfo];\n\t\t\t\t\t\tconst mapping: Counts = {};\n\t\t\t\t\t\tmapping[templateName] = providers.filter(provider => provider !== undefined);\n\t\t\t\t\t\treturn { ...retval, ...mapping };\n\t\t\t\t\t},\n\t\t\t\t\tretval,\n\t\t\t\t),\n\t\t{} as Counts,\n\t);\n};\n\nconst getOperationCounts = (pluginInfo: PluginInfo.t[]): Counts => {\n\treturn pluginInfo.reduce(\n\t\t(retval, pluginInfo) =>\n\t\t\tpluginInfo.operations === undefined\n\t\t\t\t? retval\n\t\t\t\t: pluginInfo.operations.reduce(\n\t\t\t\t\t(retval: Counts, operation: ParsedOperation.t) => {\n\t\t\t\t\t\tconst operationName = operation.operation;\n\t\t\t\t\t\tconst providers = retval[operationName]\n\t\t\t\t\t\t\t? [...retval[operationName], pluginInfo]\n\t\t\t\t\t\t\t: [pluginInfo];\n\t\t\t\t\t\tconst mapping: Counts = {};\n\t\t\t\t\t\tmapping[operationName] = providers.filter(provider => provider !== undefined);\n\t\t\t\t\t\treturn { ...retval, ...mapping };\n\t\t\t\t\t},\n\t\t\t\t\tretval,\n\t\t\t\t),\n\t\t{} as Counts,\n\t);\n};\n\nconst toChoices = (plugins: PluginInfo.t[]) =>\n\tplugins.reduce(\n\t\t(retval, pluginInfo) => {\n\t\t\treturn [...retval, pluginInfo.name as NonEmptyString.t, pluginInfo.alias as NonEmptyString.t];\n\t\t},\n\t\t[] as NonEmptyString.t[],\n\t);\n\nconst isComposite = (name: Verb.t, counts: Counts) => counts[name] && counts[name].length > 1;\n\nconst getInstalledPlugin = (config: Config.t, name: string) =>\n\tconfig.plugins?.find(\n\t\t(plugin: InstalledPlugin.t) => [`taqueria-plugin-${name}`, name].includes(plugin.name),\n\t);\n\nexport const mapTasksToPlugins = (config: Config.t, pluginInfo: PluginInfo.t[], i18n: i18n) => {\n\tconst taskCounts = getTaskCounts(pluginInfo);\n\treturn attemptP<TaqError, TaskToPluginMap>(async () =>\n\t\tawait pluginInfo.reduce(\n\t\t\tasync (retval, pluginInfo) =>\n\t\t\t\t!pluginInfo.tasks\n\t\t\t\t\t? Promise.resolve({} as TaskToPluginMap)\n\t\t\t\t\t: await pluginInfo.tasks.reduce(\n\t\t\t\t\t\tasync (retval, { task, hidden }) => {\n\t\t\t\t\t\t\tif (isComposite(task, taskCounts)) {\n\t\t\t\t\t\t\t\tconst command = await eager(Command.make(task));\n\t\t\t\t\t\t\t\tconst compositeTask = await eager(Task.make({\n\t\t\t\t\t\t\t\t\ttask,\n\t\t\t\t\t\t\t\t\tcommand,\n\t\t\t\t\t\t\t\t\tdescription: await eager(NonEmptyString.make(i18n.__('providedByMany'))),\n\t\t\t\t\t\t\t\t\thidden,\n\t\t\t\t\t\t\t\t\toptions: [\n\t\t\t\t\t\t\t\t\t\tawait eager(Option.make({\n\t\t\t\t\t\t\t\t\t\t\tflag: await eager(Verb.make('plugin')),\n\t\t\t\t\t\t\t\t\t\t\tdescription: await eager(\n\t\t\t\t\t\t\t\t\t\t\t\tNonEmptyString.make('Specify which plugin should be used to execute this task'),\n\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\tchoices: toChoices(taskCounts[task]),\n\t\t\t\t\t\t\t\t\t\t\trequired: true,\n\t\t\t\t\t\t\t\t\t\t})),\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\thandler: 'proxy',\n\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t\treturn { ...await retval, [task]: compositeTask };\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Task is provided by just a single plugin\n\t\t\t\t\t\t\tconst installedPlugin = getInstalledPlugin(config, pluginInfo.name);\n\t\t\t\t\t\t\treturn installedPlugin\n\t\t\t\t\t\t\t\t? { ...await retval, [task]: installedPlugin }\n\t\t\t\t\t\t\t\t: retval;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tretval,\n\t\t\t\t\t),\n\t\t\tPromise.resolve({} as TaskToPluginMap),\n\t\t)\n\t).pipe(mapRej(rej => rej as TaqError));\n};\n\nexport const mapOperationsToPlugins = (config: Config.t, pluginInfo: PluginInfo.t[], i18n: i18n) => {\n\tconst opCounts = getOperationCounts(pluginInfo);\n\treturn attemptP(async () =>\n\t\tawait pluginInfo.reduce(\n\t\t\tasync (retval, pluginInfo) =>\n\t\t\t\t!pluginInfo.operations\n\t\t\t\t\t? Promise.resolve({} as OpToPluginMap)\n\t\t\t\t\t: await pluginInfo.operations.reduce(\n\t\t\t\t\t\tasync (retval, { operation }) => {\n\t\t\t\t\t\t\tif (isComposite(operation, opCounts)) {\n\t\t\t\t\t\t\t\tconst command = await eager(Command.make(operation));\n\t\t\t\t\t\t\t\tconst compositeOp = await eager(ParsedOperation.make({\n\t\t\t\t\t\t\t\t\toperation,\n\t\t\t\t\t\t\t\t\tcommand,\n\t\t\t\t\t\t\t\t\tdescription: await eager(NonEmptyString.make(i18n.__('providedByMany'))),\n\t\t\t\t\t\t\t\t\toptions: [\n\t\t\t\t\t\t\t\t\t\tawait eager(Option.make({\n\t\t\t\t\t\t\t\t\t\t\tflag: await eager(Verb.make('plugin')),\n\t\t\t\t\t\t\t\t\t\t\tdescription: await eager(\n\t\t\t\t\t\t\t\t\t\t\t\tNonEmptyString.make('Specify which plugin should be used to execute this operation'),\n\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\tchoices: toChoices(opCounts[operation]),\n\t\t\t\t\t\t\t\t\t\t\trequired: true,\n\t\t\t\t\t\t\t\t\t\t})),\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t\treturn { ...await retval, [operation]: compositeOp };\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Operation is provided by just a single plugin\n\t\t\t\t\t\t\tconst installedPlugin = getInstalledPlugin(config, pluginInfo.name);\n\t\t\t\t\t\t\treturn installedPlugin\n\t\t\t\t\t\t\t\t? { ...await retval, [operation]: installedPlugin }\n\t\t\t\t\t\t\t\t: retval;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tretval,\n\t\t\t\t\t),\n\t\t\tPromise.resolve({} as OpToPluginMap),\n\t\t)\n\t).pipe(mapRej(rej => rej as TaqError));\n};\n\nexport const mapTemplatesToPlugins = (config: Config.t, pluginInfo: PluginInfo.t[], i18n: i18n) => {\n\tconst tmplCounts = getTemplateCounts(pluginInfo);\n\treturn attemptP<TaqError, TemplateToPluginMap>(async () =>\n\t\tawait pluginInfo.reduce(\n\t\t\tasync (retval, pluginInfo) =>\n\t\t\t\t!pluginInfo.templates\n\t\t\t\t\t? Promise.resolve({} as TemplateToPluginMap)\n\t\t\t\t\t: await pluginInfo.templates!.reduce(\n\t\t\t\t\t\tasync (retval, { template, hidden }) => {\n\t\t\t\t\t\t\tif (isComposite(template, tmplCounts)) {\n\t\t\t\t\t\t\t\tconst command = await eager(Command.make(template));\n\t\t\t\t\t\t\t\tconst description = await eager(NonEmptyString.of(i18n.__('providedByMany')));\n\t\t\t\t\t\t\t\tconst compositeTmpl = await eager(ParsedTemplate.make({\n\t\t\t\t\t\t\t\t\ttemplate,\n\t\t\t\t\t\t\t\t\tcommand,\n\t\t\t\t\t\t\t\t\tdescription,\n\t\t\t\t\t\t\t\t\toptions: [\n\t\t\t\t\t\t\t\t\t\tawait eager(Option.make({\n\t\t\t\t\t\t\t\t\t\t\tflag: await eager(Verb.make('plugin')),\n\t\t\t\t\t\t\t\t\t\t\tdescription: await eager(\n\t\t\t\t\t\t\t\t\t\t\t\tNonEmptyString.make('Specify which plugin should be used to execute this task'),\n\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\tchoices: toChoices(tmplCounts[template]),\n\t\t\t\t\t\t\t\t\t\t\trequired: true,\n\t\t\t\t\t\t\t\t\t\t})),\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\thandler: 'proxy',\n\t\t\t\t\t\t\t\t\tencoding: PluginResponseEncoding.create('none'),\n\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t\treturn { ...await retval, [template]: compositeTmpl };\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Template is provided by just a single plugin\n\t\t\t\t\t\t\tconst installedPlugin = getInstalledPlugin(config, pluginInfo.name);\n\t\t\t\t\t\t\treturn installedPlugin\n\t\t\t\t\t\t\t\t? { ...await retval, [template]: installedPlugin }\n\t\t\t\t\t\t\t\t: retval;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tretval,\n\t\t\t\t\t),\n\t\t\tPromise.resolve({} as TemplateToPluginMap),\n\t\t)\n\t).pipe(mapRej(rej => rej as TaqError));\n};\n\nexport const getTasks = (pluginInfo: PluginInfo.t[]) =>\n\tpluginInfo.reduce(\n\t\t(retval: Task.t[], pluginInfo) => [...retval, ...(pluginInfo.tasks ?? [])],\n\t\t[],\n\t);\n","import { map, reject } from 'fluture';\nimport { ZodError } from 'zod';\n\nexport type ErrorType =\n\t| 'E_INVALID_PATH_DOES_NOT_EXIST'\n\t| 'E_INVALID_PATH_EXISTS_AND_NOT_AN_EMPTY_DIR'\n\t| 'E_INVALID_PATH_ALREADY_EXISTS'\n\t| 'E_INVALID_CONFIG'\n\t| 'E_INVALID_JSON'\n\t| 'E_FORK'\n\t| 'E_INVALID_TASK'\n\t| 'E_READFILE'\n\t| 'E_NPM_INIT'\n\t| 'E_INVALID_PLUGIN_RESPONSE'\n\t| 'E_INVALID_ARGS'\n\t| 'E_MKDIR_FAILED'\n\t| 'E_GIT_CLONE_FAILED'\n\t| 'E_PROVISION'\n\t| 'E_PARSE'\n\t| 'E_PARSE_UNKNOWN'\n\t| 'E_INVALID_ARCH'\n\t| 'E_NO_PROVISIONS'\n\t| 'E_INTERNAL_LOGICAL_VALIDATION_FAILURE'\n\t| 'E_EXEC'\n\t| 'E_OPT_IN_WARNING'\n\t| 'E_INVALID_OPTION'\n\t| 'E_TAQ_PROJECT_NOT_FOUND';\n\nexport interface TaqError {\n\treadonly kind: ErrorType;\n\tmsg: string;\n\tprevious?: TaqError | Error | unknown;\n\tcontext?: unknown;\n}\n\nexport type t = TaqError;\n\nexport class E_TaqError extends Error {\n\treadonly context;\n\treadonly kind;\n\treadonly previous;\n\tconstructor(taqErr: TaqError) {\n\t\tsuper(taqErr.msg);\n\t\tthis.context = taqErr.context;\n\t\tthis.kind = taqErr.kind;\n\t\tthis.name = this.kind;\n\t\tthis.previous = taqErr.previous;\n\t}\n}\n\nexport const toFutureParseErr = <T>(previous: ZodError, msg: string, context?: unknown) =>\n\treject(toParseErr(previous, msg, context))\n\t\t.pipe(map((val: unknown) => val as T));\n\nexport const toParseErr = (previous: ZodError, msg: string, context?: unknown) =>\n\tcreate({\n\t\tkind: 'E_PARSE',\n\t\tmsg: msg,\n\t\tcontext,\n\t\tprevious,\n\t});\n\nexport const toParseUnknownErr = (previous: Error | TaqError | E_TaqError | unknown, msg: string, context?: unknown) =>\n\tcreate({\n\t\tkind: 'E_PARSE_UNKNOWN',\n\t\tmsg: msg,\n\t\tcontext,\n\t\tprevious,\n\t});\n\nexport const toFutureParseUnknownErr = <T>(\n\tprevious: Error | TaqError | E_TaqError | unknown,\n\tmsg: string,\n\tcontext?: unknown,\n) =>\n\treject(toParseUnknownErr(previous, msg, context))\n\t\t.pipe(map((val: unknown) => val as T));\n\nexport const create = (err: TaqError) => err;\n","import { toFutureParseErr, toFutureParseUnknownErr } from './TaqError';\nimport { FutureInstance, resolve } from 'fluture';\nimport { z, ZodError, ZodSchema } from 'zod';\n\ntype Future<L, R> = FutureInstance<L, R>;\n\ntype ErrMsg = string | ((value: unknown, previous?: unknown) => string);\n\ninterface CreateSchemaParams {\n\trawSchema: ZodSchema;\n\tinternalSchema?: ZodSchema;\n\ttransformer?: (value: unknown) => unknown;\n\tisStringLike?: boolean;\n}\n\ninterface CreateTypeParams extends CreateSchemaParams {\n\tparseErrMsg: ErrMsg;\n\tunknownErrMsg: ErrMsg;\n}\nexport type Flatten<T> = { [k in keyof T]: T[k] };\n\nexport const createSchema = <I>(params: CreateSchemaParams) => {\n\tconst { rawSchema, isStringLike } = params;\n\tconst internalSchema = params.internalSchema ?? params.rawSchema;\n\tconst noop = (val: unknown) => val;\n\tconst transformer = params.transformer ?? noop;\n\n\tconst schema = isStringLike\n\t\t? internalSchema\n\t\t\t.transform((val: unknown) =>\n\t\t\t\ttransformer(val) as I & {\n\t\t\t\t\treadonly __type: 'generated' & z.infer<typeof internalSchema>;\n\t\t\t\t}\n\t\t\t)\n\t\t: internalSchema\n\t\t\t.transform((val: unknown) =>\n\t\t\t\ttransformer(val) as Flatten<\n\t\t\t\t\tI & {\n\t\t\t\t\t\treadonly __type: 'generated' & z.infer<typeof internalSchema>;\n\t\t\t\t\t}\n\t\t\t\t>\n\t\t\t);\n\n\ttype GeneratedSchema = typeof schema;\n\n\treturn {\n\t\trawSchema,\n\t\tinternalSchema,\n\t\tschema,\n\t};\n};\n\n// TODO:\n// TypeScript appears to have a bug with default generic values\n// For instance, I'd like to use this:\n// export const createType = <R, I = R>(params: CreateTypeParams) => {\n//\n// However, I == unknown when having I default to R if no I was given.\n// So, we need to require R and I explicitly\nexport const createType = <R, I>(params: CreateTypeParams) => {\n\tconst schemas = createSchema<I>(params);\n\tconst { parseErrMsg, unknownErrMsg } = params;\n\n\ttype T = z.infer<typeof schemas.schema>;\n\n\tconst internalOf = (input: unknown) => {\n\t\ttry {\n\t\t\treturn resolve<T>(schemas.schema.parse(input));\n\t\t} catch (previous) {\n\t\t\tconst parseMsg = typeof parseErrMsg === 'string'\n\t\t\t\t? parseErrMsg\n\t\t\t\t: parseErrMsg(input, previous);\n\n\t\t\tconst unknownMsg = typeof unknownErrMsg === 'string'\n\t\t\t\t? unknownErrMsg\n\t\t\t\t: unknownErrMsg(input);\n\n\t\t\tif (previous instanceof ZodError) {\n\t\t\t\treturn toFutureParseErr<T>(previous, parseMsg, input);\n\t\t\t}\n\t\t\treturn toFutureParseUnknownErr<T>(previous, unknownMsg, input);\n\t\t}\n\t};\n\tconst of = internalOf;\n\n\tconst make = (input: I) => internalOf(input);\n\n\tconst create = (input: R | I) => schemas.schema.parse(input) as T;\n\n\tconst from = (input: unknown) => schemas.schema.parse(input) as T;\n\n\tconst factory = {\n\t\tmake,\n\t\tof,\n\t\tcreate,\n\t\tfrom,\n\t};\n\n\treturn {\n\t\tschemas,\n\t\tfactory,\n\t};\n};\n\nexport default createType;\n"],"mappings":"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","names":["create","import_fluture","rawSchema","schemas","of","make","create","factory","import_fluture","import_zod","create","pluginInfo","retval"]}