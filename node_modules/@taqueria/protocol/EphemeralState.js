"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// EphemeralState.ts
var EphemeralState_exports = {};
__export(EphemeralState_exports, {
  create: () => create2,
  factory: () => factory,
  generatedSchemas: () => generatedSchemas,
  getTasks: () => getTasks,
  make: () => make,
  mapOperationsToPlugins: () => mapOperationsToPlugins,
  mapTasksToPlugins: () => mapTasksToPlugins,
  mapTemplatesToPlugins: () => mapTemplatesToPlugins,
  of: () => of,
  schemas: () => schemas
});
module.exports = __toCommonJS(EphemeralState_exports);
var import_protocol = require("@taqueria/protocol");

// TaqError.ts
var import_fluture = require("fluture");
var E_TaqError = class extends Error {
  constructor(taqErr) {
    super(taqErr.msg);
    this.context = taqErr.context;
    this.kind = taqErr.kind;
    this.name = this.kind;
    this.previous = taqErr.previous;
  }
};
var toFutureParseErr = (previous, msg, context) => (0, import_fluture.reject)(toParseErr(previous, msg, context)).pipe((0, import_fluture.map)((val) => val));
var toParseErr = (previous, msg, context) => create({
  kind: "E_PARSE",
  msg,
  context,
  previous
});
var toParseUnknownErr = (previous, msg, context) => create({
  kind: "E_PARSE_UNKNOWN",
  msg,
  context,
  previous
});
var toFutureParseUnknownErr = (previous, msg, context) => (0, import_fluture.reject)(toParseUnknownErr(previous, msg, context)).pipe((0, import_fluture.map)((val) => val));
var create = (err) => err;

// Base.ts
var import_fluture2 = require("fluture");
var import_zod = require("zod");
var createSchema = (params) => {
  var _a, _b;
  const { rawSchema: rawSchema2, isStringLike } = params;
  const internalSchema = (_a = params.internalSchema) != null ? _a : params.rawSchema;
  const noop = (val) => val;
  const transformer = (_b = params.transformer) != null ? _b : noop;
  const schema = isStringLike ? internalSchema.transform(
    (val) => transformer(val)
  ) : internalSchema.transform(
    (val) => transformer(val)
  );
  return {
    rawSchema: rawSchema2,
    internalSchema,
    schema
  };
};
var createType = (params) => {
  const schemas2 = createSchema(params);
  const { parseErrMsg, unknownErrMsg } = params;
  const internalOf = (input) => {
    try {
      return (0, import_fluture2.resolve)(schemas2.schema.parse(input));
    } catch (previous) {
      const parseMsg = typeof parseErrMsg === "string" ? parseErrMsg : parseErrMsg(input, previous);
      const unknownMsg = typeof unknownErrMsg === "string" ? unknownErrMsg : unknownErrMsg(input);
      if (previous instanceof import_zod.ZodError) {
        return toFutureParseErr(previous, parseMsg, input);
      }
      return toFutureParseUnknownErr(previous, unknownMsg, input);
    }
  };
  const of2 = internalOf;
  const make2 = (input) => internalOf(input);
  const create3 = (input) => schemas2.schema.parse(input);
  const from = (input) => schemas2.schema.parse(input);
  const factory2 = {
    make: make2,
    of: of2,
    create: create3,
    from
  };
  return {
    schemas: schemas2,
    factory: factory2
  };
};
var Base_default = createType;

// EphemeralState.ts
var import_fluture3 = require("fluture");
var import_zod2 = require("zod");
var eager = (f) => (0, import_fluture3.promise)(
  (0, import_fluture3.mapRej)((err) => new E_TaqError(err))(f)
);
var taskToPluginMap = import_zod2.z.record(
  import_zod2.z.union([
    import_protocol.InstalledPlugin.schemas.schema,
    import_protocol.Task.schemas.schema
  ], { description: "Task/Plugin Mapping" })
);
var operationToPluginMap = import_zod2.z.record(
  import_zod2.z.union([
    import_protocol.InstalledPlugin.schemas.schema,
    import_protocol.ParsedOperation.schemas.schema
  ], { description: "Operation/Plugin Mapping" })
);
var templateToPluginMap = import_zod2.z.record(
  import_zod2.z.union([
    import_protocol.InstalledPlugin.schemas.schema,
    import_protocol.ParsedTemplate.schemas.schema
  ])
);
var rawSchema = import_zod2.z.object({
  build: import_zod2.z.string({ description: "cache.build" }),
  configHash: import_zod2.z.string({ description: "cache.configHash" }),
  tasks: taskToPluginMap,
  operations: operationToPluginMap,
  templates: templateToPluginMap,
  plugins: import_zod2.z.array(import_protocol.PluginInfo.schemas.schema, { description: "cache.plugins" })
}).describe("Ephemeral State");
var { schemas: generatedSchemas, factory } = Base_default({
  rawSchema,
  parseErrMsg: (value) => `${value} is not a valid representation of ephemeral state`,
  unknownErrMsg: "Something went wrong when parsing the ephemeral state"
});
var { create: create2, of, make } = factory;
var schemas = {
  ...generatedSchemas,
  schema: generatedSchemas.schema.transform((val) => val)
};
var getTaskCounts = (pluginInfo) => {
  return pluginInfo.reduce(
    (retval, pluginInfo2) => pluginInfo2.tasks === void 0 ? {} : pluginInfo2.tasks.reduce(
      (retval2, task) => {
        const taskName = task.task;
        const providers = retval2[taskName] ? [...retval2[taskName], pluginInfo2] : [pluginInfo2];
        const mapping = {};
        mapping[taskName] = providers.filter((provider) => provider !== void 0);
        return { ...retval2, ...mapping };
      },
      retval
    ),
    {}
  );
};
var getTemplateCounts = (pluginInfo) => {
  return pluginInfo.reduce(
    (retval, pluginInfo2) => !pluginInfo2.templates ? retval : pluginInfo2.templates.reduce(
      (retval2, template) => {
        const templateName = template.template;
        const providers = retval2[templateName] ? [...retval2[templateName], pluginInfo2] : [pluginInfo2];
        const mapping = {};
        mapping[templateName] = providers.filter((provider) => provider !== void 0);
        return { ...retval2, ...mapping };
      },
      retval
    ),
    {}
  );
};
var getOperationCounts = (pluginInfo) => {
  return pluginInfo.reduce(
    (retval, pluginInfo2) => pluginInfo2.operations === void 0 ? retval : pluginInfo2.operations.reduce(
      (retval2, operation) => {
        const operationName = operation.operation;
        const providers = retval2[operationName] ? [...retval2[operationName], pluginInfo2] : [pluginInfo2];
        const mapping = {};
        mapping[operationName] = providers.filter((provider) => provider !== void 0);
        return { ...retval2, ...mapping };
      },
      retval
    ),
    {}
  );
};
var toChoices = (plugins) => plugins.reduce(
  (retval, pluginInfo) => {
    return [...retval, pluginInfo.name, pluginInfo.alias];
  },
  []
);
var isComposite = (name, counts) => counts[name] && counts[name].length > 1;
var getInstalledPlugin = (config, name) => {
  var _a;
  return (_a = config.plugins) == null ? void 0 : _a.find(
    (plugin) => [`taqueria-plugin-${name}`, name].includes(plugin.name)
  );
};
var mapTasksToPlugins = (config, pluginInfo, i18n) => {
  const taskCounts = getTaskCounts(pluginInfo);
  return (0, import_fluture3.attemptP)(
    async () => await pluginInfo.reduce(
      async (retval, pluginInfo2) => !pluginInfo2.tasks ? Promise.resolve({}) : await pluginInfo2.tasks.reduce(
        async (retval2, { task, hidden }) => {
          if (isComposite(task, taskCounts)) {
            const command = await eager(import_protocol.Command.make(task));
            const compositeTask = await eager(import_protocol.Task.make({
              task,
              command,
              description: await eager(import_protocol.NonEmptyString.make(i18n.__("providedByMany"))),
              hidden,
              options: [
                await eager(import_protocol.Option.make({
                  flag: await eager(import_protocol.Verb.make("plugin")),
                  description: await eager(
                    import_protocol.NonEmptyString.make("Specify which plugin should be used to execute this task")
                  ),
                  choices: toChoices(taskCounts[task]),
                  required: true
                }))
              ],
              handler: "proxy"
            }));
            return { ...await retval2, [task]: compositeTask };
          }
          const installedPlugin = getInstalledPlugin(config, pluginInfo2.name);
          return installedPlugin ? { ...await retval2, [task]: installedPlugin } : retval2;
        },
        retval
      ),
      Promise.resolve({})
    )
  ).pipe((0, import_fluture3.mapRej)((rej) => rej));
};
var mapOperationsToPlugins = (config, pluginInfo, i18n) => {
  const opCounts = getOperationCounts(pluginInfo);
  return (0, import_fluture3.attemptP)(
    async () => await pluginInfo.reduce(
      async (retval, pluginInfo2) => !pluginInfo2.operations ? Promise.resolve({}) : await pluginInfo2.operations.reduce(
        async (retval2, { operation }) => {
          if (isComposite(operation, opCounts)) {
            const command = await eager(import_protocol.Command.make(operation));
            const compositeOp = await eager(import_protocol.ParsedOperation.make({
              operation,
              command,
              description: await eager(import_protocol.NonEmptyString.make(i18n.__("providedByMany"))),
              options: [
                await eager(import_protocol.Option.make({
                  flag: await eager(import_protocol.Verb.make("plugin")),
                  description: await eager(
                    import_protocol.NonEmptyString.make("Specify which plugin should be used to execute this operation")
                  ),
                  choices: toChoices(opCounts[operation]),
                  required: true
                }))
              ]
            }));
            return { ...await retval2, [operation]: compositeOp };
          }
          const installedPlugin = getInstalledPlugin(config, pluginInfo2.name);
          return installedPlugin ? { ...await retval2, [operation]: installedPlugin } : retval2;
        },
        retval
      ),
      Promise.resolve({})
    )
  ).pipe((0, import_fluture3.mapRej)((rej) => rej));
};
var mapTemplatesToPlugins = (config, pluginInfo, i18n) => {
  const tmplCounts = getTemplateCounts(pluginInfo);
  return (0, import_fluture3.attemptP)(
    async () => await pluginInfo.reduce(
      async (retval, pluginInfo2) => !pluginInfo2.templates ? Promise.resolve({}) : await pluginInfo2.templates.reduce(
        async (retval2, { template, hidden }) => {
          if (isComposite(template, tmplCounts)) {
            const command = await eager(import_protocol.Command.make(template));
            const description = await eager(import_protocol.NonEmptyString.of(i18n.__("providedByMany")));
            const compositeTmpl = await eager(import_protocol.ParsedTemplate.make({
              template,
              command,
              description,
              options: [
                await eager(import_protocol.Option.make({
                  flag: await eager(import_protocol.Verb.make("plugin")),
                  description: await eager(
                    import_protocol.NonEmptyString.make("Specify which plugin should be used to execute this task")
                  ),
                  choices: toChoices(tmplCounts[template]),
                  required: true
                }))
              ],
              handler: "proxy",
              encoding: import_protocol.PluginResponseEncoding.create("none")
            }));
            return { ...await retval2, [template]: compositeTmpl };
          }
          const installedPlugin = getInstalledPlugin(config, pluginInfo2.name);
          return installedPlugin ? { ...await retval2, [template]: installedPlugin } : retval2;
        },
        retval
      ),
      Promise.resolve({})
    )
  ).pipe((0, import_fluture3.mapRej)((rej) => rej));
};
var getTasks = (pluginInfo) => pluginInfo.reduce(
  (retval, pluginInfo2) => {
    var _a;
    return [...retval, ...(_a = pluginInfo2.tasks) != null ? _a : []];
  },
  []
);
//# sourceMappingURL=EphemeralState.js.map