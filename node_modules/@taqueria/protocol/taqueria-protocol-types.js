"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from28, except, desc) => {
  if (from28 && typeof from28 === "object" || typeof from28 === "function") {
    for (let key of __getOwnPropNames(from28))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from28[key], enumerable: !(desc = __getOwnPropDesc(from28, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// taqueria-protocol-types.ts
var taqueria_protocol_types_exports = {};
__export(taqueria_protocol_types_exports, {
  Alias: () => Alias_exports,
  Config: () => Config_exports,
  EconomicalProtocolHash: () => EconomicalProtocolHash_exports,
  Environment: () => Environment_exports,
  EphemeralState: () => EphemeralState_exports,
  HumanReadableIdentifier: () => HumanReadableIdentifier_exports,
  InstalledPlugin: () => InstalledPlugin_exports,
  LoadedConfig: () => LoadedConfig_exports,
  MetadataConfig: () => MetadataConfig_exports,
  NetworkConfig: () => NetworkConfig_exports,
  Operation: () => Operation_exports,
  Option: () => Option_exports,
  ParsedOperation: () => ParsedOperation_exports,
  ParsedTemplate: () => ParsedTemplate_exports,
  PersistentState: () => PersistentState_exports,
  PluginActionName: () => PluginActionName_exports,
  PluginInfo: () => PluginInfo_exports,
  PluginJsonResponse: () => PluginJsonResponse_exports,
  PluginResponseEncoding: () => PluginResponseEncoding_exports,
  PluginSchema: () => PluginSchema_exports,
  PositionalArg: () => PositionalArg_exports,
  RequestArgs: () => RequestArgs_exports,
  SHA256: () => SHA256_exports,
  SandboxAccountConfig: () => SandboxAccountConfig_exports,
  SandboxConfig: () => SandboxConfig_exports,
  SanitizedAbsPath: () => SanitizedAbsPath_exports,
  SanitizedArgs: () => SanitizedArgs_exports,
  SanitizedPath: () => SanitizedPath_exports,
  ScaffoldConfig: () => ScaffoldConfig_exports,
  TaqError: () => TaqError_exports,
  Task: () => Task_exports,
  Template: () => Template_exports,
  Url: () => Url_exports,
  Verb: () => Verb_exports,
  VersionNumber: () => VersionNumber_exports,
  i18n: () => i18n_exports
});
module.exports = __toCommonJS(taqueria_protocol_types_exports);

// Alias.ts
var Alias_exports = {};
__export(Alias_exports, {
  create: () => create2,
  from: () => from,
  internalSchema: () => internalSchema,
  make: () => make,
  of: () => of,
  rawSchema: () => rawSchema,
  schemas: () => schemas
});

// TaqError.ts
var TaqError_exports = {};
__export(TaqError_exports, {
  E_TaqError: () => E_TaqError,
  create: () => create,
  toFutureParseErr: () => toFutureParseErr,
  toFutureParseUnknownErr: () => toFutureParseUnknownErr,
  toParseErr: () => toParseErr,
  toParseUnknownErr: () => toParseUnknownErr
});
var import_fluture = require("fluture");
var E_TaqError = class extends Error {
  constructor(taqErr) {
    super(taqErr.msg);
    this.context = taqErr.context;
    this.kind = taqErr.kind;
    this.name = this.kind;
    this.previous = taqErr.previous;
  }
};
var toFutureParseErr = (previous, msg, context) => (0, import_fluture.reject)(toParseErr(previous, msg, context)).pipe((0, import_fluture.map)((val) => val));
var toParseErr = (previous, msg, context) => create({
  kind: "E_PARSE",
  msg,
  context,
  previous
});
var toParseUnknownErr = (previous, msg, context) => create({
  kind: "E_PARSE_UNKNOWN",
  msg,
  context,
  previous
});
var toFutureParseUnknownErr = (previous, msg, context) => (0, import_fluture.reject)(toParseUnknownErr(previous, msg, context)).pipe((0, import_fluture.map)((val) => val));
var create = (err) => err;

// out/types/Alias.ts
var import_fluture2 = require("fluture");
var import_zod2 = require("zod");

// out/types-zod.ts
var import_zod = require("zod");
var nonEmptyStringSchema = import_zod.z.string().min(1);
var singleCharSchema = nonEmptyStringSchema.regex(/^[A-Za-z]$/);
var verbSchema = nonEmptyStringSchema.regex(/^[A-Za-z\-\ ]+/);
var aliasSchema = import_zod.z.union([verbSchema, singleCharSchema]);
var humanReadableIdentifierSchema = nonEmptyStringSchema.regex(
  /^[A-Za-z]+[A-Za-z0-9-_ ]*$/
);
var sanitizedAbsPathSchema = nonEmptyStringSchema;
var sanitizedPathSchema = nonEmptyStringSchema;
var settingsSchema = import_zod.z.object({
  consent: import_zod.z.union([
    import_zod.z.literal("opt_in"),
    import_zod.z.literal("opt_out"),
    import_zod.z.literal("unspecified")
  ])
});
var timestampSchema = import_zod.z.number().min(1651846877);
var tzSchema = nonEmptyStringSchema.min(1).regex(/^\d([\d_]+\d)?$/);
var versionNumberSchema = nonEmptyStringSchema.min(1).regex(/^\d+\.\d+(\.\d+)*$/);
var urlSchema = nonEmptyStringSchema.url();
var commandSchema = nonEmptyStringSchema;
var optionSchema = import_zod.z.object({
  shortFlag: singleCharSchema.optional(),
  flag: verbSchema,
  description: nonEmptyStringSchema,
  defaultValue: import_zod.z.union([import_zod.z.string(), import_zod.z.number(), import_zod.z.boolean()]).optional(),
  type: import_zod.z.union([import_zod.z.literal("string"), import_zod.z.literal("number"), import_zod.z.literal("boolean")]).optional(),
  required: import_zod.z.boolean().optional(),
  boolean: import_zod.z.boolean().optional(),
  choices: import_zod.z.array(nonEmptyStringSchema).optional()
});
var positionalArgSchema = import_zod.z.object({
  placeholder: humanReadableIdentifierSchema,
  description: nonEmptyStringSchema,
  defaultValue: import_zod.z.union([import_zod.z.string(), import_zod.z.number(), import_zod.z.boolean()]).optional(),
  type: import_zod.z.union([import_zod.z.literal("string"), import_zod.z.literal("number"), import_zod.z.literal("boolean")]).optional(),
  required: import_zod.z.boolean().optional()
});
var installedPluginSchema = import_zod.z.object({
  type: import_zod.z.union([import_zod.z.literal("npm"), import_zod.z.literal("binary"), import_zod.z.literal("deno")]),
  name: nonEmptyStringSchema
});
var runtimeDependencySchema = import_zod.z.object({
  name: humanReadableIdentifierSchema,
  path: import_zod.z.string(),
  version: import_zod.z.string(),
  kind: import_zod.z.union([import_zod.z.literal("required"), import_zod.z.literal("optional")])
});
var runtimeDependencyReportSchema = runtimeDependencySchema.extend(
  {
    met: import_zod.z.boolean()
  }
);
var pluginDependenciesResponseSchema = import_zod.z.object({
  report: import_zod.z.array(runtimeDependencyReportSchema)
});
var pluginJsonResponseSchema = import_zod.z.union([
  import_zod.z.object({
    data: import_zod.z.unknown().optional(),
    render: import_zod.z.union([import_zod.z.literal("none"), import_zod.z.literal("table"), import_zod.z.literal("string")]).default("none")
  }),
  import_zod.z.void()
]);
var pluginProxyResponseSchema = import_zod.z.union([
  import_zod.z.void(),
  pluginJsonResponseSchema
]);
var pluginResponseEncodingSchema = import_zod.z.union([import_zod.z.literal("none"), import_zod.z.literal("json"), import_zod.z.literal("application/json")]).default("none");
var buildNumberSchema = import_zod.z.number();
var sanitizedArgsSchema = import_zod.z.object({
  _: import_zod.z.array(import_zod.z.string()),
  projectDir: sanitizedPathSchema,
  maxConcurrency: import_zod.z.number(),
  debug: import_zod.z.boolean(),
  disableState: import_zod.z.boolean(),
  logPluginRequests: import_zod.z.boolean(),
  fromVsCode: import_zod.z.boolean(),
  version: import_zod.z.boolean(),
  build: import_zod.z.boolean(),
  help: import_zod.z.boolean(),
  yes: import_zod.z.boolean(),
  plugin: nonEmptyStringSchema.optional(),
  env: nonEmptyStringSchema,
  quickstart: nonEmptyStringSchema,
  setBuild: import_zod.z.union([nonEmptyStringSchema, buildNumberSchema]),
  setVersion: nonEmptyStringSchema
}).passthrough();
var pluginActionNameSchema = import_zod.z.union([
  import_zod.z.literal("proxy"),
  import_zod.z.literal("pluginInfo"),
  import_zod.z.literal("checkRuntimeDependencies"),
  import_zod.z.literal("installRuntimeDependencies"),
  import_zod.z.literal("proxyTemplate")
]);
var economicalProtocolHashSchema = import_zod.z.string();
var publicKeyHashSchema = import_zod.z.string().regex(/^tz\d[A-Za-z0-9]{33}$/);
var sha256Schema = import_zod.z.string().regex(/^[A-Fa-f0-9]{64}$/);
var contractSchema = import_zod.z.object({
  sourceFile: nonEmptyStringSchema,
  hash: sha256Schema
});
var faucetSchema = import_zod.z.object({
  pkh: publicKeyHashSchema,
  mnemonic: import_zod.z.array(import_zod.z.string()),
  email: import_zod.z.string().email(),
  password: import_zod.z.string(),
  amount: import_zod.z.string().regex(/^\d+$/),
  activation_code: import_zod.z.string()
});
var tzKtConfigPostgresqlPortSchema = import_zod.z.number().default(5432);
var tzKtConfigApiPortSchema = import_zod.z.number().default(5e3);
var tzKtConfigSchema = import_zod.z.object({
  disableAutostartWithSandbox: import_zod.z.boolean().optional(),
  postgresqlPort: tzKtConfigPostgresqlPortSchema.optional(),
  apiPort: tzKtConfigApiPortSchema.optional()
});
var persistedTaskSchema = import_zod.z.object({
  task: verbSchema,
  plugin: nonEmptyStringSchema,
  time: timestampSchema,
  output: import_zod.z.unknown().optional()
});
var persistedOperationSchema = import_zod.z.object({
  hash: sha256Schema,
  time: timestampSchema,
  output: import_zod.z.unknown().optional()
});
var provisionerIDSchema = import_zod.z.string().min(1).regex(
  /^[A-Za-z0-9]+[A-Za-z0-9-_]+\.[A-Za-z0-9]+[A-Za-z0-9-_]+\.[A-Za-z0-9]+[A-Za-z0-9-_]+$/
);
var provisionerSchema = import_zod.z.object({
  id: provisionerIDSchema,
  plugin: nonEmptyStringSchema,
  operation: import_zod.z.union([nonEmptyStringSchema, import_zod.z.literal("custom")]),
  command: import_zod.z.string().optional(),
  label: import_zod.z.string().optional(),
  depends_on: import_zod.z.array(provisionerIDSchema).optional()
});
var provisionsSchema = import_zod.z.array(provisionerSchema);
var environmentSchema = import_zod.z.object({
  networks: import_zod.z.array(nonEmptyStringSchema),
  sandboxes: import_zod.z.array(nonEmptyStringSchema),
  storage: import_zod.z.record(nonEmptyStringSchema).optional(),
  aliases: import_zod.z.record(import_zod.z.record(nonEmptyStringSchema)).optional()
});
var environmentNameSchema = nonEmptyStringSchema.min(
  1,
  "Default environment must reference the name of an existing environment."
);
var humanLanguageSchema = import_zod.z.union([import_zod.z.literal("en"), import_zod.z.literal("fr")]).default("en");
var configContractsDirSchema = import_zod.z.string().min(1).default("contracts");
var configArtifactsDirSchema = import_zod.z.string().min(1).default("artifacts");
var currencyAmountV2Schema = import_zod.z.object({
  amount: import_zod.z.string(),
  units: import_zod.z.string()
});
var versionV2Schema = import_zod.z.string().regex(/^v2$/);
var sandboxAccountSchema = import_zod.z.object({
  type: import_zod.z.string().optional()
}).passthrough();
var sandboxAccountsSchema = import_zod.z.record(sandboxAccountSchema);
var configEnvironmentFileV2Schema = import_zod.z.object({
  type: import_zod.z.string().optional(),
  accounts: sandboxAccountsSchema.optional(),
  accountDefault: import_zod.z.any().optional(),
  contracts: import_zod.z.record(
    import_zod.z.object({
      address: import_zod.z.string().optional()
    })
  ).optional()
}).passthrough();
var metadataConfigSchema = import_zod.z.object({
  name: import_zod.z.string().optional(),
  projectDescription: import_zod.z.string().optional(),
  authors: import_zod.z.array(import_zod.z.string()).optional(),
  license: import_zod.z.string().optional(),
  homepage: import_zod.z.string().optional()
});
var networkAccountConfigSchema = import_zod.z.object({
  publicKey: nonEmptyStringSchema.optional(),
  publicKeyHash: publicKeyHashSchema.optional(),
  privateKey: nonEmptyStringSchema.optional(),
  mnemonic: nonEmptyStringSchema.optional()
});
var sandboxAccountConfigSchema = import_zod.z.object({
  encryptedKey: nonEmptyStringSchema,
  publicKeyHash: publicKeyHashSchema,
  secretKey: nonEmptyStringSchema
});
var sandboxConfigSchema = import_zod.z.object({
  label: nonEmptyStringSchema,
  rpcUrl: urlSchema,
  protocol: economicalProtocolHashSchema.optional(),
  plugin: verbSchema.optional(),
  accounts: import_zod.z.record(import_zod.z.union([sandboxAccountConfigSchema, nonEmptyStringSchema])).optional(),
  tzkt: tzKtConfigSchema.optional(),
  annotations: import_zod.z.record(import_zod.z.unknown()).optional()
});
var scaffoldConfigSchema = import_zod.z.object({
  postInit: import_zod.z.string().optional()
});
var taskSchema = import_zod.z.object({
  task: verbSchema,
  command: commandSchema,
  aliases: import_zod.z.array(aliasSchema).optional(),
  description: nonEmptyStringSchema.min(3).optional(),
  example: nonEmptyStringSchema.optional(),
  hidden: import_zod.z.boolean().optional(),
  encoding: pluginResponseEncodingSchema.optional(),
  handler: import_zod.z.union([import_zod.z.literal("proxy"), nonEmptyStringSchema]),
  options: import_zod.z.array(optionSchema).optional(),
  positionals: import_zod.z.array(positionalArgSchema).optional()
});
var persistentStateSchema = import_zod.z.object({
  operations: import_zod.z.record(persistedOperationSchema),
  tasks: import_zod.z.record(persistedTaskSchema)
});
var configAccountSchema = import_zod.z.object({
  balance: currencyAmountV2Schema
});
var configFileV2Schema = import_zod.z.object({
  version: versionV2Schema,
  language: humanLanguageSchema.optional(),
  metadata: metadataConfigSchema.optional(),
  artifactsDir: configArtifactsDirSchema.optional(),
  contractsDir: configContractsDirSchema.optional(),
  accounts: import_zod.z.record(configAccountSchema).optional(),
  contracts: import_zod.z.record(contractSchema).optional(),
  environmentDefault: environmentNameSchema.optional(),
  environments: import_zod.z.record(configEnvironmentFileV2Schema).optional(),
  plugins: import_zod.z.array(installedPluginSchema).optional()
});
var networkConfigSchema = import_zod.z.object({
  label: humanReadableIdentifierSchema,
  rpcUrl: urlSchema,
  accounts: import_zod.z.record(networkAccountConfigSchema).optional(),
  faucet: faucetSchema.optional()
});
var pluginSchemaBaseSchema = import_zod.z.object({
  name: nonEmptyStringSchema,
  version: versionNumberSchema,
  schema: versionNumberSchema,
  alias: aliasSchema,
  tasks: import_zod.z.array(taskSchema).optional()
});
var configSchema = import_zod.z.object({
  language: humanLanguageSchema.optional(),
  metadata: metadataConfigSchema.optional(),
  artifactsDir: configArtifactsDirSchema.optional(),
  contractsDir: configContractsDirSchema.optional(),
  contracts: import_zod.z.record(contractSchema).optional(),
  plugins: import_zod.z.array(installedPluginSchema).optional(),
  accounts: import_zod.z.record(tzSchema).optional(),
  environment: import_zod.z.record(import_zod.z.union([environmentSchema, environmentNameSchema])),
  network: import_zod.z.record(networkConfigSchema).optional(),
  sandbox: import_zod.z.record(sandboxConfigSchema).optional()
});
var configFileV1Schema = import_zod.z.object({
  language: humanLanguageSchema.optional(),
  plugins: import_zod.z.array(installedPluginSchema).optional(),
  contractsDir: configContractsDirSchema.optional(),
  artifactsDir: configArtifactsDirSchema.optional(),
  network: import_zod.z.record(networkConfigSchema).optional(),
  sandbox: import_zod.z.record(sandboxConfigSchema).optional(),
  environment: import_zod.z.record(import_zod.z.union([environmentSchema, environmentNameSchema])).optional(),
  accounts: import_zod.z.record(tzSchema).optional(),
  contracts: import_zod.z.record(contractSchema).optional(),
  metadata: metadataConfigSchema.optional()
});
var loadedConfigSchema = configSchema.extend(
  {
    projectDir: sanitizedAbsPathSchema,
    configFile: sanitizedAbsPathSchema,
    hash: sha256Schema
  }
);
var parsedConfigSchema = configSchema.omit({ sandbox: true }).extend(
  {
    sandbox: import_zod.z.record(import_zod.z.union([sandboxConfigSchema, nonEmptyStringSchema]))
  }
);
var requestArgsSchema = sanitizedArgsSchema.omit({ quickstart: true }).extend(
  {
    taqRun: pluginActionNameSchema,
    config: loadedConfigSchema
  }
).passthrough();
var proxyTaskArgsSchema = requestArgsSchema.extend(
  {
    task: nonEmptyStringSchema
  }
).passthrough();
var proxyTemplateArgsSchema = requestArgsSchema.extend(
  {
    template: nonEmptyStringSchema
  }
).passthrough();
var operationSchema = import_zod.z.object({
  operation: verbSchema,
  command: commandSchema,
  description: nonEmptyStringSchema.optional(),
  positionals: import_zod.z.array(positionalArgSchema).optional(),
  options: import_zod.z.array(optionSchema).optional(),
  handler: import_zod.z.function().args(persistentStateSchema).returns(import_zod.z.function().args(requestArgsSchema).returns(import_zod.z.void())).optional()
});
var parsedOperationSchema = operationSchema.omit({ handler: true });
var templateHandlerSchema = import_zod.z.union([
  nonEmptyStringSchema,
  import_zod.z.function().args(requestArgsSchema).returns(
    import_zod.z.union([pluginJsonResponseSchema, import_zod.z.promise(pluginJsonResponseSchema)])
  ),
  import_zod.z.promise(import_zod.z.void())
]);
var templateSchema = import_zod.z.object({
  template: verbSchema,
  command: commandSchema,
  description: nonEmptyStringSchema,
  hidden: import_zod.z.boolean().optional(),
  options: import_zod.z.array(optionSchema).optional(),
  positionals: import_zod.z.array(positionalArgSchema).optional(),
  handler: templateHandlerSchema,
  encoding: pluginResponseEncodingSchema.optional()
});
var parsedTemplateSchema = templateSchema.omit({ handler: true }).extend(
  {
    handler: import_zod.z.string()
  }
);
var pluginInfoSchema = pluginSchemaBaseSchema.extend(
  {
    operations: import_zod.z.array(parsedOperationSchema).optional(),
    templates: import_zod.z.array(parsedTemplateSchema).optional()
  }
);
var pluginSchemaSchema = pluginSchemaBaseSchema.extend(
  {
    operations: import_zod.z.array(operationSchema).optional(),
    templates: import_zod.z.array(templateSchema).optional(),
    proxy: import_zod.z.function().args(requestArgsSchema).returns(import_zod.z.promise(pluginProxyResponseSchema)).optional(),
    checkRuntimeDependencies: import_zod.z.function().args(requestArgsSchema).returns(import_zod.z.promise(pluginDependenciesResponseSchema)).optional(),
    installRuntimeDependencies: import_zod.z.function().args(requestArgsSchema).returns(import_zod.z.promise(pluginDependenciesResponseSchema)).optional()
  }
);
var ephemeralStateSchema = import_zod.z.object({
  build: import_zod.z.string(),
  configHash: import_zod.z.string(),
  tasks: import_zod.z.record(installedPluginSchema.and(taskSchema)),
  operations: import_zod.z.record(installedPluginSchema.and(parsedOperationSchema)),
  templates: import_zod.z.record(installedPluginSchema.and(parsedTemplateSchema)),
  plugins: import_zod.z.array(pluginInfoSchema)
});

// out/types/Alias.ts
var from = (input) => {
  try {
    return aliasSchema.parse(input);
  } catch (previous) {
    if (previous instanceof import_zod2.ZodError) {
      const msgs = previous.errors.reduce(
        (retval, issue) => {
          const path2 = issue.path.join(" \u2192 ");
          const msg = path2 + ": " + issue.message;
          return [...retval, msg];
        },
        ["Alias is invalid:"]
      );
      const validationErr = msgs.join("\n") + "\n";
      throw toParseErr(previous, validationErr);
    }
    throw toParseUnknownErr(previous, "There was a problem trying to parse a Alias.");
  }
};
var create2 = (input) => from(input);
var of = (input) => {
  try {
    return (0, import_fluture2.resolve)(from(input));
  } catch (err) {
    return (0, import_fluture2.reject)(err);
  }
};
var make = (input) => of(input);
var schemas = {
  rawSchema: aliasSchema,
  schema: aliasSchema.transform((val) => val)
};
var rawSchema = schemas.rawSchema;
var internalSchema = aliasSchema;

// Config.ts
var Config_exports = {};
__export(Config_exports, {
  create: () => create3,
  from: () => from2,
  internalSchema: () => internalSchema2,
  make: () => make2,
  of: () => of2,
  rawSchema: () => rawSchema2,
  schemas: () => schemas2
});

// out/types/Config.ts
var import_fluture3 = require("fluture");
var import_zod3 = require("zod");
var from2 = (input) => {
  try {
    return configSchema.parse(input);
  } catch (previous) {
    if (previous instanceof import_zod3.ZodError) {
      const msgs = previous.errors.reduce(
        (retval, issue) => {
          const path2 = issue.path.join(" \u2192 ");
          const msg = path2 + ": " + issue.message;
          return [...retval, msg];
        },
        ["Your .taq/config.json is invalid:"]
      );
      const validationErr = msgs.join("\n") + "\n";
      throw toParseErr(previous, validationErr);
    }
    throw toParseUnknownErr(previous, "There was a problem trying to parse a Config.");
  }
};
var create3 = (input) => from2(input);
var of2 = (input) => {
  try {
    return (0, import_fluture3.resolve)(from2(input));
  } catch (err) {
    return (0, import_fluture3.reject)(err);
  }
};
var make2 = (input) => of2(input);
var schemas2 = {
  rawSchema: configSchema,
  schema: configSchema.transform((val) => val)
};
var rawSchema2 = schemas2.rawSchema;
var internalSchema2 = configSchema;

// EconomicalProtocolHash.ts
var EconomicalProtocolHash_exports = {};
__export(EconomicalProtocolHash_exports, {
  create: () => create4,
  from: () => from3,
  internalSchema: () => internalSchema3,
  make: () => make3,
  of: () => of3,
  rawSchema: () => rawSchema3,
  schemas: () => schemas3
});

// out/types/EconomicalProtocolHash.ts
var import_fluture4 = require("fluture");
var import_zod4 = require("zod");
var from3 = (input) => {
  try {
    return economicalProtocolHashSchema.parse(input);
  } catch (previous) {
    if (previous instanceof import_zod4.ZodError) {
      const msgs = previous.errors.reduce(
        (retval, issue) => {
          const path2 = issue.path.join(" \u2192 ");
          const msg = path2 + ": " + issue.message;
          return [...retval, msg];
        },
        ["EconomicalProtocolHash is invalid:"]
      );
      const validationErr = msgs.join("\n") + "\n";
      throw toParseErr(previous, validationErr);
    }
    throw toParseUnknownErr(previous, "There was a problem trying to parse a EconomicalProtocolHash.");
  }
};
var create4 = (input) => from3(input);
var of3 = (input) => {
  try {
    return (0, import_fluture4.resolve)(from3(input));
  } catch (err) {
    return (0, import_fluture4.reject)(err);
  }
};
var make3 = (input) => of3(input);
var schemas3 = {
  rawSchema: economicalProtocolHashSchema,
  schema: economicalProtocolHashSchema.transform((val) => val)
};
var rawSchema3 = schemas3.rawSchema;
var internalSchema3 = economicalProtocolHashSchema;

// Environment.ts
var Environment_exports = {};
__export(Environment_exports, {
  create: () => create5,
  from: () => from4,
  internalSchema: () => internalSchema4,
  make: () => make4,
  of: () => of4,
  rawSchema: () => rawSchema4,
  schemas: () => schemas4
});

// out/types/Environment.ts
var import_fluture5 = require("fluture");
var import_zod5 = require("zod");
var from4 = (input) => {
  try {
    return environmentSchema.parse(input);
  } catch (previous) {
    if (previous instanceof import_zod5.ZodError) {
      const msgs = previous.errors.reduce(
        (retval, issue) => {
          const path2 = issue.path.join(" \u2192 ");
          const msg = path2 + ": " + issue.message;
          return [...retval, msg];
        },
        ["Environment is invalid:"]
      );
      const validationErr = msgs.join("\n") + "\n";
      throw toParseErr(previous, validationErr);
    }
    throw toParseUnknownErr(previous, "There was a problem trying to parse a Environment.");
  }
};
var create5 = (input) => from4(input);
var of4 = (input) => {
  try {
    return (0, import_fluture5.resolve)(from4(input));
  } catch (err) {
    return (0, import_fluture5.reject)(err);
  }
};
var make4 = (input) => of4(input);
var schemas4 = {
  rawSchema: environmentSchema,
  schema: environmentSchema.transform((val) => val)
};
var rawSchema4 = schemas4.rawSchema;
var internalSchema4 = environmentSchema;

// EphemeralState.ts
var EphemeralState_exports = {};
__export(EphemeralState_exports, {
  create: () => create6,
  factory: () => factory,
  generatedSchemas: () => generatedSchemas,
  getTasks: () => getTasks,
  make: () => make5,
  mapOperationsToPlugins: () => mapOperationsToPlugins,
  mapTasksToPlugins: () => mapTasksToPlugins,
  mapTemplatesToPlugins: () => mapTemplatesToPlugins,
  of: () => of5,
  schemas: () => schemas5
});
var import_protocol = require("@taqueria/protocol");

// Base.ts
var import_fluture6 = require("fluture");
var import_zod6 = require("zod");
var createSchema = (params) => {
  var _a, _b;
  const { rawSchema: rawSchema37, isStringLike } = params;
  const internalSchema32 = (_a = params.internalSchema) != null ? _a : params.rawSchema;
  const noop = (val) => val;
  const transformer = (_b = params.transformer) != null ? _b : noop;
  const schema = isStringLike ? internalSchema32.transform(
    (val) => transformer(val)
  ) : internalSchema32.transform(
    (val) => transformer(val)
  );
  return {
    rawSchema: rawSchema37,
    internalSchema: internalSchema32,
    schema
  };
};
var createType = (params) => {
  const schemas37 = createSchema(params);
  const { parseErrMsg, unknownErrMsg } = params;
  const internalOf = (input) => {
    try {
      return (0, import_fluture6.resolve)(schemas37.schema.parse(input));
    } catch (previous) {
      const parseMsg = typeof parseErrMsg === "string" ? parseErrMsg : parseErrMsg(input, previous);
      const unknownMsg = typeof unknownErrMsg === "string" ? unknownErrMsg : unknownErrMsg(input);
      if (previous instanceof import_zod6.ZodError) {
        return toFutureParseErr(previous, parseMsg, input);
      }
      return toFutureParseUnknownErr(previous, unknownMsg, input);
    }
  };
  const of35 = internalOf;
  const make35 = (input) => internalOf(input);
  const create37 = (input) => schemas37.schema.parse(input);
  const from28 = (input) => schemas37.schema.parse(input);
  const factory8 = {
    make: make35,
    of: of35,
    create: create37,
    from: from28
  };
  return {
    schemas: schemas37,
    factory: factory8
  };
};
var Base_default = createType;

// EphemeralState.ts
var import_fluture7 = require("fluture");
var import_zod7 = require("zod");
var eager = (f) => (0, import_fluture7.promise)(
  (0, import_fluture7.mapRej)((err) => new E_TaqError(err))(f)
);
var taskToPluginMap = import_zod7.z.record(
  import_zod7.z.union([
    import_protocol.InstalledPlugin.schemas.schema,
    import_protocol.Task.schemas.schema
  ], { description: "Task/Plugin Mapping" })
);
var operationToPluginMap = import_zod7.z.record(
  import_zod7.z.union([
    import_protocol.InstalledPlugin.schemas.schema,
    import_protocol.ParsedOperation.schemas.schema
  ], { description: "Operation/Plugin Mapping" })
);
var templateToPluginMap = import_zod7.z.record(
  import_zod7.z.union([
    import_protocol.InstalledPlugin.schemas.schema,
    import_protocol.ParsedTemplate.schemas.schema
  ])
);
var rawSchema5 = import_zod7.z.object({
  build: import_zod7.z.string({ description: "cache.build" }),
  configHash: import_zod7.z.string({ description: "cache.configHash" }),
  tasks: taskToPluginMap,
  operations: operationToPluginMap,
  templates: templateToPluginMap,
  plugins: import_zod7.z.array(import_protocol.PluginInfo.schemas.schema, { description: "cache.plugins" })
}).describe("Ephemeral State");
var { schemas: generatedSchemas, factory } = Base_default({
  rawSchema: rawSchema5,
  parseErrMsg: (value) => `${value} is not a valid representation of ephemeral state`,
  unknownErrMsg: "Something went wrong when parsing the ephemeral state"
});
var { create: create6, of: of5, make: make5 } = factory;
var schemas5 = {
  ...generatedSchemas,
  schema: generatedSchemas.schema.transform((val) => val)
};
var getTaskCounts = (pluginInfo) => {
  return pluginInfo.reduce(
    (retval, pluginInfo2) => pluginInfo2.tasks === void 0 ? {} : pluginInfo2.tasks.reduce(
      (retval2, task) => {
        const taskName = task.task;
        const providers = retval2[taskName] ? [...retval2[taskName], pluginInfo2] : [pluginInfo2];
        const mapping = {};
        mapping[taskName] = providers.filter((provider) => provider !== void 0);
        return { ...retval2, ...mapping };
      },
      retval
    ),
    {}
  );
};
var getTemplateCounts = (pluginInfo) => {
  return pluginInfo.reduce(
    (retval, pluginInfo2) => !pluginInfo2.templates ? retval : pluginInfo2.templates.reduce(
      (retval2, template) => {
        const templateName = template.template;
        const providers = retval2[templateName] ? [...retval2[templateName], pluginInfo2] : [pluginInfo2];
        const mapping = {};
        mapping[templateName] = providers.filter((provider) => provider !== void 0);
        return { ...retval2, ...mapping };
      },
      retval
    ),
    {}
  );
};
var getOperationCounts = (pluginInfo) => {
  return pluginInfo.reduce(
    (retval, pluginInfo2) => pluginInfo2.operations === void 0 ? retval : pluginInfo2.operations.reduce(
      (retval2, operation) => {
        const operationName = operation.operation;
        const providers = retval2[operationName] ? [...retval2[operationName], pluginInfo2] : [pluginInfo2];
        const mapping = {};
        mapping[operationName] = providers.filter((provider) => provider !== void 0);
        return { ...retval2, ...mapping };
      },
      retval
    ),
    {}
  );
};
var toChoices = (plugins) => plugins.reduce(
  (retval, pluginInfo) => {
    return [...retval, pluginInfo.name, pluginInfo.alias];
  },
  []
);
var isComposite = (name, counts) => counts[name] && counts[name].length > 1;
var getInstalledPlugin = (config, name) => {
  var _a;
  return (_a = config.plugins) == null ? void 0 : _a.find(
    (plugin) => [`taqueria-plugin-${name}`, name].includes(plugin.name)
  );
};
var mapTasksToPlugins = (config, pluginInfo, i18n) => {
  const taskCounts = getTaskCounts(pluginInfo);
  return (0, import_fluture7.attemptP)(
    async () => await pluginInfo.reduce(
      async (retval, pluginInfo2) => !pluginInfo2.tasks ? Promise.resolve({}) : await pluginInfo2.tasks.reduce(
        async (retval2, { task, hidden }) => {
          if (isComposite(task, taskCounts)) {
            const command = await eager(import_protocol.Command.make(task));
            const compositeTask = await eager(import_protocol.Task.make({
              task,
              command,
              description: await eager(import_protocol.NonEmptyString.make(i18n.__("providedByMany"))),
              hidden,
              options: [
                await eager(import_protocol.Option.make({
                  flag: await eager(import_protocol.Verb.make("plugin")),
                  description: await eager(
                    import_protocol.NonEmptyString.make("Specify which plugin should be used to execute this task")
                  ),
                  choices: toChoices(taskCounts[task]),
                  required: true
                }))
              ],
              handler: "proxy"
            }));
            return { ...await retval2, [task]: compositeTask };
          }
          const installedPlugin = getInstalledPlugin(config, pluginInfo2.name);
          return installedPlugin ? { ...await retval2, [task]: installedPlugin } : retval2;
        },
        retval
      ),
      Promise.resolve({})
    )
  ).pipe((0, import_fluture7.mapRej)((rej) => rej));
};
var mapOperationsToPlugins = (config, pluginInfo, i18n) => {
  const opCounts = getOperationCounts(pluginInfo);
  return (0, import_fluture7.attemptP)(
    async () => await pluginInfo.reduce(
      async (retval, pluginInfo2) => !pluginInfo2.operations ? Promise.resolve({}) : await pluginInfo2.operations.reduce(
        async (retval2, { operation }) => {
          if (isComposite(operation, opCounts)) {
            const command = await eager(import_protocol.Command.make(operation));
            const compositeOp = await eager(import_protocol.ParsedOperation.make({
              operation,
              command,
              description: await eager(import_protocol.NonEmptyString.make(i18n.__("providedByMany"))),
              options: [
                await eager(import_protocol.Option.make({
                  flag: await eager(import_protocol.Verb.make("plugin")),
                  description: await eager(
                    import_protocol.NonEmptyString.make("Specify which plugin should be used to execute this operation")
                  ),
                  choices: toChoices(opCounts[operation]),
                  required: true
                }))
              ]
            }));
            return { ...await retval2, [operation]: compositeOp };
          }
          const installedPlugin = getInstalledPlugin(config, pluginInfo2.name);
          return installedPlugin ? { ...await retval2, [operation]: installedPlugin } : retval2;
        },
        retval
      ),
      Promise.resolve({})
    )
  ).pipe((0, import_fluture7.mapRej)((rej) => rej));
};
var mapTemplatesToPlugins = (config, pluginInfo, i18n) => {
  const tmplCounts = getTemplateCounts(pluginInfo);
  return (0, import_fluture7.attemptP)(
    async () => await pluginInfo.reduce(
      async (retval, pluginInfo2) => !pluginInfo2.templates ? Promise.resolve({}) : await pluginInfo2.templates.reduce(
        async (retval2, { template, hidden }) => {
          if (isComposite(template, tmplCounts)) {
            const command = await eager(import_protocol.Command.make(template));
            const description = await eager(import_protocol.NonEmptyString.of(i18n.__("providedByMany")));
            const compositeTmpl = await eager(import_protocol.ParsedTemplate.make({
              template,
              command,
              description,
              options: [
                await eager(import_protocol.Option.make({
                  flag: await eager(import_protocol.Verb.make("plugin")),
                  description: await eager(
                    import_protocol.NonEmptyString.make("Specify which plugin should be used to execute this task")
                  ),
                  choices: toChoices(tmplCounts[template]),
                  required: true
                }))
              ],
              handler: "proxy",
              encoding: import_protocol.PluginResponseEncoding.create("none")
            }));
            return { ...await retval2, [template]: compositeTmpl };
          }
          const installedPlugin = getInstalledPlugin(config, pluginInfo2.name);
          return installedPlugin ? { ...await retval2, [template]: installedPlugin } : retval2;
        },
        retval
      ),
      Promise.resolve({})
    )
  ).pipe((0, import_fluture7.mapRej)((rej) => rej));
};
var getTasks = (pluginInfo) => pluginInfo.reduce(
  (retval, pluginInfo2) => {
    var _a;
    return [...retval, ...(_a = pluginInfo2.tasks) != null ? _a : []];
  },
  []
);

// HumanReadableIdentifier.ts
var HumanReadableIdentifier_exports = {};
__export(HumanReadableIdentifier_exports, {
  create: () => create7,
  from: () => from5,
  internalSchema: () => internalSchema5,
  make: () => make6,
  of: () => of6,
  rawSchema: () => rawSchema6,
  schemas: () => schemas6
});

// out/types/HumanReadableIdentifier.ts
var import_fluture8 = require("fluture");
var import_zod8 = require("zod");
var from5 = (input) => {
  try {
    return humanReadableIdentifierSchema.parse(input);
  } catch (previous) {
    if (previous instanceof import_zod8.ZodError) {
      const msgs = previous.errors.reduce(
        (retval, issue) => {
          const path2 = issue.path.join(" \u2192 ");
          const msg = path2 + ": " + issue.message;
          return [...retval, msg];
        },
        ["HumanReadableIdentifier is invalid:"]
      );
      const validationErr = msgs.join("\n") + "\n";
      throw toParseErr(previous, validationErr);
    }
    throw toParseUnknownErr(previous, "There was a problem trying to parse a HumanReadableIdentifier.");
  }
};
var create7 = (input) => from5(input);
var of6 = (input) => {
  try {
    return (0, import_fluture8.resolve)(from5(input));
  } catch (err) {
    return (0, import_fluture8.reject)(err);
  }
};
var make6 = (input) => of6(input);
var schemas6 = {
  rawSchema: humanReadableIdentifierSchema,
  schema: humanReadableIdentifierSchema.transform((val) => val)
};
var rawSchema6 = schemas6.rawSchema;
var internalSchema5 = humanReadableIdentifierSchema;

// i18n.ts
var i18n_exports = {};
__export(i18n_exports, {
  default: () => i18n_default
});
var import_i18next = __toESM(require("i18next"));
var i18n_default = async () => {
  const i18n = {
    ...await import_i18next.default.init({
      lng: "en",
      debug: false,
      resources: {
        en: {
          translation: {
            "appName": "Taqueria",
            "appDesc": "Taqueria is an integrated environment for compiling, testing, and deploying Tezos software.",
            "versionDesc": "Display the version number of the Taqueria program",
            "betaWarning": "Please be advised that Taqueria is currently in BETA.",
            "configDirDesc": "Config directory (default ./.taq)",
            "initDesc": "Initialize a new project",
            "optInDesc": "Opt-in to sharing anonymous usage analytics",
            "optOutDesc": "Opt-out of sharing anonymous usage analytics",
            "initPathDesc": "Path to your project directory",
            "workflowDesc": "Select a workflow to initialize your Taqueria project. Choices are (ligo|smartpy|archetype|michelson)",
            "scaffoldDesc": "Generate a new project using pre-made scaffold",
            "scaffoldUrlDesc": "Alias or Url for the scaffold project",
            "scaffoldProjectDirDesc": "Path where to create the new project. This must be a new directory.",
            "scaffoldDoneMsg": "The project was created using the scaffold.",
            "installDesc": "Install a plugin",
            "pluginInstalled": "Plugin installed successfully",
            "pluginUninstalled": "Plugin uninstalled successfully",
            "uninstallDesc": "Uninstall a plugin",
            "pluginNameDesc": "The name of the plugin",
            "promptForTask": "Please specify which task you would like to execute. If you're starting a new project, please run 'init'.\n",
            "pluginKindDesc": "Kind of plugin (NPM, Binary)",
            "pluginAlreadyInstalled": "That plugin is already installed.",
            "pluginOptionDesc": "Use the task from this plugin",
            "bootstrapMsg": "Project taq'ified!",
            "maxConcurrencyDesc": "Set the maximum concurrency limit used internally",
            "providedByMany": "Provided by more than one plugin. The option --plugin is required.",
            "pluginDesc": "Specify what plugin should execute this command. Use this when more than one plugin provide a task of the same name.",
            "listNetworks": "List known networks",
            "envDesc": "Specify an environment configuration",
            "disableStateDesc": "Does not use the saved state.json file. State is computed for each execution.",
            "logPluginCallsDesc": "Logs any execution calls to a plugin to the console",
            "npmInitRequired": "This project isn't a valid NPM project. Please run: npm init",
            "testFromVsCode": "An internal command used by VS Code to test for the taq binary",
            "fromVsCode": "An internal flag used to indicate that taq is executed via vscode",
            "buildDesc": "Display build information about the current version",
            "pluginOption": "Use to specify what plugin you'd like when running this task.",
            "yesOptionDesc": 'Select "yes" to any prompt',
            "templateNotFound": "Template not found. Perhaps you need to install a plugin?",
            "createDesc": "Create files from pre-existing templates",
            "templateDesc": "Name of the template to use"
          }
        }
      }
    }),
    __: import_i18next.default.t
  };
  return i18n;
};

// InstalledPlugin.ts
var InstalledPlugin_exports = {};
__export(InstalledPlugin_exports, {
  create: () => create8,
  from: () => from6,
  internalSchema: () => internalSchema6,
  make: () => make7,
  of: () => of7,
  rawSchema: () => rawSchema7,
  schemas: () => schemas7
});

// out/types/InstalledPlugin.ts
var import_fluture9 = require("fluture");
var import_zod9 = require("zod");
var from6 = (input) => {
  try {
    return installedPluginSchema.parse(input);
  } catch (previous) {
    if (previous instanceof import_zod9.ZodError) {
      const msgs = previous.errors.reduce(
        (retval, issue) => {
          const path2 = issue.path.join(" \u2192 ");
          const msg = path2 + ": " + issue.message;
          return [...retval, msg];
        },
        ["InstalledPlugin is invalid:"]
      );
      const validationErr = msgs.join("\n") + "\n";
      throw toParseErr(previous, validationErr);
    }
    throw toParseUnknownErr(previous, "There was a problem trying to parse a InstalledPlugin.");
  }
};
var create8 = (input) => from6(input);
var of7 = (input) => {
  try {
    return (0, import_fluture9.resolve)(from6(input));
  } catch (err) {
    return (0, import_fluture9.reject)(err);
  }
};
var make7 = (input) => of7(input);
var schemas7 = {
  rawSchema: installedPluginSchema,
  schema: installedPluginSchema.transform((val) => val)
};
var rawSchema7 = schemas7.rawSchema;
var internalSchema6 = installedPluginSchema;

// LoadedConfig.ts
var LoadedConfig_exports = {};
__export(LoadedConfig_exports, {
  create: () => create9,
  from: () => from7,
  internalSchema: () => internalSchema7,
  make: () => make8,
  of: () => of8,
  rawSchema: () => rawSchema8,
  schemas: () => schemas8
});

// out/types/LoadedConfig.ts
var import_fluture10 = require("fluture");
var import_zod10 = require("zod");
var from7 = (input) => {
  try {
    return loadedConfigSchema.parse(input);
  } catch (previous) {
    if (previous instanceof import_zod10.ZodError) {
      const msgs = previous.errors.reduce(
        (retval, issue) => {
          const path2 = issue.path.join(" \u2192 ");
          const msg = path2 + ": " + issue.message;
          return [...retval, msg];
        },
        ["Your .taq/config.json is invalid:"]
      );
      const validationErr = msgs.join("\n") + "\n";
      throw toParseErr(previous, validationErr);
    }
    throw toParseUnknownErr(previous, "There was a problem trying to parse a LoadedConfig.");
  }
};
var create9 = (input) => from7(input);
var of8 = (input) => {
  try {
    return (0, import_fluture10.resolve)(from7(input));
  } catch (err) {
    return (0, import_fluture10.reject)(err);
  }
};
var make8 = (input) => of8(input);
var schemas8 = {
  rawSchema: loadedConfigSchema,
  schema: loadedConfigSchema.transform((val) => val)
};
var rawSchema8 = schemas8.rawSchema;
var internalSchema7 = loadedConfigSchema;

// MetadataConfig.ts
var MetadataConfig_exports = {};
__export(MetadataConfig_exports, {
  create: () => create10,
  from: () => from8,
  internalSchema: () => internalSchema8,
  make: () => make9,
  of: () => of9,
  rawSchema: () => rawSchema9,
  schemas: () => schemas9
});

// out/types/MetadataConfig.ts
var import_fluture11 = require("fluture");
var import_zod11 = require("zod");
var from8 = (input) => {
  try {
    return metadataConfigSchema.parse(input);
  } catch (previous) {
    if (previous instanceof import_zod11.ZodError) {
      const msgs = previous.errors.reduce(
        (retval, issue) => {
          const path2 = issue.path.join(" \u2192 ");
          const msg = path2 + ": " + issue.message;
          return [...retval, msg];
        },
        ["MetadataConfig is invalid:"]
      );
      const validationErr = msgs.join("\n") + "\n";
      throw toParseErr(previous, validationErr);
    }
    throw toParseUnknownErr(previous, "There was a problem trying to parse a MetadataConfig.");
  }
};
var create10 = (input) => from8(input);
var of9 = (input) => {
  try {
    return (0, import_fluture11.resolve)(from8(input));
  } catch (err) {
    return (0, import_fluture11.reject)(err);
  }
};
var make9 = (input) => of9(input);
var schemas9 = {
  rawSchema: metadataConfigSchema,
  schema: metadataConfigSchema.transform((val) => val)
};
var rawSchema9 = schemas9.rawSchema;
var internalSchema8 = metadataConfigSchema;

// NetworkConfig.ts
var NetworkConfig_exports = {};
__export(NetworkConfig_exports, {
  create: () => create11,
  from: () => from9,
  internalSchema: () => internalSchema9,
  make: () => make10,
  of: () => of10,
  rawSchema: () => rawSchema10,
  schemas: () => schemas10
});

// out/types/NetworkConfig.ts
var import_fluture12 = require("fluture");
var import_zod12 = require("zod");
var from9 = (input) => {
  try {
    return networkConfigSchema.parse(input);
  } catch (previous) {
    if (previous instanceof import_zod12.ZodError) {
      const msgs = previous.errors.reduce(
        (retval, issue) => {
          const path2 = issue.path.join(" \u2192 ");
          const msg = path2 + ": " + issue.message;
          return [...retval, msg];
        },
        ["NetworkConfig is invalid:"]
      );
      const validationErr = msgs.join("\n") + "\n";
      throw toParseErr(previous, validationErr);
    }
    throw toParseUnknownErr(previous, "There was a problem trying to parse a NetworkConfig.");
  }
};
var create11 = (input) => from9(input);
var of10 = (input) => {
  try {
    return (0, import_fluture12.resolve)(from9(input));
  } catch (err) {
    return (0, import_fluture12.reject)(err);
  }
};
var make10 = (input) => of10(input);
var schemas10 = {
  rawSchema: networkConfigSchema,
  schema: networkConfigSchema.transform((val) => val)
};
var rawSchema10 = schemas10.rawSchema;
var internalSchema9 = networkConfigSchema;

// Operation.ts
var Operation_exports = {};
__export(Operation_exports, {
  create: () => create12,
  from: () => from10,
  internalSchema: () => internalSchema10,
  make: () => make11,
  of: () => of11,
  rawSchema: () => rawSchema11,
  schemas: () => schemas11
});

// out/types/Operation.ts
var import_fluture13 = require("fluture");
var import_zod13 = require("zod");
var from10 = (input) => {
  try {
    return operationSchema.parse(input);
  } catch (previous) {
    if (previous instanceof import_zod13.ZodError) {
      const msgs = previous.errors.reduce(
        (retval, issue) => {
          const path2 = issue.path.join(" \u2192 ");
          const msg = path2 + ": " + issue.message;
          return [...retval, msg];
        },
        ["Operation is invalid:"]
      );
      const validationErr = msgs.join("\n") + "\n";
      throw toParseErr(previous, validationErr);
    }
    throw toParseUnknownErr(previous, "There was a problem trying to parse a Operation.");
  }
};
var create12 = (input) => from10(input);
var of11 = (input) => {
  try {
    return (0, import_fluture13.resolve)(from10(input));
  } catch (err) {
    return (0, import_fluture13.reject)(err);
  }
};
var make11 = (input) => of11(input);
var schemas11 = {
  rawSchema: operationSchema,
  schema: operationSchema.transform((val) => val)
};
var rawSchema11 = schemas11.rawSchema;
var internalSchema10 = operationSchema;

// Option.ts
var Option_exports = {};
__export(Option_exports, {
  create: () => create13,
  from: () => from11,
  internalSchema: () => internalSchema11,
  make: () => make12,
  of: () => of12,
  rawSchema: () => rawSchema12,
  schemas: () => schemas12
});

// out/types/Option.ts
var import_fluture14 = require("fluture");
var import_zod14 = require("zod");
var from11 = (input) => {
  try {
    return optionSchema.parse(input);
  } catch (previous) {
    if (previous instanceof import_zod14.ZodError) {
      const msgs = previous.errors.reduce(
        (retval, issue) => {
          const path2 = issue.path.join(" \u2192 ");
          const msg = path2 + ": " + issue.message;
          return [...retval, msg];
        },
        ["Option is invalid:"]
      );
      const validationErr = msgs.join("\n") + "\n";
      throw toParseErr(previous, validationErr);
    }
    throw toParseUnknownErr(previous, "There was a problem trying to parse a Option.");
  }
};
var create13 = (input) => from11(input);
var of12 = (input) => {
  try {
    return (0, import_fluture14.resolve)(from11(input));
  } catch (err) {
    return (0, import_fluture14.reject)(err);
  }
};
var make12 = (input) => of12(input);
var schemas12 = {
  rawSchema: optionSchema,
  schema: optionSchema.transform((val) => val)
};
var rawSchema12 = schemas12.rawSchema;
var internalSchema11 = optionSchema;

// ParsedOperation.ts
var ParsedOperation_exports = {};
__export(ParsedOperation_exports, {
  create: () => create14,
  from: () => from12,
  internalSchema: () => internalSchema12,
  make: () => make13,
  of: () => of13,
  rawSchema: () => rawSchema13,
  schemas: () => schemas13
});

// out/types/ParsedOperation.ts
var import_fluture15 = require("fluture");
var import_zod15 = require("zod");
var from12 = (input) => {
  try {
    return parsedOperationSchema.parse(input);
  } catch (previous) {
    if (previous instanceof import_zod15.ZodError) {
      const msgs = previous.errors.reduce(
        (retval, issue) => {
          const path2 = issue.path.join(" \u2192 ");
          const msg = path2 + ": " + issue.message;
          return [...retval, msg];
        },
        ["ParsedOperation is invalid:"]
      );
      const validationErr = msgs.join("\n") + "\n";
      throw toParseErr(previous, validationErr);
    }
    throw toParseUnknownErr(previous, "There was a problem trying to parse a ParsedOperation.");
  }
};
var create14 = (input) => from12(input);
var of13 = (input) => {
  try {
    return (0, import_fluture15.resolve)(from12(input));
  } catch (err) {
    return (0, import_fluture15.reject)(err);
  }
};
var make13 = (input) => of13(input);
var schemas13 = {
  rawSchema: parsedOperationSchema,
  schema: parsedOperationSchema.transform((val) => val)
};
var rawSchema13 = schemas13.rawSchema;
var internalSchema12 = parsedOperationSchema;

// ParsedTemplate.ts
var ParsedTemplate_exports = {};
__export(ParsedTemplate_exports, {
  create: () => create15,
  from: () => from13,
  internalSchema: () => internalSchema13,
  make: () => make14,
  of: () => of14,
  rawSchema: () => rawSchema14,
  schemas: () => schemas14
});

// out/types/ParsedTemplate.ts
var import_fluture16 = require("fluture");
var import_zod16 = require("zod");
var from13 = (input) => {
  try {
    return parsedTemplateSchema.parse(input);
  } catch (previous) {
    if (previous instanceof import_zod16.ZodError) {
      const msgs = previous.errors.reduce(
        (retval, issue) => {
          const path2 = issue.path.join(" \u2192 ");
          const msg = path2 + ": " + issue.message;
          return [...retval, msg];
        },
        ["ParsedTemplate is invalid:"]
      );
      const validationErr = msgs.join("\n") + "\n";
      throw toParseErr(previous, validationErr);
    }
    throw toParseUnknownErr(previous, "There was a problem trying to parse a ParsedTemplate.");
  }
};
var create15 = (input) => from13(input);
var of14 = (input) => {
  try {
    return (0, import_fluture16.resolve)(from13(input));
  } catch (err) {
    return (0, import_fluture16.reject)(err);
  }
};
var make14 = (input) => of14(input);
var schemas14 = {
  rawSchema: parsedTemplateSchema,
  schema: parsedTemplateSchema.transform((val) => val)
};
var rawSchema14 = schemas14.rawSchema;
var internalSchema13 = parsedTemplateSchema;

// PersistentState.ts
var PersistentState_exports = {};
__export(PersistentState_exports, {
  create: () => create18,
  factory: () => factory3,
  generatedSchemas: () => generatedSchemas3,
  internalSchema: () => internalSchema16,
  make: () => make17,
  of: () => of17,
  rawSchema: () => rawSchema18,
  schemas: () => schemas18
});

// SHA256.ts
var SHA256_exports = {};
__export(SHA256_exports, {
  Crypto: () => Crypto,
  create: () => create16,
  internalSchema: () => internalSchema14,
  make: () => make15,
  of: () => of15,
  rawSchema: () => rawSchema15,
  schemas: () => schemas15,
  toSHA256: () => toSHA256
});
var import_fluture17 = require("fluture");
var import_rambda = require("rambda");
var import_util = require("util");
var import_zod17 = require("zod");
var eager2 = (f) => (0, import_fluture17.promise)(
  (0, import_fluture17.mapRej)((err) => new E_TaqError(err))(f)
);
var Crypto = class {
  constructor() {
    this.subtle = {
      digest(_method, _data) {
        return new ArrayBuffer(50);
      }
    };
  }
};
var getSubtleCrypto = async () => {
  if ((0, import_rambda.has)("SubtleCrypto", globalThis)) {
    return Promise.resolve(crypto.subtle);
  }
  const { Crypto: Crypto2 } = await import("@peculiar/webcrypto");
  const webcrypto = new Crypto2();
  return Promise.resolve(webcrypto.subtle);
};
var rawSchema15 = import_zod17.z.string({ description: "SHA256" }).length(64);
var { schemas: generatedSchemas2, factory: factory2 } = Base_default({
  isStringLike: true,
  rawSchema: rawSchema15,
  parseErrMsg: (value) => `${value} is an invalid SHA256 hash`,
  unknownErrMsg: (value) => `Something went wrong trying to parse the following as a SHA256 value, ${value}`
});
var toSHA256 = async (value) => {
  const encoder = new import_util.TextEncoder();
  const data = encoder.encode(value);
  const hash = await (await getSubtleCrypto()).digest("SHA-256", data);
  const hashArray = Array.from(new Uint8Array(hash));
  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  return eager2(factory2.make(hashHex));
};
var internalSchema14 = generatedSchemas2.schema;
var { create: create16, of: of15, make: make15 } = factory2;
var schemas15 = {
  ...generatedSchemas2,
  schema: generatedSchemas2.schema.transform((val) => val)
};

// out/types/Timestamp.ts
var import_fluture18 = require("fluture");
var import_zod18 = require("zod");
var schemas16 = {
  rawSchema: timestampSchema,
  schema: timestampSchema.transform((val) => val)
};
var rawSchema16 = schemas16.rawSchema;

// Verb.ts
var Verb_exports = {};
__export(Verb_exports, {
  create: () => create17,
  from: () => from14,
  internalSchema: () => internalSchema15,
  make: () => make16,
  of: () => of16,
  rawSchema: () => rawSchema17,
  schemas: () => schemas17
});

// out/types/Verb.ts
var import_fluture19 = require("fluture");
var import_zod19 = require("zod");
var from14 = (input) => {
  try {
    return verbSchema.parse(input);
  } catch (previous) {
    if (previous instanceof import_zod19.ZodError) {
      const msgs = previous.errors.reduce(
        (retval, issue) => {
          const path2 = issue.path.join(" \u2192 ");
          const msg = path2 + ": " + issue.message;
          return [...retval, msg];
        },
        ["Verb is invalid:"]
      );
      const validationErr = msgs.join("\n") + "\n";
      throw toParseErr(previous, validationErr);
    }
    throw toParseUnknownErr(previous, "There was a problem trying to parse a Verb.");
  }
};
var create17 = (input) => from14(input);
var of16 = (input) => {
  try {
    return (0, import_fluture19.resolve)(from14(input));
  } catch (err) {
    return (0, import_fluture19.reject)(err);
  }
};
var make16 = (input) => of16(input);
var schemas17 = {
  rawSchema: verbSchema,
  schema: verbSchema.transform((val) => val)
};
var rawSchema17 = schemas17.rawSchema;
var internalSchema15 = verbSchema;

// PersistentState.ts
var import_zod20 = require("zod");
var rawOpSchema = import_zod20.z.object({
  hash: rawSchema15.describe("state.op.hash"),
  time: rawSchema16.describe("state.op.time"),
  output: import_zod20.z.unknown().describe("state.op.output")
}).describe("Persistent State Operation");
var rawTaskSchema = import_zod20.z.object({
  task: schemas17.rawSchema,
  plugin: import_zod20.z.string().min(1),
  time: rawSchema16.describe("state.task.time"),
  output: import_zod20.z.unknown().describe("state.task.output")
});
var internalOpSchema = import_zod20.z.object({
  hash: schemas15.schema.describe("state.op.hash"),
  time: schemas16.schema.describe("state.op.time"),
  output: import_zod20.z.unknown().describe("state.op.output")
});
var internalTaskSchema = import_zod20.z.object({
  task: schemas17.schema,
  plugin: import_zod20.z.string().min(1),
  time: schemas16.schema.describe("state.task.time"),
  output: import_zod20.z.unknown().describe("state.op.output")
});
var rawSchema18 = import_zod20.z.object({
  operations: import_zod20.z.record(rawOpSchema),
  tasks: import_zod20.z.record(rawTaskSchema)
});
var internalSchema16 = import_zod20.z.object({
  operations: import_zod20.z.record(internalOpSchema),
  tasks: import_zod20.z.record(internalTaskSchema)
}).transform((val) => ({
  operations: val.operations,
  tasks: val.tasks
}));
var { schemas: generatedSchemas3, factory: factory3 } = Base_default({
  rawSchema: rawSchema18,
  parseErrMsg: `The persistent state is invalid`,
  unknownErrMsg: `Something went wrong trying to parse the persistent state`
});
var { create: create18, of: of17, make: make17 } = factory3;
var schemas18 = {
  ...generatedSchemas3,
  schema: generatedSchemas3.schema.transform((val) => val)
};

// PluginActionName.ts
var PluginActionName_exports = {};
__export(PluginActionName_exports, {
  create: () => create19,
  from: () => from15,
  internalSchema: () => internalSchema17,
  make: () => make18,
  of: () => of18,
  rawSchema: () => rawSchema19,
  schemas: () => schemas19
});

// out/types/PluginActionName.ts
var import_fluture20 = require("fluture");
var import_zod21 = require("zod");
var from15 = (input) => {
  try {
    return pluginActionNameSchema.parse(input);
  } catch (previous) {
    if (previous instanceof import_zod21.ZodError) {
      const msgs = previous.errors.reduce(
        (retval, issue) => {
          const path2 = issue.path.join(" \u2192 ");
          const msg = path2 + ": " + issue.message;
          return [...retval, msg];
        },
        ["PluginActionName is invalid:"]
      );
      const validationErr = msgs.join("\n") + "\n";
      throw toParseErr(previous, validationErr);
    }
    throw toParseUnknownErr(previous, "There was a problem trying to parse a PluginActionName.");
  }
};
var create19 = (input) => from15(input);
var of18 = (input) => {
  try {
    return (0, import_fluture20.resolve)(from15(input));
  } catch (err) {
    return (0, import_fluture20.reject)(err);
  }
};
var make18 = (input) => of18(input);
var schemas19 = {
  rawSchema: pluginActionNameSchema,
  schema: pluginActionNameSchema.transform((val) => val)
};
var rawSchema19 = schemas19.rawSchema;
var internalSchema17 = pluginActionNameSchema;

// PluginInfo.ts
var PluginInfo_exports = {};
__export(PluginInfo_exports, {
  create: () => create22,
  factory: () => factory4,
  internalSchema: () => internalSchema20,
  make: () => make21,
  of: () => of21,
  rawSchema: () => rawSchema22,
  schemas: () => schemas22
});

// Task.ts
var Task_exports = {};
__export(Task_exports, {
  create: () => create20,
  from: () => from16,
  internalSchema: () => internalSchema18,
  make: () => make19,
  of: () => of19,
  rawSchema: () => rawSchema20,
  schemas: () => schemas20
});

// out/types/Task.ts
var import_fluture21 = require("fluture");
var import_zod22 = require("zod");
var from16 = (input) => {
  try {
    return taskSchema.parse(input);
  } catch (previous) {
    if (previous instanceof import_zod22.ZodError) {
      const msgs = previous.errors.reduce(
        (retval, issue) => {
          const path2 = issue.path.join(" \u2192 ");
          const msg = path2 + ": " + issue.message;
          return [...retval, msg];
        },
        ["Task is invalid:"]
      );
      const validationErr = msgs.join("\n") + "\n";
      throw toParseErr(previous, validationErr);
    }
    throw toParseUnknownErr(previous, "There was a problem trying to parse a Task.");
  }
};
var create20 = (input) => from16(input);
var of19 = (input) => {
  try {
    return (0, import_fluture21.resolve)(from16(input));
  } catch (err) {
    return (0, import_fluture21.reject)(err);
  }
};
var make19 = (input) => of19(input);
var schemas20 = {
  rawSchema: taskSchema,
  schema: taskSchema.transform((val) => val)
};
var rawSchema20 = schemas20.rawSchema;
var internalSchema18 = taskSchema;

// VersionNumber.ts
var VersionNumber_exports = {};
__export(VersionNumber_exports, {
  create: () => create21,
  from: () => from17,
  internalSchema: () => internalSchema19,
  make: () => make20,
  of: () => of20,
  rawSchema: () => rawSchema21,
  schemas: () => schemas21
});

// out/types/VersionNumber.ts
var import_fluture22 = require("fluture");
var import_zod23 = require("zod");
var from17 = (input) => {
  try {
    return versionNumberSchema.parse(input);
  } catch (previous) {
    if (previous instanceof import_zod23.ZodError) {
      const msgs = previous.errors.reduce(
        (retval, issue) => {
          const path2 = issue.path.join(" \u2192 ");
          const msg = path2 + ": " + issue.message;
          return [...retval, msg];
        },
        ["VersionNumber is invalid:"]
      );
      const validationErr = msgs.join("\n") + "\n";
      throw toParseErr(previous, validationErr);
    }
    throw toParseUnknownErr(previous, "There was a problem trying to parse a VersionNumber.");
  }
};
var create21 = (input) => from17(input);
var of20 = (input) => {
  try {
    return (0, import_fluture22.resolve)(from17(input));
  } catch (err) {
    return (0, import_fluture22.reject)(err);
  }
};
var make20 = (input) => of20(input);
var schemas21 = {
  rawSchema: versionNumberSchema,
  schema: versionNumberSchema.transform((val) => val)
};
var rawSchema21 = schemas21.rawSchema;
var internalSchema19 = versionNumberSchema;

// PluginInfo.ts
var import_zod24 = require("zod");
var rawSchema22 = import_zod24.z.object({
  name: import_zod24.z.string({ description: "Plugin Name" }).min(1),
  version: rawSchema21.describe("Plugin Version #"),
  schema: rawSchema21.describe("Plugin Schema Version #"),
  alias: rawSchema.describe("Plugin Alias"),
  tasks: import_zod24.z.preprocess(
    (val) => val != null ? val : [],
    import_zod24.z.array(
      schemas20.schema.describe("Plugin Task"),
      { description: "Plugin Tasks" }
    )
  ).optional(),
  operations: import_zod24.z.preprocess(
    (val) => val != null ? val : [],
    import_zod24.z.array(
      schemas13.schema.describe("Plugin Operation"),
      { description: "Plugin Operations" }
    )
  ).optional(),
  templates: import_zod24.z.preprocess(
    (val) => val != null ? val : [],
    import_zod24.z.array(
      schemas14.schema.describe("Plugin Template")
    )
  ).optional()
});
var internalSchema20 = rawSchema22.extend({
  version: schemas21.schema.describe("Plugin Version #"),
  schema: schemas21.schema.describe("Plugin Schema Version #"),
  alias: schemas.schema.describe("Plugin Alias"),
  tasks: import_zod24.z.preprocess(
    (val) => val != null ? val : [],
    import_zod24.z.array(
      schemas20.schema.describe("Plugin Task"),
      { description: "Plugin Tasks" }
    )
  ).optional(),
  operations: import_zod24.z.preprocess(
    (val) => val != null ? val : [],
    import_zod24.z.array(
      schemas13.schema.describe("Plugin Operation"),
      { description: "Plugin Operations" }
    )
  ).optional(),
  templates: import_zod24.z.preprocess(
    (val) => val != null ? val : [],
    import_zod24.z.array(
      schemas14.schema.describe("Plugin Template")
    )
  ).optional()
}).describe("Plugin Schema");
var { schemas: schemas22, factory: factory4 } = Base_default({
  rawSchema: rawSchema22,
  internalSchema: internalSchema20,
  parseErrMsg: "The schema returned from the plugin is invalid",
  unknownErrMsg: "Something went wrong parsing the schema from a plugin"
});
var { create: create22, of: of21, make: make21 } = factory4;

// PluginJsonResponse.ts
var PluginJsonResponse_exports = {};
__export(PluginJsonResponse_exports, {
  create: () => create23,
  from: () => from18,
  internalSchema: () => internalSchema21,
  make: () => make22,
  of: () => of22,
  rawSchema: () => rawSchema23,
  schemas: () => schemas23
});

// out/types/PluginJsonResponse.ts
var import_fluture23 = require("fluture");
var import_zod25 = require("zod");
var from18 = (input) => {
  try {
    return pluginJsonResponseSchema.parse(input);
  } catch (previous) {
    if (previous instanceof import_zod25.ZodError) {
      const msgs = previous.errors.reduce(
        (retval, issue) => {
          const path2 = issue.path.join(" \u2192 ");
          const msg = path2 + ": " + issue.message;
          return [...retval, msg];
        },
        ["PluginJsonResponse is invalid:"]
      );
      const validationErr = msgs.join("\n") + "\n";
      throw toParseErr(previous, validationErr);
    }
    throw toParseUnknownErr(previous, "There was a problem trying to parse a PluginJsonResponse.");
  }
};
var create23 = (input) => from18(input);
var of22 = (input) => {
  try {
    return (0, import_fluture23.resolve)(from18(input));
  } catch (err) {
    return (0, import_fluture23.reject)(err);
  }
};
var make22 = (input) => of22(input);
var schemas23 = {
  rawSchema: pluginJsonResponseSchema,
  schema: pluginJsonResponseSchema.transform((val) => val)
};
var rawSchema23 = schemas23.rawSchema;
var internalSchema21 = pluginJsonResponseSchema;

// PluginResponseEncoding.ts
var PluginResponseEncoding_exports = {};
__export(PluginResponseEncoding_exports, {
  create: () => create24,
  from: () => from19,
  internalSchema: () => internalSchema22,
  make: () => make23,
  of: () => of23,
  rawSchema: () => rawSchema24,
  schemas: () => schemas24
});

// out/types/PluginResponseEncoding.ts
var import_fluture24 = require("fluture");
var import_zod26 = require("zod");
var from19 = (input) => {
  try {
    return pluginResponseEncodingSchema.parse(input);
  } catch (previous) {
    if (previous instanceof import_zod26.ZodError) {
      const msgs = previous.errors.reduce(
        (retval, issue) => {
          const path2 = issue.path.join(" \u2192 ");
          const msg = path2 + ": " + issue.message;
          return [...retval, msg];
        },
        ["PluginResponseEncoding is invalid:"]
      );
      const validationErr = msgs.join("\n") + "\n";
      throw toParseErr(previous, validationErr);
    }
    throw toParseUnknownErr(previous, "There was a problem trying to parse a PluginResponseEncoding.");
  }
};
var create24 = (input) => from19(input);
var of23 = (input) => {
  try {
    return (0, import_fluture24.resolve)(from19(input));
  } catch (err) {
    return (0, import_fluture24.reject)(err);
  }
};
var make23 = (input) => of23(input);
var schemas24 = {
  rawSchema: pluginResponseEncodingSchema,
  schema: pluginResponseEncodingSchema.transform((val) => val)
};
var rawSchema24 = schemas24.rawSchema;
var internalSchema22 = pluginResponseEncodingSchema;

// PluginSchema.ts
var PluginSchema_exports = {};
__export(PluginSchema_exports, {
  create: () => create27,
  factory: () => factory5,
  generatedSchemas: () => generatedSchemas4,
  make: () => make25,
  of: () => of25,
  rawSchema: () => rawSchema26,
  schemas: () => schemas26
});

// Template.ts
var Template_exports = {};
__export(Template_exports, {
  create: () => create26,
  from: () => from20,
  internalSchema: () => internalSchema23,
  make: () => make24,
  of: () => of24,
  rawSchema: () => rawSchema25,
  schemas: () => schemas25
});

// out/types/Template.ts
var import_fluture25 = require("fluture");
var import_zod27 = require("zod");
var from20 = (input) => {
  try {
    return templateSchema.parse(input);
  } catch (previous) {
    if (previous instanceof import_zod27.ZodError) {
      const msgs = previous.errors.reduce(
        (retval, issue) => {
          const path2 = issue.path.join(" \u2192 ");
          const msg = path2 + ": " + issue.message;
          return [...retval, msg];
        },
        ["Template is invalid:"]
      );
      const validationErr = msgs.join("\n") + "\n";
      throw toParseErr(previous, validationErr);
    }
    throw toParseUnknownErr(previous, "There was a problem trying to parse a Template.");
  }
};
var create25 = (input) => from20(input);
var of24 = (input) => {
  try {
    return (0, import_fluture25.resolve)(from20(input));
  } catch (err) {
    return (0, import_fluture25.reject)(err);
  }
};
var make24 = (input) => of24(input);
var schemas25 = {
  rawSchema: templateSchema,
  schema: templateSchema.transform((val) => val)
};
var rawSchema25 = schemas25.rawSchema;
var internalSchema23 = templateSchema;

// Template.ts
function create26(args) {
  return create25(args);
}

// PluginSchema.ts
var import_zod28 = require("zod");
var internalSchema24 = internalSchema20.extend({
  operations: import_zod28.z.preprocess(
    (val) => val != null ? val : [],
    import_zod28.z.array(
      schemas11.schema,
      { description: "ParsedOperations" }
    ).optional()
  ),
  templates: import_zod28.z.preprocess(
    (val) => val != null ? val : [],
    import_zod28.z.array(
      schemas25.schema
    ).optional()
  )
}).passthrough().describe("ParsedPluginInfo");
var rawSchema26 = rawSchema22.extend({
  name: rawSchema.optional(),
  operations: import_zod28.z.preprocess(
    (val) => val != null ? val : [],
    import_zod28.z.array(
      rawSchema11,
      { description: "ParsedOperation" }
    )
  ).optional(),
  templates: import_zod28.z.preprocess(
    (val) => val != null ? val : [],
    import_zod28.z.array(
      schemas25.schema
    ).optional()
  )
}).passthrough().describe("ParsedPluginInfo");
var { schemas: generatedSchemas4, factory: factory5 } = Base_default({
  rawSchema: rawSchema26,
  internalSchema: internalSchema24,
  parseErrMsg: (value) => `The following plugin info gave us trouble when parsing the following plugin information: ${value}`,
  unknownErrMsg: "Something went wrong trying to parse the plugin information"
});
var { create: create27, of: of25, make: make25 } = factory5;
var schemas26 = {
  ...generatedSchemas4,
  schema: generatedSchemas4.schema.transform((val) => val)
};

// PositionalArg.ts
var PositionalArg_exports = {};
__export(PositionalArg_exports, {
  create: () => create28,
  from: () => from21,
  internalSchema: () => internalSchema25,
  make: () => make26,
  of: () => of26,
  rawSchema: () => rawSchema27,
  schemas: () => schemas27
});

// out/types/PositionalArg.ts
var import_fluture26 = require("fluture");
var import_zod29 = require("zod");
var from21 = (input) => {
  try {
    return positionalArgSchema.parse(input);
  } catch (previous) {
    if (previous instanceof import_zod29.ZodError) {
      const msgs = previous.errors.reduce(
        (retval, issue) => {
          const path2 = issue.path.join(" \u2192 ");
          const msg = path2 + ": " + issue.message;
          return [...retval, msg];
        },
        ["PositionalArg is invalid:"]
      );
      const validationErr = msgs.join("\n") + "\n";
      throw toParseErr(previous, validationErr);
    }
    throw toParseUnknownErr(previous, "There was a problem trying to parse a PositionalArg.");
  }
};
var create28 = (input) => from21(input);
var of26 = (input) => {
  try {
    return (0, import_fluture26.resolve)(from21(input));
  } catch (err) {
    return (0, import_fluture26.reject)(err);
  }
};
var make26 = (input) => of26(input);
var schemas27 = {
  rawSchema: positionalArgSchema,
  schema: positionalArgSchema.transform((val) => val)
};
var rawSchema27 = schemas27.rawSchema;
var internalSchema25 = positionalArgSchema;

// RequestArgs.ts
var RequestArgs_exports = {};
__export(RequestArgs_exports, {
  create: () => create29,
  from: () => from22,
  internalSchema: () => internalSchema26,
  make: () => make27,
  of: () => of27,
  rawSchema: () => rawSchema28,
  schemas: () => schemas28
});

// out/types/RequestArgs.ts
var import_fluture27 = require("fluture");
var import_zod30 = require("zod");
var from22 = (input) => {
  try {
    return requestArgsSchema.parse(input);
  } catch (previous) {
    if (previous instanceof import_zod30.ZodError) {
      const msgs = previous.errors.reduce(
        (retval, issue) => {
          const path2 = issue.path.join(" \u2192 ");
          const msg = path2 + ": " + issue.message;
          return [...retval, msg];
        },
        ["RequestArgs is invalid:"]
      );
      const validationErr = msgs.join("\n") + "\n";
      throw toParseErr(previous, validationErr);
    }
    throw toParseUnknownErr(previous, "There was a problem trying to parse a RequestArgs.");
  }
};
var create29 = (input) => from22(input);
var of27 = (input) => {
  try {
    return (0, import_fluture27.resolve)(from22(input));
  } catch (err) {
    return (0, import_fluture27.reject)(err);
  }
};
var make27 = (input) => of27(input);
var schemas28 = {
  rawSchema: requestArgsSchema,
  schema: requestArgsSchema.transform((val) => val)
};
var rawSchema28 = schemas28.rawSchema;
var internalSchema26 = requestArgsSchema;

// SandboxAccountConfig.ts
var SandboxAccountConfig_exports = {};
__export(SandboxAccountConfig_exports, {
  create: () => create30,
  from: () => from23,
  internalSchema: () => internalSchema27,
  make: () => make28,
  of: () => of28,
  rawSchema: () => rawSchema29,
  schemas: () => schemas29
});

// out/types/SandboxAccountConfig.ts
var import_fluture28 = require("fluture");
var import_zod31 = require("zod");
var from23 = (input) => {
  try {
    return sandboxAccountConfigSchema.parse(input);
  } catch (previous) {
    if (previous instanceof import_zod31.ZodError) {
      const msgs = previous.errors.reduce(
        (retval, issue) => {
          const path2 = issue.path.join(" \u2192 ");
          const msg = path2 + ": " + issue.message;
          return [...retval, msg];
        },
        ["SandboxAccountConfig is invalid:"]
      );
      const validationErr = msgs.join("\n") + "\n";
      throw toParseErr(previous, validationErr);
    }
    throw toParseUnknownErr(previous, "There was a problem trying to parse a SandboxAccountConfig.");
  }
};
var create30 = (input) => from23(input);
var of28 = (input) => {
  try {
    return (0, import_fluture28.resolve)(from23(input));
  } catch (err) {
    return (0, import_fluture28.reject)(err);
  }
};
var make28 = (input) => of28(input);
var schemas29 = {
  rawSchema: sandboxAccountConfigSchema,
  schema: sandboxAccountConfigSchema.transform((val) => val)
};
var rawSchema29 = schemas29.rawSchema;
var internalSchema27 = sandboxAccountConfigSchema;

// SandboxConfig.ts
var SandboxConfig_exports = {};
__export(SandboxConfig_exports, {
  create: () => create31,
  from: () => from24,
  internalSchema: () => internalSchema28,
  make: () => make29,
  of: () => of29,
  rawSchema: () => rawSchema30,
  schemas: () => schemas30
});

// out/types/SandboxConfig.ts
var import_fluture29 = require("fluture");
var import_zod32 = require("zod");
var from24 = (input) => {
  try {
    return sandboxConfigSchema.parse(input);
  } catch (previous) {
    if (previous instanceof import_zod32.ZodError) {
      const msgs = previous.errors.reduce(
        (retval, issue) => {
          const path2 = issue.path.join(" \u2192 ");
          const msg = path2 + ": " + issue.message;
          return [...retval, msg];
        },
        ["SandboxConfig is invalid:"]
      );
      const validationErr = msgs.join("\n") + "\n";
      throw toParseErr(previous, validationErr);
    }
    throw toParseUnknownErr(previous, "There was a problem trying to parse a SandboxConfig.");
  }
};
var create31 = (input) => from24(input);
var of29 = (input) => {
  try {
    return (0, import_fluture29.resolve)(from24(input));
  } catch (err) {
    return (0, import_fluture29.reject)(err);
  }
};
var make29 = (input) => of29(input);
var schemas30 = {
  rawSchema: sandboxConfigSchema,
  schema: sandboxConfigSchema.transform((val) => val)
};
var rawSchema30 = schemas30.rawSchema;
var internalSchema28 = sandboxConfigSchema;

// SanitizedAbsPath.ts
var SanitizedAbsPath_exports = {};
__export(SanitizedAbsPath_exports, {
  create: () => create32,
  factory: () => factory6,
  generatedSchemas: () => generatedSchemas5,
  make: () => make30,
  of: () => of30,
  rawSchema: () => rawSchema31,
  schemas: () => schemas31
});
var path = __toESM(require("path"));
var import_zod33 = require("zod");
var rawSchema31 = import_zod33.z.string({ description: "SanitizedAbsPath" }).min(1);
var { schemas: generatedSchemas5, factory: factory6 } = Base_default({
  isStringLike: true,
  rawSchema: rawSchema31,
  transformer: (value) => path.resolve(value),
  parseErrMsg: (value) => `${value} is an invalid absolute path`,
  unknownErrMsg: (value) => `Something went wrong trying to parse the absolute path, ${value}`
});
var { create: create32, make: make30, of: of30 } = factory6;
var schemas31 = {
  ...generatedSchemas5,
  schema: generatedSchemas5.schema.transform((val) => val)
};

// SanitizedArgs.ts
var SanitizedArgs_exports = {};
__export(SanitizedArgs_exports, {
  create: () => create33,
  createCreateTaskArgs: () => createCreateTaskArgs,
  createInstallTaskArgs: () => createInstallTaskArgs,
  createProvisionTaskArgs: () => createProvisionTaskArgs,
  createScaffoldTaskArgs: () => createScaffoldTaskArgs,
  createSetEnvTaskArgs: () => createSetEnvTaskArgs,
  createTaskArgs: () => createTaskArgs,
  createUninstallTaskArgs: () => createUninstallTaskArgs,
  factory: () => factory7,
  generatedSchemas: () => generatedSchemas6,
  initRawSchema: () => initRawSchema,
  installTaskArgs: () => installTaskArgs,
  make: () => make31,
  makeCreateTaskArgs: () => makeCreateTaskArgs,
  makeInstallTaskArgs: () => makeInstallTaskArgs,
  makeProvisionTaskArgs: () => makeProvisionTaskArgs,
  makeScaffoldTaskArgs: () => makeScaffoldTaskArgs,
  makeSetEnvTaskArgs: () => makeSetEnvTaskArgs,
  makeUninstallTaskArgs: () => makeUninstallTaskArgs,
  managePluginRawSchema: () => managePluginRawSchema,
  of: () => of31,
  ofCreateTaskArgs: () => ofCreateTaskArgs,
  ofInstallTaskArgs: () => ofInstallTaskArgs,
  ofProvisionTaskArgs: () => ofProvisionTaskArgs,
  ofScaffoldTaskArgs: () => ofScaffoldTaskArgs,
  ofSetEnvTaskArgs: () => ofSetEnvTaskArgs,
  ofUninstallTaskArgs: () => ofUninstallTaskArgs,
  provisionRawSchema: () => provisionRawSchema,
  provisionTaskArgs: () => provisionTaskArgs,
  rawSchema: () => rawSchema33,
  scaffoldRawSchema: () => scaffoldRawSchema,
  scaffoldTaskArgs: () => scaffoldTaskArgs,
  schemas: () => schemas33,
  setEnvRawSchema: () => setEnvRawSchema,
  setEnvTaskArgs: () => setEnvTaskArgs,
  templateRawSchema: () => templateRawSchema,
  uninstallTaskArgs: () => uninstallTaskArgs
});

// out/types/NonEmptyString.ts
var import_fluture30 = require("fluture");
var import_zod34 = require("zod");
var schemas32 = {
  rawSchema: nonEmptyStringSchema,
  schema: nonEmptyStringSchema.transform((val) => val)
};
var rawSchema32 = schemas32.rawSchema;

// SanitizedArgs.ts
var import_zod35 = require("zod");
var rawSchema33 = import_zod35.z.object({
  _: import_zod35.z.array(import_zod35.z.union([import_zod35.z.string().min(1), import_zod35.z.number()])),
  projectDir: schemas31.schema,
  maxConcurrency: import_zod35.z.preprocess(
    (val) => typeof val === "string" ? parseInt(val) : Number(val),
    import_zod35.z.number().int().min(1).default(10)
  ),
  debug: import_zod35.z.preprocess(
    (val) => Boolean(val),
    import_zod35.z.boolean().default(false)
  ),
  disableState: import_zod35.z.preprocess(
    (val) => Boolean(val),
    import_zod35.z.boolean().default(false)
  ),
  logPluginRequests: import_zod35.z.preprocess(
    (val) => Boolean(val),
    import_zod35.z.boolean().default(false)
  ),
  fromVsCode: import_zod35.z.preprocess(
    (val) => Boolean(val),
    import_zod35.z.boolean().default(false)
  ),
  version: import_zod35.z.preprocess(
    (val) => Boolean(val),
    import_zod35.z.boolean().optional()
  ),
  build: import_zod35.z.preprocess(
    (val) => Boolean(val),
    import_zod35.z.boolean().optional()
  ),
  help: import_zod35.z.preprocess(
    (val) => Boolean(val),
    import_zod35.z.boolean().optional()
  ),
  yes: import_zod35.z.preprocess(
    (val) => Boolean(val),
    import_zod35.z.boolean().optional()
  ),
  plugin: schemas32.schema.optional(),
  env: import_zod35.z.string().optional(),
  quickstart: import_zod35.z.string().min(1).optional(),
  setBuild: import_zod35.z.preprocess(
    (val) => String(val),
    import_zod35.z.string().min(3)
  ),
  setVersion: import_zod35.z.string().min(3),
  pluginName: import_zod35.z.string().min(1).optional()
}, { description: "Sanitizied Args" }).passthrough();
var scaffoldRawSchema = rawSchema33.extend({
  scaffoldProjectDir: import_zod35.z.string().min(1).transform((val) => val),
  scaffoldUrl: import_zod35.z.string().min(1).url().transform((val) => val),
  branch: import_zod35.z.string().min(1).optional()
});
var initRawSchema = rawSchema33.extend({
  workflow: import_zod35.z.string().refine((val) => val === "ligo" || val === "smartpy" || val === "archetype" || val === "michelson").optional()
});
var provisionRawSchema = rawSchema33.extend({
  operation: import_zod35.z.string().min(1).describe("Operation name"),
  name: import_zod35.z.string().min(1).regex(
    /^[a-z0-9]+[a-z0-9-_]$/,
    "Provisioner name must consist of one or more letters/numbers and may not start with an underscore or dash."
  ).describe("Provisioner name").optional()
}).passthrough();
var templateRawSchema = rawSchema33.extend({
  template: import_zod35.z.string().min(1)
}).passthrough();
var managePluginRawSchema = rawSchema33.omit({ pluginName: true }).extend({
  pluginName: import_zod35.z.string().min(1)
});
var setEnvRawSchema = rawSchema33.extend({
  defaultEnvironment: import_zod35.z.string().min(1)
});
var { schemas: generatedSchemas6, factory: factory7 } = Base_default({
  rawSchema: rawSchema33,
  parseErrMsg: "The arguments provided are invalid",
  unknownErrMsg: "Something went wrong parsing the command-line arguments"
});
var { create: create33, of: of31, make: make31 } = factory7;
var schemas33 = {
  ...generatedSchemas6,
  schema: generatedSchemas6.schema.transform((val) => val)
};
var scaffoldTaskArgs = Base_default({
  rawSchema: scaffoldRawSchema,
  parseErrMsg: "The arguments provided are invalid for the scaffold task",
  unknownErrMsg: "Something went wrong parsing the arguments for the scaffold task"
});
var provisionTaskArgs = Base_default({
  rawSchema: provisionRawSchema,
  parseErrMsg: "The arguments provided are invalid for the provision task",
  unknownErrMsg: "Something went wrong parsing the arguments for the provision task"
});
var installTaskArgs = Base_default({
  rawSchema: managePluginRawSchema,
  parseErrMsg: "The arguments provided are invalid for the install task",
  unknownErrMsg: "Something went wrong parsing the arguments for the install task"
});
var uninstallTaskArgs = Base_default({
  rawSchema: managePluginRawSchema,
  parseErrMsg: "The arguments provided are invalid for the uninstall task",
  unknownErrMsg: "Something went wrong parsing the arguments for the uninstall task"
});
var setEnvTaskArgs = Base_default({
  rawSchema: setEnvRawSchema,
  parseErrMsg: "The arguments provided are invalid for the set-environment task",
  unknownErrMsg: "Something went wrong parsing the arguments for the set-environment task"
});
var createTaskArgs = Base_default({
  rawSchema: templateRawSchema,
  parseErrMsg: "The arguments provided are invalid for the create task",
  unknownErrMsg: "Something went wrong parsing the arguments for the create task"
});
var createScaffoldTaskArgs = scaffoldTaskArgs.factory.from;
var makeScaffoldTaskArgs = scaffoldTaskArgs.factory.make;
var ofScaffoldTaskArgs = scaffoldTaskArgs.factory.of;
var createProvisionTaskArgs = provisionTaskArgs.factory.create;
var makeProvisionTaskArgs = provisionTaskArgs.factory.make;
var ofProvisionTaskArgs = provisionTaskArgs.factory.of;
var createInstallTaskArgs = installTaskArgs.factory.create;
var makeInstallTaskArgs = installTaskArgs.factory.make;
var ofInstallTaskArgs = installTaskArgs.factory.of;
var createUninstallTaskArgs = uninstallTaskArgs.factory.create;
var makeUninstallTaskArgs = uninstallTaskArgs.factory.make;
var ofUninstallTaskArgs = uninstallTaskArgs.factory.of;
var createSetEnvTaskArgs = setEnvTaskArgs.factory.create;
var makeSetEnvTaskArgs = setEnvTaskArgs.factory.make;
var ofSetEnvTaskArgs = setEnvTaskArgs.factory.of;
var createCreateTaskArgs = createTaskArgs.factory.create;
var makeCreateTaskArgs = createTaskArgs.factory.make;
var ofCreateTaskArgs = createTaskArgs.factory.of;

// SanitizedPath.ts
var SanitizedPath_exports = {};
__export(SanitizedPath_exports, {
  create: () => create34,
  from: () => from25,
  internalSchema: () => internalSchema29,
  make: () => make32,
  of: () => of32,
  rawSchema: () => rawSchema34,
  schemas: () => schemas34
});

// out/types/SanitizedPath.ts
var import_fluture31 = require("fluture");
var import_zod36 = require("zod");
var from25 = (input) => {
  try {
    return sanitizedPathSchema.parse(input);
  } catch (previous) {
    if (previous instanceof import_zod36.ZodError) {
      const msgs = previous.errors.reduce(
        (retval, issue) => {
          const path2 = issue.path.join(" \u2192 ");
          const msg = path2 + ": " + issue.message;
          return [...retval, msg];
        },
        ["SanitizedPath is invalid:"]
      );
      const validationErr = msgs.join("\n") + "\n";
      throw toParseErr(previous, validationErr);
    }
    throw toParseUnknownErr(previous, "There was a problem trying to parse a SanitizedPath.");
  }
};
var create34 = (input) => from25(input);
var of32 = (input) => {
  try {
    return (0, import_fluture31.resolve)(from25(input));
  } catch (err) {
    return (0, import_fluture31.reject)(err);
  }
};
var make32 = (input) => of32(input);
var schemas34 = {
  rawSchema: sanitizedPathSchema,
  schema: sanitizedPathSchema.transform((val) => val)
};
var rawSchema34 = schemas34.rawSchema;
var internalSchema29 = sanitizedPathSchema;

// ScaffoldConfig.ts
var ScaffoldConfig_exports = {};
__export(ScaffoldConfig_exports, {
  create: () => create35,
  from: () => from26,
  internalSchema: () => internalSchema30,
  make: () => make33,
  of: () => of33,
  rawSchema: () => rawSchema35,
  schemas: () => schemas35
});

// out/types/ScaffoldConfig.ts
var import_fluture32 = require("fluture");
var import_zod37 = require("zod");
var from26 = (input) => {
  try {
    return scaffoldConfigSchema.parse(input);
  } catch (previous) {
    if (previous instanceof import_zod37.ZodError) {
      const msgs = previous.errors.reduce(
        (retval, issue) => {
          const path2 = issue.path.join(" \u2192 ");
          const msg = path2 + ": " + issue.message;
          return [...retval, msg];
        },
        ["ScaffoldConfig is invalid:"]
      );
      const validationErr = msgs.join("\n") + "\n";
      throw toParseErr(previous, validationErr);
    }
    throw toParseUnknownErr(previous, "There was a problem trying to parse a ScaffoldConfig.");
  }
};
var create35 = (input) => from26(input);
var of33 = (input) => {
  try {
    return (0, import_fluture32.resolve)(from26(input));
  } catch (err) {
    return (0, import_fluture32.reject)(err);
  }
};
var make33 = (input) => of33(input);
var schemas35 = {
  rawSchema: scaffoldConfigSchema,
  schema: scaffoldConfigSchema.transform((val) => val)
};
var rawSchema35 = schemas35.rawSchema;
var internalSchema30 = scaffoldConfigSchema;

// Url.ts
var Url_exports = {};
__export(Url_exports, {
  create: () => create36,
  from: () => from27,
  internalSchema: () => internalSchema31,
  make: () => make34,
  of: () => of34,
  rawSchema: () => rawSchema36,
  schemas: () => schemas36
});

// out/types/Url.ts
var import_fluture33 = require("fluture");
var import_zod38 = require("zod");
var from27 = (input) => {
  try {
    return urlSchema.parse(input);
  } catch (previous) {
    if (previous instanceof import_zod38.ZodError) {
      const msgs = previous.errors.reduce(
        (retval, issue) => {
          const path2 = issue.path.join(" \u2192 ");
          const msg = path2 + ": " + issue.message;
          return [...retval, msg];
        },
        ["Url is invalid:"]
      );
      const validationErr = msgs.join("\n") + "\n";
      throw toParseErr(previous, validationErr);
    }
    throw toParseUnknownErr(previous, "There was a problem trying to parse a Url.");
  }
};
var create36 = (input) => from27(input);
var of34 = (input) => {
  try {
    return (0, import_fluture33.resolve)(from27(input));
  } catch (err) {
    return (0, import_fluture33.reject)(err);
  }
};
var make34 = (input) => of34(input);
var schemas36 = {
  rawSchema: urlSchema,
  schema: urlSchema.transform((val) => val)
};
var rawSchema36 = schemas36.rawSchema;
var internalSchema31 = urlSchema;
//# sourceMappingURL=taqueria-protocol-types.js.map