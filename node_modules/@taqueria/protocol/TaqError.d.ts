import { ZodError } from 'zod';
export type ErrorType = 'E_INVALID_PATH_DOES_NOT_EXIST' | 'E_INVALID_PATH_EXISTS_AND_NOT_AN_EMPTY_DIR' | 'E_INVALID_PATH_ALREADY_EXISTS' | 'E_INVALID_CONFIG' | 'E_INVALID_JSON' | 'E_FORK' | 'E_INVALID_TASK' | 'E_READFILE' | 'E_NPM_INIT' | 'E_INVALID_PLUGIN_RESPONSE' | 'E_INVALID_ARGS' | 'E_MKDIR_FAILED' | 'E_GIT_CLONE_FAILED' | 'E_PROVISION' | 'E_PARSE' | 'E_PARSE_UNKNOWN' | 'E_INVALID_ARCH' | 'E_NO_PROVISIONS' | 'E_INTERNAL_LOGICAL_VALIDATION_FAILURE' | 'E_EXEC' | 'E_OPT_IN_WARNING' | 'E_INVALID_OPTION' | 'E_TAQ_PROJECT_NOT_FOUND';
export interface TaqError {
    readonly kind: ErrorType;
    msg: string;
    previous?: TaqError | Error | unknown;
    context?: unknown;
}
export type t = TaqError;
export declare class E_TaqError extends Error {
    readonly context: unknown;
    readonly kind: ErrorType;
    readonly previous: unknown;
    constructor(taqErr: TaqError);
}
export declare const toFutureParseErr: <T>(previous: ZodError, msg: string, context?: unknown) => import("fluture").FutureInstance<TaqError, T>;
export declare const toParseErr: (previous: ZodError, msg: string, context?: unknown) => TaqError;
export declare const toParseUnknownErr: (previous: Error | TaqError | E_TaqError | unknown, msg: string, context?: unknown) => TaqError;
export declare const toFutureParseUnknownErr: <T>(previous: Error | TaqError | E_TaqError | unknown, msg: string, context?: unknown) => import("fluture").FutureInstance<TaqError, T>;
export declare const create: (err: TaqError) => TaqError;
//# sourceMappingURL=TaqError.d.ts.map