{"version":3,"sources":["tzkt-config.ts","TaqError.ts","Base.ts"],"sourcesContent":["import createType from './Base';\nimport { z } from 'zod';\n\nexport const rawSchema = z.object({\n\tdisableAutostartWithSandbox: z.boolean({ description: 'Do not start TzKt when sandbox starts' }).default(false),\n\tpostgresqlPort: z.number({ description: 'Port number for postgresql container' }).default(5432),\n\tapiPort: z.number({ description: 'Port number for TzKt API' }).default(5000),\n});\n\ntype Input = z.infer<typeof rawSchema>;\n\nexport const { schemas: generatedSchemas, factory } = createType<Input, Input>({\n\trawSchema,\n\tparseErrMsg: (value: unknown) => `${value} is not a valid TzKt configuration `,\n\tunknownErrMsg: 'Something went wrong trying to parse the TzKt configuration',\n});\n\nexport type TzKtConfig = z.infer<typeof generatedSchemas.schema>;\n\nexport type t = TzKtConfig;\n\nexport const { create, of, make } = factory;\n\nexport const schemas = {\n\t...generatedSchemas,\n\tschema: generatedSchemas.schema.transform(val => val as TzKtConfig),\n};\n","import { map, reject } from 'fluture';\nimport { ZodError } from 'zod';\n\nexport type ErrorType =\n\t| 'E_INVALID_PATH_DOES_NOT_EXIST'\n\t| 'E_INVALID_PATH_EXISTS_AND_NOT_AN_EMPTY_DIR'\n\t| 'E_INVALID_PATH_ALREADY_EXISTS'\n\t| 'E_INVALID_CONFIG'\n\t| 'E_INVALID_JSON'\n\t| 'E_FORK'\n\t| 'E_INVALID_TASK'\n\t| 'E_READFILE'\n\t| 'E_NPM_INIT'\n\t| 'E_INVALID_PLUGIN_RESPONSE'\n\t| 'E_INVALID_ARGS'\n\t| 'E_MKDIR_FAILED'\n\t| 'E_GIT_CLONE_FAILED'\n\t| 'E_PROVISION'\n\t| 'E_PARSE'\n\t| 'E_PARSE_UNKNOWN'\n\t| 'E_INVALID_ARCH'\n\t| 'E_NO_PROVISIONS'\n\t| 'E_INTERNAL_LOGICAL_VALIDATION_FAILURE'\n\t| 'E_EXEC'\n\t| 'E_OPT_IN_WARNING'\n\t| 'E_INVALID_OPTION'\n\t| 'E_TAQ_PROJECT_NOT_FOUND';\n\nexport interface TaqError {\n\treadonly kind: ErrorType;\n\tmsg: string;\n\tprevious?: TaqError | Error | unknown;\n\tcontext?: unknown;\n}\n\nexport type t = TaqError;\n\nexport class E_TaqError extends Error {\n\treadonly context;\n\treadonly kind;\n\treadonly previous;\n\tconstructor(taqErr: TaqError) {\n\t\tsuper(taqErr.msg);\n\t\tthis.context = taqErr.context;\n\t\tthis.kind = taqErr.kind;\n\t\tthis.name = this.kind;\n\t\tthis.previous = taqErr.previous;\n\t}\n}\n\nexport const toFutureParseErr = <T>(previous: ZodError, msg: string, context?: unknown) =>\n\treject(toParseErr(previous, msg, context))\n\t\t.pipe(map((val: unknown) => val as T));\n\nexport const toParseErr = (previous: ZodError, msg: string, context?: unknown) =>\n\tcreate({\n\t\tkind: 'E_PARSE',\n\t\tmsg: msg,\n\t\tcontext,\n\t\tprevious,\n\t});\n\nexport const toParseUnknownErr = (previous: Error | TaqError | E_TaqError | unknown, msg: string, context?: unknown) =>\n\tcreate({\n\t\tkind: 'E_PARSE_UNKNOWN',\n\t\tmsg: msg,\n\t\tcontext,\n\t\tprevious,\n\t});\n\nexport const toFutureParseUnknownErr = <T>(\n\tprevious: Error | TaqError | E_TaqError | unknown,\n\tmsg: string,\n\tcontext?: unknown,\n) =>\n\treject(toParseUnknownErr(previous, msg, context))\n\t\t.pipe(map((val: unknown) => val as T));\n\nexport const create = (err: TaqError) => err;\n","import { toFutureParseErr, toFutureParseUnknownErr } from './TaqError';\nimport { FutureInstance, resolve } from 'fluture';\nimport { z, ZodError, ZodSchema } from 'zod';\n\ntype Future<L, R> = FutureInstance<L, R>;\n\ntype ErrMsg = string | ((value: unknown, previous?: unknown) => string);\n\ninterface CreateSchemaParams {\n\trawSchema: ZodSchema;\n\tinternalSchema?: ZodSchema;\n\ttransformer?: (value: unknown) => unknown;\n\tisStringLike?: boolean;\n}\n\ninterface CreateTypeParams extends CreateSchemaParams {\n\tparseErrMsg: ErrMsg;\n\tunknownErrMsg: ErrMsg;\n}\nexport type Flatten<T> = { [k in keyof T]: T[k] };\n\nexport const createSchema = <I>(params: CreateSchemaParams) => {\n\tconst { rawSchema, isStringLike } = params;\n\tconst internalSchema = params.internalSchema ?? params.rawSchema;\n\tconst noop = (val: unknown) => val;\n\tconst transformer = params.transformer ?? noop;\n\n\tconst schema = isStringLike\n\t\t? internalSchema\n\t\t\t.transform((val: unknown) =>\n\t\t\t\ttransformer(val) as I & {\n\t\t\t\t\treadonly __type: 'generated' & z.infer<typeof internalSchema>;\n\t\t\t\t}\n\t\t\t)\n\t\t: internalSchema\n\t\t\t.transform((val: unknown) =>\n\t\t\t\ttransformer(val) as Flatten<\n\t\t\t\t\tI & {\n\t\t\t\t\t\treadonly __type: 'generated' & z.infer<typeof internalSchema>;\n\t\t\t\t\t}\n\t\t\t\t>\n\t\t\t);\n\n\ttype GeneratedSchema = typeof schema;\n\n\treturn {\n\t\trawSchema,\n\t\tinternalSchema,\n\t\tschema,\n\t};\n};\n\n// TODO:\n// TypeScript appears to have a bug with default generic values\n// For instance, I'd like to use this:\n// export const createType = <R, I = R>(params: CreateTypeParams) => {\n//\n// However, I == unknown when having I default to R if no I was given.\n// So, we need to require R and I explicitly\nexport const createType = <R, I>(params: CreateTypeParams) => {\n\tconst schemas = createSchema<I>(params);\n\tconst { parseErrMsg, unknownErrMsg } = params;\n\n\ttype T = z.infer<typeof schemas.schema>;\n\n\tconst internalOf = (input: unknown) => {\n\t\ttry {\n\t\t\treturn resolve<T>(schemas.schema.parse(input));\n\t\t} catch (previous) {\n\t\t\tconst parseMsg = typeof parseErrMsg === 'string'\n\t\t\t\t? parseErrMsg\n\t\t\t\t: parseErrMsg(input, previous);\n\n\t\t\tconst unknownMsg = typeof unknownErrMsg === 'string'\n\t\t\t\t? unknownErrMsg\n\t\t\t\t: unknownErrMsg(input);\n\n\t\t\tif (previous instanceof ZodError) {\n\t\t\t\treturn toFutureParseErr<T>(previous, parseMsg, input);\n\t\t\t}\n\t\t\treturn toFutureParseUnknownErr<T>(previous, unknownMsg, input);\n\t\t}\n\t};\n\tconst of = internalOf;\n\n\tconst make = (input: I) => internalOf(input);\n\n\tconst create = (input: R | I) => schemas.schema.parse(input) as T;\n\n\tconst from = (input: unknown) => schemas.schema.parse(input) as T;\n\n\tconst factory = {\n\t\tmake,\n\t\tof,\n\t\tcreate,\n\t\tfrom,\n\t};\n\n\treturn {\n\t\tschemas,\n\t\tfactory,\n\t};\n};\n\nexport default createType;\n"],"mappings":"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","names":["create","import_fluture","rawSchema","schemas","of","make","create","factory","import_zod","create"]}