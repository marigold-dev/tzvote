{"version":3,"sources":["SHA256.ts","TaqError.ts","Base.ts"],"sourcesContent":["import createType from './Base';\nimport { E_TaqError, TaqError } from './TaqError';\nimport { FutureInstance as Future, mapRej, promise } from 'fluture';\nimport { has } from 'rambda';\nimport { TextEncoder } from 'util';\nimport { z } from 'zod';\n\nconst eager = <T>(f: Future<TaqError, T>) =>\n\tpromise(\n\t\tmapRej((err: TaqError) => new E_TaqError(err))(f),\n\t);\n\n// Access to SubtleCrypto is different on NodeJS vs Deno\ninterface SubtleCrypto {\n\tdigest(method: 'SHA-256', data: Uint8Array): ArrayBuffer;\n}\nexport class Crypto {\n\tsubtle: SubtleCrypto;\n\tconstructor() {\n\t\tthis.subtle = {\n\t\t\tdigest(_method: 'SHA-256', _data: Uint8Array) {\n\t\t\t\treturn new ArrayBuffer(50);\n\t\t\t},\n\t\t};\n\t}\n}\n// deno-lint-ignore var\ndeclare var crypto: Crypto;\n\nconst getSubtleCrypto = async () => {\n\tif (has('SubtleCrypto', globalThis)) {\n\t\treturn Promise.resolve(crypto.subtle);\n\t}\n\n\tconst { Crypto } = await import('@peculiar/webcrypto');\n\tconst webcrypto = new Crypto();\n\treturn Promise.resolve(webcrypto.subtle);\n};\n\nexport const rawSchema = z.string({ description: 'SHA256' }).length(64);\n\ntype RawInput = z.infer<typeof rawSchema>;\n\nconst { schemas: generatedSchemas, factory } = createType<RawInput, RawInput>({\n\tisStringLike: true,\n\trawSchema,\n\tparseErrMsg: (value: unknown) => `${value} is an invalid SHA256 hash`,\n\tunknownErrMsg: (value: unknown) => `Something went wrong trying to parse the following as a SHA256 value, ${value}`,\n});\n\nexport const toSHA256 = async (value: string) => {\n\tconst encoder = new TextEncoder();\n\tconst data = encoder.encode(value);\n\tconst hash = await (await getSubtleCrypto()).digest('SHA-256', data);\n\tconst hashArray = Array.from(new Uint8Array(hash)); // convert buffer to byte array\n\tconst hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n\treturn eager(factory.make(hashHex));\n};\n\nexport const internalSchema = generatedSchemas.schema;\n\nexport type SHA256 = z.infer<typeof internalSchema>;\nexport type t = SHA256;\nexport const { create, of, make } = factory;\nexport const schemas = {\n\t...generatedSchemas,\n\tschema: generatedSchemas.schema.transform(val => val as SHA256),\n};\n","import { map, reject } from 'fluture';\nimport { ZodError } from 'zod';\n\nexport type ErrorType =\n\t| 'E_INVALID_PATH_DOES_NOT_EXIST'\n\t| 'E_INVALID_PATH_EXISTS_AND_NOT_AN_EMPTY_DIR'\n\t| 'E_INVALID_PATH_ALREADY_EXISTS'\n\t| 'E_INVALID_CONFIG'\n\t| 'E_INVALID_JSON'\n\t| 'E_FORK'\n\t| 'E_INVALID_TASK'\n\t| 'E_READFILE'\n\t| 'E_NPM_INIT'\n\t| 'E_INVALID_PLUGIN_RESPONSE'\n\t| 'E_INVALID_ARGS'\n\t| 'E_MKDIR_FAILED'\n\t| 'E_GIT_CLONE_FAILED'\n\t| 'E_PROVISION'\n\t| 'E_PARSE'\n\t| 'E_PARSE_UNKNOWN'\n\t| 'E_INVALID_ARCH'\n\t| 'E_NO_PROVISIONS'\n\t| 'E_INTERNAL_LOGICAL_VALIDATION_FAILURE'\n\t| 'E_EXEC'\n\t| 'E_OPT_IN_WARNING'\n\t| 'E_INVALID_OPTION'\n\t| 'E_TAQ_PROJECT_NOT_FOUND';\n\nexport interface TaqError {\n\treadonly kind: ErrorType;\n\tmsg: string;\n\tprevious?: TaqError | Error | unknown;\n\tcontext?: unknown;\n}\n\nexport type t = TaqError;\n\nexport class E_TaqError extends Error {\n\treadonly context;\n\treadonly kind;\n\treadonly previous;\n\tconstructor(taqErr: TaqError) {\n\t\tsuper(taqErr.msg);\n\t\tthis.context = taqErr.context;\n\t\tthis.kind = taqErr.kind;\n\t\tthis.name = this.kind;\n\t\tthis.previous = taqErr.previous;\n\t}\n}\n\nexport const toFutureParseErr = <T>(previous: ZodError, msg: string, context?: unknown) =>\n\treject(toParseErr(previous, msg, context))\n\t\t.pipe(map((val: unknown) => val as T));\n\nexport const toParseErr = (previous: ZodError, msg: string, context?: unknown) =>\n\tcreate({\n\t\tkind: 'E_PARSE',\n\t\tmsg: msg,\n\t\tcontext,\n\t\tprevious,\n\t});\n\nexport const toParseUnknownErr = (previous: Error | TaqError | E_TaqError | unknown, msg: string, context?: unknown) =>\n\tcreate({\n\t\tkind: 'E_PARSE_UNKNOWN',\n\t\tmsg: msg,\n\t\tcontext,\n\t\tprevious,\n\t});\n\nexport const toFutureParseUnknownErr = <T>(\n\tprevious: Error | TaqError | E_TaqError | unknown,\n\tmsg: string,\n\tcontext?: unknown,\n) =>\n\treject(toParseUnknownErr(previous, msg, context))\n\t\t.pipe(map((val: unknown) => val as T));\n\nexport const create = (err: TaqError) => err;\n","import { toFutureParseErr, toFutureParseUnknownErr } from './TaqError';\nimport { FutureInstance, resolve } from 'fluture';\nimport { z, ZodError, ZodSchema } from 'zod';\n\ntype Future<L, R> = FutureInstance<L, R>;\n\ntype ErrMsg = string | ((value: unknown, previous?: unknown) => string);\n\ninterface CreateSchemaParams {\n\trawSchema: ZodSchema;\n\tinternalSchema?: ZodSchema;\n\ttransformer?: (value: unknown) => unknown;\n\tisStringLike?: boolean;\n}\n\ninterface CreateTypeParams extends CreateSchemaParams {\n\tparseErrMsg: ErrMsg;\n\tunknownErrMsg: ErrMsg;\n}\nexport type Flatten<T> = { [k in keyof T]: T[k] };\n\nexport const createSchema = <I>(params: CreateSchemaParams) => {\n\tconst { rawSchema, isStringLike } = params;\n\tconst internalSchema = params.internalSchema ?? params.rawSchema;\n\tconst noop = (val: unknown) => val;\n\tconst transformer = params.transformer ?? noop;\n\n\tconst schema = isStringLike\n\t\t? internalSchema\n\t\t\t.transform((val: unknown) =>\n\t\t\t\ttransformer(val) as I & {\n\t\t\t\t\treadonly __type: 'generated' & z.infer<typeof internalSchema>;\n\t\t\t\t}\n\t\t\t)\n\t\t: internalSchema\n\t\t\t.transform((val: unknown) =>\n\t\t\t\ttransformer(val) as Flatten<\n\t\t\t\t\tI & {\n\t\t\t\t\t\treadonly __type: 'generated' & z.infer<typeof internalSchema>;\n\t\t\t\t\t}\n\t\t\t\t>\n\t\t\t);\n\n\ttype GeneratedSchema = typeof schema;\n\n\treturn {\n\t\trawSchema,\n\t\tinternalSchema,\n\t\tschema,\n\t};\n};\n\n// TODO:\n// TypeScript appears to have a bug with default generic values\n// For instance, I'd like to use this:\n// export const createType = <R, I = R>(params: CreateTypeParams) => {\n//\n// However, I == unknown when having I default to R if no I was given.\n// So, we need to require R and I explicitly\nexport const createType = <R, I>(params: CreateTypeParams) => {\n\tconst schemas = createSchema<I>(params);\n\tconst { parseErrMsg, unknownErrMsg } = params;\n\n\ttype T = z.infer<typeof schemas.schema>;\n\n\tconst internalOf = (input: unknown) => {\n\t\ttry {\n\t\t\treturn resolve<T>(schemas.schema.parse(input));\n\t\t} catch (previous) {\n\t\t\tconst parseMsg = typeof parseErrMsg === 'string'\n\t\t\t\t? parseErrMsg\n\t\t\t\t: parseErrMsg(input, previous);\n\n\t\t\tconst unknownMsg = typeof unknownErrMsg === 'string'\n\t\t\t\t? unknownErrMsg\n\t\t\t\t: unknownErrMsg(input);\n\n\t\t\tif (previous instanceof ZodError) {\n\t\t\t\treturn toFutureParseErr<T>(previous, parseMsg, input);\n\t\t\t}\n\t\t\treturn toFutureParseUnknownErr<T>(previous, unknownMsg, input);\n\t\t}\n\t};\n\tconst of = internalOf;\n\n\tconst make = (input: I) => internalOf(input);\n\n\tconst create = (input: R | I) => schemas.schema.parse(input) as T;\n\n\tconst from = (input: unknown) => schemas.schema.parse(input) as T;\n\n\tconst factory = {\n\t\tmake,\n\t\tof,\n\t\tcreate,\n\t\tfrom,\n\t};\n\n\treturn {\n\t\tschemas,\n\t\tfactory,\n\t};\n};\n\nexport default createType;\n"],"mappings":"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","names":["create","import_fluture","rawSchema","internalSchema","schemas","of","make","create","factory","import_fluture","import_zod","Crypto","create"]}