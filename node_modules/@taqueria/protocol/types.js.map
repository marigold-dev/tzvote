{"version":3,"sources":["types.ts"],"sourcesContent":["// ---- Simple Types & Type Fragments ----\n\n/** @minLength 1 */\nexport type NonEmptyString = string;\n\n/** @pattern ^[A-Za-z]$ */\nexport type SingleChar = NonEmptyString;\n\n/** @pattern ^[A-Za-z\\-\\ ]+ */\nexport type Verb = NonEmptyString;\n\nexport type Alias = (Verb | SingleChar);\n\n/** @pattern ^[A-Za-z]+[A-Za-z0-9-_ ]*$ */\nexport type HumanReadableIdentifier = NonEmptyString;\n\nexport type SanitizedAbsPath = NonEmptyString;\n\nexport type SanitizedPath = NonEmptyString;\n\nexport type Settings = {\n\tconsent: 'opt_in' | 'opt_out' | 'unspecified';\n};\n\n/**\n * @minimum 1651846877\n * @integer\n */\nexport type Timestamp = number;\n\n/**\n * @minLength 1\n * @pattern ^\\d([\\d_]+\\d)?$ */\nexport type Tz = NonEmptyString;\n\n/**\n * @minLength 1\n * @pattern ^\\d+\\.\\d+(\\.\\d+)*$ */\nexport type VersionNumber = NonEmptyString;\n\n/** @format url */\nexport type Url = NonEmptyString;\n\n// ---- Plugin Definition Types ----\n\n/** interpreted using yargs @pattern ^([A-Za-z-_ ]+ ?)((\\[.+\\] ?)|(\\<.+\\>) ?)*$ */\nexport type Command = NonEmptyString;\n\nexport type Option = {\n\tshortFlag?: SingleChar;\n\tflag: Verb;\n\tdescription: NonEmptyString;\n\tdefaultValue?: string | number | boolean;\n\ttype?: 'string' | 'number' | 'boolean';\n\trequired?: boolean;\n\tboolean?: boolean;\n\tchoices?: NonEmptyString[];\n};\n\nexport type PositionalArg = {\n\tplaceholder: HumanReadableIdentifier;\n\tdescription: NonEmptyString;\n\tdefaultValue?: string | number | boolean;\n\ttype?: 'string' | 'number' | 'boolean';\n\trequired?: boolean;\n};\n\nexport type InstalledPlugin = {\n\ttype: 'npm' | 'binary' | 'deno';\n\tname: NonEmptyString;\n};\n\nexport type Operation = {\n\toperation: Verb;\n\tcommand: Command;\n\tdescription?: NonEmptyString;\n\tpositionals?: PositionalArg[];\n\toptions?: Option[];\n\thandler?: (args: PersistentState) => (args: RequestArgs) => void;\n};\n\nexport type ParsedOperation = Omit<Operation, 'handler'>;\n\nexport type Template = {\n\ttemplate: Verb;\n\tcommand: Command;\n\tdescription: NonEmptyString;\n\thidden?: boolean;\n\toptions?: Option[];\n\tpositionals?: PositionalArg[];\n\thandler: TemplateHandler;\n\tencoding?: PluginResponseEncoding;\n};\n\ntype TemplateHandler =\n\t| NonEmptyString // TODO: should this be Verb?\n\t| ((args: RequestArgs) =>\n\t\t| PluginJsonResponse\n\t\t| Promise<PluginJsonResponse>)\n\t| Promise<void>;\n\nexport type ParsedTemplate = Omit<Template, 'handler'> & {\n\thandler: string;\n};\n\ntype PluginSchemaBase = {\n\tname: NonEmptyString;\n\tversion: VersionNumber;\n\tschema: VersionNumber;\n\talias: Alias;\n\ttasks?: Task[];\n};\n\nexport type PluginInfo = PluginSchemaBase & {\n\toperations?: ParsedOperation[];\n\ttemplates?: ParsedTemplate[];\n};\n\nexport type PluginSchema = PluginSchemaBase & {\n\toperations?: Operation[];\n\ttemplates?: Template[];\n\tproxy?: (args: RequestArgs) => Promise<PluginProxyResponse>;\n\tcheckRuntimeDependencies?: (args: RequestArgs) => Promise<PluginDependenciesResponse>;\n\tinstallRuntimeDependencies?: (args: RequestArgs) => Promise<PluginDependenciesResponse>;\n};\n\nexport type Task = {\n\ttask: Verb;\n\tcommand: Command;\n\taliases?: Alias[];\n\t/** @minLength 3 */\n\tdescription?: NonEmptyString;\n\texample?: NonEmptyString;\n\thidden?: boolean;\n\tencoding?: PluginResponseEncoding;\n\thandler: 'proxy' | NonEmptyString;\n\toptions?: Option[];\n\tpositionals?: PositionalArg[];\n};\n\n// ---- Process Interop ----\n\nexport type RuntimeDependency = {\n\tname: HumanReadableIdentifier;\n\tpath: string;\n\tversion: string;\n\tkind: 'required' | 'optional';\n};\n\nexport type RuntimeDependencyReport = RuntimeDependency & {\n\tmet: boolean;\n};\n\nexport type PluginDependenciesResponse = {\n\treport: RuntimeDependencyReport[];\n};\n\nexport type PluginJsonResponse = {\n\tdata?: unknown;\n\n\t/** @default none */\n\trender: 'none' | 'table' | 'string';\n} | void;\n\nexport type PluginProxyResponse = void | PluginJsonResponse;\n\n/** @default none */\nexport type PluginResponseEncoding = 'none' | 'json' | 'application/json';\n\n/**\n * @min 100\n */\nexport type BuildNumber = number;\n\nexport type SanitizedArgs = {\n\t_: string[];\n\tprojectDir: SanitizedPath;\n\tmaxConcurrency: number;\n\tdebug: boolean;\n\tdisableState: boolean;\n\tlogPluginRequests: boolean;\n\tfromVsCode: boolean;\n\tversion: boolean;\n\tbuild: boolean;\n\thelp: boolean;\n\tyes: boolean;\n\tplugin?: NonEmptyString;\n\tenv: NonEmptyString;\n\tquickstart: NonEmptyString;\n\tsetBuild: NonEmptyString | BuildNumber;\n\tsetVersion: NonEmptyString;\n};\n\nexport type PluginActionName =\n\t| 'proxy'\n\t| 'pluginInfo'\n\t| 'checkRuntimeDependencies'\n\t| 'installRuntimeDependencies'\n\t| 'proxyTemplate';\n\nexport type RequestArgs = Omit<SanitizedArgs, 'quickstart'> & {\n\ttaqRun: PluginActionName;\n\t// TODO: JSON.parse if string\n\tconfig: LoadedConfig;\n};\n\nexport type ProxyTaskArgs = RequestArgs & {\n\ttask: NonEmptyString;\n};\n\nexport type ProxyTemplateArgs = RequestArgs & {\n\ttemplate: NonEmptyString;\n};\n\n// ---- Hash Types ----\n\n/** @min 1 */\nexport type EconomicalProtocolHash = string;\n\n/** @pattern ^tz\\d[A-Za-z0-9]{33}$ */\nexport type PublicKeyHash = string;\n\n/** @pattern ^[A-Fa-f0-9]{64}$ */\nexport type SHA256 = string;\n\n// ---- Contract Objects ----\n\nexport type Contract = {\n\tsourceFile: NonEmptyString;\n\thash: SHA256;\n};\n\nexport type Faucet = {\n\tpkh: PublicKeyHash;\n\tmnemonic: string[];\n\t/** @format email */\n\temail: string;\n\tpassword: string;\n\t/** @pattern ^\\d+$ */\n\tamount: string;\n\tactivation_code: string;\n};\n\n// ---- External ----\n\n/** Port number for postgresql container\n * @default 5432\n */\ntype TzKtConfigPostgresqlPort = number;\n\n/** Port number for TzKt API\n * @default 5000\n */\ntype TzKtConfigApiPort = number;\n\nexport type TzKtConfig = {\n\t/** Do not start TzKt when sandbox starts */\n\tdisableAutostartWithSandbox?: boolean;\n\tpostgresqlPort?: TzKtConfigPostgresqlPort;\n\tapiPort?: TzKtConfigApiPort;\n};\n\n// ---- Project Files ----\n\nexport type EphemeralState = {\n\tbuild: string;\n\tconfigHash: string;\n\n\t// Note: these were changed from a union(either type) to intersection(both types): i.e. InstalledPlugin | Task is not correct\n\n\t/** Task/Plugin Mapping */\n\ttasks: Record<string, InstalledPlugin & Task>;\n\t/** Operation/Plugin Mapping */\n\toperations: Record<string, InstalledPlugin & ParsedOperation>;\n\t/** Templates/Plugin Mapping */\n\ttemplates: Record<string, InstalledPlugin & ParsedTemplate>;\n\n\tplugins: PluginInfo[];\n};\n\nexport type PersistentState = {\n\toperations: Record<string, PersistedOperation>;\n\ttasks: Record<string, PersistedTask>;\n};\n\nexport type PersistedTask = {\n\ttask: Verb;\n\tplugin: NonEmptyString;\n\ttime: Timestamp;\n\toutput?: unknown;\n};\n\nexport type PersistedOperation = {\n\thash: SHA256;\n\ttime: Timestamp;\n\toutput?: unknown;\n};\n\n/**\n * @minLength 1\n * @pattern ^[A-Za-z0-9]+[A-Za-z0-9-_]+\\.[A-Za-z0-9]+[A-Za-z0-9-_]+\\.[A-Za-z0-9]+[A-Za-z0-9-_]+$\n */\nexport type ProvisionerID = string;\n\nexport type Provisioner = {\n\tid: ProvisionerID;\n\tplugin: NonEmptyString;\n\toperation: NonEmptyString | 'custom';\n\tcommand?: string;\n\tlabel?: string;\n\tdepends_on?: ProvisionerID[];\n};\n\nexport type Provisions = Provisioner[];\n\n// ---- Project Files: Config ----\n\nexport type Environment = {\n\tnetworks: NonEmptyString[];\n\tsandboxes: NonEmptyString[];\n\tstorage?: Record<string, NonEmptyString>;\n\taliases?: Record<string, Record<string, NonEmptyString>>;\n};\n\n/** @minLength 1 Default environment must reference the name of an existing environment.*/\ntype EnvironmentName = NonEmptyString;\n\n/** @default en */\ntype HumanLanguage = 'en' | 'fr';\n\n/**\n * @default contracts\n * @minLength 1\n */\nexport type ConfigContractsDir = string;\n\n/**\n * @default artifacts\n * @minLength 1\n */\nexport type ConfigArtifactsDir = string;\n\nexport type ConfigAccount = {\n\tbalance: CurrencyAmountV2;\n};\n\n// Incrementally Convert from ConfigFileV1 to ConfigFileV2\n// 1. A wrapper will load/save the ConfigFileV2 and convert it to this Config runtime type (which is initially the same as ConfigFileV1)\n// 2. This type will be modified incrementally as the implementation uses the new type structure\n// - The new schema definitions will be used immediately in the file system\n// - Current implementation works the same\n// - This decouples the schema change from implementation changes and unblocks the development team\nexport type Config = {\n\t// same\n\tlanguage?: HumanLanguage;\n\tmetadata?: MetadataConfig;\n\tartifactsDir?: ConfigArtifactsDir;\n\tcontractsDir?: ConfigContractsDir;\n\tcontracts?: Record<string, Contract>;\n\tplugins?: InstalledPlugin[];\n\n\t// to change\n\taccounts?: Record<string, Tz>;\n\t// accounts?: Record<string, ConfigAccount>;\n\n\t// to change\n\tenvironment: Record<string, Environment | EnvironmentName>;\n\t// environments?: Record<string, ConfigFileEnvironmentV2>;\n\n\t// to remove\n\tnetwork?: Record<string, NetworkConfig>;\n\t// to remove\n\tsandbox?: Record<string, SandboxConfig>;\n};\n\n// This is the original Config and is retained to support auto migration of files\nexport type ConfigFileV1 = {\n\tlanguage?: HumanLanguage;\n\tplugins?: InstalledPlugin[];\n\tcontractsDir?: ConfigContractsDir;\n\tartifactsDir?: ConfigArtifactsDir;\n\tnetwork?: Record<string, NetworkConfig>;\n\tsandbox?: Record<string, SandboxConfig>;\n\n\t// TODO: This causes a type conflict and is not supported\n\t// accounts?: {\n\t// \tdefault: EnvironmentName;\n\t// } & Record<string, Environment>;\n\tenvironment?: Record<string, Environment | EnvironmentName>;\n\taccounts?: Record<string, Tz>;\n\tcontracts?: Record<string, Contract>;\n\tmetadata?: MetadataConfig;\n};\n\nexport type CurrencyAmountV2 = {\n\tamount: string;\n\tunits: string;\n};\n\n/**\n * Workaround: zod won`t support VersionV2 = `v2`\n * @pattern ^v2$\n */\ntype VersionV2 = string;\n\nexport type ConfigFileV2 = {\n\tversion: VersionV2;\n\tlanguage?: HumanLanguage;\n\tmetadata?: MetadataConfig;\n\tartifactsDir?: ConfigArtifactsDir;\n\tcontractsDir?: ConfigContractsDir;\n\n\t/** Declared accounts */\n\taccounts?: Record<string, ConfigAccount>;\n\n\tcontracts?: Record<string, Contract>;\n\n\t/** The default environment key */\n\tenvironmentDefault?: EnvironmentName;\n\n\t/** Environments\n\t *\n\t * An environment represents a unique context on a network with its own account instances and contracts.\n\t *\n\t * The environment implementation is provided by a plugin which enables network control, account management, and contract interaction.\n\t *\n\t * Example environment types:\n\t *\n\t * - a sandbox running locally (using flextesa and taquito plugin)\n\t * - teztnets.xyz (using taquito plugin)\n\t * - mainnet (using taquito plugin with a custom rpcUrl)\n\t *\n\t * The environment implementation also implements the account types that are supported by that environmentType:\n\t *\n\t * - flextesa\n\t *   - in-memory signer\n\t * - mainnet\n\t *   - beacon wallet\n\t *   - multi-sig\n\t *\n\t * Using the above as an example, the flextesa sandbox only needs an in-memory signer since it generates it's own accounts,\n\t * but mainnet might support something like a beacon wallet or a multi-sig account.\n\t */\n\tenvironments?: Record<string, ConfigEnvironmentFileV2>;\n\n\tplugins?: InstalledPlugin[];\n};\n\n/** Account overrides for this environment */\nexport type SandboxAccount = {\n\ttype?: string;\n};\n\nexport type SandboxAccounts = Record<string, SandboxAccount>;\n\nexport type ConfigEnvironmentFileV2 = {\n\t/** environment types provided by plugins\n\t *\n\t * Examples: flextesa, teztnet, mainnet\n\t *\n\t * annotations provides plugin specific data like rpcUrl\n\t */\n\ttype?: string;\n\n\t// Account overrides for the environment\n\taccounts?: SandboxAccounts;\n\n\t// Default account to use for this environment\n\taccountDefault?: keyof SandboxAccounts;\n\n\t/** Contract deployment data for this environment */\n\tcontracts?: Record<string, {\n\t\taddress?: string;\n\t}>;\n\t// Other fields may exist, but they are not type checked here\n\t// It is expected that this will be cast to a more specific type\n\t// by the plugin to access the additional fields\n};\n\n// TODO: sandbox breaks ts-to-zod\nexport type LoadedConfig = Config & {\n\tprojectDir: SanitizedAbsPath;\n\tconfigFile: SanitizedAbsPath;\n\thash: SHA256;\n};\n\nexport type MetadataConfig = {\n\tname?: string;\n\tprojectDescription?: string;\n\tauthors?: string[];\n\tlicense?: string;\n\thomepage?: string;\n};\n\nexport type NetworkConfig = {\n\tlabel: HumanReadableIdentifier;\n\trpcUrl: Url;\n\taccounts?: Record<string, NetworkAccountConfig>;\n\tfaucet?: Faucet;\n};\n\nexport type NetworkAccountConfig = {\n\tpublicKey?: NonEmptyString;\n\tpublicKeyHash?: PublicKeyHash;\n\tprivateKey?: NonEmptyString; /** TODO: Should this be secretKey: @see {SandboxAccountConfig} */\n\tmnemonic?: NonEmptyString;\n};\n\nexport type SandboxAccountConfig = {\n\tencryptedKey: NonEmptyString;\n\tpublicKeyHash: PublicKeyHash;\n\tsecretKey: NonEmptyString;\n};\n\nexport type SandboxConfig = {\n\tlabel: NonEmptyString;\n\trpcUrl: Url; // should this be optional?\n\tprotocol?: EconomicalProtocolHash;\n\tplugin?: Verb;\n\n\t// TODO: This causes a type conflict and is not supported\n\t// accounts?: {\n\t// \tdefault: NonEmptyString;\n\t// } & Record<string, SandboxAccountConfig>;\n\taccounts?: Record<string, SandboxAccountConfig | NonEmptyString>;\n\n\ttzkt?: TzKtConfig;\n\tannotations?: Record<string, unknown>;\n};\n\nexport type ScaffoldConfig = {\n\tpostInit?: string;\n};\n\nexport type ParsedConfig = Omit<Config, 'sandbox'> & {\n\tsandbox: Record<string, SandboxConfig | NonEmptyString>;\n};\n"],"mappings":";;;;;;;;;;;;;;;;AAAA;AAAA;","names":[]}