// index.ts
import { Option, Plugin, PositionalArg, Task } from "@taqueria/node-sdk";

// main.ts
import { sendAsyncErr as sendAsyncErr5, sendAsyncRes } from "@taqueria/node-sdk";

// client.ts
import { getArch, sendAsyncErr, sendRes, spawnCmd } from "@taqueria/node-sdk";

// common.ts
import { getArchSync, getDockerImage } from "@taqueria/node-sdk";
import { join } from "path";
var getFlextesaImage = (_arch) => "oxheadalpha/flextesa:20230607";
var FLEXTESA_IMAGE_ENV_VAR = "TAQ_FLEXTESA_IMAGE";
var getClientDockerImage = () => getDockerImage(getFlextesaImage(getArchSync()), FLEXTESA_IMAGE_ENV_VAR);
var ENDPOINT = process.env["TAQ_TEZOS_CLIENT_RPC"] ?? "https://rpc.ghostnet.teztnets.xyz";
var GLOBAL_OPTIONS = `--endpoint ${ENDPOINT}`;
var trimTezosClientMenuIfPresent = (msg) => {
  return msg.replace(/Usage:(.|\n)+/, "");
};
var getInputFilename = (opts, sourceFile) => join("/project", opts.config.artifactsDir ?? "artifacts", sourceFile);
var getCheckFileExistenceCommand = async (parsedArgs, sourceFile) => {
  const projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;
  if (!projectDir)
    throw `No project directory provided`;
  const arch = getArchSync();
  const baseCmd = `docker run --rm -v "${projectDir}":/project -w /project --platform ${arch} ${getClientDockerImage()} ls`;
  const inputFile = getInputFilename(parsedArgs, sourceFile);
  const cmd = `${baseCmd} ${inputFile}`;
  return cmd;
};

// client.ts
var getArbitraryClientCmd = async (parsedArgs, userArgs) => {
  const projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;
  if (!projectDir)
    throw `No project directory provided`;
  const arch = await getArch();
  const flextesaImage = getClientDockerImage();
  const binary = "docker";
  const baseArgs = [
    "run",
    "--rm",
    "-v",
    `${projectDir}:/project`,
    "-w",
    "/project",
    "--platform",
    arch,
    flextesaImage,
    "octez-client"
  ];
  const processedUserArgs = userArgs.split(" ").map((arg) => arg.startsWith("\\-") ? arg.substring(1) : arg).filter(
    (arg) => arg
  );
  const args = baseArgs.concat(processedUserArgs);
  const envVars = {};
  return [
    [binary, ...args].join(" "),
    envVars
  ];
};
var runArbitraryClientCmd = (parsedArgs, cmd) => getArbitraryClientCmd(parsedArgs, cmd).then(([cmd2, envVars]) => spawnCmd(cmd2, envVars)).then(
  (code) => code !== null && code === 0 ? `Command "${cmd}" ran successfully by octez-client` : `Command "${cmd}" failed. Please check your command`
).catch((err) => sendAsyncErr(`An internal error has occurred: ${err.message}`));
var client = (parsedArgs) => {
  const args = parsedArgs.command;
  return runArbitraryClientCmd(parsedArgs, args).then(sendRes).catch((err) => sendAsyncErr(err, false));
};
var client_default = client;

// simulate.ts
import {
  addTzExtensionIfMissing,
  execCmd,
  getArch as getArch2,
  getContractContent,
  getParameter,
  sendAsyncErr as sendAsyncErr2,
  sendErr,
  sendJsonRes,
  sendWarn
} from "@taqueria/node-sdk";
import { basename, extname } from "path";
var getDefaultStorageFilename = (contractName) => {
  const baseFilename = basename(contractName, extname(contractName));
  const extFilename = extname(contractName);
  const defaultStorage = `${baseFilename}.default_storage${extFilename}`;
  return defaultStorage;
};
var getSimulateCmd = async (parsedArgs, sourceFile) => {
  var _a;
  const projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;
  if (!projectDir)
    throw `No project directory provided`;
  const storageFilename = parsedArgs.storage ?? getDefaultStorageFilename(sourceFile);
  const storage = (_a = await getContractContent(parsedArgs, storageFilename)) == null ? void 0 : _a.trim();
  if (storage === void 0) {
    return Promise.reject(
      new Error(
        `\u274C No initial storage file was found for ${sourceFile}
Storage must be specified in a file as a Michelson expression and will automatically be linked to this contract if specified with the name "${getDefaultStorageFilename(sourceFile)}" in the artifacts directory
You can also manually pass a storage file to the simulate task using the --storage STORAGE_FILE_NAME option
`
      )
    );
  }
  const paramFilename = parsedArgs.param;
  const param = (await getParameter(parsedArgs, paramFilename)).trim();
  const arch = await getArch2();
  const flextesaImage = getClientDockerImage();
  const baseCmd = `docker run --rm -v "${projectDir}":/project -w /project --platform ${arch} ${flextesaImage}`;
  const inputFile = getInputFilename(parsedArgs, sourceFile);
  const entrypoint = parsedArgs.entrypoint ? `--entrypoint ${parsedArgs.entrypoint}` : "";
  const cmd = `${baseCmd} octez-client ${GLOBAL_OPTIONS} run script ${inputFile} on storage '${storage}' and input '${param}' ${entrypoint}`;
  return cmd;
};
var simulateContract = (parsedArgs, sourceFile) => getCheckFileExistenceCommand(parsedArgs, sourceFile).then(execCmd).then(
  () => getSimulateCmd(parsedArgs, sourceFile).then(execCmd).then(({ stdout, stderr }) => {
    if (stderr.length > 0)
      sendWarn(`
${stderr}`);
    return {
      contract: sourceFile,
      result: stdout
    };
  }).catch((err) => {
    sendErr(`
=== For ${sourceFile} ===`);
    const msg = trimTezosClientMenuIfPresent(err.message);
    sendErr(msg.replace(/Command failed.+?\n/, ""));
    return {
      contract: sourceFile,
      result: "Invalid"
    };
  })
).catch((err) => {
  sendErr(`
=== For ${sourceFile} ===`);
  sendErr(err.message.replace(/Command failed.+?\n/, ""));
  return {
    contract: sourceFile,
    result: "N/A"
  };
});
var simulate = (parsedArgs) => {
  const sourceFile = addTzExtensionIfMissing(parsedArgs.sourceFile);
  return simulateContract(parsedArgs, sourceFile).then((result) => [result]).then(sendJsonRes).catch(
    (err) => sendAsyncErr2(err, false)
  );
};
var simulate_default = simulate;

// typecheck.ts
import {
  addTzExtensionIfMissing as addTzExtensionIfMissing2,
  execCmd as execCmd2,
  getArch as getArch3,
  sendAsyncErr as sendAsyncErr3,
  sendErr as sendErr2,
  sendJsonRes as sendJsonRes2,
  sendWarn as sendWarn2
} from "@taqueria/node-sdk";
var getTypecheckCmd = async (parsedArgs, sourceFile) => {
  const projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;
  if (!projectDir)
    throw `No project directory provided`;
  const arch = await getArch3();
  const flextesaImage = getClientDockerImage();
  const baseCmd = `docker run --rm -v "${projectDir}":/project -w /project --platform ${arch} ${flextesaImage}`;
  const inputFile = getInputFilename(parsedArgs, sourceFile);
  const cmd = `${baseCmd} octez-client ${GLOBAL_OPTIONS} typecheck script ${inputFile}`;
  return cmd;
};
var typecheckContract = (parsedArgs, sourceFile) => getCheckFileExistenceCommand(parsedArgs, sourceFile).then(execCmd2).then(
  () => getTypecheckCmd(parsedArgs, sourceFile).then(execCmd2).then(({ stderr }) => {
    if (stderr.length > 0)
      sendWarn2(stderr);
    return {
      contract: sourceFile,
      result: "Valid"
    };
  }).catch((err) => {
    sendErr2(`
=== For ${sourceFile} ===`);
    const msg = trimTezosClientMenuIfPresent(err.message);
    sendErr2(msg.replace(/Command failed.+?\n/, ""));
    return {
      contract: sourceFile,
      result: "Invalid"
    };
  })
).catch((err) => {
  sendErr2(`
=== For ${sourceFile} ===`);
  sendErr2(err.message.replace(/Command failed.+?\n/, ""));
  return {
    contract: sourceFile,
    result: "N/A"
  };
});
var typecheck = (parsedArgs) => {
  const sourceFile = addTzExtensionIfMissing2(parsedArgs.sourceFile);
  return typecheckContract(parsedArgs, sourceFile).then((result) => [result]).then(sendJsonRes2).catch(
    (err) => sendAsyncErr3(err, false)
  );
};
var typecheck_default = typecheck;

// typecheckAll.ts
import { getArtifactsDir, isContractFile, sendAsyncErr as sendAsyncErr4, sendJsonRes as sendJsonRes3 } from "@taqueria/node-sdk";
import glob from "fast-glob";
import { join as join2 } from "path";
var compileAll = async (parsedArgs) => {
  let p = [];
  const contractFilenames = await glob(
    ["**/*.tz"],
    { cwd: join2(parsedArgs.config.projectDir, getArtifactsDir(parsedArgs)), absolute: false }
  );
  for (const filename of contractFilenames) {
    if (isContractFile(filename))
      p.push(typecheckContract(parsedArgs, filename));
  }
  return Promise.all(p).then(sendJsonRes3).catch((err) => sendAsyncErr4(err, false));
};
var typecheckAll_default = compileAll;

// main.ts
var main = (parsedArgs) => {
  const unsafeOpts = parsedArgs;
  switch (unsafeOpts.task) {
    case "client":
      return client_default(unsafeOpts);
    case "typecheck":
      return typecheck_default(unsafeOpts);
    case "typecheck-all":
      return typecheckAll_default(unsafeOpts);
    case "simulate":
      return simulate_default(unsafeOpts);
    case "get-image":
      return sendAsyncRes(getClientDockerImage());
    default:
      return sendAsyncErr5(`${unsafeOpts.task} is not an understood task by the Tezos-client plugin`);
  }
};
var main_default = main;

// index.ts
Plugin.create((i18n) => ({
  alias: "tezos-client",
  schema: "1.0",
  version: "0.1",
  tasks: [
    Task.create({
      task: "client",
      command: "client",
      description: "This task allows you to run arbitrary octez-client native commands. Note that they might not benefit from the abstractions provided by Taqueria",
      options: [
        Option.create({
          shortFlag: "c",
          flag: "command",
          type: "string",
          description: "The command to be passed to the underlying octez-client binary, wrapped in quotes",
          required: true
        })
      ],
      handler: "proxy",
      encoding: "none"
    }),
    Task.create({
      task: "typecheck",
      command: "typecheck <sourceFile>",
      aliases: ["tc"],
      description: "Typecheck a Michelson contract",
      handler: "proxy",
      positionals: [
        PositionalArg.create({
          placeholder: "sourceFile",
          description: "The name of the Michelson contract you wish to typecheck"
        })
      ],
      encoding: "json"
    }),
    Task.create({
      task: "typecheck-all",
      command: "typecheck-all",
      description: "Typecheck all Michelson contracts in the artifacts directory",
      handler: "proxy",
      encoding: "json"
    }),
    Task.create({
      task: "simulate",
      command: "simulate <sourceFile>",
      aliases: ["sim"],
      description: "Run a Michelson contract as a simulation",
      options: [
        Option.create({
          flag: "storage",
          description: "Name of the storage file that contains the storage value as a Michelson expression, in the artifacts directory, used for originating a contract",
          required: false
        }),
        Option.create({
          flag: "param",
          description: "Name of the parameter file that contains the parameter value as a Michelson expression, in the artifacts directory, used for invoking a deployed contract",
          required: true
        }),
        Option.create({
          flag: "entrypoint",
          description: "You may explicitly specify an entrypoint to make the parameter value shorter, without having to specify a chain of (Left (Right ... 14 ...))",
          required: false
        })
      ],
      handler: "proxy",
      positionals: [
        PositionalArg.create({
          placeholder: "sourceFile",
          description: "The name of the Michelson contract you wish to simulate"
        })
      ],
      encoding: "json"
    }),
    Task.create({
      task: "get-image",
      command: "get-image",
      description: "Gets the name of the image to be used",
      handler: "proxy",
      hidden: true
    })
  ],
  proxy: main_default
}), process.argv);
//# sourceMappingURL=index.mjs.map