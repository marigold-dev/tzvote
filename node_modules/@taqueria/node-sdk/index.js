"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// index.ts
var taqueria_sdk_exports = {};
__export(taqueria_sdk_exports, {
  Config: () => import_protocol.Config,
  EconomicalProtocolHash: () => import_protocol.EconomicalProtocolHash,
  Environment: () => import_protocol.Environment,
  Faucet: () => import_protocol.Faucet,
  LoadedConfig: () => import_protocol.LoadedConfig,
  NetworkConfig: () => import_protocol.NetworkConfig,
  NonEmptyString: () => import_protocol.NonEmptyString,
  Option: () => import_protocol.Option,
  Plugin: () => Plugin,
  PositionalArg: () => import_protocol.PositionalArg,
  Protocol: () => Protocol2,
  ProxyTaskArgs: () => import_protocol.ProxyTaskArgs,
  ProxyTemplateArgs: () => import_protocol.ProxyTemplateArgs,
  RequestArgs: () => import_protocol.RequestArgs,
  TAQ_OPERATOR_ACCOUNT: () => TAQ_OPERATOR_ACCOUNT,
  Task: () => import_protocol.Task,
  Template: () => Template2,
  addTzExtensionIfMissing: () => addTzExtensionIfMissing,
  eager: () => eager,
  execCmd: () => execCmd,
  execCommandWithoutWrapping: () => execCommandWithoutWrapping,
  getAccountPrivateKey: () => getAccountPrivateKey,
  getAddressOfAlias: () => getAddressOfAlias,
  getArch: () => getArch,
  getArchSync: () => getArchSync,
  getArtifactsDir: () => getArtifactsDir,
  getContractContent: () => getContractContent,
  getContracts: () => getContracts,
  getContractsDir: () => getContractsDir,
  getCurrentEnvironment: () => getCurrentEnvironment,
  getCurrentEnvironmentConfig: () => getCurrentEnvironmentConfig,
  getDefaultSandboxAccount: () => getDefaultSandboxAccount,
  getDockerImage: () => getDockerImage,
  getMetadataConfig: () => getMetadataConfig,
  getNetworkConfig: () => getNetworkConfig,
  getParameter: () => getParameter,
  getSandboxAccountConfig: () => getSandboxAccountConfig,
  getSandboxAccountNames: () => getSandboxAccountNames,
  getSandboxConfig: () => getSandboxConfig,
  getSelectedEnvironment: () => getSelectedEnvironment,
  isContractFile: () => isContractFile,
  isTaqError: () => isTaqError,
  noop: () => noop,
  parseJSON: () => parseJSON,
  readJsonFile: () => readJsonFile,
  sendAsyncErr: () => sendAsyncErr,
  sendAsyncJson: () => sendAsyncJson,
  sendAsyncJsonErr: () => sendAsyncJsonErr,
  sendAsyncJsonRes: () => sendAsyncJsonRes,
  sendAsyncRes: () => sendAsyncRes,
  sendErr: () => sendErr,
  sendJson: () => sendJson,
  sendJsonErr: () => sendJsonErr,
  sendJsonRes: () => sendJsonRes,
  sendRes: () => sendRes,
  sendWarn: () => sendWarn,
  spawnCmd: () => spawnCmd,
  stringToSHA256: () => stringToSHA256,
  toExecErr: () => toExecErr,
  updateAddressAlias: () => updateAddressAlias,
  writeJsonFile: () => writeJsonFile
});
module.exports = __toCommonJS(taqueria_sdk_exports);
__reExport(taqueria_sdk_exports, require("@taqueria/protocol/types"), module.exports);
var Protocol2 = __toESM(require("@taqueria/protocol"));
var import_protocol = require("@taqueria/protocol");
var Template2 = __toESM(require("@taqueria/protocol/Template"));
var import_i18n = __toESM(require("@taqueria/protocol/i18n"));
var SHA256 = __toESM(require("@taqueria/protocol/SHA256"));
var import_TaqError = require("@taqueria/protocol/TaqError");
var import_types_config_files = require("@taqueria/protocol/types-config-files");
var import_child_process = require("child_process");
var import_fluture = require("fluture");
var import_promises = require("fs/promises");
var import_path = require("path");
var import_stacktrace_js = require("stacktrace-js");
var import_zod = require("zod");

// types.ts
var Protocol = __toESM(require("@taqueria/protocol"));
var Environment = __toESM(require("@taqueria/protocol/Environment"));
var LoadedConfig = __toESM(require("@taqueria/protocol/LoadedConfig"));
var MetadataConfig = __toESM(require("@taqueria/protocol/MetadataConfig"));
var NetworkConfig = __toESM(require("@taqueria/protocol/NetworkConfig"));
var Operation = __toESM(require("@taqueria/protocol/Operation"));
var Option = __toESM(require("@taqueria/protocol/Option"));
var PersistentState = __toESM(require("@taqueria/protocol/PersistentState"));
var PluginSchema = __toESM(require("@taqueria/protocol/PluginSchema"));
var PositionalArg = __toESM(require("@taqueria/protocol/PositionalArg"));
var SandboxAccountConfig = __toESM(require("@taqueria/protocol/SandboxAccountConfig"));
var SandboxConfig = __toESM(require("@taqueria/protocol/SandboxConfig"));
var SanitizedAbsPath = __toESM(require("@taqueria/protocol/SanitizedAbsPath"));
var SanitizedPath = __toESM(require("@taqueria/protocol/SanitizedPath"));
var TaqError = __toESM(require("@taqueria/protocol/TaqError"));
var Task = __toESM(require("@taqueria/protocol/Task"));
var Template = __toESM(require("@taqueria/protocol/Template"));

// index.ts
var import_signer = require("@taquito/signer");
var import_taquito = require("@taquito/taquito");
var import_utils = require("@taquito/utils");
var Bip39 = __toESM(require("bip39"));
var import_crypto = __toESM(require("crypto"));
var import_project_name_generator = __toESM(require("project-name-generator"));
var yargs = require("yargs");
var TAQ_OPERATOR_ACCOUNT = "taqOperatorAccount";
var eager = (f) => (0, import_fluture.promise)(
  (0, import_fluture.mapRej)((err) => new import_TaqError.E_TaqError(err))(f)
);
var writeJsonFileInner = (filename) => (data) => (0, import_promises.writeFile)(filename, JSON.stringify(data, void 0, 4), { encoding: "utf8" }).then((_) => filename);
var writeJsonFile = (0, import_types_config_files.writeJsonFileInterceptConfig)(writeJsonFileInner);
var readJsonFileInner = (filename) => (0, import_promises.readFile)(filename, { encoding: "utf-8" }).then(JSON.parse).then((result) => result);
var readJsonFile = (0, import_types_config_files.readJsonFileInterceptConfig)(readJsonFileInner);
var execCmd = (cmd) => new Promise((resolve, reject) => {
  const escapedCmd = cmd.replaceAll(/"/gm, '\\"');
  (0, import_child_process.exec)(`sh -c "${escapedCmd}"`, (err, stdout, stderr) => {
    if (err) {
      reject(toExecErr(err, { stderr, stdout }));
    } else {
      resolve({
        stdout,
        stderr
      });
    }
  });
});
var toExecErr = (message, props) => {
  const err = message instanceof Error ? message : new Error(message);
  const retval = err;
  retval.stderr = props.stderr;
  retval.stdout = props.stdout;
  return retval;
};
var execCommandWithoutWrapping = (cmd) => new Promise((resolve, reject) => {
  (0, import_child_process.exec)(cmd, (err, stdout, stderr) => {
    if (err)
      reject(err);
    else {
      resolve({
        stdout,
        stderr
      });
    }
  });
});
var spawnCmd = (cmd, envVars = {}) => new Promise((resolve, reject) => {
  const child = (0, import_child_process.spawn)(cmd, { env: { ...process.env, ...envVars }, stdio: "inherit", shell: true });
  child.on("close", resolve);
  child.on("error", reject);
});
var getArchSync = () => {
  switch (process.arch) {
    case "arm64":
      return "linux/arm64/v8";
    case "x32":
    case "x64":
      return "linux/amd64";
    default:
      const err = {
        kind: "E_INVALID_ARCH",
        msg: `The ${process.arch} architecture is not supported at this time.`,
        context: process.arch
      };
      throw err;
  }
};
var getArch = () => new Promise((resolve, reject) => {
  try {
    const arch = getArchSync();
    resolve(arch);
  } catch (e) {
    reject(e);
  }
});
var parseJSON = (input) => new Promise((resolve, reject) => {
  try {
    const json = JSON.parse(input);
    resolve(json);
  } catch (previous) {
    const taqErr = {
      kind: "E_INVALID_JSON",
      msg: `Invalid JSON: ${input}`,
      previous,
      context: input
    };
    return reject(taqErr);
  }
});
var sendRes = (msg, newline = true) => {
  if (!msg || msg.length === 0)
    return;
  return newline ? console.log(msg) : process.stdout.write(msg);
};
var sendAsyncRes = (msg, newline = true) => Promise.resolve(sendRes(msg, newline));
var sendErr = (msg, newline = true) => {
  if (!msg || msg.length === 0)
    return;
  return newline ? console.error(msg) : process.stderr.write(msg);
};
var sendWarn = (msg, newline = true) => {
  if (!msg || msg.length === 0)
    return;
  return newline ? console.warn(msg) : process.stderr.write(msg);
};
var sendAsyncErr = (msg, newline = true) => Promise.reject(sendErr(msg, newline));
var sendJson = (msg, newline = true) => sendRes(JSON.stringify(msg), newline);
var sendJsonErr = (msg, newline = true) => sendErr(JSON.stringify(msg), newline);
var sendAsyncJson = (msg, newline = true) => sendAsyncRes(JSON.stringify(msg), newline);
var sendAsyncJsonErr = (msg, newline = true) => sendAsyncErr(JSON.stringify(msg), newline);
var sendJsonRes = (data) => typeof data === "object" ? sendJson({
  data,
  render: "table"
}) : sendJson({
  data,
  render: "string"
});
var sendAsyncJsonRes = (data) => Promise.resolve(sendJsonRes(data));
var noop = () => {
};
var parseArgs = (unparsedArgs) => {
  if (unparsedArgs && Array.isArray(unparsedArgs) && unparsedArgs.length >= 2) {
    try {
      const preprocessedArgs = preprocessArgs(unparsedArgs);
      const argv = yargs(preprocessedArgs.slice(2)).argv;
      const postprocessedArgs = postprocessArgs(argv);
      const formattedArgs = formatArgs(postprocessedArgs);
      const requestArgs = Protocol2.RequestArgs.from(formattedArgs);
      return Promise.resolve(requestArgs);
    } catch (previous) {
      if (previous instanceof import_zod.ZodError) {
        return eager(
          (0, import_TaqError.toFutureParseErr)(previous, "The plugin request arguments are invalid", unparsedArgs)
        );
      }
      return eager(
        (0, import_TaqError.toFutureParseUnknownErr)(
          previous,
          "There was a problem trying to parse the plugin request arguments",
          unparsedArgs
        )
      );
    }
  }
  return Promise.reject("Invalid usage. If you were testing your plugin, did you remember to specify --taqRun?");
};
var preprocessArgs = (args) => {
  return args.map((arg) => /^0x[0-9a-fA-F]+$/.test(arg) ? "___" + arg + "___" : arg);
};
var getSelectedEnvironment = (args) => args.env ? args.env : args.config.environment["default"] ?? "development";
var formatArgs = (args) => {
  const entries = Object.entries(args).map(
    ([key, value]) => {
      if (key === "config")
        return [key, JSON.parse(value)];
      else if (value === "false")
        return [key, false];
      else if (value === "true")
        return [key, true];
      return [key, value];
    }
  );
  const formatted = Object.fromEntries(entries);
  return {
    ...formatted,
    env: getSelectedEnvironment(formatted)
  };
};
var postprocessArgs = (args) => {
  const postprocessedArgs = Object.entries(args).map(([key, val]) => [
    key,
    typeof val === "string" && /^___0x[0-9a-fA-F]+___$/.test(val) ? val.slice(3, -3) : val
  ]);
  const groupedArgs = postprocessedArgs.reduce(
    (acc, arg) => {
      const key = arg[0];
      const val = arg[1];
      return { ...acc, [key]: val };
    },
    {}
  );
  return groupedArgs;
};
var parseSchema = (i18n, definer, defaultPluginName, requestArgs) => {
  const inputSchema = definer(requestArgs, i18n);
  const { proxy } = inputSchema;
  const pluginInfo = PluginSchema.create({
    ...inputSchema,
    name: inputSchema.name ?? defaultPluginName
  });
  return {
    ...pluginInfo,
    proxy
  };
};
var toProxableArgs = (requestArgs, from) => {
  const retval = Object.entries(requestArgs).reduce(
    (retval2, [key, value]) => {
      if (key === "projectDir")
        value = (0, import_path.resolve)(value.toString());
      else if (typeof value === "string") {
        if (value === "true")
          value = true;
        else if (value === "false")
          value = false;
        else if (key === "config")
          value = JSON.parse(value);
      }
      const proxyArgs = {
        ...retval2,
        ...Object.fromEntries([[key, value]])
      };
      return proxyArgs;
    },
    {}
  );
  return from(retval);
};
var getResponse = (definer, defaultPluginName) => async (requestArgs) => {
  var _a;
  const { taqRun } = requestArgs;
  const i18n = await (0, import_i18n.default)();
  const schema = parseSchema(i18n, definer, defaultPluginName, requestArgs);
  try {
    switch (taqRun) {
      case "pluginInfo": {
        const output = {
          ...schema,
          templates: schema.templates ? schema.templates.map(
            (template) => {
              const handler = typeof template.handler === "function" ? "function" : template.handler;
              return {
                ...template,
                handler
              };
            }
          ) : [],
          tasks: schema.tasks ? schema.tasks.map(
            (task) => {
              const handler = typeof task.handler === "function" ? "function" : task.handler;
              return {
                ...task,
                handler
              };
            }
          ) : [],
          proxy: true,
          checkRuntimeDependencies: schema.checkRuntimeDependencies ? true : false,
          installRuntimeDependencies: schema.installRuntimeDependencies ? true : false
        };
        return sendAsyncJson(output);
      }
      case "proxy":
        if (schema.proxy) {
          return schema.proxy(toProxableArgs(requestArgs, Protocol2.ProxyTaskArgs.from.bind(Protocol2.ProxyTaskArgs)));
        }
        return Promise.reject({
          errCode: "E_NOT_SUPPORTED",
          message: i18n.__("proxyNotSupported"),
          context: requestArgs
        });
      case "proxyTemplate": {
        const proxyArgs = toProxableArgs(
          requestArgs,
          Protocol2.ProxyTemplateArgs.from.bind(Protocol2.ProxyTemplateArgs)
        );
        const template = (_a = schema.templates) == null ? void 0 : _a.find((tmpl) => tmpl.template === proxyArgs.template);
        if (template) {
          if (typeof template.handler === "function") {
            return template.handler(proxyArgs);
          }
          return Promise.reject({
            errCode: "E_NOT_SUPPORTED",
            message: i18n.__("proxyNotSupported"),
            context: requestArgs
          });
        }
        return Promise.reject({
          errCode: "E_INVALID_TEMPLATE",
          message: i18n.__("invalidTemplate"),
          context: requestArgs
        });
      }
      default:
        return Promise.reject({
          errCode: "E_NOT_SUPPORTED",
          message: i18n.__("actionNotSupported"),
          context: requestArgs
        });
    }
  } catch (previous) {
    return Promise.reject({
      errCode: "E_UNEXPECTED",
      message: "The plugin encountered a fatal error",
      previous
    });
  }
};
var getNameFromPluginManifest = (packageJsonAbspath) => {
  try {
    return `${require(packageJsonAbspath).name}`;
  } catch (_) {
    return (0, import_project_name_generator.default)().dashed;
  }
};
var getCurrentEnvironment = (parsedArgs) => {
  return parsedArgs.env ? parsedArgs.env : parsedArgs.config.environment ? parsedArgs.config.environment.default : "development";
};
var getCurrentEnvironmentConfig = (parsedArgs) => {
  const currentEnv = getCurrentEnvironment(parsedArgs);
  return parsedArgs.config.environment && parsedArgs.config.environment[currentEnv] ? parsedArgs.config.environment[currentEnv] : void 0;
};
var getMetadataConfig = (parsedArgs) => () => parsedArgs.config.metadata ?? void 0;
var getNetworkConfig = (parsedArgs) => (networkName) => parsedArgs.config.network[networkName] ?? void 0;
var getSandboxConfig = (parsedArgs) => (sandboxName) => parsedArgs.config.sandbox[sandboxName] ?? void 0;
var getSandboxAccountNames = (parsedArgs) => (sandboxName) => {
  const sandbox = getSandboxConfig(parsedArgs)(sandboxName);
  return sandbox ? Object.keys(sandbox.accounts ?? []).filter((accountName) => accountName !== "default") : [];
};
var getSandboxAccountConfig = (sandbox, accountName) => {
  if (sandbox.accounts) {
    const accounts = sandbox.accounts;
    return accounts[accountName];
  }
  return void 0;
};
var addTzExtensionIfMissing = (contractFilename) => /\.tz$/.test(contractFilename) ? contractFilename : `${contractFilename}.tz`;
var getArtifactsDir = (parsedArgs) => parsedArgs.config.artifactsDir ?? "artifacts";
var getContractsDir = (parsedArgs) => parsedArgs.config.contractsDir ?? "contracts";
var getContractContent = async (parsedArgs, contractFilename) => {
  const contractWithTzExtension = addTzExtensionIfMissing(contractFilename);
  const contractPath = (0, import_path.join)(parsedArgs.config.projectDir, getArtifactsDir(parsedArgs), contractWithTzExtension);
  try {
    const content = await (0, import_promises.readFile)(contractPath, { encoding: "utf-8" });
    return content;
  } catch (err) {
    sendErr(`Could not read ${contractPath}. Maybe it doesn't exist.
`);
    return void 0;
  }
};
var getParameter = async (parsedArgs, paramFilename) => {
  const paramPath = (0, import_path.join)(parsedArgs.config.projectDir, parsedArgs.config.artifactsDir ?? "artifacts", paramFilename);
  try {
    const content = await (0, import_promises.readFile)(paramPath, { encoding: "utf-8" });
    return content;
  } catch (err) {
    return sendAsyncErr(`Could not read ${paramPath}. Maybe it doesn't exist.`);
  }
};
var updateAddressAlias = async (parsedArgs, alias, address) => {
  const env = getCurrentEnvironmentConfig(parsedArgs);
  if (!env)
    return;
  if (!env.aliases) {
    env.aliases = { [alias]: { address } };
  } else if (!env.aliases[alias]) {
    env.aliases[alias] = { address };
  } else {
    env.aliases[alias].address = address;
  }
  try {
    await writeJsonFile(parsedArgs.config.configFile)(parsedArgs.config);
  } catch (err) {
    sendErr(`Could not write to ${parsedArgs.config.configFile}
`);
  }
};
var getAddressOfAlias = async (env, alias) => {
  var _a, _b;
  const address = (_b = (_a = env.aliases) == null ? void 0 : _a[alias]) == null ? void 0 : _b.address;
  if (!address) {
    return sendAsyncErr(
      `Address for alias "${alias}" is not present in the config.json. Make sure to deploy a contract with such alias.`
    );
  }
  return address;
};
var getAccountPrivateKey = async (parsedArgs, network, account) => {
  var _a, _b;
  if (!network.accounts)
    network.accounts = {};
  if (!network.accounts[account] || !network.accounts[account].privateKey) {
    const mnemonic = ((_b = (_a = network == null ? void 0 : network.accounts) == null ? void 0 : _a[account]) == null ? void 0 : _b.mnemonic) ?? Bip39.generateMnemonic();
    const signer = import_signer.InMemorySigner.fromMnemonic({ mnemonic });
    const tezos = new import_taquito.TezosToolkit(network.rpcUrl);
    tezos.setSignerProvider(signer);
    const publicKey = Protocol2.NonEmptyString.create(await tezos.signer.publicKey());
    const publicKeyHash = Protocol2.PublicKeyHash.create(await tezos.signer.publicKeyHash());
    const privateKey2 = Protocol2.NonEmptyString.create(await tezos.signer.secretKey() ?? "");
    if (!privateKey2)
      return sendAsyncErr("The private key must exist after creating it");
    network.accounts[account] = Protocol2.NetworkAccountConfig.create({
      publicKey,
      publicKeyHash,
      privateKey: privateKey2,
      mnemonic
    });
    try {
      await writeJsonFile("./.taq/config.json")(parsedArgs.config);
    } catch (err) {
      return sendAsyncErr(`Could not write to ./.taq/config.json
`);
    }
    if (account === TAQ_OPERATOR_ACCOUNT) {
      return sendAsyncErr(
        `A keypair with public key hash ${network.accounts[account].publicKeyHash} was generated for you.
To fund this account:
1. Go to https://teztnets.xyz and click "Faucet" of the target testnet
2. Copy and paste the above key into the wallet address field
3. Request some Tez (Note that you might need to wait for a few seconds for the network to register the funds)`
      );
    }
  }
  const privateKey = network.accounts[account].privateKey;
  if (!privateKey)
    return sendAsyncErr("The private key must exist after creating it");
  return privateKey;
};
var getDockerImage = (defaultImageName, envVarName) => process.env[envVarName] ?? defaultImageName;
var getDefaultSandboxAccount = (sandbox) => {
  const accounts = sandbox.accounts ?? {};
  const defaultAccount = accounts["default"];
  if (defaultAccount)
    return getSandboxAccountConfig(sandbox, defaultAccount);
  return void 0;
};
var getContracts = (regex, config) => {
  if (!config.contracts)
    return [];
  return Object.values(config.contracts).reduce(
    (retval, contract) => regex.test(contract.sourceFile) ? [...retval, contract.sourceFile] : retval,
    []
  );
};
var stringToSHA256 = (s) => SHA256.toSHA256(s);
var getPackageName = () => {
  const stack = (0, import_stacktrace_js.getSync)({
    filter: (stackFrame) => {
      const filename = stackFrame.getFileName();
      return !filename.includes("taqueria-sdk") && !filename.includes("@taqueria/node-sdk") && !filename.includes("stacktrace-js");
    }
  });
  const frame = stack.shift();
  if (frame) {
    const filename = frame.getFileName().replace(/^file:\/\//, "").replace(/^file:/, "");
    const pluginManifest = (0, import_path.join)((0, import_path.dirname)(filename), "package.json");
    return getNameFromPluginManifest(pluginManifest);
  }
  return (0, import_project_name_generator.default)().dashed;
};
var isTaqError = (err) => {
  return err.kind !== void 0;
};
var sanitizedStderrWriter = () => {
  const stream = require("stream");
  const { Console } = require("console");
  const writable = stream.Writable({
    write(chunk, _encoding, next) {
      console.error(chunk.toString("utf8").replaceAll(/("[^"]+key\"):("[^"]+\")/gi, `$1:"[hidden]"`));
      next();
    }
  });
  return new Console(process.stdout, writable);
};
var outputSanitizedErr = (err) => {
  const console2 = sanitizedStderrWriter();
  console2.error(err);
};
var Plugin = {
  create: (definer, unparsedArgs) => {
    const packageName = getPackageName();
    return parseArgs(unparsedArgs).then(getResponse(definer, packageName)).catch((err) => {
      if (err) {
        const debug = unparsedArgs.join(",").includes(["--debug", true].join(","));
        if (isTaqError(err) && err.kind === "E_PARSE" && err.previous && err.previous instanceof import_zod.ZodError) {
          const msgs = err.previous.errors.reduce(
            (retval, issue) => {
              const path = issue.path.join(" \u2192 ");
              const msg = `  ${path}: ${issue.message}`;
              return [...retval, msg];
            },
            [`Taqueria tried to send data to ${packageName} that it couldn't parse or understand. This is most likely due to the version of the plugin being out-of-date and incompatible with the CLI or vice versa. More details:`]
          );
          console.error(msgs.join("\n") + "\n");
        } else if (typeof err === "string")
          console.error(err);
        else if (!debug) {
          console.error(`${packageName} encountered an unexpected problem. Use --debug to learn more.`);
        }
        if (debug) {
          outputSanitizedErr(err);
        }
      }
      process.exit(1);
    });
  }
};
var isContractFile = (filename) => {
  return !filename.includes(".default_storage.") && !filename.includes(".storage.") && !filename.includes(".parameter.") && !filename.includes(".expression.");
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Config,
  EconomicalProtocolHash,
  Environment,
  Faucet,
  LoadedConfig,
  NetworkConfig,
  NonEmptyString,
  Option,
  Plugin,
  PositionalArg,
  Protocol,
  ProxyTaskArgs,
  ProxyTemplateArgs,
  RequestArgs,
  TAQ_OPERATOR_ACCOUNT,
  Task,
  Template,
  addTzExtensionIfMissing,
  eager,
  execCmd,
  execCommandWithoutWrapping,
  getAccountPrivateKey,
  getAddressOfAlias,
  getArch,
  getArchSync,
  getArtifactsDir,
  getContractContent,
  getContracts,
  getContractsDir,
  getCurrentEnvironment,
  getCurrentEnvironmentConfig,
  getDefaultSandboxAccount,
  getDockerImage,
  getMetadataConfig,
  getNetworkConfig,
  getParameter,
  getSandboxAccountConfig,
  getSandboxAccountNames,
  getSandboxConfig,
  getSelectedEnvironment,
  isContractFile,
  isTaqError,
  noop,
  parseJSON,
  readJsonFile,
  sendAsyncErr,
  sendAsyncJson,
  sendAsyncJsonErr,
  sendAsyncJsonRes,
  sendAsyncRes,
  sendErr,
  sendJson,
  sendJsonErr,
  sendJsonRes,
  sendRes,
  sendWarn,
  spawnCmd,
  stringToSHA256,
  toExecErr,
  updateAddressAlias,
  writeJsonFile
});
//# sourceMappingURL=index.js.map