import {
  generateContractTypesFromMichelsonCode,
  normalizeContractName
} from "./chunk-L4VA7R4W.js";

// src/cli-process.ts
import fsRaw from "fs";
import path from "path";
import { promisify } from "util";

// src/type-aliases-file-content.ts
var typeAliasesFileContent = `
import { assertMichelsonInstruction, Expr, MichelsonCode } from '@taquito/michel-codec';
import { MichelsonMap } from '@taquito/taquito';
import { BigNumber } from 'bignumber.js';

export type Instruction = MichelsonCode;

export type unit = (true | undefined) & { __type: 'unit' };

export type address = string & { __type: 'address' };
export type bytes = string & { __type: 'bytes' };
export type contract = string & { __type: 'contract' };
export type operation = string & { __type: 'operation' };
export type key = string & { __type: 'key' };
export type key_hash = string & { __type: 'key_hash' };
export type signature = string & { __type: 'signature' };
export type ticket = string & { __type: 'ticket' };

export type timestamp = string & { __type: 'timestamp' };

export type int = BigNumber & { __type: 'int' };
export type nat = BigNumber & { __type: 'nat' };

export type mutez = BigNumber & { __type: 'mutez' };
export type tez = BigNumber & { __type: 'tez' };

type MapKey = Array<any> | object | string | boolean | number;
export type MMap<K extends MapKey, V> = Omit<MichelsonMap<K, V>, 'get'> & { get: (key: K) => V };
export type BigMap<K extends MapKey, V> = Omit<MichelsonMap<K, V>, 'get'> & { get: (key: K) => Promise<V> };

export type chest = string & { __type: 'chest' };
export type chest_key = string & { __type: 'chest_key' };

const createStringTypeTas = <T extends string>() => {
	return (value: string): T => value as T;
};

const createBigNumberTypeTas = <T extends BigNumber>() => {
	return (value: number | BigNumber | string): T => new BigNumber(value) as T;
};

type asMapParamOf<K, V> = K extends string ? { [key: string]: V } | Array<{ key: K; value: V }>
	: K extends number ? { [key: number]: V } | Array<{ key: K; value: V }>
	: Array<{ key: K; value: V }>;

function asMap<K extends MapKey, V>(value: asMapParamOf<K, V>): MMap<K, V> {
	const m = new MichelsonMap<K, V>();
	if (Array.isArray(value)) {
		const vArray = value as Array<{ key: K; value: V }>;
		vArray.forEach(x => m.set(x.key, x.value));
	} else {
		const vObject = value as { [key: string]: V };
		Object.keys(vObject).forEach(key => m.set(key as unknown as K, vObject[key]));
	}
	return m as MMap<K, V>;
}
const asBigMap = <K extends MapKey, V>(value: asMapParamOf<K, V>) => asMap(value) as unknown as BigMap<K, V>;

function add<T extends BigNumber>(a: T, b: T): T {
	return a.plus(b) as T;
}
function subtract<T extends BigNumber>(a: T, b: T): T {
	return a.minus(b) as T;
}

function createLambdaTypeTas(expr: Expr): MichelsonCode {
	assertMichelsonInstruction(expr);
    return expr as MichelsonCode;
}

/** tas: Tezos 'as' casting for strict types */
export const tas = {
	address: createStringTypeTas<address>(),
	bytes: createStringTypeTas<bytes>(),
	contract: createStringTypeTas<contract>(),
	chest: createStringTypeTas<chest>(),
	chest_key: createStringTypeTas<chest_key>(),
	timestamp: (value: string | Date): timestamp => new Date(value).toISOString() as timestamp,

	int: createBigNumberTypeTas<int>(),
	nat: createBigNumberTypeTas<nat>(),
	mutez: createBigNumberTypeTas<mutez>(),
	tez: createBigNumberTypeTas<tez>(),

	map: asMap,
	bigMap: asBigMap,

	// Operations
	add,
	subtract,

    lambda: createLambdaTypeTas,

	// To number
	number: (value: string | BigNumber) => Number(value + ''),
	unit: () => true as unit,
};
`;

// src/type-utils-file-content.ts
var typeUtilsFileContent = `
import { ContractAbstraction, ContractMethod, ContractMethodObject, ContractProvider, Wallet } from '@taquito/taquito';

type BaseContractType = { methods: unknown, methodsObject: unknown, storage: unknown };

type ContractMethodsOf<T extends ContractProvider | Wallet, TContract extends BaseContractType> = {
[M in keyof TContract['methods']]:
TContract['methods'][M] extends (...args: infer A) => unknown
? (...args: A) => ContractMethod<T>
: never
};
type ContractMethodsObjectsOf<T extends ContractProvider | Wallet, TContract extends BaseContractType> = {
[M in keyof TContract['methodsObject']]:
TContract['methodsObject'][M] extends (...args: infer A) => unknown
? (...args: A) => ContractMethodObject<T>
: never
};
type ContractStorageOf<TContract extends BaseContractType> = TContract['storage'];

export type ContractAbstractionFromContractType<TContract extends BaseContractType> = 
    ContractAbstraction<ContractProvider, 
        ContractMethodsOf<ContractProvider, TContract>,
        ContractMethodsObjectsOf<ContractProvider, TContract>,
        {},
        {},
        ContractStorageOf<TContract>
    >;

export type WalletContractAbstractionFromContractType<TContract extends BaseContractType> = 
    ContractAbstraction<Wallet, 
        ContractMethodsOf<Wallet, TContract>,
        ContractMethodsObjectsOf<Wallet, TContract>,
        {},
        {},
        ContractStorageOf<TContract>
    >;
`;

// src/cli-process.ts
var fs = {
  mkdir: promisify(fsRaw.mkdir),
  copyFile: promisify(fsRaw.copyFile),
  readdir: promisify(fsRaw.readdir),
  readFile: promisify(fsRaw.readFile),
  writeFile: promisify(fsRaw.writeFile),
  stat: promisify(fsRaw.stat),
  exists: fsRaw.existsSync
};
var getAllFiles = async (rootPath, filter) => {
  const allFiles = [];
  const getAllFilesRecursive = async (dirPath) => {
    let files = await fs.readdir(dirPath, { withFileTypes: true });
    for (const f of files) {
      const subPath = path.resolve(dirPath, f.name);
      if (f.isDirectory()) {
        await getAllFilesRecursive(subPath);
        continue;
      }
      if (!filter(subPath)) {
        continue;
      }
      allFiles.push(subPath);
    }
  };
  await getAllFilesRecursive(rootPath);
  return allFiles;
};
var generateContractTypesProcessContractFiles = async ({
  inputTzContractDirectory,
  inputFiles,
  outputTypescriptDirectory,
  format,
  typeAliasMode
}) => {
  console.log(
    `Generating Types: ${path.resolve(inputTzContractDirectory)} => ${path.resolve(outputTypescriptDirectory)}`
  );
  const ext = "." + format;
  const filesAll = await getAllFiles(inputTzContractDirectory, (x) => x.endsWith(ext));
  const files = inputFiles ? filesAll.filter((f) => inputFiles.some((inputFile) => f.endsWith(inputFile))) : filesAll;
  console.log(`Contracts Found: ${[``, ...files].join(`
	- `)}`);
  const typeAliasImportPath = `@taquito/contract-type-generator`;
  const typeAliasData = typeAliasMode === "local" ? { mode: typeAliasMode, fileContent: typeAliasesFileContent } : typeAliasMode === "file" ? { mode: typeAliasMode, importPath: `./type-aliases` } : typeAliasMode === "library" ? { mode: typeAliasMode, importPath: typeAliasImportPath } : { mode: "simple" };
  if (typeAliasMode === "file") {
    await fs.mkdir(outputTypescriptDirectory, { recursive: true });
    await fs.writeFile(path.join(outputTypescriptDirectory, "./type-aliases.ts"), typeAliasesFileContent);
  }
  const typeUtilsData = { importPath: `./type-utils` };
  await fs.mkdir(outputTypescriptDirectory, { recursive: true });
  await fs.writeFile(path.join(outputTypescriptDirectory, "./type-utils.ts"), typeUtilsFileContent);
  for (const fullPath of files) {
    const fileRelativePath = fullPath.replace(path.resolve(inputTzContractDirectory), "");
    const fileName = fileRelativePath.replace(ext, "");
    const inputFilePath = path.join(inputTzContractDirectory, fileRelativePath);
    const typesOutputFilePath = path.join(outputTypescriptDirectory, fileRelativePath.replace(ext, `.types.ts`));
    const codeContentOutputFilePath = path.join(outputTypescriptDirectory, fileRelativePath.replace(ext, `.code.ts`));
    const schemaContentOutputFilePath = path.join(
      outputTypescriptDirectory,
      fileRelativePath.replace(ext, `.schema.json`)
    );
    console.log(`Processing ${fileRelativePath}...`);
    try {
      const contractTypeName = normalizeContractName(fileName);
      const michelsonCode = await fs.readFile(inputFilePath, { encoding: `utf8` });
      const {
        schemaOutput,
        typescriptCodeOutput: { typesFileContent: typesFileContentRaw, contractCodeFileContent }
      } = generateContractTypesFromMichelsonCode(michelsonCode, contractTypeName, format, typeAliasData, typeUtilsData);
      const nestedDirDepth = fileRelativePath.replace(/^.?\/?/, "").split("/").length - 1;
      const typesFileContent = nestedDirDepth <= 0 ? typesFileContentRaw : typesFileContentRaw.replace(
        /from '\.\//g,
        `from '${[...new Array(nestedDirDepth)].map(() => "../").join("")}`
      );
      await fs.mkdir(path.dirname(typesOutputFilePath), { recursive: true });
      await fs.writeFile(typesOutputFilePath, typesFileContent);
      await fs.writeFile(codeContentOutputFilePath, contractCodeFileContent);
      const debugSchema = false;
      if (debugSchema) {
        await fs.writeFile(schemaContentOutputFilePath, JSON.stringify(schemaOutput, null, 2));
      }
    } catch (err) {
      console.error(`\u274C Could not process ${fileRelativePath}`, { err });
    }
  }
};

export {
  generateContractTypesProcessContractFiles
};
//# sourceMappingURL=chunk-WOC2EYW3.js.map