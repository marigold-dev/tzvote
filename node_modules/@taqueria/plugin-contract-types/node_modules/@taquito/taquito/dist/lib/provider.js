"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Provider = void 0;
const types_1 = require("./operations/types");
const operation_errors_1 = require("./operations/operation-errors");
const prepare_1 = require("./contract/prepare");
const rpc_1 = require("@taquito/rpc");
const utils_1 = require("@taquito/utils");
class Provider {
    constructor(context) {
        this.context = context;
    }
    get rpc() {
        return this.context.rpc;
    }
    get signer() {
        return this.context.signer;
    }
    forge({ opOb: { branch, contents, protocol }, counter }) {
        return __awaiter(this, void 0, void 0, function* () {
            const forgedBytes = yield this.context.forger.forge({ branch, contents });
            return {
                opbytes: forgedBytes,
                opOb: {
                    branch,
                    contents,
                    protocol,
                },
                counter,
            };
        });
    }
    estimate(_a, estimator) {
        var { fee, gasLimit, storageLimit } = _a, rest = __rest(_a, ["fee", "gasLimit", "storageLimit"]);
        return __awaiter(this, void 0, void 0, function* () {
            let calculatedFee = fee;
            let calculatedGas = gasLimit;
            let calculatedStorage = storageLimit;
            if (calculatedFee && calculatedFee % 1 !== 0) {
                throw new operation_errors_1.InvalidEstimateValueError(`Fee value must not be a decimal: ${calculatedFee}`);
            }
            if (calculatedGas && calculatedGas % 1 !== 0) {
                throw new operation_errors_1.InvalidEstimateValueError(`Gas Limit value must not be a decimal: ${calculatedGas}`);
            }
            if (calculatedStorage && calculatedStorage % 1 !== 0) {
                throw new operation_errors_1.InvalidEstimateValueError(`Storage Limit value must not be a decimal: ${calculatedStorage}`);
            }
            if (fee === undefined || gasLimit === undefined || storageLimit === undefined) {
                const estimation = yield estimator(Object.assign({ fee, gasLimit, storageLimit }, rest));
                calculatedFee !== null && calculatedFee !== void 0 ? calculatedFee : (calculatedFee = estimation.suggestedFeeMutez);
                calculatedGas !== null && calculatedGas !== void 0 ? calculatedGas : (calculatedGas = estimation.gasLimit);
                calculatedStorage !== null && calculatedStorage !== void 0 ? calculatedStorage : (calculatedStorage = estimation.storageLimit);
            }
            return {
                fee: calculatedFee,
                gasLimit: calculatedGas,
                storageLimit: calculatedStorage,
            };
        });
    }
    getRPCOp(param) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (param.kind) {
                case rpc_1.OpKind.TRANSACTION:
                    return prepare_1.createTransferOperation(Object.assign({}, param));
                case rpc_1.OpKind.ORIGINATION:
                    return prepare_1.createOriginationOperation(yield this.context.parser.prepareCodeOrigination(Object.assign({}, param)));
                case rpc_1.OpKind.DELEGATION:
                    return prepare_1.createSetDelegateOperation(Object.assign({}, param));
                case rpc_1.OpKind.REGISTER_GLOBAL_CONSTANT:
                    return prepare_1.createRegisterGlobalConstantOperation(Object.assign({}, param));
                case rpc_1.OpKind.INCREASE_PAID_STORAGE:
                    return prepare_1.createIncreasePaidStorageOperation(Object.assign({}, param));
                case rpc_1.OpKind.TRANSFER_TICKET:
                    return prepare_1.createTransferTicketOperation(Object.assign({}, param));
                case rpc_1.OpKind.SMART_ROLLUP_ADD_MESSAGES:
                    return prepare_1.createSmartRollupAddMessagesOperation(Object.assign({}, param));
                case rpc_1.OpKind.SMART_ROLLUP_ORIGINATE:
                    return prepare_1.createSmartRollupOriginateOperation(Object.assign({}, param));
                default:
                    throw new utils_1.InvalidOperationKindError(param.kind);
            }
        });
    }
    simulate(op) {
        return __awaiter(this, void 0, void 0, function* () {
            return {
                opResponse: yield this.rpc.runOperation(op),
                op,
                context: this.context.clone(),
            };
        });
    }
    isRevealOpNeeded(op, pkh) {
        return __awaiter(this, void 0, void 0, function* () {
            return !(yield this.isAccountRevealRequired(pkh)) || !this.isRevealRequiredForOpType(op)
                ? false
                : true;
        });
    }
    isAccountRevealRequired(publicKeyHash) {
        return __awaiter(this, void 0, void 0, function* () {
            return !(yield this.context.readProvider.isAccountRevealed(publicKeyHash, 'head'));
        });
    }
    isRevealRequiredForOpType(op) {
        let opRequireReveal = false;
        for (const operation of op) {
            if (types_1.isOpRequireReveal(operation)) {
                opRequireReveal = true;
            }
        }
        return opRequireReveal;
    }
    signAndInject(forgedBytes) {
        return __awaiter(this, void 0, void 0, function* () {
            const signed = yield this.signer.sign(forgedBytes.opbytes, new Uint8Array([3]));
            forgedBytes.opbytes = signed.sbytes;
            forgedBytes.opOb.signature = signed.prefixSig;
            const opResponse = [];
            const results = yield this.rpc.preapplyOperations([forgedBytes.opOb]);
            if (!Array.isArray(results)) {
                throw new operation_errors_1.TezosPreapplyFailureError(results);
            }
            for (let i = 0; i < results.length; i++) {
                for (let j = 0; j < results[i].contents.length; j++) {
                    opResponse.push(results[i].contents[j]);
                }
            }
            const errors = operation_errors_1.flattenErrors(results);
            if (errors.length) {
                throw new operation_errors_1.TezosOperationError(errors, 'Error occurred during validation simulation of operation');
            }
            return {
                hash: yield this.context.injector.inject(forgedBytes.opbytes),
                forgedBytes,
                opResponse,
                context: this.context.clone(),
            };
        });
    }
}
exports.Provider = Provider;
//# sourceMappingURL=provider.js.map