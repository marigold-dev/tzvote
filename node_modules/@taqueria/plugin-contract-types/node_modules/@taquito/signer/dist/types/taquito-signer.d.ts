import { Curves } from './helpers';
export * from './import-key';
export { VERSION } from './version';
export * from './derivation-tools';
export * from './helpers';
export { InvalidPassphraseError } from './errors';
export interface FromMnemonicParams {
    mnemonic: string;
    password?: string;
    derivationPath?: string;
    curve?: Curves;
}
/**
 * @description A local implementation of the signer. Will represent a Tezos account and be able to produce signature in its behalf
 *
 * @warn If running in production and dealing with tokens that have real value, it is strongly recommended to use a HSM backed signer so that private key material is not stored in memory or on disk
 * @throws {@link InvalidMnemonicError}
 */
export declare class InMemorySigner {
    private _key;
    static fromFundraiser(email: string, password: string, mnemonic: string): InMemorySigner;
    static fromSecretKey(key: string, passphrase?: string): Promise<InMemorySigner>;
    /**
     *
     * @description Instantiation of an InMemorySigner instance from a mnemonic
     * @param mnemonic 12-24 word mnemonic
     * @param password password used to encrypt the mnemonic to seed value
     * @param derivationPath default 44'/1729'/0'/0' (44'/1729' mandatory)
     * @param curve currently only supported for tz1, tz2, tz3 addresses. soon bip25519
     * @returns InMemorySigner
     * @throws {@link InvalidMnemonicError}
     */
    static fromMnemonic({ mnemonic, password, derivationPath, curve, }: FromMnemonicParams): InMemorySigner;
    /**
     *
     * @param key Encoded private key
     * @param passphrase Passphrase to decrypt the private key if it is encrypted
     * @throws {@link InvalidKeyError}
     *
     */
    constructor(key: string, passphrase?: string);
    /**
     *
     * @param bytes Bytes to sign
     * @param watermark Watermark to append to the bytes
     */
    sign(bytes: string, watermark?: Uint8Array): Promise<{
        bytes: string;
        sig: string;
        prefixSig: string;
        sbytes: string;
    }>;
    /**
     * @returns Encoded public key
     */
    publicKey(): Promise<string>;
    /**
     * @returns Encoded public key hash
     */
    publicKeyHash(): Promise<string>;
    /**
     * @returns Encoded private key
     */
    secretKey(): Promise<string>;
}
