{"version":3,"sources":["index.ts","tasks.ts","src/cli-process.ts","src/generator/contract-name.ts","src/generator/process.ts","src/generator/common.ts","src/generator/contract-parser.ts","src/generator/schema-output.ts","src/generator/typescript-output.ts","src/type-aliases-file-content.ts","src/type-utils-file-content.ts"],"sourcesContent":["import { Option, Plugin, PositionalArg, Task } from '@taqueria/node-sdk';\nimport { tasks } from './tasks';\nexport { generateContractTypesProcessContractFiles } from './src/cli-process';\n\nPlugin.create(i18n => ({\n\talias: 'contract-types',\n\tschema: '1.0',\n\tversion: '0.1',\n\ttasks: [\n\t\tTask.create({\n\t\t\ttask: 'generate types',\n\t\t\tcommand: 'generate types [typescriptDir]',\n\t\t\tdescription: 'Generate types for a contract to be used with taquito',\n\t\t\tpositionals: [\n\t\t\t\tPositionalArg.create({\n\t\t\t\t\tplaceholder: 'typescriptDir',\n\t\t\t\t\tdescription: 'The output directory for the generated type files',\n\t\t\t\t\tdefaultValue: 'types',\n\t\t\t\t}),\n\t\t\t],\n\t\t\toptions: [\n\t\t\t\tOption.create({\n\t\t\t\t\tshortFlag: 't',\n\t\t\t\t\tflag: 'typeAliasMode',\n\t\t\t\t\tchoices: ['file', 'simple'],\n\t\t\t\t\tdescription: 'The type aliases used in the generated types',\n\t\t\t\t}),\n\t\t\t],\n\t\t\taliases: ['gen types', 'gentypes'],\n\t\t\thandler: 'proxy',\n\t\t}),\n\t],\n\tproxy: tasks.generateTypes,\n}), process.argv);\n","import { isContractFile, RequestArgs } from '@taqueria/node-sdk';\nimport glob from 'fast-glob';\nimport { join } from 'path';\nimport { generateContractTypesProcessContractFiles } from './src/cli-process';\ninterface Opts extends RequestArgs.t {\n\t// TODO: Document these\n\ttypescriptDir?: string;\n\ttypeAliasMode?: 'local' | 'file' | 'library' | 'simple';\n\tcontract?: string;\n}\n\nconst getContractAbspath = (contractFilename: string, parsedArgs: Opts) =>\n\tjoin(\n\t\tparsedArgs.config.artifactsDir ?? 'artifacts',\n\t\t/\\.tz$/.test(contractFilename) ? contractFilename : `${contractFilename}.tz`,\n\t);\n\nconst generateContractTypes = (parsedArgs: Opts) =>\n\tasync (contractFilename: string): Promise<string> => {\n\t\tconst contractAbspath = getContractAbspath(contractFilename, parsedArgs);\n\t\tawait generateContractTypesProcessContractFiles({\n\t\t\tinputTzContractDirectory: parsedArgs.config.artifactsDir ?? 'artifacts',\n\t\t\tinputFiles: [contractAbspath],\n\t\t\toutputTypescriptDirectory: parsedArgs.typescriptDir || 'types',\n\t\t\tformat: 'tz',\n\t\t\ttypeAliasMode: parsedArgs.typeAliasMode ?? 'file',\n\t\t});\n\n\t\treturn `${contractFilename}: Types generated`;\n\t};\n\nconst generateContractTypesAll = async (parsedArgs: Opts): Promise<string[]> => {\n\tconst files = await glob('**/*.tz', { cwd: parsedArgs.config.artifactsDir });\n\tconst contractFiles = files.filter(isContractFile);\n\treturn await Promise.all(contractFiles.map(generateContractTypes(parsedArgs)));\n};\n\nexport const generateTypes = (parsedArgs: Opts) => {\n\tparsedArgs.typescriptDir = parsedArgs.typescriptDir || 'types';\n\n\tconsole.log('generateTypes', {\n\t\ttypescriptDir: parsedArgs.typescriptDir,\n\t});\n\n\tconst p = parsedArgs.contract\n\t\t? generateContractTypes(parsedArgs)(parsedArgs.contract)\n\t\t: generateContractTypesAll(parsedArgs);\n\n\treturn p.then(data => {\n\t\tconsole.log(\n\t\t\t(Array.isArray(data))\n\t\t\t\t? data.join('\\n')\n\t\t\t\t: data,\n\t\t);\n\t});\n};\n\nexport const tasks = {\n\tgenerateTypes,\n};\n","import fsRaw from 'fs';\nimport path from 'path';\nimport { promisify } from 'util';\nimport { normalizeContractName } from './generator/contract-name';\nimport { generateContractTypesFromMichelsonCode } from './generator/process';\nimport { TypeAliasData, TypeUtilsData } from './generator/typescript-output';\nimport { typeAliasesFileContent } from './type-aliases-file-content';\nimport { typeUtilsFileContent } from './type-utils-file-content';\n\nconst fs = {\n\tmkdir: promisify(fsRaw.mkdir),\n\tcopyFile: promisify(fsRaw.copyFile),\n\treaddir: promisify(fsRaw.readdir),\n\treadFile: promisify(fsRaw.readFile),\n\twriteFile: promisify(fsRaw.writeFile),\n\tstat: promisify(fsRaw.stat),\n\texists: fsRaw.existsSync,\n};\n\nconst getAllFiles = async (rootPath: string, filter: (fullPath: string) => boolean): Promise<string[]> => {\n\tconst allFiles = [] as string[];\n\n\tconst getAllFilesRecursive = async (dirPath: string) => {\n\t\tlet files = await fs.readdir(dirPath, { withFileTypes: true });\n\n\t\tfor (const f of files) {\n\t\t\tconst subPath = path.resolve(dirPath, f.name);\n\n\t\t\tif (f.isDirectory()) {\n\t\t\t\tawait getAllFilesRecursive(subPath);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!filter(subPath)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tallFiles.push(subPath);\n\t\t}\n\t};\n\n\tawait getAllFilesRecursive(rootPath);\n\treturn allFiles;\n};\n\nexport const generateContractTypesProcessContractFiles = async ({\n\tinputTzContractDirectory,\n\tinputFiles,\n\toutputTypescriptDirectory,\n\tformat,\n\ttypeAliasMode,\n}: {\n\tinputTzContractDirectory: string;\n\tinputFiles?: string[];\n\toutputTypescriptDirectory: string;\n\tformat: 'tz' | 'json';\n\ttypeAliasMode: 'local' | 'file' | 'library' | 'simple';\n}): Promise<void> => {\n\tconsole.log(\n\t\t`Generating Types: ${path.resolve(inputTzContractDirectory)} => ${path.resolve(outputTypescriptDirectory)}`,\n\t);\n\n\tconst ext = '.' + format;\n\tconst filesAll = await getAllFiles(inputTzContractDirectory, x => x.endsWith(ext));\n\tconst files = inputFiles ? filesAll.filter(f => inputFiles.some(inputFile => f.endsWith(inputFile))) : filesAll;\n\n\tconsole.log(`Contracts Found: ${[``, ...files].join(`\\n\\t- `)}`);\n\n\tconst typeAliasImportPath = `@taquito/contract-type-generator`;\n\n\tconst typeAliasData: TypeAliasData = typeAliasMode === 'local'\n\t\t? { mode: typeAliasMode, fileContent: typeAliasesFileContent }\n\t\t: typeAliasMode === 'file'\n\t\t? { mode: typeAliasMode, importPath: `./type-aliases` }\n\t\t: typeAliasMode === 'library'\n\t\t? { mode: typeAliasMode, importPath: typeAliasImportPath }\n\t\t: { mode: 'simple' };\n\n\tif (typeAliasMode === 'file') {\n\t\t// Copy the type alias file\n\t\tawait fs.mkdir(outputTypescriptDirectory, { recursive: true });\n\t\tawait fs.writeFile(path.join(outputTypescriptDirectory, './type-aliases.ts'), typeAliasesFileContent);\n\t}\n\n\t// Copy the type utils file\n\tconst typeUtilsData: TypeUtilsData = { importPath: `./type-utils` };\n\tawait fs.mkdir(outputTypescriptDirectory, { recursive: true });\n\tawait fs.writeFile(path.join(outputTypescriptDirectory, './type-utils.ts'), typeUtilsFileContent);\n\n\tfor (const fullPath of files) {\n\t\tconst fileRelativePath = fullPath.replace(path.resolve(inputTzContractDirectory), '');\n\t\tconst fileName = fileRelativePath.replace(ext, '');\n\t\tconst inputFilePath = path.join(inputTzContractDirectory, fileRelativePath);\n\t\tconst typesOutputFilePath = path.join(outputTypescriptDirectory, fileRelativePath.replace(ext, `.types.ts`));\n\t\tconst codeContentOutputFilePath = path.join(outputTypescriptDirectory, fileRelativePath.replace(ext, `.code.ts`));\n\t\tconst schemaContentOutputFilePath = path.join(\n\t\t\toutputTypescriptDirectory,\n\t\t\tfileRelativePath.replace(ext, `.schema.json`),\n\t\t);\n\t\tconsole.log(`Processing ${fileRelativePath}...`);\n\n\t\ttry {\n\t\t\tconst contractTypeName = normalizeContractName(fileName);\n\n\t\t\tconst michelsonCode = await fs.readFile(inputFilePath, { encoding: `utf8` });\n\n\t\t\tconst {\n\t\t\t\tschemaOutput,\n\t\t\t\ttypescriptCodeOutput: { typesFileContent: typesFileContentRaw, contractCodeFileContent },\n\t\t\t} = generateContractTypesFromMichelsonCode(michelsonCode, contractTypeName, format, typeAliasData, typeUtilsData);\n\n\t\t\t// Correct relative paths for nested contracts\n\t\t\tconst nestedDirDepth = fileRelativePath.replace(/^.?\\/?/, '').split('/').length - 1;\n\t\t\tconst typesFileContent = nestedDirDepth <= 0\n\t\t\t\t? typesFileContentRaw\n\t\t\t\t: typesFileContentRaw.replace(\n\t\t\t\t\t/from '\\.\\//g,\n\t\t\t\t\t`from '${[...new Array(nestedDirDepth)].map(() => '../').join('')}`,\n\t\t\t\t);\n\n\t\t\t// Write output (ensure dir exists)\n\t\t\tawait fs.mkdir(path.dirname(typesOutputFilePath), { recursive: true });\n\t\t\tawait fs.writeFile(typesOutputFilePath, typesFileContent);\n\t\t\tawait fs.writeFile(codeContentOutputFilePath, contractCodeFileContent);\n\n\t\t\tconst debugSchema = false;\n\t\t\tif (debugSchema) {\n\t\t\t\tawait fs.writeFile(schemaContentOutputFilePath, JSON.stringify(schemaOutput, null, 2));\n\t\t\t}\n\t\t} catch (err: unknown) {\n\t\t\tconsole.error(`❌ Could not process ${fileRelativePath}`, { err });\n\t\t}\n\t}\n};\n","export const normalizeContractName = (text: string) =>\n\ttext\n\t\t.replace(/[^A-Za-z0-9]/g, '_')\n\t\t.split('_')\n\t\t.filter(x => x)\n\t\t.map(x => x[0].toUpperCase() + x.substring(1))\n\t\t.join('');\n","import * as M from '@taquito/michel-codec';\nimport { GenerateApiError } from './common';\nimport { parseContractParameter, parseContractStorage } from './contract-parser';\nimport { SchemaOutput, toSchema } from './schema-output';\nimport { toTypescriptCode, TypeAliasData, TypescriptCodeOutput, TypeUtilsData } from './typescript-output';\n\nconst parseContractWithMinimalProtocolLevel = (\n\tcontractScript: string,\n\tformat: 'tz' | 'json',\n\tcontractLevelIndex: number,\n): { contract: M.MichelsonContract; protocol: { name: string; key: string } } => {\n\tconst contractLevels = [\n\t\t{ name: 'PsDELPH1', key: M.Protocol.PsDELPH1 },\n\t\t{ name: 'PtEdo2Zk', key: M.Protocol.PtEdo2Zk },\n\t\t{ name: 'PsFLorena', key: M.Protocol.PsFLorena },\n\t];\n\n\tconst protocol = contractLevels[contractLevelIndex];\n\tif (!protocol) {\n\t\tthrow new GenerateApiError(`Could not parse contract script`, contractScript);\n\t}\n\n\tconst p = new M.Parser({ protocol: protocol.key });\n\n\ttry {\n\t\tconst contract = (\n\t\t\tformat === 'tz'\n\t\t\t\t? p.parseScript(contractScript)\n\t\t\t\t: p.parseJSON(JSON.parse(contractScript))\n\t\t) as M.MichelsonContract;\n\t\tif (contract) {\n\t\t\treturn {\n\t\t\t\tcontract,\n\t\t\t\tprotocol,\n\t\t\t};\n\t\t}\n\t} catch {\n\t\t// Ignore parse errors\n\t}\n\n\t// Try again with next level\n\treturn parseContractWithMinimalProtocolLevel(contractScript, format, contractLevelIndex + 1);\n};\n\nexport const parseContractInterface = (\n\tcontractScript: string,\n\tformat: 'tz' | 'json',\n) => {\n\tconst p = new M.Parser({ protocol: M.Protocol.PsFLorena });\n\n\tconst { contract, protocol } = parseContractWithMinimalProtocolLevel(contractScript, format, 0);\n\n\tconst contractStorage = contract.find(x => x.prim === `storage`) as undefined | M.MichelsonContractStorage;\n\tconst contractParameter = contract.find(x => x.prim === `parameter`) as undefined | M.MichelsonContractParameter;\n\n\tconst storageResult = contractStorage && parseContractStorage(contractStorage);\n\tconst storage = storageResult\n\t\t?? { storage: { kind: `object`, raw: { prim: `never` } as M.MichelsonType, fields: [] } };\n\n\tconst parameterResult = contractParameter && parseContractParameter(contractParameter);\n\tconst methods = parameterResult?.methods ?? [];\n\n\treturn {\n\t\tstorage,\n\t\tmethods,\n\t\tcontract,\n\t\tprotocol,\n\t};\n};\n\nexport const generateContractTypesFromMichelsonCode = (\n\tcontractScript: string,\n\tcontractName: string,\n\tformat: 'tz' | 'json',\n\ttypeAliasData: TypeAliasData,\n\ttypeUtilsData: TypeUtilsData,\n): {\n\tschemaOutput: SchemaOutput;\n\ttypescriptCodeOutput: TypescriptCodeOutput;\n\tparsedContract: M.MichelsonContract;\n\tminimalProtocol: string;\n} => {\n\tconst {\n\t\tstorage,\n\t\tmethods,\n\t\tcontract,\n\t\tprotocol,\n\t} = parseContractInterface(\n\t\tcontractScript,\n\t\tformat,\n\t);\n\n\t// If there's only one entrypoint, then we call it \"default\"\n\tif (methods.length === 1) methods[0].name = `default`;\n\n\tconst schemaOutput = toSchema(methods, storage);\n\n\tconst typescriptCode = toTypescriptCode(\n\t\tstorage,\n\t\tmethods,\n\t\tcontractName,\n\t\tcontract,\n\t\tprotocol,\n\t\ttypeAliasData,\n\t\ttypeUtilsData,\n\t);\n\n\treturn {\n\t\tschemaOutput,\n\t\ttypescriptCodeOutput: typescriptCode,\n\t\tparsedContract: contract,\n\t\tminimalProtocol: protocol.key,\n\t};\n};\n","export class GenerateApiError implements Error {\n\tname = `GenerateApiError`;\n\tconstructor(public message: string, readonly data: unknown) {\n\t\tconsole.error(`❌ GenerateApiError: ${message}`, data);\n\t}\n}\n\nexport const assertExhaustive = (value: never, message: string): void => {\n\tconsole.error(message, { value });\n};\n\nexport const reduceFlatMap = <T>(out: T[], x: T[]): T[] => {\n\tout.push(...x);\n\treturn out;\n};\n\n// const reduceFlatMapTest = () => {\n//     const items = [['a'], ['b']];\n//     const itemsFlat = items.reduce(reduceFlatMap);\n// };\n","import * as M from '@taquito/michel-codec';\nimport { assertExhaustive, GenerateApiError, reduceFlatMap } from './common';\n\nexport type TypedStorage = {\n\tstorage: TypedType;\n};\nexport type TypedParameter = {\n\tmethods: TypedMethod[];\n};\nexport type TypedMethod = {\n\tname: string;\n\targs: TypedVar[];\n};\nexport type TypedVar = {\n\tname?: string;\n\ttype: TypedType;\n};\nexport type TypedType =\n\t& {\n\t\traw: M.MichelsonType;\n\t\toptional?: boolean;\n\t}\n\t& (\n\t\t{\n\t\t\tkind: 'unit';\n\t\t} | {\n\t\t\tkind: 'never';\n\t\t} | {\n\t\t\tkind: 'unknown';\n\t\t} | {\n\t\t\tkind: 'value';\n\t\t\tvalue: string;\n\t\t\ttypescriptType: 'string' | 'boolean' | 'number' | 'Date';\n\t\t} | {\n\t\t\tkind: 'union';\n\t\t\tunion: TypedVar[];\n\t\t} | {\n\t\t\tkind: 'object';\n\t\t\tfields: TypedVar[];\n\t\t} | {\n\t\t\tkind: 'array';\n\t\t\tarray: { item: TypedType };\n\t\t} | {\n\t\t\tkind: 'map';\n\t\t\tmap: { key: TypedType; value: TypedType; isBigMap: boolean };\n\t\t} | {\n\t\t\tkind: 'lambda';\n\t\t\tlambda: { arg: TypedType; ret: TypedType };\n\t\t}\n\t);\n\nconst toDebugSource = (node: M.MichelsonType) => {\n\treturn JSON.stringify(node);\n};\n\nexport const parseContractStorage = (storage: M.MichelsonContractStorage): TypedStorage => {\n\tconst fields = storage.args\n\t\t.map(x => visitVar(x))\n\t\t.reduce(reduceFlatMap, []);\n\n\tif (fields.length === 1 && !fields[0].name) {\n\t\treturn {\n\t\t\tstorage: fields[0].type,\n\t\t};\n\t}\n\n\treturn {\n\t\tstorage: {\n\t\t\tkind: `object` as const,\n\t\t\traw: storage as unknown as M.MichelsonType,\n\t\t\tfields,\n\t\t},\n\t};\n};\n\nexport const parseContractParameter = (parameter: M.MichelsonContractParameter): TypedParameter => {\n\treturn {\n\t\tmethods: parameter.args\n\t\t\t.map(x => visitContractParameterEndpoint(x as MMethod))\n\t\t\t.reduce(reduceFlatMap, []),\n\t};\n};\n\ntype MMethod = M.MichelsonTypeOr<[M.MichelsonType, M.MichelsonType]>;\nconst visitContractParameterEndpoint = (node: MMethod): TypedMethod[] => {\n\t// console.log('visitContractParameterEndpoint', { node });\n\n\t// Sub endpoints (i.e. admin endpoints that are imported)\n\tif (node.prim === `or`) {\n\t\treturn node.args.map(x => visitContractParameterEndpoint(x as MMethod)).reduce(reduceFlatMap, []);\n\t}\n\n\t// Sub endpoints as a list with a single or (i.e. admin endpoints that are imported)\n\tif (node.prim === `list` && node.args.length as number === 1 && (node.args[0] as MMethod)?.prim === `or`) {\n\t\treturn node.args.map(x => visitContractParameterEndpoint(x as MMethod)).reduce(reduceFlatMap, []);\n\t}\n\n\tconst nameRaw = node.annots?.[0];\n\n\t// If the name is missing, then we assume its the main / default entrypoint\n\tconst name = nameRaw?.startsWith('%') ? nameRaw.substr(1) : 'default';\n\n\tif (!name) {\n\t\tconsole.warn(`Unknown method: ${node.prim as string}`, { node, args: node.args });\n\t\treturn [];\n\t}\n\n\tconst nodeType = visitType(node, { ignorePairName: node.prim === 'pair' });\n\n\t// Method args are usually objects\n\tif (nodeType.kind === 'object') {\n\t\treturn [{ name, args: nodeType.fields }];\n\t}\n\n\t// Simple methods can have a single unnamed argument\n\treturn [{\n\t\tname,\n\t\targs: [{ type: nodeType }],\n\t}];\n};\n\n// type PrimOf<T extends M.MichelsonType> = T extends { prim: infer U } ? U : never;\n// type WithPrim<T extends M.MichelsonType, P extends PrimOf<T>> = T extends { prim: P } ? T : never;\n// const isPrimType = <TPrim extends PrimOf<M.MichelsonType>>(node: undefined | null | M.MichelsonType, prim: TPrim): node is WithPrim<M.MichelsonType, TPrim> => {\n//     return (node && 'prim' in node && node.prim === prim) || false;\n// };\n\ntype MVarArgs = M.MichelsonType;\nconst visitVar = (node: MVarArgs): TypedVar[] => {\n\tconst name = `annots` in node && node.annots?.length === 1 ? node.annots[0].substr(1) : undefined;\n\tconst type = visitType(node);\n\n\treturn [{\n\t\tname,\n\t\ttype,\n\t}];\n};\n\ntype MType = M.MichelsonType;\nconst visitType = (node: MType, options?: { ignorePairName?: boolean }): TypedType => {\n\t// console.log('visitType', { node });\n\t// const debug_source = toDebugSource(node);\n\n\t// if (typeof node === `string`) {\n\t//     return { kind: `value`, raw: node, value: node, typescriptType: `string` };\n\t// }\n\n\tif (!(`prim` in node)) {\n\t\t// Unknown\n\t\tconsole.error(`visitType no prim`, { node });\n\t\treturn { kind: `unknown`, raw: node };\n\t}\n\n\t// Union\n\tif (node.prim === `or`) {\n\t\tconst unionVars = node.args.map(x => visitVar(x)).reduce(reduceFlatMap, []).map(x => x);\n\n\t\t// Flatten with child unions\n\t\tconst union = unionVars.map(x => !x.name && x.type.kind === 'union' ? x.type.union : [x]).reduce(reduceFlatMap, []);\n\t\t// const union = unionVars.map(x=>x.type);\n\n\t\t// const union = unionVars.map(x => x.type);\n\n\t\t// Flatten with child unions\n\n\t\t// const rightSide = union[1];\n\t\t// if (rightSide.kind === `union`) {\n\t\t//     union.pop();\n\t\t//     union.push(...rightSide.union);\n\t\t// }\n\n\t\tif (union.some(x => !x)) {\n\t\t\tthrow new GenerateApiError(`or: Some fields are null`, { node });\n\t\t}\n\t\treturn {\n\t\t\tkind: `union`,\n\t\t\traw: node,\n\t\t\tunion,\n\t\t};\n\t}\n\n\t// Intersect\n\tif (node.prim === `pair`) {\n\t\tconst fields = node.args.map(x => visitVar(x)).reduce(reduceFlatMap, []);\n\t\tif (fields.some(x => !x)) {\n\t\t\tthrow new GenerateApiError(`pair: Some fields are null`, { node, args: node.args, fields });\n\t\t}\n\t\t// Disabled Check: Apparently pairs can have more than 2 items\n\t\t// if (fields.length !== 2) {\n\t\t//     throw new GenerateApiError(`pair: Expected 2 items`, { node, length: fields.length, fields });\n\t\t// }\n\n\t\t// Flatten with unnamed child pairs\n\t\tconst fieldsFlat = fields.map(x =>\n\t\t\t(!x.name || options?.ignorePairName) && x.type.kind === 'object' ? x.type.fields : [x]\n\t\t).reduce(reduceFlatMap, []);\n\n\t\treturn {\n\t\t\tkind: `object`,\n\t\t\traw: node,\n\t\t\tfields: fieldsFlat,\n\t\t};\n\t}\n\n\t// list\n\tif (\n\t\tnode.prim === `list`\n\t\t|| node.prim === `set`\n\t) {\n\t\tif (node.args.length !== 1) {\n\t\t\tthrow new GenerateApiError(`list does not have 1 arg`, { node, args: node.args });\n\t\t}\n\n\t\tconst arrayItem = visitType(node.args[0]);\n\t\tif (!arrayItem) {\n\t\t\tthrow new GenerateApiError(`arrayItem are null`, { node, args: node.args, arrayItem });\n\t\t}\n\t\treturn {\n\t\t\tkind: `array`,\n\t\t\traw: node,\n\t\t\tarray: { item: arrayItem },\n\t\t};\n\t}\n\n\t// map\n\tif (\n\t\tnode.prim === `map`\n\t\t|| node.prim === `big_map`\n\t) {\n\t\tif (node.args.length !== 2) {\n\t\t\tthrow new GenerateApiError(`map does not have 2 args`, { node, args: node.args });\n\t\t}\n\n\t\tconst mapKey = visitType(node.args[0]);\n\t\tconst mapValue = visitType(node.args[1]);\n\t\tif (!mapKey || !mapValue) {\n\t\t\tthrow new GenerateApiError(`map is missing key or value`, { node, args: node.args, mapKey, mapValue });\n\t\t}\n\t\treturn {\n\t\t\tkind: `map`,\n\t\t\traw: node,\n\t\t\tmap: {\n\t\t\t\tkey: mapKey,\n\t\t\t\tvalue: mapValue,\n\t\t\t\tisBigMap: node.prim === `big_map`,\n\t\t\t},\n\t\t};\n\t}\n\n\t// option\n\tif (node.prim === `option`) {\n\t\treturn {\n\t\t\t...visitType(node.args[0]),\n\t\t\toptional: true,\n\t\t};\n\t}\n\n\t// boolean\n\tif (node.prim === `bool`) {\n\t\treturn {\n\t\t\tkind: `value`,\n\t\t\traw: node,\n\t\t\tvalue: node.prim,\n\t\t\ttypescriptType: `boolean`,\n\t\t};\n\t}\n\n\t// numbers\n\tif (\n\t\tnode.prim === `nat`\n\t\t|| node.prim === `int`\n\t\t|| node.prim === `mutez`\n\t) {\n\t\treturn {\n\t\t\tkind: `value`,\n\t\t\traw: node,\n\t\t\tvalue: node.prim,\n\t\t\ttypescriptType: `number`,\n\t\t};\n\t}\n\n\t// Date\n\tif (node.prim === `timestamp`) {\n\t\treturn {\n\t\t\tkind: `value`,\n\t\t\traw: node,\n\t\t\tvalue: node.prim,\n\t\t\ttypescriptType: `Date`,\n\t\t};\n\t}\n\n\t// strings\n\tif (\n\t\tnode.prim === `address`\n\t\t|| node.prim === `key`\n\t\t|| node.prim === `key_hash`\n\t\t|| node.prim === `chain_id`\n\t\t|| node.prim === `string`\n\t\t|| node.prim === `signature`\n\t\t|| node.prim === `ticket`\n\t\t|| node.prim === `bls12_381_fr`\n\t\t|| node.prim === `bls12_381_g1`\n\t\t|| node.prim === `bls12_381_g2`\n\t\t|| node.prim === `sapling_state`\n\t\t|| node.prim === `sapling_transaction`\n\t\t|| node.prim === `contract`\n\t) {\n\t\treturn {\n\t\t\tkind: `value`,\n\t\t\traw: node,\n\t\t\tvalue: node.prim,\n\t\t\ttypescriptType: `string`,\n\t\t};\n\t}\n\n\t// void\n\tif (node.prim === `unit`) {\n\t\treturn {\n\t\t\tkind: `unit`,\n\t\t\traw: node,\n\t\t};\n\t}\n\n\t// bytes?\n\tif (node.prim === `bytes`) {\n\t\treturn {\n\t\t\tkind: `value`,\n\t\t\traw: node,\n\t\t\tvalue: node.prim,\n\t\t\ttypescriptType: `string`,\n\t\t};\n\t}\n\n\tif (node.prim === `lambda`) {\n\t\tif (node.args.length !== 2) {\n\t\t\tthrow new GenerateApiError(`lambda does not have 2 args`, { node, args: node.args });\n\t\t}\n\n\t\tconst argType = visitType(node.args[0]);\n\t\tconst retType = visitType(node.args[1]);\n\t\tif (!argType || !retType) {\n\t\t\tthrow new GenerateApiError(`lambda is missing arg or return`, { node, args: node.args, argType, retType });\n\t\t}\n\n\t\treturn {\n\t\t\tkind: `lambda`,\n\t\t\traw: node,\n\t\t\tlambda: {\n\t\t\t\targ: argType,\n\t\t\t\tret: retType,\n\t\t\t},\n\t\t};\n\t}\n\n\t// misc?\n\tif (node.prim === `operation`) {\n\t\treturn {\n\t\t\tkind: `value`,\n\t\t\traw: node,\n\t\t\tvalue: node.prim,\n\t\t\ttypescriptType: `string`,\n\t\t};\n\t}\n\n\t// chest\n\tif (node.prim === 'chest' || node.prim === 'chest_key') {\n\t\treturn {\n\t\t\tkind: `value`,\n\t\t\traw: node,\n\t\t\tvalue: node.prim,\n\t\t\ttypescriptType: `string`,\n\t\t};\n\t}\n\n\t// never\n\tif (node.prim === `never`) {\n\t\treturn {\n\t\t\tkind: `never`,\n\t\t\traw: node,\n\t\t};\n\t}\n\n\t// Unknown\n\tassertExhaustive(node, `Unknown type`);\n\tthrow new GenerateApiError(`Unknown type`, { node });\n};\n","import { GenerateApiError } from './common';\nimport { TypedMethod, TypedStorage, TypedType, TypedVar } from './contract-parser';\n\ntype SchemaObjectType = { [name: string]: SchemaType };\ntype SchemaType = string | SchemaType[] | SchemaObjectType;\ntype SchemaMethods = {\n\t[name: string]: {\n\t\tparams: SchemaType;\n\t};\n};\nexport type SchemaOutput = {\n\tmethods: SchemaMethods;\n\tstorage: SchemaType;\n};\n\nexport const toSchema = (methods: TypedMethod[], storage: TypedStorage): SchemaOutput => {\n\tconst getSchemaObjectType = (vars: TypedVar[]) => {\n\t\t// console.log('getSchemaObjectType', { vars });\n\n\t\tif (vars.some(x => !x)) {\n\t\t\tthrow new GenerateApiError(`getSchemaObjectType has null vars`, { vars });\n\t\t}\n\n\t\treturn vars.reduce((out, x, i) => {\n\t\t\tout[x.name ?? i] = getSchemaType(x.type);\n\t\t\treturn out;\n\t\t}, {} as SchemaObjectType);\n\t};\n\n\tconst getSchemaType = (t: TypedType): SchemaType => {\n\t\t// console.log('getSchemaType', { t });\n\n\t\treturn (t.kind === `value` && t.value ? t.value : null)\n\t\t\t?? (t.kind === `array` && t.array ? [getSchemaType(t.array.item)] : null)\n\t\t\t?? (t.kind === `map` && t.map ? [`map`, getSchemaType(t.map.key), getSchemaType(t.map.value)] : null)\n\t\t\t?? (t.kind === `object` && t.fields ? getSchemaObjectType(t.fields) : null)\n\t\t\t?? (t.kind === `unit` ? `unit` : null)\n\t\t\t?? (t.kind === `never` ? `never` : null)\n\t\t\t?? (t.kind === 'lambda' ? ['lambda', getSchemaType(t.lambda.arg), getSchemaType(t.lambda.ret)] : null)\n\t\t\t?? `${t.raw as unknown as string}`;\n\t};\n\n\tconst schemaMethods = methods.reduce((out, x) => {\n\t\t// console.log('schemaMethods', { x });\n\n\t\tout[x.name] = {\n\t\t\tparams: x.args.length === 1 && !x.args[0].name\n\t\t\t\t? getSchemaType(x.args[0].type)\n\t\t\t\t: getSchemaObjectType(x.args ?? []),\n\t\t};\n\t\treturn out;\n\t}, {} as SchemaMethods);\n\n\tconst schemaStorage = getSchemaType(storage.storage);\n\n\treturn {\n\t\tmethods: schemaMethods,\n\t\tstorage: schemaStorage,\n\t};\n};\n","import { assertExhaustive, GenerateApiError, reduceFlatMap } from './common';\nimport { TypedMethod, TypedStorage, TypedType, TypedVar } from './contract-parser';\n\nexport type TypescriptCodeOutput = {\n\ttypesFileContent: string;\n\tcontractCodeFileContent: string;\n\tstorage: string;\n\tmethods: string;\n\tmethodsObject: string;\n};\n\nexport type TypeAliasData = {\n\tmode: 'local';\n\tfileContent?: string;\n} | {\n\tmode: 'file' | 'library';\n\timportPath?: string;\n} | {\n\tmode: 'simple';\n};\n\nexport type TypeUtilsData = {\n\timportPath: string;\n};\n\nexport const createTypescriptCodeGenerator = (options?: { mode?: 'types' | 'defaultValue' }) => {\n\ttype TypeAlias = {\n\t\taliasType: string;\n\t\tsimpleTypeDefinition: string;\n\t\tsimpleTypeImports?: { name: string; isDefault?: boolean; from: string }[];\n\t};\n\tconst usedStrictTypes = [] as TypeAlias[];\n\tconst addTypeAlias = (strictType: TypeAlias) => {\n\t\tif (!usedStrictTypes.some(x => x.aliasType === strictType.aliasType)) {\n\t\t\tusedStrictTypes.push(strictType);\n\t\t}\n\t};\n\n\t// Not really tabs :)\n\tconst tabs = (indent: number) => Array(indent).fill(`    `).join(``);\n\tconst toIndentedItems = (\n\t\tindent: number,\n\t\tdelimiters: { afterItem?: string; beforeItem?: string },\n\t\titems: string[],\n\t) => {\n\t\treturn `\n${tabs(indent + 1)}${\n\t\t\titems.join(`${delimiters.afterItem ?? ``}\n${tabs(indent + 1)}${delimiters.beforeItem ?? ``}`)\n\t\t}\n${tabs(indent)}`;\n\t};\n\n\tconst typeToCode = (t: TypedType, indent: number): string => {\n\t\tif (options?.mode === 'defaultValue') {\n\t\t\treturn typeToCode_defaultValue(t, indent);\n\t\t}\n\n\t\tif (t.kind === `value`) {\n\t\t\t// return `${t.typescriptType}`;\n\n\t\t\tconst prim = `prim` in t.raw ? t.raw.prim : `unknown`;\n\n\t\t\t// Strict mode\n\t\t\tif (\n\t\t\t\tt.typescriptType === `boolean`\n\t\t\t\t|| t.typescriptType === `string` && prim === `string`\n\t\t\t) {\n\t\t\t\treturn `${t.typescriptType}`;\n\t\t\t}\n\n\t\t\tif (t.typescriptType === 'number') {\n\t\t\t\tconst simpleBaseType = `string | BigNumber | number`;\n\t\t\t\tconst typeAlias: TypeAlias = {\n\t\t\t\t\taliasType: prim,\n\t\t\t\t\tsimpleTypeDefinition: `type ${prim} = ${simpleBaseType};`,\n\t\t\t\t\tsimpleTypeImports: [{ name: 'BigNumber', isDefault: true, from: 'bignumber.js' }],\n\t\t\t\t};\n\t\t\t\taddTypeAlias(typeAlias);\n\n\t\t\t\treturn typeAlias.aliasType;\n\t\t\t}\n\n\t\t\tconst simpleBaseType = t.typescriptType === 'Date' ? 'Date | string' : t.typescriptType;\n\t\t\tconst typeAlias: TypeAlias = { aliasType: prim, simpleTypeDefinition: `type ${prim} = ${simpleBaseType};` };\n\t\t\taddTypeAlias(typeAlias);\n\n\t\t\treturn typeAlias.aliasType;\n\t\t}\n\t\tif (t.kind === `array`) {\n\t\t\treturn `Array<${typeToCode(t.array.item, indent)}>`;\n\t\t}\n\t\tif (t.kind === `map`) {\n\t\t\tconst typeAlias: TypeAlias = t.map.isBigMap\n\t\t\t\t? {\n\t\t\t\t\taliasType: `BigMap`,\n\t\t\t\t\tsimpleTypeDefinition: 'type BigMap<K, T> = MichelsonMap<K, T>;',\n\t\t\t\t\tsimpleTypeImports: [{ name: 'MichelsonMap', from: '@taquito/taquito' }],\n\t\t\t\t}\n\t\t\t\t: {\n\t\t\t\t\taliasType: `MMap`,\n\t\t\t\t\tsimpleTypeDefinition: 'type MMap<K, T> = MichelsonMap<K, T>;',\n\t\t\t\t\tsimpleTypeImports: [{ name: 'MichelsonMap', from: '@taquito/taquito' }],\n\t\t\t\t};\n\t\t\taddTypeAlias(typeAlias);\n\n\t\t\treturn `${typeAlias.aliasType}<${typeToCode(t.map.key, indent)}, ${typeToCode(t.map.value, indent)}>`;\n\t\t}\n\t\tif (t.kind === `lambda`) {\n\t\t\tconst typeAlias: TypeAlias = {\n\t\t\t\taliasType: 'Instruction',\n\t\t\t\tsimpleTypeDefinition: `type Instruction = MichelsonInstruction;`,\n\t\t\t\tsimpleTypeImports: [{ name: 'MichelsonInstruction', isDefault: false, from: '@taquito/michel-codec' }],\n\t\t\t};\n\t\t\taddTypeAlias(typeAlias);\n\t\t\treturn `Instruction[]`;\n\t\t}\n\t\tif (t.kind === `object`) {\n\t\t\treturn `{${toIndentedItems(indent, {}, t.fields.map((a, i) => varToCode(a, i, indent + 1) + `;`))}}`;\n\t\t}\n\t\tif (t.kind === `union`) {\n\t\t\tconst getUnionItem = (a: TypedVar, i: number) => {\n\t\t\t\tconst itemCode = `${varToCode(a, i, indent + 1)}`;\n\n\t\t\t\t// Keep on single line if already on single line\n\t\t\t\tif (!itemCode.includes(`\\n`)) {\n\t\t\t\t\treturn `{ ${itemCode} }`;\n\t\t\t\t}\n\n\t\t\t\t// Indent if multi-line (and remake with extra indent)\n\t\t\t\treturn `{${toIndentedItems(indent + 1, {}, [`${varToCode(a, i, indent + 2)}`])}}`;\n\t\t\t};\n\n\t\t\treturn `(${toIndentedItems(indent, { beforeItem: `| ` }, t.union.map(getUnionItem))})`;\n\t\t}\n\t\tif (t.kind === `unit`) {\n\t\t\tconst typeAlias: TypeAlias = {\n\t\t\t\taliasType: `unit`,\n\t\t\t\tsimpleTypeDefinition: `type unit = (true | undefined);`,\n\t\t\t};\n\t\t\taddTypeAlias(typeAlias);\n\t\t\treturn typeAlias.aliasType;\n\t\t}\n\t\tif (t.kind === `never`) {\n\t\t\treturn `never`;\n\t\t}\n\t\tif (t.kind === `unknown`) {\n\t\t\treturn `unknown`;\n\t\t}\n\n\t\tassertExhaustive(t, `Unknown type`);\n\t\tthrow new GenerateApiError(`Unknown type node`, { t });\n\t};\n\n\tconst typeToCode_defaultValue = (t: TypedType, indent: number): string => {\n\t\tif (t.kind === `value`) {\n\t\t\t// return `${t.typescriptType}`;\n\n\t\t\tconst prim = `prim` in t.raw ? t.raw.prim : `unknown`;\n\n\t\t\t// Strict mode\n\t\t\tif (t.typescriptType === 'boolean') {\n\t\t\t\treturn `true`;\n\t\t\t}\n\t\t\tif (t.typescriptType === `string` && prim === `string`) {\n\t\t\t\treturn `'VALUE'`;\n\t\t\t}\n\t\t\tif (t.typescriptType === 'number') {\n\t\t\t\treturn `tas.${prim}('42')`;\n\t\t\t}\n\t\t\tif (t.typescriptType === 'Date') {\n\t\t\t\treturn `tas.timestamp(new Date())`;\n\t\t\t}\n\t\t\tif (\n\t\t\t\tprim === 'address'\n\t\t\t\t|| prim === 'contract'\n\t\t\t) {\n\t\t\t\treturn `tas.${prim}('tz1ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456')`;\n\t\t\t}\n\t\t\tif (prim === 'bytes') {\n\t\t\t\treturn `tas.${prim}(char2Bytes('DATA'))`;\n\t\t\t}\n\t\t\tif (t.typescriptType === 'string') {\n\t\t\t\treturn `tas.${prim}('VALUE')`;\n\t\t\t}\n\t\t\tassertExhaustive(t.typescriptType, `Unknown value type`);\n\n\t\t\treturn prim;\n\t\t}\n\t\tif (t.kind === `array`) {\n\t\t\treturn `[${typeToCode(t.array.item, indent)}]`;\n\t\t}\n\t\tif (t.kind === `map`) {\n\t\t\tconst keyPrim = `prim` in t.map.key.raw ? t.map.key.raw.prim : `unknown`;\n\t\t\tconst isStringBasedKey = t.map.key.kind === 'value' && keyPrim === 'string';\n\t\t\tif (isStringBasedKey) {\n\t\t\t\treturn `tas.${t.map.isBigMap ? 'bigMap' : 'map'}({ \n${tabs(indent + 1)}${typeToCode(t.map.key, indent)}: ${typeToCode(t.map.value, indent)},\n${tabs(indent)}})`;\n\t\t\t}\n\n\t\t\treturn `tas.${t.map.isBigMap ? 'bigMap' : 'map'}([{ \n${tabs(indent + 1)}key: ${typeToCode(t.map.key, indent)}, \n${tabs(indent + 1)}value: ${typeToCode(t.map.value, indent)},\n${tabs(indent)}}])`;\n\t\t}\n\t\tif (t.kind === `object`) {\n\t\t\tconst delimiter = options?.mode === 'defaultValue' ? ',' : `;`;\n\t\t\treturn `{${toIndentedItems(indent, {}, t.fields.map((a, i) => varToCode(a, i, indent + 1) + delimiter))}}`;\n\t\t}\n\t\tif (t.kind === `union`) {\n\t\t\tconst getUnionItem = (a: TypedVar, i: number) => {\n\t\t\t\tconst itemCode = `${varToCode(a, i, indent + 1)}`;\n\n\t\t\t\t// Keep on single line if already on single line\n\t\t\t\tif (!itemCode.includes(`\\n`)) {\n\t\t\t\t\treturn `{ ${itemCode} }`;\n\t\t\t\t}\n\n\t\t\t\t// Indent if multi-line (and remake with extra indent)\n\t\t\t\treturn `{${toIndentedItems(indent + 1, {}, [`${varToCode(a, i, indent + 2)}`])}}`;\n\t\t\t};\n\n\t\t\treturn `(${toIndentedItems(indent, { beforeItem: `| ` }, t.union.map(getUnionItem))})`;\n\t\t}\n\t\tif (t.kind === `unit`) {\n\t\t\treturn `tas.unit()`;\n\t\t}\n\t\tif (t.kind === `never`) {\n\t\t\treturn `never`;\n\t\t}\n\t\tif (t.kind === `unknown`) {\n\t\t\treturn `unknown`;\n\t\t}\n\t\tif (t.kind === 'lambda') {\n\t\t\treturn `tas.lambda([])`;\n\t\t}\n\n\t\tassertExhaustive(t, `Unknown type`);\n\t\tthrow new GenerateApiError(`Unknown type node`, { t });\n\t};\n\n\tconst varToCode = (t: TypedVar, i: number, indent: number, numberVarNamePrefix = ''): string => {\n\t\tlet typeName = typeToCode(t.type, indent);\n\t\tif (t.type.optional) {\n\t\t\ttypeName = `{Some: ${typeName}} | null`;\n\t\t}\n\t\treturn `${t.name ?? `${numberVarNamePrefix}${i}`}: ${typeName}`;\n\t};\n\n\tconst argsToCode = (args: TypedVar[], indent: number, asObject: boolean): string => {\n\t\tif (args.length === 1) {\n\t\t\tif (args[0].type.kind === `unit`) return ``;\n\n\t\t\tif (options?.mode === 'defaultValue') {\n\t\t\t\treturn typeToCode(args[0].type, indent + 1);\n\t\t\t}\n\t\t\treturn `${args[0].name ?? `param`}: ${typeToCode(args[0].type, indent + 1)}`;\n\t\t}\n\n\t\tconst result = `${\n\t\t\ttoIndentedItems(\n\t\t\t\tindent,\n\t\t\t\t{},\n\t\t\t\targs.filter(x => x.name || x.type.kind !== `unit`).map((a, i) => {\n\t\t\t\t\tif (!asObject && options?.mode === 'defaultValue') {\n\t\t\t\t\t\treturn typeToCode(a.type, indent + 1) + `,`;\n\t\t\t\t\t}\n\t\t\t\t\treturn varToCode(a, i, indent + 1, asObject ? '' : '_') + `,`;\n\t\t\t\t}),\n\t\t\t)\n\t\t}`;\n\n\t\tif (asObject) {\n\t\t\tif (options?.mode === 'defaultValue') {\n\t\t\t\treturn `{${result}}`;\n\t\t\t}\n\t\t\treturn `params: {${result}}`;\n\t\t}\n\n\t\treturn result;\n\t};\n\n\treturn {\n\t\tusedStrictTypes,\n\t\ttabs,\n\t\ttoIndentedItems,\n\t\ttypeToCode,\n\t\targsToCode,\n\t};\n};\n\nexport const toTypescriptCode = (\n\tstorage: TypedStorage,\n\tmethods: TypedMethod[],\n\tcontractName: string,\n\tparsedContract: unknown,\n\tprotocol: { name: string; key: string },\n\ttypeAliasData: TypeAliasData,\n\ttypeUtilsData: TypeUtilsData,\n): TypescriptCodeOutput => {\n\tconst {\n\t\tusedStrictTypes,\n\t\ttoIndentedItems,\n\t\ttypeToCode,\n\t\targsToCode,\n\t} = createTypescriptCodeGenerator();\n\n\tconst methodsToCode = (indent: number) => {\n\t\tconst methodFields = methods.map(x => {\n\t\t\tconst methodCode = `${x.name}: (${argsToCode(x.args, indent + 1, false)}) => Promise<void>;`;\n\t\t\treturn methodCode;\n\t\t});\n\n\t\tconst methodsTypeCode = `type Methods = {${toIndentedItems(indent, {}, methodFields)}};`;\n\t\treturn methodsTypeCode;\n\t};\n\tconst methodsObjectToCode = (indent: number) => {\n\t\tconst methodFields = methods.map(x => {\n\t\t\tconst methodCode = `${x.name}: (${argsToCode(x.args, indent + 1, true)}) => Promise<void>;`;\n\t\t\treturn methodCode;\n\t\t});\n\n\t\tconst methodsTypeCode = `type MethodsObject = {${toIndentedItems(indent, {}, methodFields)}};`;\n\t\treturn methodsTypeCode;\n\t};\n\n\tconst storageToCode = (indent: number) => {\n\t\tconst storageTypeCode = `export type Storage = ${typeToCode(storage.storage, indent)};`;\n\t\treturn storageTypeCode;\n\t};\n\n\tconst methodsCode = methodsToCode(0);\n\tconst methodsObjectCode = methodsObjectToCode(0);\n\tconst storageCode = storageToCode(0);\n\n\t// Simple type aliases\n\tconst simpleTypeMappingImportsAll = new Map(\n\t\tusedStrictTypes.map(x => x.simpleTypeImports ?? []).reduce(reduceFlatMap, []).map(\n\t\t\tx => [`${x?.from}:${x?.name}:${x?.isDefault}`, x],\n\t\t),\n\t);\n\tconst simpleTypeMappingImportsFrom = [...simpleTypeMappingImportsAll.values()].reduce((out, x) => {\n\t\tconst entry = out[x.from] ?? (out[x.from] = { names: [] });\n\t\tif (x.isDefault) {\n\t\t\tentry.default = x.name;\n\t\t} else {\n\t\t\tentry.names.push(x.name);\n\t\t}\n\t\tentry.names.sort((a, b) => a.localeCompare(b));\n\t\treturn out;\n\t}, {} as { [from: string]: { names: string[]; default?: string } });\n\n\tconst simpleTypeMappingImportsText = Object.keys(simpleTypeMappingImportsFrom)\n\t\t.map(k => {\n\t\t\tconst entry = simpleTypeMappingImportsFrom[k];\n\t\t\tconst items = [entry.default, entry.names.length ? `{ ${entry.names.join(', ')} }` : ''].filter(x => x);\n\t\t\treturn `import ${items.join(', ')} from '${k}';\\n`;\n\t\t})\n\t\t.join('');\n\n\tconst simpleTypeMapping = usedStrictTypes\n\t\t.sort((a, b) => a.aliasType.localeCompare(b.aliasType))\n\t\t.map(x => x.simpleTypeDefinition).join(`\\n`);\n\n\tconst typeUtilsDefinitions =\n\t\t`import { ContractAbstractionFromContractType, WalletContractAbstractionFromContractType } from '${typeUtilsData.importPath}';`;\n\n\tconst typeAliasesDefinitions = typeAliasData.mode === 'simple'\n\t\t? `${simpleTypeMappingImportsText}${simpleTypeMapping}`\n\t\t: typeAliasData.mode === 'local'\n\t\t? typeAliasData.fileContent\n\t\t: `import { ${usedStrictTypes.map(x => x.aliasType).join(`, `)} } from '${typeAliasData.importPath}';`;\n\n\tconst contractTypeName = `${contractName}ContractType`;\n\tconst walletTypeName = `${contractName}WalletType`;\n\tconst codeName = `${contractName}Code`;\n\n\tconst typesFileContent = `\n${typeUtilsDefinitions}\n${typeAliasesDefinitions}\n\n${storageCode}\n\n${methodsCode}\n\n${methodsObjectCode}\n\ntype contractTypes = { methods: Methods, methodsObject: MethodsObject, storage: Storage, code: { __type: '${codeName}', protocol: string, code: object[] } };\nexport type ${contractTypeName} = ContractAbstractionFromContractType<contractTypes>;\nexport type ${walletTypeName} = WalletContractAbstractionFromContractType<contractTypes>;\n`;\n\n\tconst contractCodeFileContent = `\nexport const ${codeName}: { __type: '${codeName}', protocol: string, code: object[] } = {\n    __type: '${codeName}',\n    protocol: '${protocol.key}',\n    code: JSON.parse(\\`${JSON.stringify(parsedContract)}\\`)\n};\n`;\n\treturn {\n\t\ttypesFileContent,\n\t\tcontractCodeFileContent,\n\t\tstorage: storageCode,\n\t\tmethods: methodsCode,\n\t\tmethodsObject: methodsObjectCode,\n\t};\n};\n","// This is required for copying the type aliases to a local file\nexport const typeAliasesFileContent = `\nimport { assertMichelsonInstruction, Expr, MichelsonCode } from '@taquito/michel-codec';\nimport { MichelsonMap } from '@taquito/taquito';\nimport { BigNumber } from 'bignumber.js';\n\nexport type Instruction = MichelsonCode;\n\nexport type unit = (true | undefined) & { __type: 'unit' };\n\nexport type address = string & { __type: 'address' };\nexport type bytes = string & { __type: 'bytes' };\nexport type contract = string & { __type: 'contract' };\nexport type operation = string & { __type: 'operation' };\nexport type key = string & { __type: 'key' };\nexport type key_hash = string & { __type: 'key_hash' };\nexport type signature = string & { __type: 'signature' };\nexport type ticket = string & { __type: 'ticket' };\n\nexport type timestamp = string & { __type: 'timestamp' };\n\nexport type int = BigNumber & { __type: 'int' };\nexport type nat = BigNumber & { __type: 'nat' };\n\nexport type mutez = BigNumber & { __type: 'mutez' };\nexport type tez = BigNumber & { __type: 'tez' };\n\ntype MapKey = Array<any> | object | string | boolean | number;\nexport type MMap<K extends MapKey, V> = Omit<MichelsonMap<K, V>, 'get'> & { get: (key: K) => V };\nexport type BigMap<K extends MapKey, V> = Omit<MichelsonMap<K, V>, 'get'> & { get: (key: K) => Promise<V> };\n\nexport type chest = string & { __type: 'chest' };\nexport type chest_key = string & { __type: 'chest_key' };\n\nconst createStringTypeTas = <T extends string>() => {\n\treturn (value: string): T => value as T;\n};\n\nconst createBigNumberTypeTas = <T extends BigNumber>() => {\n\treturn (value: number | BigNumber | string): T => new BigNumber(value) as T;\n};\n\ntype asMapParamOf<K, V> = K extends string ? { [key: string]: V } | Array<{ key: K; value: V }>\n\t: K extends number ? { [key: number]: V } | Array<{ key: K; value: V }>\n\t: Array<{ key: K; value: V }>;\n\nfunction asMap<K extends MapKey, V>(value: asMapParamOf<K, V>): MMap<K, V> {\n\tconst m = new MichelsonMap<K, V>();\n\tif (Array.isArray(value)) {\n\t\tconst vArray = value as Array<{ key: K; value: V }>;\n\t\tvArray.forEach(x => m.set(x.key, x.value));\n\t} else {\n\t\tconst vObject = value as { [key: string]: V };\n\t\tObject.keys(vObject).forEach(key => m.set(key as unknown as K, vObject[key]));\n\t}\n\treturn m as MMap<K, V>;\n}\nconst asBigMap = <K extends MapKey, V>(value: asMapParamOf<K, V>) => asMap(value) as unknown as BigMap<K, V>;\n\nfunction add<T extends BigNumber>(a: T, b: T): T {\n\treturn a.plus(b) as T;\n}\nfunction subtract<T extends BigNumber>(a: T, b: T): T {\n\treturn a.minus(b) as T;\n}\n\nfunction createLambdaTypeTas(expr: Expr): MichelsonCode {\n\tassertMichelsonInstruction(expr);\n    return expr as MichelsonCode;\n}\n\n/** tas: Tezos 'as' casting for strict types */\nexport const tas = {\n\taddress: createStringTypeTas<address>(),\n\tbytes: createStringTypeTas<bytes>(),\n\tcontract: createStringTypeTas<contract>(),\n\tchest: createStringTypeTas<chest>(),\n\tchest_key: createStringTypeTas<chest_key>(),\n\ttimestamp: (value: string | Date): timestamp => new Date(value).toISOString() as timestamp,\n\n\tint: createBigNumberTypeTas<int>(),\n\tnat: createBigNumberTypeTas<nat>(),\n\tmutez: createBigNumberTypeTas<mutez>(),\n\ttez: createBigNumberTypeTas<tez>(),\n\n\tmap: asMap,\n\tbigMap: asBigMap,\n\n\t// Operations\n\tadd,\n\tsubtract,\n\n    lambda: createLambdaTypeTas,\n\n\t// To number\n\tnumber: (value: string | BigNumber) => Number(value + ''),\n\tunit: () => true as unit,\n};\n`;\n","// This is required for copying the type utils to a local file\nexport const typeUtilsFileContent = `\nimport { ContractAbstraction, ContractMethod, ContractMethodObject, ContractProvider, Wallet } from '@taquito/taquito';\n\ntype BaseContractType = { methods: unknown, methodsObject: unknown, storage: unknown };\n\ntype ContractMethodsOf<T extends ContractProvider | Wallet, TContract extends BaseContractType> = {\n[M in keyof TContract['methods']]:\nTContract['methods'][M] extends (...args: infer A) => unknown\n? (...args: A) => ContractMethod<T>\n: never\n};\ntype ContractMethodsObjectsOf<T extends ContractProvider | Wallet, TContract extends BaseContractType> = {\n[M in keyof TContract['methodsObject']]:\nTContract['methodsObject'][M] extends (...args: infer A) => unknown\n? (...args: A) => ContractMethodObject<T>\n: never\n};\ntype ContractStorageOf<TContract extends BaseContractType> = TContract['storage'];\n\nexport type ContractAbstractionFromContractType<TContract extends BaseContractType> = \n    ContractAbstraction<ContractProvider, \n        ContractMethodsOf<ContractProvider, TContract>,\n        ContractMethodsObjectsOf<ContractProvider, TContract>,\n        {},\n        {},\n        ContractStorageOf<TContract>\n    >;\n\nexport type WalletContractAbstractionFromContractType<TContract extends BaseContractType> = \n    ContractAbstraction<Wallet, \n        ContractMethodsOf<Wallet, TContract>,\n        ContractMethodsObjectsOf<Wallet, TContract>,\n        {},\n        {},\n        ContractStorageOf<TContract>\n    >;\n`;\n"],"mappings":"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","names":["import_node_sdk","import_path","simpleBaseType","typeAlias","fsRaw","path","glob"]}