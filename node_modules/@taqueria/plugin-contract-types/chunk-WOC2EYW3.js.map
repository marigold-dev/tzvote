{"version":3,"sources":["src/cli-process.ts","src/type-aliases-file-content.ts","src/type-utils-file-content.ts"],"sourcesContent":["import fsRaw from 'fs';\nimport path from 'path';\nimport { promisify } from 'util';\nimport { normalizeContractName } from './generator/contract-name';\nimport { generateContractTypesFromMichelsonCode } from './generator/process';\nimport { TypeAliasData, TypeUtilsData } from './generator/typescript-output';\nimport { typeAliasesFileContent } from './type-aliases-file-content';\nimport { typeUtilsFileContent } from './type-utils-file-content';\n\nconst fs = {\n\tmkdir: promisify(fsRaw.mkdir),\n\tcopyFile: promisify(fsRaw.copyFile),\n\treaddir: promisify(fsRaw.readdir),\n\treadFile: promisify(fsRaw.readFile),\n\twriteFile: promisify(fsRaw.writeFile),\n\tstat: promisify(fsRaw.stat),\n\texists: fsRaw.existsSync,\n};\n\nconst getAllFiles = async (rootPath: string, filter: (fullPath: string) => boolean): Promise<string[]> => {\n\tconst allFiles = [] as string[];\n\n\tconst getAllFilesRecursive = async (dirPath: string) => {\n\t\tlet files = await fs.readdir(dirPath, { withFileTypes: true });\n\n\t\tfor (const f of files) {\n\t\t\tconst subPath = path.resolve(dirPath, f.name);\n\n\t\t\tif (f.isDirectory()) {\n\t\t\t\tawait getAllFilesRecursive(subPath);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!filter(subPath)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tallFiles.push(subPath);\n\t\t}\n\t};\n\n\tawait getAllFilesRecursive(rootPath);\n\treturn allFiles;\n};\n\nexport const generateContractTypesProcessContractFiles = async ({\n\tinputTzContractDirectory,\n\tinputFiles,\n\toutputTypescriptDirectory,\n\tformat,\n\ttypeAliasMode,\n}: {\n\tinputTzContractDirectory: string;\n\tinputFiles?: string[];\n\toutputTypescriptDirectory: string;\n\tformat: 'tz' | 'json';\n\ttypeAliasMode: 'local' | 'file' | 'library' | 'simple';\n}): Promise<void> => {\n\tconsole.log(\n\t\t`Generating Types: ${path.resolve(inputTzContractDirectory)} => ${path.resolve(outputTypescriptDirectory)}`,\n\t);\n\n\tconst ext = '.' + format;\n\tconst filesAll = await getAllFiles(inputTzContractDirectory, x => x.endsWith(ext));\n\tconst files = inputFiles ? filesAll.filter(f => inputFiles.some(inputFile => f.endsWith(inputFile))) : filesAll;\n\n\tconsole.log(`Contracts Found: ${[``, ...files].join(`\\n\\t- `)}`);\n\n\tconst typeAliasImportPath = `@taquito/contract-type-generator`;\n\n\tconst typeAliasData: TypeAliasData = typeAliasMode === 'local'\n\t\t? { mode: typeAliasMode, fileContent: typeAliasesFileContent }\n\t\t: typeAliasMode === 'file'\n\t\t? { mode: typeAliasMode, importPath: `./type-aliases` }\n\t\t: typeAliasMode === 'library'\n\t\t? { mode: typeAliasMode, importPath: typeAliasImportPath }\n\t\t: { mode: 'simple' };\n\n\tif (typeAliasMode === 'file') {\n\t\t// Copy the type alias file\n\t\tawait fs.mkdir(outputTypescriptDirectory, { recursive: true });\n\t\tawait fs.writeFile(path.join(outputTypescriptDirectory, './type-aliases.ts'), typeAliasesFileContent);\n\t}\n\n\t// Copy the type utils file\n\tconst typeUtilsData: TypeUtilsData = { importPath: `./type-utils` };\n\tawait fs.mkdir(outputTypescriptDirectory, { recursive: true });\n\tawait fs.writeFile(path.join(outputTypescriptDirectory, './type-utils.ts'), typeUtilsFileContent);\n\n\tfor (const fullPath of files) {\n\t\tconst fileRelativePath = fullPath.replace(path.resolve(inputTzContractDirectory), '');\n\t\tconst fileName = fileRelativePath.replace(ext, '');\n\t\tconst inputFilePath = path.join(inputTzContractDirectory, fileRelativePath);\n\t\tconst typesOutputFilePath = path.join(outputTypescriptDirectory, fileRelativePath.replace(ext, `.types.ts`));\n\t\tconst codeContentOutputFilePath = path.join(outputTypescriptDirectory, fileRelativePath.replace(ext, `.code.ts`));\n\t\tconst schemaContentOutputFilePath = path.join(\n\t\t\toutputTypescriptDirectory,\n\t\t\tfileRelativePath.replace(ext, `.schema.json`),\n\t\t);\n\t\tconsole.log(`Processing ${fileRelativePath}...`);\n\n\t\ttry {\n\t\t\tconst contractTypeName = normalizeContractName(fileName);\n\n\t\t\tconst michelsonCode = await fs.readFile(inputFilePath, { encoding: `utf8` });\n\n\t\t\tconst {\n\t\t\t\tschemaOutput,\n\t\t\t\ttypescriptCodeOutput: { typesFileContent: typesFileContentRaw, contractCodeFileContent },\n\t\t\t} = generateContractTypesFromMichelsonCode(michelsonCode, contractTypeName, format, typeAliasData, typeUtilsData);\n\n\t\t\t// Correct relative paths for nested contracts\n\t\t\tconst nestedDirDepth = fileRelativePath.replace(/^.?\\/?/, '').split('/').length - 1;\n\t\t\tconst typesFileContent = nestedDirDepth <= 0\n\t\t\t\t? typesFileContentRaw\n\t\t\t\t: typesFileContentRaw.replace(\n\t\t\t\t\t/from '\\.\\//g,\n\t\t\t\t\t`from '${[...new Array(nestedDirDepth)].map(() => '../').join('')}`,\n\t\t\t\t);\n\n\t\t\t// Write output (ensure dir exists)\n\t\t\tawait fs.mkdir(path.dirname(typesOutputFilePath), { recursive: true });\n\t\t\tawait fs.writeFile(typesOutputFilePath, typesFileContent);\n\t\t\tawait fs.writeFile(codeContentOutputFilePath, contractCodeFileContent);\n\n\t\t\tconst debugSchema = false;\n\t\t\tif (debugSchema) {\n\t\t\t\tawait fs.writeFile(schemaContentOutputFilePath, JSON.stringify(schemaOutput, null, 2));\n\t\t\t}\n\t\t} catch (err: unknown) {\n\t\t\tconsole.error(`‚ùå Could not process ${fileRelativePath}`, { err });\n\t\t}\n\t}\n};\n","// This is required for copying the type aliases to a local file\nexport const typeAliasesFileContent = `\nimport { assertMichelsonInstruction, Expr, MichelsonCode } from '@taquito/michel-codec';\nimport { MichelsonMap } from '@taquito/taquito';\nimport { BigNumber } from 'bignumber.js';\n\nexport type Instruction = MichelsonCode;\n\nexport type unit = (true | undefined) & { __type: 'unit' };\n\nexport type address = string & { __type: 'address' };\nexport type bytes = string & { __type: 'bytes' };\nexport type contract = string & { __type: 'contract' };\nexport type operation = string & { __type: 'operation' };\nexport type key = string & { __type: 'key' };\nexport type key_hash = string & { __type: 'key_hash' };\nexport type signature = string & { __type: 'signature' };\nexport type ticket = string & { __type: 'ticket' };\n\nexport type timestamp = string & { __type: 'timestamp' };\n\nexport type int = BigNumber & { __type: 'int' };\nexport type nat = BigNumber & { __type: 'nat' };\n\nexport type mutez = BigNumber & { __type: 'mutez' };\nexport type tez = BigNumber & { __type: 'tez' };\n\ntype MapKey = Array<any> | object | string | boolean | number;\nexport type MMap<K extends MapKey, V> = Omit<MichelsonMap<K, V>, 'get'> & { get: (key: K) => V };\nexport type BigMap<K extends MapKey, V> = Omit<MichelsonMap<K, V>, 'get'> & { get: (key: K) => Promise<V> };\n\nexport type chest = string & { __type: 'chest' };\nexport type chest_key = string & { __type: 'chest_key' };\n\nconst createStringTypeTas = <T extends string>() => {\n\treturn (value: string): T => value as T;\n};\n\nconst createBigNumberTypeTas = <T extends BigNumber>() => {\n\treturn (value: number | BigNumber | string): T => new BigNumber(value) as T;\n};\n\ntype asMapParamOf<K, V> = K extends string ? { [key: string]: V } | Array<{ key: K; value: V }>\n\t: K extends number ? { [key: number]: V } | Array<{ key: K; value: V }>\n\t: Array<{ key: K; value: V }>;\n\nfunction asMap<K extends MapKey, V>(value: asMapParamOf<K, V>): MMap<K, V> {\n\tconst m = new MichelsonMap<K, V>();\n\tif (Array.isArray(value)) {\n\t\tconst vArray = value as Array<{ key: K; value: V }>;\n\t\tvArray.forEach(x => m.set(x.key, x.value));\n\t} else {\n\t\tconst vObject = value as { [key: string]: V };\n\t\tObject.keys(vObject).forEach(key => m.set(key as unknown as K, vObject[key]));\n\t}\n\treturn m as MMap<K, V>;\n}\nconst asBigMap = <K extends MapKey, V>(value: asMapParamOf<K, V>) => asMap(value) as unknown as BigMap<K, V>;\n\nfunction add<T extends BigNumber>(a: T, b: T): T {\n\treturn a.plus(b) as T;\n}\nfunction subtract<T extends BigNumber>(a: T, b: T): T {\n\treturn a.minus(b) as T;\n}\n\nfunction createLambdaTypeTas(expr: Expr): MichelsonCode {\n\tassertMichelsonInstruction(expr);\n    return expr as MichelsonCode;\n}\n\n/** tas: Tezos 'as' casting for strict types */\nexport const tas = {\n\taddress: createStringTypeTas<address>(),\n\tbytes: createStringTypeTas<bytes>(),\n\tcontract: createStringTypeTas<contract>(),\n\tchest: createStringTypeTas<chest>(),\n\tchest_key: createStringTypeTas<chest_key>(),\n\ttimestamp: (value: string | Date): timestamp => new Date(value).toISOString() as timestamp,\n\n\tint: createBigNumberTypeTas<int>(),\n\tnat: createBigNumberTypeTas<nat>(),\n\tmutez: createBigNumberTypeTas<mutez>(),\n\ttez: createBigNumberTypeTas<tez>(),\n\n\tmap: asMap,\n\tbigMap: asBigMap,\n\n\t// Operations\n\tadd,\n\tsubtract,\n\n    lambda: createLambdaTypeTas,\n\n\t// To number\n\tnumber: (value: string | BigNumber) => Number(value + ''),\n\tunit: () => true as unit,\n};\n`;\n","// This is required for copying the type utils to a local file\nexport const typeUtilsFileContent = `\nimport { ContractAbstraction, ContractMethod, ContractMethodObject, ContractProvider, Wallet } from '@taquito/taquito';\n\ntype BaseContractType = { methods: unknown, methodsObject: unknown, storage: unknown };\n\ntype ContractMethodsOf<T extends ContractProvider | Wallet, TContract extends BaseContractType> = {\n[M in keyof TContract['methods']]:\nTContract['methods'][M] extends (...args: infer A) => unknown\n? (...args: A) => ContractMethod<T>\n: never\n};\ntype ContractMethodsObjectsOf<T extends ContractProvider | Wallet, TContract extends BaseContractType> = {\n[M in keyof TContract['methodsObject']]:\nTContract['methodsObject'][M] extends (...args: infer A) => unknown\n? (...args: A) => ContractMethodObject<T>\n: never\n};\ntype ContractStorageOf<TContract extends BaseContractType> = TContract['storage'];\n\nexport type ContractAbstractionFromContractType<TContract extends BaseContractType> = \n    ContractAbstraction<ContractProvider, \n        ContractMethodsOf<ContractProvider, TContract>,\n        ContractMethodsObjectsOf<ContractProvider, TContract>,\n        {},\n        {},\n        ContractStorageOf<TContract>\n    >;\n\nexport type WalletContractAbstractionFromContractType<TContract extends BaseContractType> = \n    ContractAbstraction<Wallet, \n        ContractMethodsOf<Wallet, TContract>,\n        ContractMethodsObjectsOf<Wallet, TContract>,\n        {},\n        {},\n        ContractStorageOf<TContract>\n    >;\n`;\n"],"mappings":"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","names":[]}