import * as M from '@taquito/michel-codec';

declare const normalizeContractName: (text: string) => string;

type TypedStorage = {
    storage: TypedType;
};
type TypedMethod = {
    name: string;
    args: TypedVar[];
};
type TypedVar = {
    name?: string;
    type: TypedType;
};
type TypedType = {
    raw: M.MichelsonType;
    optional?: boolean;
} & ({
    kind: 'unit';
} | {
    kind: 'never';
} | {
    kind: 'unknown';
} | {
    kind: 'value';
    value: string;
    typescriptType: 'string' | 'boolean' | 'number' | 'Date';
} | {
    kind: 'union';
    union: TypedVar[];
} | {
    kind: 'object';
    fields: TypedVar[];
} | {
    kind: 'array';
    array: {
        item: TypedType;
    };
} | {
    kind: 'map';
    map: {
        key: TypedType;
        value: TypedType;
        isBigMap: boolean;
    };
} | {
    kind: 'lambda';
    lambda: {
        arg: TypedType;
        ret: TypedType;
    };
});

type CodeGenerationFormatting = {
    indent?: number;
    useSemicolons?: boolean;
};
declare const createTestingCodeGenerator: ({ contractSource, contractFormat, }: {
    contractSource: string;
    contractFormat: 'tz' | 'json';
}) => {
    storage: TypedStorage;
    methods: TypedMethod[];
    generateOrigination: ({ contractVarName, formatting, }: {
        contractVarName?: string | undefined;
        formatting?: CodeGenerationFormatting | undefined;
    }) => {
        code: string;
    };
    generateMethodCall: ({ methodName, formatting, }: {
        methodName: string;
        formatting?: CodeGenerationFormatting | undefined;
    }) => {
        code: string;
    };
    generateStorageAccess: ({ storagePath, }: {
        storagePath: string;
    }) => {
        getStorageValueFunctionCode: string;
        getStorageValueFunctionName: string;
    };
};

export { createTestingCodeGenerator, normalizeContractName };
