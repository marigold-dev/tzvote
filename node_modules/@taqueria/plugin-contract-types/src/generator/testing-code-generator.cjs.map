{"version":3,"sources":["testing-code-generator.ts","contract-name.ts","process.ts","common.ts","contract-parser.ts","typescript-output.ts"],"sourcesContent":["export { normalizeContractName } from './contract-name';\nimport { TypedMethod, TypedStorage } from './contract-parser';\nimport { parseContractInterface } from './process';\nimport { createTypescriptCodeGenerator } from './typescript-output';\n\ntype CodeGenerationFormatting = {\n\tindent?: number;\n\tuseSemicolons?: boolean;\n};\n\n// export type ContractTestingCodeGeneratorFactory = {\n//     /** Load the contract from it's .tz file */\n//     load: (contractTzPath: string) => ContractTestingCodeGenerator;\n// }\n// export type ContractTestingCodeGenerator = {\n\n//     /** Generate the required imports for the tests, like the contract types or type alias utilities */\n//     generateImports: () => string;\n\n//     /** Generate the code to setup the tezos toolkit, originate a contract (providing the default storage), wait for confirmation, and set the contract instance variable */\n//     generateOrigination: (args: {\n//         contractVarName?: string;\n//         formatting?: CodeGenerationFormatting;\n//     }) => { code: string };\n\n//     /** Generate the code to use the contract instance to call an endpoint (providing the default params) and wait for confirmation */\n//     generateMethodCall: (args: {\n//         methodName: string;\n//         formatting?: CodeGenerationFormatting;\n//     }) => { code: string };\n\n//     /** Generate the code to use the contract instance to get the storage value and set it to a variable */\n//     generateReadStorageValue: (actualVarName: 'actualResult' | string) => string;\n// }\n\ntype TypescriptCodeGenerator = ReturnType<typeof createTypescriptCodeGenerator>;\ntype TypedContract = {\n\tstorage: TypedStorage;\n\tmethods: TypedMethod[];\n};\n\nexport const createTestingCodeGenerator = ({\n\tcontractSource,\n\tcontractFormat,\n}: {\n\tcontractSource: string;\n\tcontractFormat: 'tz' | 'json';\n}) => {\n\tconst {\n\t\tstorage,\n\t\tmethods,\n\t} = parseContractInterface(contractSource, contractFormat);\n\n\tconst codeGenerator = createTypescriptCodeGenerator({ mode: 'defaultValue' });\n\n\tconst getMethodByName = (methodName: string) => {\n\t\tconst method = methods.find(x => x.name === methodName);\n\t\tif (!method) {\n\t\t\tthrow new Error(`Failed to fine method: ${methodName}`);\n\t\t}\n\t\treturn method;\n\t};\n\n\treturn {\n\t\tstorage,\n\t\tmethods,\n\t\tgenerateOrigination: ({\n\t\t\tcontractVarName,\n\t\t\tformatting,\n\t\t}: {\n\t\t\tcontractVarName?: string;\n\t\t\tformatting?: CodeGenerationFormatting;\n\t\t}) =>\n\t\t\tgenerateOrigination({\n\t\t\t\tcodeGenerator,\n\t\t\t\tstorage,\n\t\t\t\tindent: formatting?.indent,\n\t\t\t}),\n\t\tgenerateMethodCall: ({\n\t\t\tmethodName,\n\t\t\tformatting,\n\t\t}: {\n\t\t\tmethodName: string;\n\t\t\tformatting?: CodeGenerationFormatting;\n\t\t}) =>\n\t\t\tgenerateMethodCall({\n\t\t\t\tcodeGenerator,\n\t\t\t\tmethod: getMethodByName(methodName),\n\t\t\t\tindent: formatting?.indent,\n\t\t\t}),\n\t\tgenerateStorageAccess: ({\n\t\t\tstoragePath,\n\t\t}: {\n\t\t\tstoragePath: string;\n\t\t}) =>\n\t\t\tgenerateStorageAccess({\n\t\t\t\tcodeGenerator,\n\t\t\t\tstoragePath,\n\t\t\t}),\n\t};\n};\n\n/*\n    const Tezos = new TezosToolkit('RPC_URL');\n    let contract: ContractType = undefined as unknown as ContractType;\n    beforeAll(async () => {\n            // Originate contract\n            const origination = await Tezos.contract.originate<ContractType>({\n                    code: ContractCode.code,\n                    storage: tas.int(0),\n            });\n            const newContractResult = await origination.contract();\n            const newContractAddress = newContractResult.address;\n            contract = await Tezos.contract.at<ContractType>(newContractAddress);\n    });\n*/\nconst generateOrigination = ({\n\tcodeGenerator,\n\tstorage,\n\tindent = 2,\n\tuseSemicolons = true,\n\tcontractVarName = 'contract',\n\tminConfirmations = 3,\n}: {\n\tcodeGenerator: TypescriptCodeGenerator;\n\tstorage: TypedStorage;\n\tindent?: number;\n\tuseSemicolons?: boolean;\n\tcontractVarName?: string;\n\tminConfirmations?: number;\n}) => {\n\tconst {\n\t\ttabs,\n\t\targsToCode,\n\t} = codeGenerator;\n\n\tconst semi = useSemicolons ? ';' : '';\n\n\tconst code = `\n${tabs(indent)}const newContractOrigination = await Tezos.contract.originate<ContractType>({\n${tabs(indent + 1)}code: ContractCode.code,\n${tabs(indent + 1)}storage: ${argsToCode([{ type: storage.storage }], indent + 1, true)},\n${tabs(indent)}})${semi}\n${tabs(indent)}const newContractResult = await newContractOrigination.contract()${semi}\n${tabs(indent)}const newContractAddress = newContractResult.address${semi}\n${tabs(indent)}${contractVarName} = await Tezos.contract.at<ContractType>(newContractAddress)${semi}\n${tabs(indent)}`;\n\n\treturn {\n\t\tcode,\n\t};\n};\n\n/*\n    // methodsObject\n    contract.methodsObject.bid(tas.nat(0));\n    contract.methodsObject.configure({\n        asset: [{\n            fa2_address: tas.address(`tz123`),\n            fa2_batch: [{\n                amount: tas.nat(100),\n                token_id: tas.nat(`100000000000000`),\n            }],\n        }],\n        start_time: tas.timestamp(new Date()),\n        end_time: tas.timestamp(`2020-01-01`),\n        extend_time: tas.nat(10),\n        min_raise: tas.mutez(10),\n        min_raise_percent: tas.nat(10),\n        opening_price: tas.mutez(10),\n        round_time: tas.nat(10),\n    });\n\n    await (await contract.methods.bid(auctionId).send({\n        mutez: true,\n\n        // Not strictly typed yet\n        // amount: tas.add(current_bid, tas.mutez(1000)),\n        amount: tas.number(tas.add(current_bid, tas.mutez(1000))),\n    })).confirmation(100);\n*/\nconst generateMethodCall = ({\n\tcodeGenerator,\n\tmethod,\n\tindent = 2,\n\tuseSemicolons = true,\n\tcontractVarName = 'contract',\n\tminConfirmations = 3,\n}: {\n\tcodeGenerator: TypescriptCodeGenerator;\n\tmethod: TypedMethod;\n\tindent?: number;\n\tuseSemicolons?: boolean;\n\tcontractVarName?: string;\n\tminConfirmations?: number;\n}) => {\n\tconst {\n\t\ttabs,\n\t\targsToCode,\n\t} = codeGenerator;\n\n\tconst semi = useSemicolons ? ';' : '';\n\n\tconst code = `\n${tabs(indent)}const ${method.name}Request = await ${contractVarName}.methodsObject.${method.name}(${\n\t\targsToCode(method.args, indent + 1, true)\n\t}).send()${semi}\n${tabs(indent)}await ${method.name}Request.confirmation(${minConfirmations})${semi}\n${tabs(indent)}`;\n\n\treturn {\n\t\tcode,\n\t};\n};\n\n/*\n    const getAuctionInfo = async (id: nat) => {\n        const storage = await contract.storage();\n\n        const auctions = storage.auctions;\n        const auction = await auctions.get(id);\n        if (!auction) {\n            throw new Error(`Auction is missing`);\n        }\n        return auction;\n    };\n*/\nconst generateStorageAccess = ({\n\tcodeGenerator,\n\tstoragePath,\n\tindent = 2,\n\tuseSemicolons = true,\n\tcontractVarName = 'contract',\n\tgetStorageValueFunctionName,\n\tstorageVarName = 'storage',\n\tstorageValueVarName = 'value',\n}: {\n\tcodeGenerator: TypescriptCodeGenerator;\n\t/**\n\t * i.e.\n\t * - auctions[id]\n\t * - auctions[id].highest_bidder\n\t * - token_metadata[tokenId]\n\t * - token_metadata[tokenId].token_info['']\n\t */\n\tstoragePath: string;\n\tindent?: number;\n\tuseSemicolons?: boolean;\n\tcontractVarName?: string;\n\tgetStorageValueFunctionName?: string;\n\tstorageVarName?: string;\n\tstorageValueVarName?: string;\n}) => {\n\tconst {\n\t\ttabs,\n\t\targsToCode,\n\t} = codeGenerator;\n\n\tconst semi = useSemicolons ? ';' : '';\n\tconst funcName = getStorageValueFunctionName ?? `getStorageValue${\n\t\tstoragePath\n\t\t\t.split('.')\n\t\t\t.map(x => x.replace(/[^A-Za-z0-9]/g, ''))\n\t\t\t.map(x => `${x.substring(0, 1).toLocaleUpperCase()}${x.substring(1)}`)\n\t\t\t.join('')\n\t}`;\n\n\tconst getStorageValueExpr = `${storageVarName}`;\n\n\tconst funcCode = `\n${tabs(indent)}const ${funcName} = async () => {\n${tabs(indent + 1)}const ${storageVarName} = await ${contractVarName}.storage()${semi}\n${tabs(indent + 1)}const ${storageValueVarName} = ${getStorageValueExpr}${semi}\n${tabs(indent + 1)}return ${storageValueVarName}${semi}\n${tabs(indent)}}${semi}\n`;\n\n\treturn {\n\t\tgetStorageValueFunctionCode: funcCode,\n\t\tgetStorageValueFunctionName: funcName,\n\t};\n};\n","export const normalizeContractName = (text: string) =>\n\ttext\n\t\t.replace(/[^A-Za-z0-9]/g, '_')\n\t\t.split('_')\n\t\t.filter(x => x)\n\t\t.map(x => x[0].toUpperCase() + x.substring(1))\n\t\t.join('');\n","import * as M from '@taquito/michel-codec';\nimport { GenerateApiError } from './common';\nimport { parseContractParameter, parseContractStorage } from './contract-parser';\nimport { SchemaOutput, toSchema } from './schema-output';\nimport { toTypescriptCode, TypeAliasData, TypescriptCodeOutput, TypeUtilsData } from './typescript-output';\n\nconst parseContractWithMinimalProtocolLevel = (\n\tcontractScript: string,\n\tformat: 'tz' | 'json',\n\tcontractLevelIndex: number,\n): { contract: M.MichelsonContract; protocol: { name: string; key: string } } => {\n\tconst contractLevels = [\n\t\t{ name: 'PsDELPH1', key: M.Protocol.PsDELPH1 },\n\t\t{ name: 'PtEdo2Zk', key: M.Protocol.PtEdo2Zk },\n\t\t{ name: 'PsFLorena', key: M.Protocol.PsFLorena },\n\t];\n\n\tconst protocol = contractLevels[contractLevelIndex];\n\tif (!protocol) {\n\t\tthrow new GenerateApiError(`Could not parse contract script`, contractScript);\n\t}\n\n\tconst p = new M.Parser({ protocol: protocol.key });\n\n\ttry {\n\t\tconst contract = (\n\t\t\tformat === 'tz'\n\t\t\t\t? p.parseScript(contractScript)\n\t\t\t\t: p.parseJSON(JSON.parse(contractScript))\n\t\t) as M.MichelsonContract;\n\t\tif (contract) {\n\t\t\treturn {\n\t\t\t\tcontract,\n\t\t\t\tprotocol,\n\t\t\t};\n\t\t}\n\t} catch {\n\t\t// Ignore parse errors\n\t}\n\n\t// Try again with next level\n\treturn parseContractWithMinimalProtocolLevel(contractScript, format, contractLevelIndex + 1);\n};\n\nexport const parseContractInterface = (\n\tcontractScript: string,\n\tformat: 'tz' | 'json',\n) => {\n\tconst p = new M.Parser({ protocol: M.Protocol.PsFLorena });\n\n\tconst { contract, protocol } = parseContractWithMinimalProtocolLevel(contractScript, format, 0);\n\n\tconst contractStorage = contract.find(x => x.prim === `storage`) as undefined | M.MichelsonContractStorage;\n\tconst contractParameter = contract.find(x => x.prim === `parameter`) as undefined | M.MichelsonContractParameter;\n\n\tconst storageResult = contractStorage && parseContractStorage(contractStorage);\n\tconst storage = storageResult\n\t\t?? { storage: { kind: `object`, raw: { prim: `never` } as M.MichelsonType, fields: [] } };\n\n\tconst parameterResult = contractParameter && parseContractParameter(contractParameter);\n\tconst methods = parameterResult?.methods ?? [];\n\n\treturn {\n\t\tstorage,\n\t\tmethods,\n\t\tcontract,\n\t\tprotocol,\n\t};\n};\n\nexport const generateContractTypesFromMichelsonCode = (\n\tcontractScript: string,\n\tcontractName: string,\n\tformat: 'tz' | 'json',\n\ttypeAliasData: TypeAliasData,\n\ttypeUtilsData: TypeUtilsData,\n): {\n\tschemaOutput: SchemaOutput;\n\ttypescriptCodeOutput: TypescriptCodeOutput;\n\tparsedContract: M.MichelsonContract;\n\tminimalProtocol: string;\n} => {\n\tconst {\n\t\tstorage,\n\t\tmethods,\n\t\tcontract,\n\t\tprotocol,\n\t} = parseContractInterface(\n\t\tcontractScript,\n\t\tformat,\n\t);\n\n\t// If there's only one entrypoint, then we call it \"default\"\n\tif (methods.length === 1) methods[0].name = `default`;\n\n\tconst schemaOutput = toSchema(methods, storage);\n\n\tconst typescriptCode = toTypescriptCode(\n\t\tstorage,\n\t\tmethods,\n\t\tcontractName,\n\t\tcontract,\n\t\tprotocol,\n\t\ttypeAliasData,\n\t\ttypeUtilsData,\n\t);\n\n\treturn {\n\t\tschemaOutput,\n\t\ttypescriptCodeOutput: typescriptCode,\n\t\tparsedContract: contract,\n\t\tminimalProtocol: protocol.key,\n\t};\n};\n","export class GenerateApiError implements Error {\n\tname = `GenerateApiError`;\n\tconstructor(public message: string, readonly data: unknown) {\n\t\tconsole.error(`âŒ GenerateApiError: ${message}`, data);\n\t}\n}\n\nexport const assertExhaustive = (value: never, message: string): void => {\n\tconsole.error(message, { value });\n};\n\nexport const reduceFlatMap = <T>(out: T[], x: T[]): T[] => {\n\tout.push(...x);\n\treturn out;\n};\n\n// const reduceFlatMapTest = () => {\n//     const items = [['a'], ['b']];\n//     const itemsFlat = items.reduce(reduceFlatMap);\n// };\n","import * as M from '@taquito/michel-codec';\nimport { assertExhaustive, GenerateApiError, reduceFlatMap } from './common';\n\nexport type TypedStorage = {\n\tstorage: TypedType;\n};\nexport type TypedParameter = {\n\tmethods: TypedMethod[];\n};\nexport type TypedMethod = {\n\tname: string;\n\targs: TypedVar[];\n};\nexport type TypedVar = {\n\tname?: string;\n\ttype: TypedType;\n};\nexport type TypedType =\n\t& {\n\t\traw: M.MichelsonType;\n\t\toptional?: boolean;\n\t}\n\t& (\n\t\t{\n\t\t\tkind: 'unit';\n\t\t} | {\n\t\t\tkind: 'never';\n\t\t} | {\n\t\t\tkind: 'unknown';\n\t\t} | {\n\t\t\tkind: 'value';\n\t\t\tvalue: string;\n\t\t\ttypescriptType: 'string' | 'boolean' | 'number' | 'Date';\n\t\t} | {\n\t\t\tkind: 'union';\n\t\t\tunion: TypedVar[];\n\t\t} | {\n\t\t\tkind: 'object';\n\t\t\tfields: TypedVar[];\n\t\t} | {\n\t\t\tkind: 'array';\n\t\t\tarray: { item: TypedType };\n\t\t} | {\n\t\t\tkind: 'map';\n\t\t\tmap: { key: TypedType; value: TypedType; isBigMap: boolean };\n\t\t} | {\n\t\t\tkind: 'lambda';\n\t\t\tlambda: { arg: TypedType; ret: TypedType };\n\t\t}\n\t);\n\nconst toDebugSource = (node: M.MichelsonType) => {\n\treturn JSON.stringify(node);\n};\n\nexport const parseContractStorage = (storage: M.MichelsonContractStorage): TypedStorage => {\n\tconst fields = storage.args\n\t\t.map(x => visitVar(x))\n\t\t.reduce(reduceFlatMap, []);\n\n\tif (fields.length === 1 && !fields[0].name) {\n\t\treturn {\n\t\t\tstorage: fields[0].type,\n\t\t};\n\t}\n\n\treturn {\n\t\tstorage: {\n\t\t\tkind: `object` as const,\n\t\t\traw: storage as unknown as M.MichelsonType,\n\t\t\tfields,\n\t\t},\n\t};\n};\n\nexport const parseContractParameter = (parameter: M.MichelsonContractParameter): TypedParameter => {\n\treturn {\n\t\tmethods: parameter.args\n\t\t\t.map(x => visitContractParameterEndpoint(x as MMethod))\n\t\t\t.reduce(reduceFlatMap, []),\n\t};\n};\n\ntype MMethod = M.MichelsonTypeOr<[M.MichelsonType, M.MichelsonType]>;\nconst visitContractParameterEndpoint = (node: MMethod): TypedMethod[] => {\n\t// console.log('visitContractParameterEndpoint', { node });\n\n\t// Sub endpoints (i.e. admin endpoints that are imported)\n\tif (node.prim === `or`) {\n\t\treturn node.args.map(x => visitContractParameterEndpoint(x as MMethod)).reduce(reduceFlatMap, []);\n\t}\n\n\t// Sub endpoints as a list with a single or (i.e. admin endpoints that are imported)\n\tif (node.prim === `list` && node.args.length as number === 1 && (node.args[0] as MMethod)?.prim === `or`) {\n\t\treturn node.args.map(x => visitContractParameterEndpoint(x as MMethod)).reduce(reduceFlatMap, []);\n\t}\n\n\tconst nameRaw = node.annots?.[0];\n\n\t// If the name is missing, then we assume its the main / default entrypoint\n\tconst name = nameRaw?.startsWith('%') ? nameRaw.substr(1) : 'default';\n\n\tif (!name) {\n\t\tconsole.warn(`Unknown method: ${node.prim as string}`, { node, args: node.args });\n\t\treturn [];\n\t}\n\n\tconst nodeType = visitType(node, { ignorePairName: node.prim === 'pair' });\n\n\t// Method args are usually objects\n\tif (nodeType.kind === 'object') {\n\t\treturn [{ name, args: nodeType.fields }];\n\t}\n\n\t// Simple methods can have a single unnamed argument\n\treturn [{\n\t\tname,\n\t\targs: [{ type: nodeType }],\n\t}];\n};\n\n// type PrimOf<T extends M.MichelsonType> = T extends { prim: infer U } ? U : never;\n// type WithPrim<T extends M.MichelsonType, P extends PrimOf<T>> = T extends { prim: P } ? T : never;\n// const isPrimType = <TPrim extends PrimOf<M.MichelsonType>>(node: undefined | null | M.MichelsonType, prim: TPrim): node is WithPrim<M.MichelsonType, TPrim> => {\n//     return (node && 'prim' in node && node.prim === prim) || false;\n// };\n\ntype MVarArgs = M.MichelsonType;\nconst visitVar = (node: MVarArgs): TypedVar[] => {\n\tconst name = `annots` in node && node.annots?.length === 1 ? node.annots[0].substr(1) : undefined;\n\tconst type = visitType(node);\n\n\treturn [{\n\t\tname,\n\t\ttype,\n\t}];\n};\n\ntype MType = M.MichelsonType;\nconst visitType = (node: MType, options?: { ignorePairName?: boolean }): TypedType => {\n\t// console.log('visitType', { node });\n\t// const debug_source = toDebugSource(node);\n\n\t// if (typeof node === `string`) {\n\t//     return { kind: `value`, raw: node, value: node, typescriptType: `string` };\n\t// }\n\n\tif (!(`prim` in node)) {\n\t\t// Unknown\n\t\tconsole.error(`visitType no prim`, { node });\n\t\treturn { kind: `unknown`, raw: node };\n\t}\n\n\t// Union\n\tif (node.prim === `or`) {\n\t\tconst unionVars = node.args.map(x => visitVar(x)).reduce(reduceFlatMap, []).map(x => x);\n\n\t\t// Flatten with child unions\n\t\tconst union = unionVars.map(x => !x.name && x.type.kind === 'union' ? x.type.union : [x]).reduce(reduceFlatMap, []);\n\t\t// const union = unionVars.map(x=>x.type);\n\n\t\t// const union = unionVars.map(x => x.type);\n\n\t\t// Flatten with child unions\n\n\t\t// const rightSide = union[1];\n\t\t// if (rightSide.kind === `union`) {\n\t\t//     union.pop();\n\t\t//     union.push(...rightSide.union);\n\t\t// }\n\n\t\tif (union.some(x => !x)) {\n\t\t\tthrow new GenerateApiError(`or: Some fields are null`, { node });\n\t\t}\n\t\treturn {\n\t\t\tkind: `union`,\n\t\t\traw: node,\n\t\t\tunion,\n\t\t};\n\t}\n\n\t// Intersect\n\tif (node.prim === `pair`) {\n\t\tconst fields = node.args.map(x => visitVar(x)).reduce(reduceFlatMap, []);\n\t\tif (fields.some(x => !x)) {\n\t\t\tthrow new GenerateApiError(`pair: Some fields are null`, { node, args: node.args, fields });\n\t\t}\n\t\t// Disabled Check: Apparently pairs can have more than 2 items\n\t\t// if (fields.length !== 2) {\n\t\t//     throw new GenerateApiError(`pair: Expected 2 items`, { node, length: fields.length, fields });\n\t\t// }\n\n\t\t// Flatten with unnamed child pairs\n\t\tconst fieldsFlat = fields.map(x =>\n\t\t\t(!x.name || options?.ignorePairName) && x.type.kind === 'object' ? x.type.fields : [x]\n\t\t).reduce(reduceFlatMap, []);\n\n\t\treturn {\n\t\t\tkind: `object`,\n\t\t\traw: node,\n\t\t\tfields: fieldsFlat,\n\t\t};\n\t}\n\n\t// list\n\tif (\n\t\tnode.prim === `list`\n\t\t|| node.prim === `set`\n\t) {\n\t\tif (node.args.length !== 1) {\n\t\t\tthrow new GenerateApiError(`list does not have 1 arg`, { node, args: node.args });\n\t\t}\n\n\t\tconst arrayItem = visitType(node.args[0]);\n\t\tif (!arrayItem) {\n\t\t\tthrow new GenerateApiError(`arrayItem are null`, { node, args: node.args, arrayItem });\n\t\t}\n\t\treturn {\n\t\t\tkind: `array`,\n\t\t\traw: node,\n\t\t\tarray: { item: arrayItem },\n\t\t};\n\t}\n\n\t// map\n\tif (\n\t\tnode.prim === `map`\n\t\t|| node.prim === `big_map`\n\t) {\n\t\tif (node.args.length !== 2) {\n\t\t\tthrow new GenerateApiError(`map does not have 2 args`, { node, args: node.args });\n\t\t}\n\n\t\tconst mapKey = visitType(node.args[0]);\n\t\tconst mapValue = visitType(node.args[1]);\n\t\tif (!mapKey || !mapValue) {\n\t\t\tthrow new GenerateApiError(`map is missing key or value`, { node, args: node.args, mapKey, mapValue });\n\t\t}\n\t\treturn {\n\t\t\tkind: `map`,\n\t\t\traw: node,\n\t\t\tmap: {\n\t\t\t\tkey: mapKey,\n\t\t\t\tvalue: mapValue,\n\t\t\t\tisBigMap: node.prim === `big_map`,\n\t\t\t},\n\t\t};\n\t}\n\n\t// option\n\tif (node.prim === `option`) {\n\t\treturn {\n\t\t\t...visitType(node.args[0]),\n\t\t\toptional: true,\n\t\t};\n\t}\n\n\t// boolean\n\tif (node.prim === `bool`) {\n\t\treturn {\n\t\t\tkind: `value`,\n\t\t\traw: node,\n\t\t\tvalue: node.prim,\n\t\t\ttypescriptType: `boolean`,\n\t\t};\n\t}\n\n\t// numbers\n\tif (\n\t\tnode.prim === `nat`\n\t\t|| node.prim === `int`\n\t\t|| node.prim === `mutez`\n\t) {\n\t\treturn {\n\t\t\tkind: `value`,\n\t\t\traw: node,\n\t\t\tvalue: node.prim,\n\t\t\ttypescriptType: `number`,\n\t\t};\n\t}\n\n\t// Date\n\tif (node.prim === `timestamp`) {\n\t\treturn {\n\t\t\tkind: `value`,\n\t\t\traw: node,\n\t\t\tvalue: node.prim,\n\t\t\ttypescriptType: `Date`,\n\t\t};\n\t}\n\n\t// strings\n\tif (\n\t\tnode.prim === `address`\n\t\t|| node.prim === `key`\n\t\t|| node.prim === `key_hash`\n\t\t|| node.prim === `chain_id`\n\t\t|| node.prim === `string`\n\t\t|| node.prim === `signature`\n\t\t|| node.prim === `ticket`\n\t\t|| node.prim === `bls12_381_fr`\n\t\t|| node.prim === `bls12_381_g1`\n\t\t|| node.prim === `bls12_381_g2`\n\t\t|| node.prim === `sapling_state`\n\t\t|| node.prim === `sapling_transaction`\n\t\t|| node.prim === `contract`\n\t) {\n\t\treturn {\n\t\t\tkind: `value`,\n\t\t\traw: node,\n\t\t\tvalue: node.prim,\n\t\t\ttypescriptType: `string`,\n\t\t};\n\t}\n\n\t// void\n\tif (node.prim === `unit`) {\n\t\treturn {\n\t\t\tkind: `unit`,\n\t\t\traw: node,\n\t\t};\n\t}\n\n\t// bytes?\n\tif (node.prim === `bytes`) {\n\t\treturn {\n\t\t\tkind: `value`,\n\t\t\traw: node,\n\t\t\tvalue: node.prim,\n\t\t\ttypescriptType: `string`,\n\t\t};\n\t}\n\n\tif (node.prim === `lambda`) {\n\t\tif (node.args.length !== 2) {\n\t\t\tthrow new GenerateApiError(`lambda does not have 2 args`, { node, args: node.args });\n\t\t}\n\n\t\tconst argType = visitType(node.args[0]);\n\t\tconst retType = visitType(node.args[1]);\n\t\tif (!argType || !retType) {\n\t\t\tthrow new GenerateApiError(`lambda is missing arg or return`, { node, args: node.args, argType, retType });\n\t\t}\n\n\t\treturn {\n\t\t\tkind: `lambda`,\n\t\t\traw: node,\n\t\t\tlambda: {\n\t\t\t\targ: argType,\n\t\t\t\tret: retType,\n\t\t\t},\n\t\t};\n\t}\n\n\t// misc?\n\tif (node.prim === `operation`) {\n\t\treturn {\n\t\t\tkind: `value`,\n\t\t\traw: node,\n\t\t\tvalue: node.prim,\n\t\t\ttypescriptType: `string`,\n\t\t};\n\t}\n\n\t// chest\n\tif (node.prim === 'chest' || node.prim === 'chest_key') {\n\t\treturn {\n\t\t\tkind: `value`,\n\t\t\traw: node,\n\t\t\tvalue: node.prim,\n\t\t\ttypescriptType: `string`,\n\t\t};\n\t}\n\n\t// never\n\tif (node.prim === `never`) {\n\t\treturn {\n\t\t\tkind: `never`,\n\t\t\traw: node,\n\t\t};\n\t}\n\n\t// Unknown\n\tassertExhaustive(node, `Unknown type`);\n\tthrow new GenerateApiError(`Unknown type`, { node });\n};\n","import { assertExhaustive, GenerateApiError, reduceFlatMap } from './common';\nimport { TypedMethod, TypedStorage, TypedType, TypedVar } from './contract-parser';\n\nexport type TypescriptCodeOutput = {\n\ttypesFileContent: string;\n\tcontractCodeFileContent: string;\n\tstorage: string;\n\tmethods: string;\n\tmethodsObject: string;\n};\n\nexport type TypeAliasData = {\n\tmode: 'local';\n\tfileContent?: string;\n} | {\n\tmode: 'file' | 'library';\n\timportPath?: string;\n} | {\n\tmode: 'simple';\n};\n\nexport type TypeUtilsData = {\n\timportPath: string;\n};\n\nexport const createTypescriptCodeGenerator = (options?: { mode?: 'types' | 'defaultValue' }) => {\n\ttype TypeAlias = {\n\t\taliasType: string;\n\t\tsimpleTypeDefinition: string;\n\t\tsimpleTypeImports?: { name: string; isDefault?: boolean; from: string }[];\n\t};\n\tconst usedStrictTypes = [] as TypeAlias[];\n\tconst addTypeAlias = (strictType: TypeAlias) => {\n\t\tif (!usedStrictTypes.some(x => x.aliasType === strictType.aliasType)) {\n\t\t\tusedStrictTypes.push(strictType);\n\t\t}\n\t};\n\n\t// Not really tabs :)\n\tconst tabs = (indent: number) => Array(indent).fill(`    `).join(``);\n\tconst toIndentedItems = (\n\t\tindent: number,\n\t\tdelimiters: { afterItem?: string; beforeItem?: string },\n\t\titems: string[],\n\t) => {\n\t\treturn `\n${tabs(indent + 1)}${\n\t\t\titems.join(`${delimiters.afterItem ?? ``}\n${tabs(indent + 1)}${delimiters.beforeItem ?? ``}`)\n\t\t}\n${tabs(indent)}`;\n\t};\n\n\tconst typeToCode = (t: TypedType, indent: number): string => {\n\t\tif (options?.mode === 'defaultValue') {\n\t\t\treturn typeToCode_defaultValue(t, indent);\n\t\t}\n\n\t\tif (t.kind === `value`) {\n\t\t\t// return `${t.typescriptType}`;\n\n\t\t\tconst prim = `prim` in t.raw ? t.raw.prim : `unknown`;\n\n\t\t\t// Strict mode\n\t\t\tif (\n\t\t\t\tt.typescriptType === `boolean`\n\t\t\t\t|| t.typescriptType === `string` && prim === `string`\n\t\t\t) {\n\t\t\t\treturn `${t.typescriptType}`;\n\t\t\t}\n\n\t\t\tif (t.typescriptType === 'number') {\n\t\t\t\tconst simpleBaseType = `string | BigNumber | number`;\n\t\t\t\tconst typeAlias: TypeAlias = {\n\t\t\t\t\taliasType: prim,\n\t\t\t\t\tsimpleTypeDefinition: `type ${prim} = ${simpleBaseType};`,\n\t\t\t\t\tsimpleTypeImports: [{ name: 'BigNumber', isDefault: true, from: 'bignumber.js' }],\n\t\t\t\t};\n\t\t\t\taddTypeAlias(typeAlias);\n\n\t\t\t\treturn typeAlias.aliasType;\n\t\t\t}\n\n\t\t\tconst simpleBaseType = t.typescriptType === 'Date' ? 'Date | string' : t.typescriptType;\n\t\t\tconst typeAlias: TypeAlias = { aliasType: prim, simpleTypeDefinition: `type ${prim} = ${simpleBaseType};` };\n\t\t\taddTypeAlias(typeAlias);\n\n\t\t\treturn typeAlias.aliasType;\n\t\t}\n\t\tif (t.kind === `array`) {\n\t\t\treturn `Array<${typeToCode(t.array.item, indent)}>`;\n\t\t}\n\t\tif (t.kind === `map`) {\n\t\t\tconst typeAlias: TypeAlias = t.map.isBigMap\n\t\t\t\t? {\n\t\t\t\t\taliasType: `BigMap`,\n\t\t\t\t\tsimpleTypeDefinition: 'type BigMap<K, T> = MichelsonMap<K, T>;',\n\t\t\t\t\tsimpleTypeImports: [{ name: 'MichelsonMap', from: '@taquito/taquito' }],\n\t\t\t\t}\n\t\t\t\t: {\n\t\t\t\t\taliasType: `MMap`,\n\t\t\t\t\tsimpleTypeDefinition: 'type MMap<K, T> = MichelsonMap<K, T>;',\n\t\t\t\t\tsimpleTypeImports: [{ name: 'MichelsonMap', from: '@taquito/taquito' }],\n\t\t\t\t};\n\t\t\taddTypeAlias(typeAlias);\n\n\t\t\treturn `${typeAlias.aliasType}<${typeToCode(t.map.key, indent)}, ${typeToCode(t.map.value, indent)}>`;\n\t\t}\n\t\tif (t.kind === `lambda`) {\n\t\t\tconst typeAlias: TypeAlias = {\n\t\t\t\taliasType: 'Instruction',\n\t\t\t\tsimpleTypeDefinition: `type Instruction = MichelsonInstruction;`,\n\t\t\t\tsimpleTypeImports: [{ name: 'MichelsonInstruction', isDefault: false, from: '@taquito/michel-codec' }],\n\t\t\t};\n\t\t\taddTypeAlias(typeAlias);\n\t\t\treturn `Instruction[]`;\n\t\t}\n\t\tif (t.kind === `object`) {\n\t\t\treturn `{${toIndentedItems(indent, {}, t.fields.map((a, i) => varToCode(a, i, indent + 1) + `;`))}}`;\n\t\t}\n\t\tif (t.kind === `union`) {\n\t\t\tconst getUnionItem = (a: TypedVar, i: number) => {\n\t\t\t\tconst itemCode = `${varToCode(a, i, indent + 1)}`;\n\n\t\t\t\t// Keep on single line if already on single line\n\t\t\t\tif (!itemCode.includes(`\\n`)) {\n\t\t\t\t\treturn `{ ${itemCode} }`;\n\t\t\t\t}\n\n\t\t\t\t// Indent if multi-line (and remake with extra indent)\n\t\t\t\treturn `{${toIndentedItems(indent + 1, {}, [`${varToCode(a, i, indent + 2)}`])}}`;\n\t\t\t};\n\n\t\t\treturn `(${toIndentedItems(indent, { beforeItem: `| ` }, t.union.map(getUnionItem))})`;\n\t\t}\n\t\tif (t.kind === `unit`) {\n\t\t\tconst typeAlias: TypeAlias = {\n\t\t\t\taliasType: `unit`,\n\t\t\t\tsimpleTypeDefinition: `type unit = (true | undefined);`,\n\t\t\t};\n\t\t\taddTypeAlias(typeAlias);\n\t\t\treturn typeAlias.aliasType;\n\t\t}\n\t\tif (t.kind === `never`) {\n\t\t\treturn `never`;\n\t\t}\n\t\tif (t.kind === `unknown`) {\n\t\t\treturn `unknown`;\n\t\t}\n\n\t\tassertExhaustive(t, `Unknown type`);\n\t\tthrow new GenerateApiError(`Unknown type node`, { t });\n\t};\n\n\tconst typeToCode_defaultValue = (t: TypedType, indent: number): string => {\n\t\tif (t.kind === `value`) {\n\t\t\t// return `${t.typescriptType}`;\n\n\t\t\tconst prim = `prim` in t.raw ? t.raw.prim : `unknown`;\n\n\t\t\t// Strict mode\n\t\t\tif (t.typescriptType === 'boolean') {\n\t\t\t\treturn `true`;\n\t\t\t}\n\t\t\tif (t.typescriptType === `string` && prim === `string`) {\n\t\t\t\treturn `'VALUE'`;\n\t\t\t}\n\t\t\tif (t.typescriptType === 'number') {\n\t\t\t\treturn `tas.${prim}('42')`;\n\t\t\t}\n\t\t\tif (t.typescriptType === 'Date') {\n\t\t\t\treturn `tas.timestamp(new Date())`;\n\t\t\t}\n\t\t\tif (\n\t\t\t\tprim === 'address'\n\t\t\t\t|| prim === 'contract'\n\t\t\t) {\n\t\t\t\treturn `tas.${prim}('tz1ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456')`;\n\t\t\t}\n\t\t\tif (prim === 'bytes') {\n\t\t\t\treturn `tas.${prim}(char2Bytes('DATA'))`;\n\t\t\t}\n\t\t\tif (t.typescriptType === 'string') {\n\t\t\t\treturn `tas.${prim}('VALUE')`;\n\t\t\t}\n\t\t\tassertExhaustive(t.typescriptType, `Unknown value type`);\n\n\t\t\treturn prim;\n\t\t}\n\t\tif (t.kind === `array`) {\n\t\t\treturn `[${typeToCode(t.array.item, indent)}]`;\n\t\t}\n\t\tif (t.kind === `map`) {\n\t\t\tconst keyPrim = `prim` in t.map.key.raw ? t.map.key.raw.prim : `unknown`;\n\t\t\tconst isStringBasedKey = t.map.key.kind === 'value' && keyPrim === 'string';\n\t\t\tif (isStringBasedKey) {\n\t\t\t\treturn `tas.${t.map.isBigMap ? 'bigMap' : 'map'}({ \n${tabs(indent + 1)}${typeToCode(t.map.key, indent)}: ${typeToCode(t.map.value, indent)},\n${tabs(indent)}})`;\n\t\t\t}\n\n\t\t\treturn `tas.${t.map.isBigMap ? 'bigMap' : 'map'}([{ \n${tabs(indent + 1)}key: ${typeToCode(t.map.key, indent)}, \n${tabs(indent + 1)}value: ${typeToCode(t.map.value, indent)},\n${tabs(indent)}}])`;\n\t\t}\n\t\tif (t.kind === `object`) {\n\t\t\tconst delimiter = options?.mode === 'defaultValue' ? ',' : `;`;\n\t\t\treturn `{${toIndentedItems(indent, {}, t.fields.map((a, i) => varToCode(a, i, indent + 1) + delimiter))}}`;\n\t\t}\n\t\tif (t.kind === `union`) {\n\t\t\tconst getUnionItem = (a: TypedVar, i: number) => {\n\t\t\t\tconst itemCode = `${varToCode(a, i, indent + 1)}`;\n\n\t\t\t\t// Keep on single line if already on single line\n\t\t\t\tif (!itemCode.includes(`\\n`)) {\n\t\t\t\t\treturn `{ ${itemCode} }`;\n\t\t\t\t}\n\n\t\t\t\t// Indent if multi-line (and remake with extra indent)\n\t\t\t\treturn `{${toIndentedItems(indent + 1, {}, [`${varToCode(a, i, indent + 2)}`])}}`;\n\t\t\t};\n\n\t\t\treturn `(${toIndentedItems(indent, { beforeItem: `| ` }, t.union.map(getUnionItem))})`;\n\t\t}\n\t\tif (t.kind === `unit`) {\n\t\t\treturn `tas.unit()`;\n\t\t}\n\t\tif (t.kind === `never`) {\n\t\t\treturn `never`;\n\t\t}\n\t\tif (t.kind === `unknown`) {\n\t\t\treturn `unknown`;\n\t\t}\n\t\tif (t.kind === 'lambda') {\n\t\t\treturn `tas.lambda([])`;\n\t\t}\n\n\t\tassertExhaustive(t, `Unknown type`);\n\t\tthrow new GenerateApiError(`Unknown type node`, { t });\n\t};\n\n\tconst varToCode = (t: TypedVar, i: number, indent: number, numberVarNamePrefix = ''): string => {\n\t\tlet typeName = typeToCode(t.type, indent);\n\t\tif (t.type.optional) {\n\t\t\ttypeName = `{Some: ${typeName}} | null`;\n\t\t}\n\t\treturn `${t.name ?? `${numberVarNamePrefix}${i}`}: ${typeName}`;\n\t};\n\n\tconst argsToCode = (args: TypedVar[], indent: number, asObject: boolean): string => {\n\t\tif (args.length === 1) {\n\t\t\tif (args[0].type.kind === `unit`) return ``;\n\n\t\t\tif (options?.mode === 'defaultValue') {\n\t\t\t\treturn typeToCode(args[0].type, indent + 1);\n\t\t\t}\n\t\t\treturn `${args[0].name ?? `param`}: ${typeToCode(args[0].type, indent + 1)}`;\n\t\t}\n\n\t\tconst result = `${\n\t\t\ttoIndentedItems(\n\t\t\t\tindent,\n\t\t\t\t{},\n\t\t\t\targs.filter(x => x.name || x.type.kind !== `unit`).map((a, i) => {\n\t\t\t\t\tif (!asObject && options?.mode === 'defaultValue') {\n\t\t\t\t\t\treturn typeToCode(a.type, indent + 1) + `,`;\n\t\t\t\t\t}\n\t\t\t\t\treturn varToCode(a, i, indent + 1, asObject ? '' : '_') + `,`;\n\t\t\t\t}),\n\t\t\t)\n\t\t}`;\n\n\t\tif (asObject) {\n\t\t\tif (options?.mode === 'defaultValue') {\n\t\t\t\treturn `{${result}}`;\n\t\t\t}\n\t\t\treturn `params: {${result}}`;\n\t\t}\n\n\t\treturn result;\n\t};\n\n\treturn {\n\t\tusedStrictTypes,\n\t\ttabs,\n\t\ttoIndentedItems,\n\t\ttypeToCode,\n\t\targsToCode,\n\t};\n};\n\nexport const toTypescriptCode = (\n\tstorage: TypedStorage,\n\tmethods: TypedMethod[],\n\tcontractName: string,\n\tparsedContract: unknown,\n\tprotocol: { name: string; key: string },\n\ttypeAliasData: TypeAliasData,\n\ttypeUtilsData: TypeUtilsData,\n): TypescriptCodeOutput => {\n\tconst {\n\t\tusedStrictTypes,\n\t\ttoIndentedItems,\n\t\ttypeToCode,\n\t\targsToCode,\n\t} = createTypescriptCodeGenerator();\n\n\tconst methodsToCode = (indent: number) => {\n\t\tconst methodFields = methods.map(x => {\n\t\t\tconst methodCode = `${x.name}: (${argsToCode(x.args, indent + 1, false)}) => Promise<void>;`;\n\t\t\treturn methodCode;\n\t\t});\n\n\t\tconst methodsTypeCode = `type Methods = {${toIndentedItems(indent, {}, methodFields)}};`;\n\t\treturn methodsTypeCode;\n\t};\n\tconst methodsObjectToCode = (indent: number) => {\n\t\tconst methodFields = methods.map(x => {\n\t\t\tconst methodCode = `${x.name}: (${argsToCode(x.args, indent + 1, true)}) => Promise<void>;`;\n\t\t\treturn methodCode;\n\t\t});\n\n\t\tconst methodsTypeCode = `type MethodsObject = {${toIndentedItems(indent, {}, methodFields)}};`;\n\t\treturn methodsTypeCode;\n\t};\n\n\tconst storageToCode = (indent: number) => {\n\t\tconst storageTypeCode = `export type Storage = ${typeToCode(storage.storage, indent)};`;\n\t\treturn storageTypeCode;\n\t};\n\n\tconst methodsCode = methodsToCode(0);\n\tconst methodsObjectCode = methodsObjectToCode(0);\n\tconst storageCode = storageToCode(0);\n\n\t// Simple type aliases\n\tconst simpleTypeMappingImportsAll = new Map(\n\t\tusedStrictTypes.map(x => x.simpleTypeImports ?? []).reduce(reduceFlatMap, []).map(\n\t\t\tx => [`${x?.from}:${x?.name}:${x?.isDefault}`, x],\n\t\t),\n\t);\n\tconst simpleTypeMappingImportsFrom = [...simpleTypeMappingImportsAll.values()].reduce((out, x) => {\n\t\tconst entry = out[x.from] ?? (out[x.from] = { names: [] });\n\t\tif (x.isDefault) {\n\t\t\tentry.default = x.name;\n\t\t} else {\n\t\t\tentry.names.push(x.name);\n\t\t}\n\t\tentry.names.sort((a, b) => a.localeCompare(b));\n\t\treturn out;\n\t}, {} as { [from: string]: { names: string[]; default?: string } });\n\n\tconst simpleTypeMappingImportsText = Object.keys(simpleTypeMappingImportsFrom)\n\t\t.map(k => {\n\t\t\tconst entry = simpleTypeMappingImportsFrom[k];\n\t\t\tconst items = [entry.default, entry.names.length ? `{ ${entry.names.join(', ')} }` : ''].filter(x => x);\n\t\t\treturn `import ${items.join(', ')} from '${k}';\\n`;\n\t\t})\n\t\t.join('');\n\n\tconst simpleTypeMapping = usedStrictTypes\n\t\t.sort((a, b) => a.aliasType.localeCompare(b.aliasType))\n\t\t.map(x => x.simpleTypeDefinition).join(`\\n`);\n\n\tconst typeUtilsDefinitions =\n\t\t`import { ContractAbstractionFromContractType, WalletContractAbstractionFromContractType } from '${typeUtilsData.importPath}';`;\n\n\tconst typeAliasesDefinitions = typeAliasData.mode === 'simple'\n\t\t? `${simpleTypeMappingImportsText}${simpleTypeMapping}`\n\t\t: typeAliasData.mode === 'local'\n\t\t? typeAliasData.fileContent\n\t\t: `import { ${usedStrictTypes.map(x => x.aliasType).join(`, `)} } from '${typeAliasData.importPath}';`;\n\n\tconst contractTypeName = `${contractName}ContractType`;\n\tconst walletTypeName = `${contractName}WalletType`;\n\tconst codeName = `${contractName}Code`;\n\n\tconst typesFileContent = `\n${typeUtilsDefinitions}\n${typeAliasesDefinitions}\n\n${storageCode}\n\n${methodsCode}\n\n${methodsObjectCode}\n\ntype contractTypes = { methods: Methods, methodsObject: MethodsObject, storage: Storage, code: { __type: '${codeName}', protocol: string, code: object[] } };\nexport type ${contractTypeName} = ContractAbstractionFromContractType<contractTypes>;\nexport type ${walletTypeName} = WalletContractAbstractionFromContractType<contractTypes>;\n`;\n\n\tconst contractCodeFileContent = `\nexport const ${codeName}: { __type: '${codeName}', protocol: string, code: object[] } = {\n    __type: '${codeName}',\n    protocol: '${protocol.key}',\n    code: JSON.parse(\\`${JSON.stringify(parsedContract)}\\`)\n};\n`;\n\treturn {\n\t\ttypesFileContent,\n\t\tcontractCodeFileContent,\n\t\tstorage: storageCode,\n\t\tmethods: methodsCode,\n\t\tmethodsObject: methodsObjectCode,\n\t};\n};\n"],"mappings":"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","names":["simpleBaseType","typeAlias"]}