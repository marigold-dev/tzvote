import {
  createTypescriptCodeGenerator,
  normalizeContractName,
  parseContractInterface
} from "../../chunk-L4VA7R4W.js";

// src/generator/testing-code-generator.ts
var createTestingCodeGenerator = ({
  contractSource,
  contractFormat
}) => {
  const {
    storage,
    methods
  } = parseContractInterface(contractSource, contractFormat);
  const codeGenerator = createTypescriptCodeGenerator({ mode: "defaultValue" });
  const getMethodByName = (methodName) => {
    const method = methods.find((x) => x.name === methodName);
    if (!method) {
      throw new Error(`Failed to fine method: ${methodName}`);
    }
    return method;
  };
  return {
    storage,
    methods,
    generateOrigination: ({
      contractVarName,
      formatting
    }) => generateOrigination({
      codeGenerator,
      storage,
      indent: formatting == null ? void 0 : formatting.indent
    }),
    generateMethodCall: ({
      methodName,
      formatting
    }) => generateMethodCall({
      codeGenerator,
      method: getMethodByName(methodName),
      indent: formatting == null ? void 0 : formatting.indent
    }),
    generateStorageAccess: ({
      storagePath
    }) => generateStorageAccess({
      codeGenerator,
      storagePath
    })
  };
};
var generateOrigination = ({
  codeGenerator,
  storage,
  indent = 2,
  useSemicolons = true,
  contractVarName = "contract",
  minConfirmations = 3
}) => {
  const {
    tabs,
    argsToCode
  } = codeGenerator;
  const semi = useSemicolons ? ";" : "";
  const code = `
${tabs(indent)}const newContractOrigination = await Tezos.contract.originate<ContractType>({
${tabs(indent + 1)}code: ContractCode.code,
${tabs(indent + 1)}storage: ${argsToCode([{ type: storage.storage }], indent + 1, true)},
${tabs(indent)}})${semi}
${tabs(indent)}const newContractResult = await newContractOrigination.contract()${semi}
${tabs(indent)}const newContractAddress = newContractResult.address${semi}
${tabs(indent)}${contractVarName} = await Tezos.contract.at<ContractType>(newContractAddress)${semi}
${tabs(indent)}`;
  return {
    code
  };
};
var generateMethodCall = ({
  codeGenerator,
  method,
  indent = 2,
  useSemicolons = true,
  contractVarName = "contract",
  minConfirmations = 3
}) => {
  const {
    tabs,
    argsToCode
  } = codeGenerator;
  const semi = useSemicolons ? ";" : "";
  const code = `
${tabs(indent)}const ${method.name}Request = await ${contractVarName}.methodsObject.${method.name}(${argsToCode(method.args, indent + 1, true)}).send()${semi}
${tabs(indent)}await ${method.name}Request.confirmation(${minConfirmations})${semi}
${tabs(indent)}`;
  return {
    code
  };
};
var generateStorageAccess = ({
  codeGenerator,
  storagePath,
  indent = 2,
  useSemicolons = true,
  contractVarName = "contract",
  getStorageValueFunctionName,
  storageVarName = "storage",
  storageValueVarName = "value"
}) => {
  const {
    tabs,
    argsToCode
  } = codeGenerator;
  const semi = useSemicolons ? ";" : "";
  const funcName = getStorageValueFunctionName ?? `getStorageValue${storagePath.split(".").map((x) => x.replace(/[^A-Za-z0-9]/g, "")).map((x) => `${x.substring(0, 1).toLocaleUpperCase()}${x.substring(1)}`).join("")}`;
  const getStorageValueExpr = `${storageVarName}`;
  const funcCode = `
${tabs(indent)}const ${funcName} = async () => {
${tabs(indent + 1)}const ${storageVarName} = await ${contractVarName}.storage()${semi}
${tabs(indent + 1)}const ${storageValueVarName} = ${getStorageValueExpr}${semi}
${tabs(indent + 1)}return ${storageValueVarName}${semi}
${tabs(indent)}}${semi}
`;
  return {
    getStorageValueFunctionCode: funcCode,
    getStorageValueFunctionName: funcName
  };
};
export {
  createTestingCodeGenerator,
  normalizeContractName
};
//# sourceMappingURL=testing-code-generator.js.map