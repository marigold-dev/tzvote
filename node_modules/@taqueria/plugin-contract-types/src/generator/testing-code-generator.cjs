"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/generator/testing-code-generator.ts
var testing_code_generator_exports = {};
__export(testing_code_generator_exports, {
  createTestingCodeGenerator: () => createTestingCodeGenerator,
  normalizeContractName: () => normalizeContractName
});
module.exports = __toCommonJS(testing_code_generator_exports);

// src/generator/contract-name.ts
var normalizeContractName = (text) => text.replace(/[^A-Za-z0-9]/g, "_").split("_").filter((x) => x).map((x) => x[0].toUpperCase() + x.substring(1)).join("");

// src/generator/process.ts
var M = __toESM(require("@taquito/michel-codec"), 1);

// src/generator/common.ts
var GenerateApiError = class {
  constructor(message, data) {
    this.message = message;
    this.data = data;
    this.name = `GenerateApiError`;
    console.error(`\u274C GenerateApiError: ${message}`, data);
  }
};
var assertExhaustive = (value, message) => {
  console.error(message, { value });
};
var reduceFlatMap = (out, x) => {
  out.push(...x);
  return out;
};

// src/generator/contract-parser.ts
var parseContractStorage = (storage) => {
  const fields = storage.args.map((x) => visitVar(x)).reduce(reduceFlatMap, []);
  if (fields.length === 1 && !fields[0].name) {
    return {
      storage: fields[0].type
    };
  }
  return {
    storage: {
      kind: `object`,
      raw: storage,
      fields
    }
  };
};
var parseContractParameter = (parameter) => {
  return {
    methods: parameter.args.map((x) => visitContractParameterEndpoint(x)).reduce(reduceFlatMap, [])
  };
};
var visitContractParameterEndpoint = (node) => {
  var _a, _b;
  if (node.prim === `or`) {
    return node.args.map((x) => visitContractParameterEndpoint(x)).reduce(reduceFlatMap, []);
  }
  if (node.prim === `list` && node.args.length === 1 && ((_a = node.args[0]) == null ? void 0 : _a.prim) === `or`) {
    return node.args.map((x) => visitContractParameterEndpoint(x)).reduce(reduceFlatMap, []);
  }
  const nameRaw = (_b = node.annots) == null ? void 0 : _b[0];
  const name = (nameRaw == null ? void 0 : nameRaw.startsWith("%")) ? nameRaw.substr(1) : "default";
  if (!name) {
    console.warn(`Unknown method: ${node.prim}`, { node, args: node.args });
    return [];
  }
  const nodeType = visitType(node, { ignorePairName: node.prim === "pair" });
  if (nodeType.kind === "object") {
    return [{ name, args: nodeType.fields }];
  }
  return [{
    name,
    args: [{ type: nodeType }]
  }];
};
var visitVar = (node) => {
  var _a;
  const name = `annots` in node && ((_a = node.annots) == null ? void 0 : _a.length) === 1 ? node.annots[0].substr(1) : void 0;
  const type = visitType(node);
  return [{
    name,
    type
  }];
};
var visitType = (node, options) => {
  if (!(`prim` in node)) {
    console.error(`visitType no prim`, { node });
    return { kind: `unknown`, raw: node };
  }
  if (node.prim === `or`) {
    const unionVars = node.args.map((x) => visitVar(x)).reduce(reduceFlatMap, []).map((x) => x);
    const union = unionVars.map((x) => !x.name && x.type.kind === "union" ? x.type.union : [x]).reduce(reduceFlatMap, []);
    if (union.some((x) => !x)) {
      throw new GenerateApiError(`or: Some fields are null`, { node });
    }
    return {
      kind: `union`,
      raw: node,
      union
    };
  }
  if (node.prim === `pair`) {
    const fields = node.args.map((x) => visitVar(x)).reduce(reduceFlatMap, []);
    if (fields.some((x) => !x)) {
      throw new GenerateApiError(`pair: Some fields are null`, { node, args: node.args, fields });
    }
    const fieldsFlat = fields.map(
      (x) => (!x.name || (options == null ? void 0 : options.ignorePairName)) && x.type.kind === "object" ? x.type.fields : [x]
    ).reduce(reduceFlatMap, []);
    return {
      kind: `object`,
      raw: node,
      fields: fieldsFlat
    };
  }
  if (node.prim === `list` || node.prim === `set`) {
    if (node.args.length !== 1) {
      throw new GenerateApiError(`list does not have 1 arg`, { node, args: node.args });
    }
    const arrayItem = visitType(node.args[0]);
    if (!arrayItem) {
      throw new GenerateApiError(`arrayItem are null`, { node, args: node.args, arrayItem });
    }
    return {
      kind: `array`,
      raw: node,
      array: { item: arrayItem }
    };
  }
  if (node.prim === `map` || node.prim === `big_map`) {
    if (node.args.length !== 2) {
      throw new GenerateApiError(`map does not have 2 args`, { node, args: node.args });
    }
    const mapKey = visitType(node.args[0]);
    const mapValue = visitType(node.args[1]);
    if (!mapKey || !mapValue) {
      throw new GenerateApiError(`map is missing key or value`, { node, args: node.args, mapKey, mapValue });
    }
    return {
      kind: `map`,
      raw: node,
      map: {
        key: mapKey,
        value: mapValue,
        isBigMap: node.prim === `big_map`
      }
    };
  }
  if (node.prim === `option`) {
    return {
      ...visitType(node.args[0]),
      optional: true
    };
  }
  if (node.prim === `bool`) {
    return {
      kind: `value`,
      raw: node,
      value: node.prim,
      typescriptType: `boolean`
    };
  }
  if (node.prim === `nat` || node.prim === `int` || node.prim === `mutez`) {
    return {
      kind: `value`,
      raw: node,
      value: node.prim,
      typescriptType: `number`
    };
  }
  if (node.prim === `timestamp`) {
    return {
      kind: `value`,
      raw: node,
      value: node.prim,
      typescriptType: `Date`
    };
  }
  if (node.prim === `address` || node.prim === `key` || node.prim === `key_hash` || node.prim === `chain_id` || node.prim === `string` || node.prim === `signature` || node.prim === `ticket` || node.prim === `bls12_381_fr` || node.prim === `bls12_381_g1` || node.prim === `bls12_381_g2` || node.prim === `sapling_state` || node.prim === `sapling_transaction` || node.prim === `contract`) {
    return {
      kind: `value`,
      raw: node,
      value: node.prim,
      typescriptType: `string`
    };
  }
  if (node.prim === `unit`) {
    return {
      kind: `unit`,
      raw: node
    };
  }
  if (node.prim === `bytes`) {
    return {
      kind: `value`,
      raw: node,
      value: node.prim,
      typescriptType: `string`
    };
  }
  if (node.prim === `lambda`) {
    if (node.args.length !== 2) {
      throw new GenerateApiError(`lambda does not have 2 args`, { node, args: node.args });
    }
    const argType = visitType(node.args[0]);
    const retType = visitType(node.args[1]);
    if (!argType || !retType) {
      throw new GenerateApiError(`lambda is missing arg or return`, { node, args: node.args, argType, retType });
    }
    return {
      kind: `lambda`,
      raw: node,
      lambda: {
        arg: argType,
        ret: retType
      }
    };
  }
  if (node.prim === `operation`) {
    return {
      kind: `value`,
      raw: node,
      value: node.prim,
      typescriptType: `string`
    };
  }
  if (node.prim === "chest" || node.prim === "chest_key") {
    return {
      kind: `value`,
      raw: node,
      value: node.prim,
      typescriptType: `string`
    };
  }
  if (node.prim === `never`) {
    return {
      kind: `never`,
      raw: node
    };
  }
  assertExhaustive(node, `Unknown type`);
  throw new GenerateApiError(`Unknown type`, { node });
};

// src/generator/typescript-output.ts
var createTypescriptCodeGenerator = (options) => {
  const usedStrictTypes = [];
  const addTypeAlias = (strictType) => {
    if (!usedStrictTypes.some((x) => x.aliasType === strictType.aliasType)) {
      usedStrictTypes.push(strictType);
    }
  };
  const tabs = (indent) => Array(indent).fill(`    `).join(``);
  const toIndentedItems = (indent, delimiters, items) => {
    return `
${tabs(indent + 1)}${items.join(`${delimiters.afterItem ?? ``}
${tabs(indent + 1)}${delimiters.beforeItem ?? ``}`)}
${tabs(indent)}`;
  };
  const typeToCode = (t, indent) => {
    if ((options == null ? void 0 : options.mode) === "defaultValue") {
      return typeToCode_defaultValue(t, indent);
    }
    if (t.kind === `value`) {
      const prim = `prim` in t.raw ? t.raw.prim : `unknown`;
      if (t.typescriptType === `boolean` || t.typescriptType === `string` && prim === `string`) {
        return `${t.typescriptType}`;
      }
      if (t.typescriptType === "number") {
        const simpleBaseType2 = `string | BigNumber | number`;
        const typeAlias2 = {
          aliasType: prim,
          simpleTypeDefinition: `type ${prim} = ${simpleBaseType2};`,
          simpleTypeImports: [{ name: "BigNumber", isDefault: true, from: "bignumber.js" }]
        };
        addTypeAlias(typeAlias2);
        return typeAlias2.aliasType;
      }
      const simpleBaseType = t.typescriptType === "Date" ? "Date | string" : t.typescriptType;
      const typeAlias = { aliasType: prim, simpleTypeDefinition: `type ${prim} = ${simpleBaseType};` };
      addTypeAlias(typeAlias);
      return typeAlias.aliasType;
    }
    if (t.kind === `array`) {
      return `Array<${typeToCode(t.array.item, indent)}>`;
    }
    if (t.kind === `map`) {
      const typeAlias = t.map.isBigMap ? {
        aliasType: `BigMap`,
        simpleTypeDefinition: "type BigMap<K, T> = MichelsonMap<K, T>;",
        simpleTypeImports: [{ name: "MichelsonMap", from: "@taquito/taquito" }]
      } : {
        aliasType: `MMap`,
        simpleTypeDefinition: "type MMap<K, T> = MichelsonMap<K, T>;",
        simpleTypeImports: [{ name: "MichelsonMap", from: "@taquito/taquito" }]
      };
      addTypeAlias(typeAlias);
      return `${typeAlias.aliasType}<${typeToCode(t.map.key, indent)}, ${typeToCode(t.map.value, indent)}>`;
    }
    if (t.kind === `lambda`) {
      const typeAlias = {
        aliasType: "Instruction",
        simpleTypeDefinition: `type Instruction = MichelsonInstruction;`,
        simpleTypeImports: [{ name: "MichelsonInstruction", isDefault: false, from: "@taquito/michel-codec" }]
      };
      addTypeAlias(typeAlias);
      return `Instruction[]`;
    }
    if (t.kind === `object`) {
      return `{${toIndentedItems(indent, {}, t.fields.map((a, i) => varToCode(a, i, indent + 1) + `;`))}}`;
    }
    if (t.kind === `union`) {
      const getUnionItem = (a, i) => {
        const itemCode = `${varToCode(a, i, indent + 1)}`;
        if (!itemCode.includes(`
`)) {
          return `{ ${itemCode} }`;
        }
        return `{${toIndentedItems(indent + 1, {}, [`${varToCode(a, i, indent + 2)}`])}}`;
      };
      return `(${toIndentedItems(indent, { beforeItem: `| ` }, t.union.map(getUnionItem))})`;
    }
    if (t.kind === `unit`) {
      const typeAlias = {
        aliasType: `unit`,
        simpleTypeDefinition: `type unit = (true | undefined);`
      };
      addTypeAlias(typeAlias);
      return typeAlias.aliasType;
    }
    if (t.kind === `never`) {
      return `never`;
    }
    if (t.kind === `unknown`) {
      return `unknown`;
    }
    assertExhaustive(t, `Unknown type`);
    throw new GenerateApiError(`Unknown type node`, { t });
  };
  const typeToCode_defaultValue = (t, indent) => {
    if (t.kind === `value`) {
      const prim = `prim` in t.raw ? t.raw.prim : `unknown`;
      if (t.typescriptType === "boolean") {
        return `true`;
      }
      if (t.typescriptType === `string` && prim === `string`) {
        return `'VALUE'`;
      }
      if (t.typescriptType === "number") {
        return `tas.${prim}('42')`;
      }
      if (t.typescriptType === "Date") {
        return `tas.timestamp(new Date())`;
      }
      if (prim === "address" || prim === "contract") {
        return `tas.${prim}('tz1ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456')`;
      }
      if (prim === "bytes") {
        return `tas.${prim}(char2Bytes('DATA'))`;
      }
      if (t.typescriptType === "string") {
        return `tas.${prim}('VALUE')`;
      }
      assertExhaustive(t.typescriptType, `Unknown value type`);
      return prim;
    }
    if (t.kind === `array`) {
      return `[${typeToCode(t.array.item, indent)}]`;
    }
    if (t.kind === `map`) {
      const keyPrim = `prim` in t.map.key.raw ? t.map.key.raw.prim : `unknown`;
      const isStringBasedKey = t.map.key.kind === "value" && keyPrim === "string";
      if (isStringBasedKey) {
        return `tas.${t.map.isBigMap ? "bigMap" : "map"}({ 
${tabs(indent + 1)}${typeToCode(t.map.key, indent)}: ${typeToCode(t.map.value, indent)},
${tabs(indent)}})`;
      }
      return `tas.${t.map.isBigMap ? "bigMap" : "map"}([{ 
${tabs(indent + 1)}key: ${typeToCode(t.map.key, indent)}, 
${tabs(indent + 1)}value: ${typeToCode(t.map.value, indent)},
${tabs(indent)}}])`;
    }
    if (t.kind === `object`) {
      const delimiter = (options == null ? void 0 : options.mode) === "defaultValue" ? "," : `;`;
      return `{${toIndentedItems(indent, {}, t.fields.map((a, i) => varToCode(a, i, indent + 1) + delimiter))}}`;
    }
    if (t.kind === `union`) {
      const getUnionItem = (a, i) => {
        const itemCode = `${varToCode(a, i, indent + 1)}`;
        if (!itemCode.includes(`
`)) {
          return `{ ${itemCode} }`;
        }
        return `{${toIndentedItems(indent + 1, {}, [`${varToCode(a, i, indent + 2)}`])}}`;
      };
      return `(${toIndentedItems(indent, { beforeItem: `| ` }, t.union.map(getUnionItem))})`;
    }
    if (t.kind === `unit`) {
      return `tas.unit()`;
    }
    if (t.kind === `never`) {
      return `never`;
    }
    if (t.kind === `unknown`) {
      return `unknown`;
    }
    if (t.kind === "lambda") {
      return `tas.lambda([])`;
    }
    assertExhaustive(t, `Unknown type`);
    throw new GenerateApiError(`Unknown type node`, { t });
  };
  const varToCode = (t, i, indent, numberVarNamePrefix = "") => {
    let typeName = typeToCode(t.type, indent);
    if (t.type.optional) {
      typeName = `{Some: ${typeName}} | null`;
    }
    return `${t.name ?? `${numberVarNamePrefix}${i}`}: ${typeName}`;
  };
  const argsToCode = (args, indent, asObject) => {
    if (args.length === 1) {
      if (args[0].type.kind === `unit`)
        return ``;
      if ((options == null ? void 0 : options.mode) === "defaultValue") {
        return typeToCode(args[0].type, indent + 1);
      }
      return `${args[0].name ?? `param`}: ${typeToCode(args[0].type, indent + 1)}`;
    }
    const result = `${toIndentedItems(
      indent,
      {},
      args.filter((x) => x.name || x.type.kind !== `unit`).map((a, i) => {
        if (!asObject && (options == null ? void 0 : options.mode) === "defaultValue") {
          return typeToCode(a.type, indent + 1) + `,`;
        }
        return varToCode(a, i, indent + 1, asObject ? "" : "_") + `,`;
      })
    )}`;
    if (asObject) {
      if ((options == null ? void 0 : options.mode) === "defaultValue") {
        return `{${result}}`;
      }
      return `params: {${result}}`;
    }
    return result;
  };
  return {
    usedStrictTypes,
    tabs,
    toIndentedItems,
    typeToCode,
    argsToCode
  };
};

// src/generator/process.ts
var parseContractWithMinimalProtocolLevel = (contractScript, format, contractLevelIndex) => {
  const contractLevels = [
    { name: "PsDELPH1", key: M.Protocol.PsDELPH1 },
    { name: "PtEdo2Zk", key: M.Protocol.PtEdo2Zk },
    { name: "PsFLorena", key: M.Protocol.PsFLorena }
  ];
  const protocol = contractLevels[contractLevelIndex];
  if (!protocol) {
    throw new GenerateApiError(`Could not parse contract script`, contractScript);
  }
  const p = new M.Parser({ protocol: protocol.key });
  try {
    const contract = format === "tz" ? p.parseScript(contractScript) : p.parseJSON(JSON.parse(contractScript));
    if (contract) {
      return {
        contract,
        protocol
      };
    }
  } catch {
  }
  return parseContractWithMinimalProtocolLevel(contractScript, format, contractLevelIndex + 1);
};
var parseContractInterface = (contractScript, format) => {
  const p = new M.Parser({ protocol: M.Protocol.PsFLorena });
  const { contract, protocol } = parseContractWithMinimalProtocolLevel(contractScript, format, 0);
  const contractStorage = contract.find((x) => x.prim === `storage`);
  const contractParameter = contract.find((x) => x.prim === `parameter`);
  const storageResult = contractStorage && parseContractStorage(contractStorage);
  const storage = storageResult ?? { storage: { kind: `object`, raw: { prim: `never` }, fields: [] } };
  const parameterResult = contractParameter && parseContractParameter(contractParameter);
  const methods = (parameterResult == null ? void 0 : parameterResult.methods) ?? [];
  return {
    storage,
    methods,
    contract,
    protocol
  };
};

// src/generator/testing-code-generator.ts
var createTestingCodeGenerator = ({
  contractSource,
  contractFormat
}) => {
  const {
    storage,
    methods
  } = parseContractInterface(contractSource, contractFormat);
  const codeGenerator = createTypescriptCodeGenerator({ mode: "defaultValue" });
  const getMethodByName = (methodName) => {
    const method = methods.find((x) => x.name === methodName);
    if (!method) {
      throw new Error(`Failed to fine method: ${methodName}`);
    }
    return method;
  };
  return {
    storage,
    methods,
    generateOrigination: ({
      contractVarName,
      formatting
    }) => generateOrigination({
      codeGenerator,
      storage,
      indent: formatting == null ? void 0 : formatting.indent
    }),
    generateMethodCall: ({
      methodName,
      formatting
    }) => generateMethodCall({
      codeGenerator,
      method: getMethodByName(methodName),
      indent: formatting == null ? void 0 : formatting.indent
    }),
    generateStorageAccess: ({
      storagePath
    }) => generateStorageAccess({
      codeGenerator,
      storagePath
    })
  };
};
var generateOrigination = ({
  codeGenerator,
  storage,
  indent = 2,
  useSemicolons = true,
  contractVarName = "contract",
  minConfirmations = 3
}) => {
  const {
    tabs,
    argsToCode
  } = codeGenerator;
  const semi = useSemicolons ? ";" : "";
  const code = `
${tabs(indent)}const newContractOrigination = await Tezos.contract.originate<ContractType>({
${tabs(indent + 1)}code: ContractCode.code,
${tabs(indent + 1)}storage: ${argsToCode([{ type: storage.storage }], indent + 1, true)},
${tabs(indent)}})${semi}
${tabs(indent)}const newContractResult = await newContractOrigination.contract()${semi}
${tabs(indent)}const newContractAddress = newContractResult.address${semi}
${tabs(indent)}${contractVarName} = await Tezos.contract.at<ContractType>(newContractAddress)${semi}
${tabs(indent)}`;
  return {
    code
  };
};
var generateMethodCall = ({
  codeGenerator,
  method,
  indent = 2,
  useSemicolons = true,
  contractVarName = "contract",
  minConfirmations = 3
}) => {
  const {
    tabs,
    argsToCode
  } = codeGenerator;
  const semi = useSemicolons ? ";" : "";
  const code = `
${tabs(indent)}const ${method.name}Request = await ${contractVarName}.methodsObject.${method.name}(${argsToCode(method.args, indent + 1, true)}).send()${semi}
${tabs(indent)}await ${method.name}Request.confirmation(${minConfirmations})${semi}
${tabs(indent)}`;
  return {
    code
  };
};
var generateStorageAccess = ({
  codeGenerator,
  storagePath,
  indent = 2,
  useSemicolons = true,
  contractVarName = "contract",
  getStorageValueFunctionName,
  storageVarName = "storage",
  storageValueVarName = "value"
}) => {
  const {
    tabs,
    argsToCode
  } = codeGenerator;
  const semi = useSemicolons ? ";" : "";
  const funcName = getStorageValueFunctionName ?? `getStorageValue${storagePath.split(".").map((x) => x.replace(/[^A-Za-z0-9]/g, "")).map((x) => `${x.substring(0, 1).toLocaleUpperCase()}${x.substring(1)}`).join("")}`;
  const getStorageValueExpr = `${storageVarName}`;
  const funcCode = `
${tabs(indent)}const ${funcName} = async () => {
${tabs(indent + 1)}const ${storageVarName} = await ${contractVarName}.storage()${semi}
${tabs(indent + 1)}const ${storageValueVarName} = ${getStorageValueExpr}${semi}
${tabs(indent + 1)}return ${storageValueVarName}${semi}
${tabs(indent)}}${semi}
`;
  return {
    getStorageValueFunctionCode: funcCode,
    getStorageValueFunctionName: funcName
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createTestingCodeGenerator,
  normalizeContractName
});
//# sourceMappingURL=testing-code-generator.cjs.map