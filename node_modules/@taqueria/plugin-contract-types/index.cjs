"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// index.ts
var taqueria_plugin_contract_types_exports = {};
__export(taqueria_plugin_contract_types_exports, {
  generateContractTypesProcessContractFiles: () => generateContractTypesProcessContractFiles
});
module.exports = __toCommonJS(taqueria_plugin_contract_types_exports);
var import_node_sdk2 = require("@taqueria/node-sdk");

// tasks.ts
var import_node_sdk = require("@taqueria/node-sdk");
var import_fast_glob = __toESM(require("fast-glob"), 1);
var import_path2 = require("path");

// src/cli-process.ts
var import_fs = __toESM(require("fs"), 1);
var import_path = __toESM(require("path"), 1);
var import_util = require("util");

// src/generator/contract-name.ts
var normalizeContractName = (text) => text.replace(/[^A-Za-z0-9]/g, "_").split("_").filter((x) => x).map((x) => x[0].toUpperCase() + x.substring(1)).join("");

// src/generator/process.ts
var M = __toESM(require("@taquito/michel-codec"), 1);

// src/generator/common.ts
var GenerateApiError = class {
  constructor(message, data) {
    this.message = message;
    this.data = data;
    this.name = `GenerateApiError`;
    console.error(`\u274C GenerateApiError: ${message}`, data);
  }
};
var assertExhaustive = (value, message) => {
  console.error(message, { value });
};
var reduceFlatMap = (out, x) => {
  out.push(...x);
  return out;
};

// src/generator/contract-parser.ts
var parseContractStorage = (storage) => {
  const fields = storage.args.map((x) => visitVar(x)).reduce(reduceFlatMap, []);
  if (fields.length === 1 && !fields[0].name) {
    return {
      storage: fields[0].type
    };
  }
  return {
    storage: {
      kind: `object`,
      raw: storage,
      fields
    }
  };
};
var parseContractParameter = (parameter) => {
  return {
    methods: parameter.args.map((x) => visitContractParameterEndpoint(x)).reduce(reduceFlatMap, [])
  };
};
var visitContractParameterEndpoint = (node) => {
  var _a, _b;
  if (node.prim === `or`) {
    return node.args.map((x) => visitContractParameterEndpoint(x)).reduce(reduceFlatMap, []);
  }
  if (node.prim === `list` && node.args.length === 1 && ((_a = node.args[0]) == null ? void 0 : _a.prim) === `or`) {
    return node.args.map((x) => visitContractParameterEndpoint(x)).reduce(reduceFlatMap, []);
  }
  const nameRaw = (_b = node.annots) == null ? void 0 : _b[0];
  const name = (nameRaw == null ? void 0 : nameRaw.startsWith("%")) ? nameRaw.substr(1) : "default";
  if (!name) {
    console.warn(`Unknown method: ${node.prim}`, { node, args: node.args });
    return [];
  }
  const nodeType = visitType(node, { ignorePairName: node.prim === "pair" });
  if (nodeType.kind === "object") {
    return [{ name, args: nodeType.fields }];
  }
  return [{
    name,
    args: [{ type: nodeType }]
  }];
};
var visitVar = (node) => {
  var _a;
  const name = `annots` in node && ((_a = node.annots) == null ? void 0 : _a.length) === 1 ? node.annots[0].substr(1) : void 0;
  const type = visitType(node);
  return [{
    name,
    type
  }];
};
var visitType = (node, options) => {
  if (!(`prim` in node)) {
    console.error(`visitType no prim`, { node });
    return { kind: `unknown`, raw: node };
  }
  if (node.prim === `or`) {
    const unionVars = node.args.map((x) => visitVar(x)).reduce(reduceFlatMap, []).map((x) => x);
    const union = unionVars.map((x) => !x.name && x.type.kind === "union" ? x.type.union : [x]).reduce(reduceFlatMap, []);
    if (union.some((x) => !x)) {
      throw new GenerateApiError(`or: Some fields are null`, { node });
    }
    return {
      kind: `union`,
      raw: node,
      union
    };
  }
  if (node.prim === `pair`) {
    const fields = node.args.map((x) => visitVar(x)).reduce(reduceFlatMap, []);
    if (fields.some((x) => !x)) {
      throw new GenerateApiError(`pair: Some fields are null`, { node, args: node.args, fields });
    }
    const fieldsFlat = fields.map(
      (x) => (!x.name || (options == null ? void 0 : options.ignorePairName)) && x.type.kind === "object" ? x.type.fields : [x]
    ).reduce(reduceFlatMap, []);
    return {
      kind: `object`,
      raw: node,
      fields: fieldsFlat
    };
  }
  if (node.prim === `list` || node.prim === `set`) {
    if (node.args.length !== 1) {
      throw new GenerateApiError(`list does not have 1 arg`, { node, args: node.args });
    }
    const arrayItem = visitType(node.args[0]);
    if (!arrayItem) {
      throw new GenerateApiError(`arrayItem are null`, { node, args: node.args, arrayItem });
    }
    return {
      kind: `array`,
      raw: node,
      array: { item: arrayItem }
    };
  }
  if (node.prim === `map` || node.prim === `big_map`) {
    if (node.args.length !== 2) {
      throw new GenerateApiError(`map does not have 2 args`, { node, args: node.args });
    }
    const mapKey = visitType(node.args[0]);
    const mapValue = visitType(node.args[1]);
    if (!mapKey || !mapValue) {
      throw new GenerateApiError(`map is missing key or value`, { node, args: node.args, mapKey, mapValue });
    }
    return {
      kind: `map`,
      raw: node,
      map: {
        key: mapKey,
        value: mapValue,
        isBigMap: node.prim === `big_map`
      }
    };
  }
  if (node.prim === `option`) {
    return {
      ...visitType(node.args[0]),
      optional: true
    };
  }
  if (node.prim === `bool`) {
    return {
      kind: `value`,
      raw: node,
      value: node.prim,
      typescriptType: `boolean`
    };
  }
  if (node.prim === `nat` || node.prim === `int` || node.prim === `mutez`) {
    return {
      kind: `value`,
      raw: node,
      value: node.prim,
      typescriptType: `number`
    };
  }
  if (node.prim === `timestamp`) {
    return {
      kind: `value`,
      raw: node,
      value: node.prim,
      typescriptType: `Date`
    };
  }
  if (node.prim === `address` || node.prim === `key` || node.prim === `key_hash` || node.prim === `chain_id` || node.prim === `string` || node.prim === `signature` || node.prim === `ticket` || node.prim === `bls12_381_fr` || node.prim === `bls12_381_g1` || node.prim === `bls12_381_g2` || node.prim === `sapling_state` || node.prim === `sapling_transaction` || node.prim === `contract`) {
    return {
      kind: `value`,
      raw: node,
      value: node.prim,
      typescriptType: `string`
    };
  }
  if (node.prim === `unit`) {
    return {
      kind: `unit`,
      raw: node
    };
  }
  if (node.prim === `bytes`) {
    return {
      kind: `value`,
      raw: node,
      value: node.prim,
      typescriptType: `string`
    };
  }
  if (node.prim === `lambda`) {
    if (node.args.length !== 2) {
      throw new GenerateApiError(`lambda does not have 2 args`, { node, args: node.args });
    }
    const argType = visitType(node.args[0]);
    const retType = visitType(node.args[1]);
    if (!argType || !retType) {
      throw new GenerateApiError(`lambda is missing arg or return`, { node, args: node.args, argType, retType });
    }
    return {
      kind: `lambda`,
      raw: node,
      lambda: {
        arg: argType,
        ret: retType
      }
    };
  }
  if (node.prim === `operation`) {
    return {
      kind: `value`,
      raw: node,
      value: node.prim,
      typescriptType: `string`
    };
  }
  if (node.prim === "chest" || node.prim === "chest_key") {
    return {
      kind: `value`,
      raw: node,
      value: node.prim,
      typescriptType: `string`
    };
  }
  if (node.prim === `never`) {
    return {
      kind: `never`,
      raw: node
    };
  }
  assertExhaustive(node, `Unknown type`);
  throw new GenerateApiError(`Unknown type`, { node });
};

// src/generator/schema-output.ts
var toSchema = (methods, storage) => {
  const getSchemaObjectType = (vars) => {
    if (vars.some((x) => !x)) {
      throw new GenerateApiError(`getSchemaObjectType has null vars`, { vars });
    }
    return vars.reduce((out, x, i) => {
      out[x.name ?? i] = getSchemaType(x.type);
      return out;
    }, {});
  };
  const getSchemaType = (t) => {
    return (t.kind === `value` && t.value ? t.value : null) ?? (t.kind === `array` && t.array ? [getSchemaType(t.array.item)] : null) ?? (t.kind === `map` && t.map ? [`map`, getSchemaType(t.map.key), getSchemaType(t.map.value)] : null) ?? (t.kind === `object` && t.fields ? getSchemaObjectType(t.fields) : null) ?? (t.kind === `unit` ? `unit` : null) ?? (t.kind === `never` ? `never` : null) ?? (t.kind === "lambda" ? ["lambda", getSchemaType(t.lambda.arg), getSchemaType(t.lambda.ret)] : null) ?? `${t.raw}`;
  };
  const schemaMethods = methods.reduce((out, x) => {
    out[x.name] = {
      params: x.args.length === 1 && !x.args[0].name ? getSchemaType(x.args[0].type) : getSchemaObjectType(x.args ?? [])
    };
    return out;
  }, {});
  const schemaStorage = getSchemaType(storage.storage);
  return {
    methods: schemaMethods,
    storage: schemaStorage
  };
};

// src/generator/typescript-output.ts
var createTypescriptCodeGenerator = (options) => {
  const usedStrictTypes = [];
  const addTypeAlias = (strictType) => {
    if (!usedStrictTypes.some((x) => x.aliasType === strictType.aliasType)) {
      usedStrictTypes.push(strictType);
    }
  };
  const tabs = (indent) => Array(indent).fill(`    `).join(``);
  const toIndentedItems = (indent, delimiters, items) => {
    return `
${tabs(indent + 1)}${items.join(`${delimiters.afterItem ?? ``}
${tabs(indent + 1)}${delimiters.beforeItem ?? ``}`)}
${tabs(indent)}`;
  };
  const typeToCode = (t, indent) => {
    if ((options == null ? void 0 : options.mode) === "defaultValue") {
      return typeToCode_defaultValue(t, indent);
    }
    if (t.kind === `value`) {
      const prim = `prim` in t.raw ? t.raw.prim : `unknown`;
      if (t.typescriptType === `boolean` || t.typescriptType === `string` && prim === `string`) {
        return `${t.typescriptType}`;
      }
      if (t.typescriptType === "number") {
        const simpleBaseType2 = `string | BigNumber | number`;
        const typeAlias2 = {
          aliasType: prim,
          simpleTypeDefinition: `type ${prim} = ${simpleBaseType2};`,
          simpleTypeImports: [{ name: "BigNumber", isDefault: true, from: "bignumber.js" }]
        };
        addTypeAlias(typeAlias2);
        return typeAlias2.aliasType;
      }
      const simpleBaseType = t.typescriptType === "Date" ? "Date | string" : t.typescriptType;
      const typeAlias = { aliasType: prim, simpleTypeDefinition: `type ${prim} = ${simpleBaseType};` };
      addTypeAlias(typeAlias);
      return typeAlias.aliasType;
    }
    if (t.kind === `array`) {
      return `Array<${typeToCode(t.array.item, indent)}>`;
    }
    if (t.kind === `map`) {
      const typeAlias = t.map.isBigMap ? {
        aliasType: `BigMap`,
        simpleTypeDefinition: "type BigMap<K, T> = MichelsonMap<K, T>;",
        simpleTypeImports: [{ name: "MichelsonMap", from: "@taquito/taquito" }]
      } : {
        aliasType: `MMap`,
        simpleTypeDefinition: "type MMap<K, T> = MichelsonMap<K, T>;",
        simpleTypeImports: [{ name: "MichelsonMap", from: "@taquito/taquito" }]
      };
      addTypeAlias(typeAlias);
      return `${typeAlias.aliasType}<${typeToCode(t.map.key, indent)}, ${typeToCode(t.map.value, indent)}>`;
    }
    if (t.kind === `lambda`) {
      const typeAlias = {
        aliasType: "Instruction",
        simpleTypeDefinition: `type Instruction = MichelsonInstruction;`,
        simpleTypeImports: [{ name: "MichelsonInstruction", isDefault: false, from: "@taquito/michel-codec" }]
      };
      addTypeAlias(typeAlias);
      return `Instruction[]`;
    }
    if (t.kind === `object`) {
      return `{${toIndentedItems(indent, {}, t.fields.map((a, i) => varToCode(a, i, indent + 1) + `;`))}}`;
    }
    if (t.kind === `union`) {
      const getUnionItem = (a, i) => {
        const itemCode = `${varToCode(a, i, indent + 1)}`;
        if (!itemCode.includes(`
`)) {
          return `{ ${itemCode} }`;
        }
        return `{${toIndentedItems(indent + 1, {}, [`${varToCode(a, i, indent + 2)}`])}}`;
      };
      return `(${toIndentedItems(indent, { beforeItem: `| ` }, t.union.map(getUnionItem))})`;
    }
    if (t.kind === `unit`) {
      const typeAlias = {
        aliasType: `unit`,
        simpleTypeDefinition: `type unit = (true | undefined);`
      };
      addTypeAlias(typeAlias);
      return typeAlias.aliasType;
    }
    if (t.kind === `never`) {
      return `never`;
    }
    if (t.kind === `unknown`) {
      return `unknown`;
    }
    assertExhaustive(t, `Unknown type`);
    throw new GenerateApiError(`Unknown type node`, { t });
  };
  const typeToCode_defaultValue = (t, indent) => {
    if (t.kind === `value`) {
      const prim = `prim` in t.raw ? t.raw.prim : `unknown`;
      if (t.typescriptType === "boolean") {
        return `true`;
      }
      if (t.typescriptType === `string` && prim === `string`) {
        return `'VALUE'`;
      }
      if (t.typescriptType === "number") {
        return `tas.${prim}('42')`;
      }
      if (t.typescriptType === "Date") {
        return `tas.timestamp(new Date())`;
      }
      if (prim === "address" || prim === "contract") {
        return `tas.${prim}('tz1ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456')`;
      }
      if (prim === "bytes") {
        return `tas.${prim}(char2Bytes('DATA'))`;
      }
      if (t.typescriptType === "string") {
        return `tas.${prim}('VALUE')`;
      }
      assertExhaustive(t.typescriptType, `Unknown value type`);
      return prim;
    }
    if (t.kind === `array`) {
      return `[${typeToCode(t.array.item, indent)}]`;
    }
    if (t.kind === `map`) {
      const keyPrim = `prim` in t.map.key.raw ? t.map.key.raw.prim : `unknown`;
      const isStringBasedKey = t.map.key.kind === "value" && keyPrim === "string";
      if (isStringBasedKey) {
        return `tas.${t.map.isBigMap ? "bigMap" : "map"}({ 
${tabs(indent + 1)}${typeToCode(t.map.key, indent)}: ${typeToCode(t.map.value, indent)},
${tabs(indent)}})`;
      }
      return `tas.${t.map.isBigMap ? "bigMap" : "map"}([{ 
${tabs(indent + 1)}key: ${typeToCode(t.map.key, indent)}, 
${tabs(indent + 1)}value: ${typeToCode(t.map.value, indent)},
${tabs(indent)}}])`;
    }
    if (t.kind === `object`) {
      const delimiter = (options == null ? void 0 : options.mode) === "defaultValue" ? "," : `;`;
      return `{${toIndentedItems(indent, {}, t.fields.map((a, i) => varToCode(a, i, indent + 1) + delimiter))}}`;
    }
    if (t.kind === `union`) {
      const getUnionItem = (a, i) => {
        const itemCode = `${varToCode(a, i, indent + 1)}`;
        if (!itemCode.includes(`
`)) {
          return `{ ${itemCode} }`;
        }
        return `{${toIndentedItems(indent + 1, {}, [`${varToCode(a, i, indent + 2)}`])}}`;
      };
      return `(${toIndentedItems(indent, { beforeItem: `| ` }, t.union.map(getUnionItem))})`;
    }
    if (t.kind === `unit`) {
      return `tas.unit()`;
    }
    if (t.kind === `never`) {
      return `never`;
    }
    if (t.kind === `unknown`) {
      return `unknown`;
    }
    if (t.kind === "lambda") {
      return `tas.lambda([])`;
    }
    assertExhaustive(t, `Unknown type`);
    throw new GenerateApiError(`Unknown type node`, { t });
  };
  const varToCode = (t, i, indent, numberVarNamePrefix = "") => {
    let typeName = typeToCode(t.type, indent);
    if (t.type.optional) {
      typeName = `{Some: ${typeName}} | null`;
    }
    return `${t.name ?? `${numberVarNamePrefix}${i}`}: ${typeName}`;
  };
  const argsToCode = (args, indent, asObject) => {
    if (args.length === 1) {
      if (args[0].type.kind === `unit`)
        return ``;
      if ((options == null ? void 0 : options.mode) === "defaultValue") {
        return typeToCode(args[0].type, indent + 1);
      }
      return `${args[0].name ?? `param`}: ${typeToCode(args[0].type, indent + 1)}`;
    }
    const result = `${toIndentedItems(
      indent,
      {},
      args.filter((x) => x.name || x.type.kind !== `unit`).map((a, i) => {
        if (!asObject && (options == null ? void 0 : options.mode) === "defaultValue") {
          return typeToCode(a.type, indent + 1) + `,`;
        }
        return varToCode(a, i, indent + 1, asObject ? "" : "_") + `,`;
      })
    )}`;
    if (asObject) {
      if ((options == null ? void 0 : options.mode) === "defaultValue") {
        return `{${result}}`;
      }
      return `params: {${result}}`;
    }
    return result;
  };
  return {
    usedStrictTypes,
    tabs,
    toIndentedItems,
    typeToCode,
    argsToCode
  };
};
var toTypescriptCode = (storage, methods, contractName, parsedContract, protocol, typeAliasData, typeUtilsData) => {
  const {
    usedStrictTypes,
    toIndentedItems,
    typeToCode,
    argsToCode
  } = createTypescriptCodeGenerator();
  const methodsToCode = (indent) => {
    const methodFields = methods.map((x) => {
      const methodCode = `${x.name}: (${argsToCode(x.args, indent + 1, false)}) => Promise<void>;`;
      return methodCode;
    });
    const methodsTypeCode = `type Methods = {${toIndentedItems(indent, {}, methodFields)}};`;
    return methodsTypeCode;
  };
  const methodsObjectToCode = (indent) => {
    const methodFields = methods.map((x) => {
      const methodCode = `${x.name}: (${argsToCode(x.args, indent + 1, true)}) => Promise<void>;`;
      return methodCode;
    });
    const methodsTypeCode = `type MethodsObject = {${toIndentedItems(indent, {}, methodFields)}};`;
    return methodsTypeCode;
  };
  const storageToCode = (indent) => {
    const storageTypeCode = `export type Storage = ${typeToCode(storage.storage, indent)};`;
    return storageTypeCode;
  };
  const methodsCode = methodsToCode(0);
  const methodsObjectCode = methodsObjectToCode(0);
  const storageCode = storageToCode(0);
  const simpleTypeMappingImportsAll = new Map(
    usedStrictTypes.map((x) => x.simpleTypeImports ?? []).reduce(reduceFlatMap, []).map(
      (x) => [`${x == null ? void 0 : x.from}:${x == null ? void 0 : x.name}:${x == null ? void 0 : x.isDefault}`, x]
    )
  );
  const simpleTypeMappingImportsFrom = [...simpleTypeMappingImportsAll.values()].reduce((out, x) => {
    const entry = out[x.from] ?? (out[x.from] = { names: [] });
    if (x.isDefault) {
      entry.default = x.name;
    } else {
      entry.names.push(x.name);
    }
    entry.names.sort((a, b) => a.localeCompare(b));
    return out;
  }, {});
  const simpleTypeMappingImportsText = Object.keys(simpleTypeMappingImportsFrom).map((k) => {
    const entry = simpleTypeMappingImportsFrom[k];
    const items = [entry.default, entry.names.length ? `{ ${entry.names.join(", ")} }` : ""].filter((x) => x);
    return `import ${items.join(", ")} from '${k}';
`;
  }).join("");
  const simpleTypeMapping = usedStrictTypes.sort((a, b) => a.aliasType.localeCompare(b.aliasType)).map((x) => x.simpleTypeDefinition).join(`
`);
  const typeUtilsDefinitions = `import { ContractAbstractionFromContractType, WalletContractAbstractionFromContractType } from '${typeUtilsData.importPath}';`;
  const typeAliasesDefinitions = typeAliasData.mode === "simple" ? `${simpleTypeMappingImportsText}${simpleTypeMapping}` : typeAliasData.mode === "local" ? typeAliasData.fileContent : `import { ${usedStrictTypes.map((x) => x.aliasType).join(`, `)} } from '${typeAliasData.importPath}';`;
  const contractTypeName = `${contractName}ContractType`;
  const walletTypeName = `${contractName}WalletType`;
  const codeName = `${contractName}Code`;
  const typesFileContent = `
${typeUtilsDefinitions}
${typeAliasesDefinitions}

${storageCode}

${methodsCode}

${methodsObjectCode}

type contractTypes = { methods: Methods, methodsObject: MethodsObject, storage: Storage, code: { __type: '${codeName}', protocol: string, code: object[] } };
export type ${contractTypeName} = ContractAbstractionFromContractType<contractTypes>;
export type ${walletTypeName} = WalletContractAbstractionFromContractType<contractTypes>;
`;
  const contractCodeFileContent = `
export const ${codeName}: { __type: '${codeName}', protocol: string, code: object[] } = {
    __type: '${codeName}',
    protocol: '${protocol.key}',
    code: JSON.parse(\`${JSON.stringify(parsedContract)}\`)
};
`;
  return {
    typesFileContent,
    contractCodeFileContent,
    storage: storageCode,
    methods: methodsCode,
    methodsObject: methodsObjectCode
  };
};

// src/generator/process.ts
var parseContractWithMinimalProtocolLevel = (contractScript, format, contractLevelIndex) => {
  const contractLevels = [
    { name: "PsDELPH1", key: M.Protocol.PsDELPH1 },
    { name: "PtEdo2Zk", key: M.Protocol.PtEdo2Zk },
    { name: "PsFLorena", key: M.Protocol.PsFLorena }
  ];
  const protocol = contractLevels[contractLevelIndex];
  if (!protocol) {
    throw new GenerateApiError(`Could not parse contract script`, contractScript);
  }
  const p = new M.Parser({ protocol: protocol.key });
  try {
    const contract = format === "tz" ? p.parseScript(contractScript) : p.parseJSON(JSON.parse(contractScript));
    if (contract) {
      return {
        contract,
        protocol
      };
    }
  } catch {
  }
  return parseContractWithMinimalProtocolLevel(contractScript, format, contractLevelIndex + 1);
};
var parseContractInterface = (contractScript, format) => {
  const p = new M.Parser({ protocol: M.Protocol.PsFLorena });
  const { contract, protocol } = parseContractWithMinimalProtocolLevel(contractScript, format, 0);
  const contractStorage = contract.find((x) => x.prim === `storage`);
  const contractParameter = contract.find((x) => x.prim === `parameter`);
  const storageResult = contractStorage && parseContractStorage(contractStorage);
  const storage = storageResult ?? { storage: { kind: `object`, raw: { prim: `never` }, fields: [] } };
  const parameterResult = contractParameter && parseContractParameter(contractParameter);
  const methods = (parameterResult == null ? void 0 : parameterResult.methods) ?? [];
  return {
    storage,
    methods,
    contract,
    protocol
  };
};
var generateContractTypesFromMichelsonCode = (contractScript, contractName, format, typeAliasData, typeUtilsData) => {
  const {
    storage,
    methods,
    contract,
    protocol
  } = parseContractInterface(
    contractScript,
    format
  );
  if (methods.length === 1)
    methods[0].name = `default`;
  const schemaOutput = toSchema(methods, storage);
  const typescriptCode = toTypescriptCode(
    storage,
    methods,
    contractName,
    contract,
    protocol,
    typeAliasData,
    typeUtilsData
  );
  return {
    schemaOutput,
    typescriptCodeOutput: typescriptCode,
    parsedContract: contract,
    minimalProtocol: protocol.key
  };
};

// src/type-aliases-file-content.ts
var typeAliasesFileContent = `
import { assertMichelsonInstruction, Expr, MichelsonCode } from '@taquito/michel-codec';
import { MichelsonMap } from '@taquito/taquito';
import { BigNumber } from 'bignumber.js';

export type Instruction = MichelsonCode;

export type unit = (true | undefined) & { __type: 'unit' };

export type address = string & { __type: 'address' };
export type bytes = string & { __type: 'bytes' };
export type contract = string & { __type: 'contract' };
export type operation = string & { __type: 'operation' };
export type key = string & { __type: 'key' };
export type key_hash = string & { __type: 'key_hash' };
export type signature = string & { __type: 'signature' };
export type ticket = string & { __type: 'ticket' };

export type timestamp = string & { __type: 'timestamp' };

export type int = BigNumber & { __type: 'int' };
export type nat = BigNumber & { __type: 'nat' };

export type mutez = BigNumber & { __type: 'mutez' };
export type tez = BigNumber & { __type: 'tez' };

type MapKey = Array<any> | object | string | boolean | number;
export type MMap<K extends MapKey, V> = Omit<MichelsonMap<K, V>, 'get'> & { get: (key: K) => V };
export type BigMap<K extends MapKey, V> = Omit<MichelsonMap<K, V>, 'get'> & { get: (key: K) => Promise<V> };

export type chest = string & { __type: 'chest' };
export type chest_key = string & { __type: 'chest_key' };

const createStringTypeTas = <T extends string>() => {
	return (value: string): T => value as T;
};

const createBigNumberTypeTas = <T extends BigNumber>() => {
	return (value: number | BigNumber | string): T => new BigNumber(value) as T;
};

type asMapParamOf<K, V> = K extends string ? { [key: string]: V } | Array<{ key: K; value: V }>
	: K extends number ? { [key: number]: V } | Array<{ key: K; value: V }>
	: Array<{ key: K; value: V }>;

function asMap<K extends MapKey, V>(value: asMapParamOf<K, V>): MMap<K, V> {
	const m = new MichelsonMap<K, V>();
	if (Array.isArray(value)) {
		const vArray = value as Array<{ key: K; value: V }>;
		vArray.forEach(x => m.set(x.key, x.value));
	} else {
		const vObject = value as { [key: string]: V };
		Object.keys(vObject).forEach(key => m.set(key as unknown as K, vObject[key]));
	}
	return m as MMap<K, V>;
}
const asBigMap = <K extends MapKey, V>(value: asMapParamOf<K, V>) => asMap(value) as unknown as BigMap<K, V>;

function add<T extends BigNumber>(a: T, b: T): T {
	return a.plus(b) as T;
}
function subtract<T extends BigNumber>(a: T, b: T): T {
	return a.minus(b) as T;
}

function createLambdaTypeTas(expr: Expr): MichelsonCode {
	assertMichelsonInstruction(expr);
    return expr as MichelsonCode;
}

/** tas: Tezos 'as' casting for strict types */
export const tas = {
	address: createStringTypeTas<address>(),
	bytes: createStringTypeTas<bytes>(),
	contract: createStringTypeTas<contract>(),
	chest: createStringTypeTas<chest>(),
	chest_key: createStringTypeTas<chest_key>(),
	timestamp: (value: string | Date): timestamp => new Date(value).toISOString() as timestamp,

	int: createBigNumberTypeTas<int>(),
	nat: createBigNumberTypeTas<nat>(),
	mutez: createBigNumberTypeTas<mutez>(),
	tez: createBigNumberTypeTas<tez>(),

	map: asMap,
	bigMap: asBigMap,

	// Operations
	add,
	subtract,

    lambda: createLambdaTypeTas,

	// To number
	number: (value: string | BigNumber) => Number(value + ''),
	unit: () => true as unit,
};
`;

// src/type-utils-file-content.ts
var typeUtilsFileContent = `
import { ContractAbstraction, ContractMethod, ContractMethodObject, ContractProvider, Wallet } from '@taquito/taquito';

type BaseContractType = { methods: unknown, methodsObject: unknown, storage: unknown };

type ContractMethodsOf<T extends ContractProvider | Wallet, TContract extends BaseContractType> = {
[M in keyof TContract['methods']]:
TContract['methods'][M] extends (...args: infer A) => unknown
? (...args: A) => ContractMethod<T>
: never
};
type ContractMethodsObjectsOf<T extends ContractProvider | Wallet, TContract extends BaseContractType> = {
[M in keyof TContract['methodsObject']]:
TContract['methodsObject'][M] extends (...args: infer A) => unknown
? (...args: A) => ContractMethodObject<T>
: never
};
type ContractStorageOf<TContract extends BaseContractType> = TContract['storage'];

export type ContractAbstractionFromContractType<TContract extends BaseContractType> = 
    ContractAbstraction<ContractProvider, 
        ContractMethodsOf<ContractProvider, TContract>,
        ContractMethodsObjectsOf<ContractProvider, TContract>,
        {},
        {},
        ContractStorageOf<TContract>
    >;

export type WalletContractAbstractionFromContractType<TContract extends BaseContractType> = 
    ContractAbstraction<Wallet, 
        ContractMethodsOf<Wallet, TContract>,
        ContractMethodsObjectsOf<Wallet, TContract>,
        {},
        {},
        ContractStorageOf<TContract>
    >;
`;

// src/cli-process.ts
var fs = {
  mkdir: (0, import_util.promisify)(import_fs.default.mkdir),
  copyFile: (0, import_util.promisify)(import_fs.default.copyFile),
  readdir: (0, import_util.promisify)(import_fs.default.readdir),
  readFile: (0, import_util.promisify)(import_fs.default.readFile),
  writeFile: (0, import_util.promisify)(import_fs.default.writeFile),
  stat: (0, import_util.promisify)(import_fs.default.stat),
  exists: import_fs.default.existsSync
};
var getAllFiles = async (rootPath, filter) => {
  const allFiles = [];
  const getAllFilesRecursive = async (dirPath) => {
    let files = await fs.readdir(dirPath, { withFileTypes: true });
    for (const f of files) {
      const subPath = import_path.default.resolve(dirPath, f.name);
      if (f.isDirectory()) {
        await getAllFilesRecursive(subPath);
        continue;
      }
      if (!filter(subPath)) {
        continue;
      }
      allFiles.push(subPath);
    }
  };
  await getAllFilesRecursive(rootPath);
  return allFiles;
};
var generateContractTypesProcessContractFiles = async ({
  inputTzContractDirectory,
  inputFiles,
  outputTypescriptDirectory,
  format,
  typeAliasMode
}) => {
  console.log(
    `Generating Types: ${import_path.default.resolve(inputTzContractDirectory)} => ${import_path.default.resolve(outputTypescriptDirectory)}`
  );
  const ext = "." + format;
  const filesAll = await getAllFiles(inputTzContractDirectory, (x) => x.endsWith(ext));
  const files = inputFiles ? filesAll.filter((f) => inputFiles.some((inputFile) => f.endsWith(inputFile))) : filesAll;
  console.log(`Contracts Found: ${[``, ...files].join(`
	- `)}`);
  const typeAliasImportPath = `@taquito/contract-type-generator`;
  const typeAliasData = typeAliasMode === "local" ? { mode: typeAliasMode, fileContent: typeAliasesFileContent } : typeAliasMode === "file" ? { mode: typeAliasMode, importPath: `./type-aliases` } : typeAliasMode === "library" ? { mode: typeAliasMode, importPath: typeAliasImportPath } : { mode: "simple" };
  if (typeAliasMode === "file") {
    await fs.mkdir(outputTypescriptDirectory, { recursive: true });
    await fs.writeFile(import_path.default.join(outputTypescriptDirectory, "./type-aliases.ts"), typeAliasesFileContent);
  }
  const typeUtilsData = { importPath: `./type-utils` };
  await fs.mkdir(outputTypescriptDirectory, { recursive: true });
  await fs.writeFile(import_path.default.join(outputTypescriptDirectory, "./type-utils.ts"), typeUtilsFileContent);
  for (const fullPath of files) {
    const fileRelativePath = fullPath.replace(import_path.default.resolve(inputTzContractDirectory), "");
    const fileName = fileRelativePath.replace(ext, "");
    const inputFilePath = import_path.default.join(inputTzContractDirectory, fileRelativePath);
    const typesOutputFilePath = import_path.default.join(outputTypescriptDirectory, fileRelativePath.replace(ext, `.types.ts`));
    const codeContentOutputFilePath = import_path.default.join(outputTypescriptDirectory, fileRelativePath.replace(ext, `.code.ts`));
    const schemaContentOutputFilePath = import_path.default.join(
      outputTypescriptDirectory,
      fileRelativePath.replace(ext, `.schema.json`)
    );
    console.log(`Processing ${fileRelativePath}...`);
    try {
      const contractTypeName = normalizeContractName(fileName);
      const michelsonCode = await fs.readFile(inputFilePath, { encoding: `utf8` });
      const {
        schemaOutput,
        typescriptCodeOutput: { typesFileContent: typesFileContentRaw, contractCodeFileContent }
      } = generateContractTypesFromMichelsonCode(michelsonCode, contractTypeName, format, typeAliasData, typeUtilsData);
      const nestedDirDepth = fileRelativePath.replace(/^.?\/?/, "").split("/").length - 1;
      const typesFileContent = nestedDirDepth <= 0 ? typesFileContentRaw : typesFileContentRaw.replace(
        /from '\.\//g,
        `from '${[...new Array(nestedDirDepth)].map(() => "../").join("")}`
      );
      await fs.mkdir(import_path.default.dirname(typesOutputFilePath), { recursive: true });
      await fs.writeFile(typesOutputFilePath, typesFileContent);
      await fs.writeFile(codeContentOutputFilePath, contractCodeFileContent);
      const debugSchema = false;
      if (debugSchema) {
        await fs.writeFile(schemaContentOutputFilePath, JSON.stringify(schemaOutput, null, 2));
      }
    } catch (err) {
      console.error(`\u274C Could not process ${fileRelativePath}`, { err });
    }
  }
};

// tasks.ts
var getContractAbspath = (contractFilename, parsedArgs) => (0, import_path2.join)(
  parsedArgs.config.artifactsDir ?? "artifacts",
  /\.tz$/.test(contractFilename) ? contractFilename : `${contractFilename}.tz`
);
var generateContractTypes = (parsedArgs) => async (contractFilename) => {
  const contractAbspath = getContractAbspath(contractFilename, parsedArgs);
  await generateContractTypesProcessContractFiles({
    inputTzContractDirectory: parsedArgs.config.artifactsDir ?? "artifacts",
    inputFiles: [contractAbspath],
    outputTypescriptDirectory: parsedArgs.typescriptDir || "types",
    format: "tz",
    typeAliasMode: parsedArgs.typeAliasMode ?? "file"
  });
  return `${contractFilename}: Types generated`;
};
var generateContractTypesAll = async (parsedArgs) => {
  const files = await (0, import_fast_glob.default)("**/*.tz", { cwd: parsedArgs.config.artifactsDir });
  const contractFiles = files.filter(import_node_sdk.isContractFile);
  return await Promise.all(contractFiles.map(generateContractTypes(parsedArgs)));
};
var generateTypes = (parsedArgs) => {
  parsedArgs.typescriptDir = parsedArgs.typescriptDir || "types";
  console.log("generateTypes", {
    typescriptDir: parsedArgs.typescriptDir
  });
  const p = parsedArgs.contract ? generateContractTypes(parsedArgs)(parsedArgs.contract) : generateContractTypesAll(parsedArgs);
  return p.then((data) => {
    console.log(
      Array.isArray(data) ? data.join("\n") : data
    );
  });
};
var tasks = {
  generateTypes
};

// index.ts
import_node_sdk2.Plugin.create((i18n) => ({
  alias: "contract-types",
  schema: "1.0",
  version: "0.1",
  tasks: [
    import_node_sdk2.Task.create({
      task: "generate types",
      command: "generate types [typescriptDir]",
      description: "Generate types for a contract to be used with taquito",
      positionals: [
        import_node_sdk2.PositionalArg.create({
          placeholder: "typescriptDir",
          description: "The output directory for the generated type files",
          defaultValue: "types"
        })
      ],
      options: [
        import_node_sdk2.Option.create({
          shortFlag: "t",
          flag: "typeAliasMode",
          choices: ["file", "simple"],
          description: "The type aliases used in the generated types"
        })
      ],
      aliases: ["gen types", "gentypes"],
      handler: "proxy"
    })
  ],
  proxy: tasks.generateTypes
}), process.argv);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  generateContractTypesProcessContractFiles
});
//# sourceMappingURL=index.cjs.map