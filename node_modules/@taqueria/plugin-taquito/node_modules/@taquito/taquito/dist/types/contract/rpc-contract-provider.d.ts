import { BigMapKeyType, MichelsonMap, MichelsonMapKey, Schema } from '@taquito/michelson-encoder';
import { OperationBatch } from '../batch/rpc-batch-provider';
import { Context } from '../context';
import { DelegateOperation } from '../operations/delegate-operation';
import { OriginationOperation } from '../operations/origination-operation';
import { RegisterGlobalConstantOperation } from '../operations/register-global-constant-operation';
import { RevealOperation } from '../operations/reveal-operation';
import { TransactionOperation } from '../operations/transaction-operation';
import { DelegateParams, OriginateParams, ParamsWithKind, RegisterDelegateParams, RegisterGlobalConstantParams, RevealParams, TransferParams, TransferTicketParams, IncreasePaidStorageParams, DrainDelegateParams, BallotParams, ProposalsParams, UpdateConsensusKeyParams, SmartRollupAddMessagesParams, SmartRollupOriginateParams } from '../operations/types';
import { DefaultContractType, ContractStorageType, ContractAbstraction } from './contract';
import { ContractProvider, ContractSchema, StorageProvider } from './interface';
import { EstimationProvider } from '../estimate/estimate-provider-interface';
import { TransferTicketOperation } from '../operations/transfer-ticket-operation';
import { IncreasePaidStorageOperation } from '../operations/increase-paid-storage-operation';
import { BallotOperation } from '../operations/ballot-operation';
import { DrainDelegateOperation } from '../operations/drain-delegate-operation';
import { ProposalsOperation } from '../operations/proposals-operation';
import { UpdateConsensusKeyOperation } from '../operations/update-consensus-key-operation';
import { SmartRollupAddMessagesOperation } from '../operations/smart-rollup-add-messages-operation';
import { SmartRollupOriginateOperation } from '../operations/smart-rollup-originate-operation';
import { Provider } from '../provider';
export declare class RpcContractProvider extends Provider implements ContractProvider, StorageProvider {
    private estimator;
    constructor(context: Context, estimator: EstimationProvider);
    contractProviderTypeSymbol: symbol;
    private prepare;
    /**
     *
     * @description Return a well formatted json object of the contract storage
     *
     * @param contract contract address you want to get the storage from
     * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema
     * @throws {@link InvalidContractAddressError}
     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script
     */
    getStorage<T>(contract: string, schema?: ContractSchema): Promise<T>;
    /**
     *
     * @description Return a well formatted json object of the contract big map storage
     *
     * @param contract contract address you want to get the storage from
     * @param key contract big map key to fetch value from
     * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema
     * @throws {@link InvalidContractAddressError}
     * @deprecated Deprecated in favor of getBigMapKeyByID
     *
     * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get
     */
    getBigMapKey<T>(contract: string, key: string, schema?: ContractSchema): Promise<T>;
    /**
     *
     * @description Return a well formatted json object of a big map value
     *
     * @param id Big Map ID
     * @param keyToEncode key to query (will be encoded properly according to the schema)
     * @param schema Big Map schema (can be determined using your contract type)
     * @param block optional block level to fetch the values from
     *
     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr
     */
    getBigMapKeyByID<T>(id: string, keyToEncode: BigMapKeyType, schema: Schema, block?: number): Promise<T>;
    /**
     *
     * @description Fetch multiple values in a big map
     * All values will be fetched on the same block level. If a block is specified in the request, the values will be fetched at it.
     * Otherwise, a first request will be done to the node to fetch the level of the head and all values will be fetched at this level.
     * If one of the keys does not exist in the big map, its value will be set to undefined.
     *
     * @param id Big Map ID
     * @param keys Array of keys to query (will be encoded properly according to the schema)
     * @param schema Big Map schema (can be determined using your contract type)
     * @param block optional block level to fetch the values from
     * @param batchSize optional batch size representing the number of requests to execute in parallel
     * @returns A MichelsonMap containing the keys queried in the big map and their value in a well-formatted JSON object format
     *
     */
    getBigMapKeysByID<T>(id: string, keys: Array<BigMapKeyType>, schema: Schema, block?: number, batchSize?: number): Promise<MichelsonMap<MichelsonMapKey, T | undefined>>;
    private getBlockForRequest;
    private getBigMapValueOrUndefined;
    /**
     *
     * @description Return a well formatted json object of a sapling state
     *
     * @param id Sapling state ID
     * @param block optional block level to fetch the value from
     *
     */
    getSaplingDiffByID(id: string, block?: number): Promise<import("@taquito/rpc").SaplingDiffResponse>;
    /**
     *
     * @description Originate a new contract according to the script in parameters. Will sign and inject an operation using the current context
     *
     * @returns An operation handle with the result from the rpc node
     *
     * @warn You cannot specify storage and init at the same time (use init to pass the raw michelson representation of storage)
     *
     * @param OriginationOperation Originate operation parameter
     */
    originate<TContract extends DefaultContractType = DefaultContractType>(params: OriginateParams<ContractStorageType<TContract>>): Promise<OriginationOperation<TContract>>;
    /**
     *
     * @description Set the delegate for a contract. Will sign and inject an operation using the current context
     *
     * @returns An operation handle with the result from the rpc node
     *
     * @param SetDelegate operation parameter
     */
    setDelegate(params: DelegateParams): Promise<DelegateOperation>;
    /**
     *
     * @description Register the current address as delegate. Will sign and inject an operation using the current context
     *
     * @returns An operation handle with the result from the rpc node
     *
     * @param RegisterDelegate operation parameter
     */
    registerDelegate(params: RegisterDelegateParams): Promise<DelegateOperation>;
    /**
     *
     * @description Transfer tz from current address to a specific address. Will sign and inject an operation using the current context
     *
     * @returns An operation handle with the result from the rpc node
     *
     * @param Transfer operation parameter
     */
    transfer(params: TransferParams): Promise<TransactionOperation>;
    /**
     *
     * @description Transfer Tickets to a smart contract address
     *
     * @returns An operation handle with the result from the rpc node
     *
     * @param TransferTicketParams operation parameter
     */
    transferTicket(params: TransferTicketParams): Promise<TransferTicketOperation>;
    /**
     *
     * @description Reveal the current address. Will throw an error if the address is already revealed.
     *
     * @returns An operation handle with the result from the rpc node
     *
     * @param RevealParams operation parameter
     */
    reveal(params: RevealParams): Promise<RevealOperation>;
    /**
     *
     * @description Register a Micheline expression in a global table of constants. Will sign and inject an operation using the current context
     *
     * @returns An operation handle with the result from the rpc node
     *
     * @param params registerGlobalConstant operation parameter
     */
    registerGlobalConstant(params: RegisterGlobalConstantParams): Promise<RegisterGlobalConstantOperation>;
    /**
     *
     * @description Increase the paid storage of a smart contract
     *
     * @returns An operation handle with the result from the rpc node
     *
     * @param params increasePaidStorage operation parameter
     */
    increasePaidStorage(params: IncreasePaidStorageParams): Promise<IncreasePaidStorageOperation>;
    /**
     *
     * @description Transfers the spendable balance of the delegate to destination when consensus_key is the active consensus key of delegate
     *
     * @returns An operation handle with the result from the rpc node
     *
     * @param params drainDelegate operation parameter
     */
    drainDelegate(params: DrainDelegateParams): Promise<DrainDelegateOperation>;
    /**
     *
     * @description Submit a ballot vote to a specified proposal
     *
     * @returns An operation handle with the result from the rpc node
     *
     * @param BallotParams Ballot operation parameter
     */
    ballot(params: BallotParams): Promise<BallotOperation>;
    /**
     *
     * @description Submit or upvote a proposal during the Proposal period
     *
     * @returns An operation handle with the result from the rpc node
     *
     * @param ProposalsParams Proposals operation parameter
     */
    proposals(params: ProposalsParams): Promise<ProposalsOperation>;
    /**
     *
     * @description Updates the consensus key of the baker to public_key starting from the current cycle plus PRESERVED_CYCLES + 1
     *
     * @returns An operation handle with the result from the rpc node
     *
     * @param UpdateConsensusKeyParams
     */
    updateConsensusKey(params: UpdateConsensusKeyParams): Promise<UpdateConsensusKeyOperation>;
    /**
     * @description Adds messages to the rollup inbox that can be executed/claimed after it gets cemented
     * @param SmartRollupAddMessagesParams
     * @returns An operation handle with results from the RPC node
     */
    smartRollupAddMessages(params: SmartRollupAddMessagesParams): Promise<SmartRollupAddMessagesOperation>;
    /**
     * @description Creates a smart rollup originate operation
     * @param SmartRollupOriginateParams
     * @returns An operation handle with results from the RPC node
     */
    smartRollupOriginate(params: SmartRollupOriginateParams): Promise<SmartRollupOriginateOperation>;
    /**
     *
     * @description Create an smart contract abstraction for the address specified.
     *
     * @param address Smart contract address
     * @throws {@link InvalidContractAddressError}
     */
    at<T extends DefaultContractType = DefaultContractType>(address: string, contractAbstractionComposer?: ContractAbstractionComposer<T>): Promise<T>;
    /**
     *
     * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch
     *
     * @returns A batch object from which we can add more operation or send a command to execute the batch
     *
     * @param params List of operation to batch together
     */
    batch(params?: ParamsWithKind[]): OperationBatch;
}
declare type ContractAbstractionComposer<T> = (abs: ContractAbstraction<ContractProvider>, context: Context) => T;
export {};
