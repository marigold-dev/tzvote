"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Wallet = exports.WalletOperationBatch = void 0;
const contract_1 = require("../contract");
const types_1 = require("../operations/types");
const core_1 = require("@taquito/core");
const utils_1 = require("@taquito/utils");
class WalletOperationBatch {
    constructor(walletProvider, context) {
        this.walletProvider = walletProvider;
        this.context = context;
        this.operations = [];
    }
    /**
     *
     * @description Add a transaction operation to the batch
     *
     * @param params Transfer operation parameter
     */
    withTransfer(params) {
        const toValidation = utils_1.validateAddress(params.to);
        if (toValidation !== utils_1.ValidationResult.VALID) {
            throw new core_1.InvalidAddressError(params.to, utils_1.invalidDetail(toValidation));
        }
        this.operations.push(Object.assign({ kind: types_1.OpKind.TRANSACTION }, params));
        return this;
    }
    /**
     *
     * @description Add a contract call to the batch
     *
     * @param params Call a contract method
     * @param options Generic operation parameters
     */
    withContractCall(params, options = {}) {
        return this.withTransfer(params.toTransferParams(options));
    }
    /**
     *
     * @description Add a delegation operation to the batch
     *
     * @param params Delegation operation parameter
     */
    withDelegation(params) {
        var _a;
        const delegateValidation = utils_1.validateAddress((_a = params.delegate) !== null && _a !== void 0 ? _a : '');
        if (params.delegate && delegateValidation !== utils_1.ValidationResult.VALID) {
            throw new core_1.InvalidAddressError(params.delegate, utils_1.invalidDetail(delegateValidation));
        }
        this.operations.push(Object.assign({ kind: types_1.OpKind.DELEGATION }, params));
        return this;
    }
    /**
     *
     * @description Add an origination operation to the batch
     *
     * @param params Origination operation parameter
     */
    withOrigination(params) {
        this.operations.push(Object.assign({ kind: types_1.OpKind.ORIGINATION }, params));
        return this;
    }
    /**
     *
     * @description Add an IncreasePaidStorage operation to the batch
     *
     * @param param IncreasePaidStorage operation parameter
     */
    withIncreasePaidStorage(params) {
        const destinationValidation = utils_1.validateAddress(params.destination);
        if (destinationValidation !== utils_1.ValidationResult.VALID) {
            throw new core_1.InvalidAddressError(params.destination, utils_1.invalidDetail(destinationValidation));
        }
        this.operations.push(Object.assign({ kind: types_1.OpKind.INCREASE_PAID_STORAGE }, params));
        return this;
    }
    mapOperation(param) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (param.kind) {
                case types_1.OpKind.TRANSACTION:
                    return this.walletProvider.mapTransferParamsToWalletParams(() => __awaiter(this, void 0, void 0, function* () { return param; }));
                case types_1.OpKind.ORIGINATION:
                    return this.walletProvider.mapOriginateParamsToWalletParams(() => __awaiter(this, void 0, void 0, function* () {
                        return this.context.parser.prepareCodeOrigination(Object.assign({}, param));
                    }));
                case types_1.OpKind.DELEGATION:
                    return this.walletProvider.mapDelegateParamsToWalletParams(() => __awaiter(this, void 0, void 0, function* () { return param; }));
                case types_1.OpKind.INCREASE_PAID_STORAGE:
                    return this.walletProvider.mapIncreasePaidStorageWalletParams(() => __awaiter(this, void 0, void 0, function* () { return param; }));
                default:
                    throw new core_1.InvalidOperationKindError(JSON.stringify(param.kind));
            }
        });
    }
    /**
     *
     * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array
     *
     * @param params Operations parameter
     * @throws {@link InvalidOperationKindError}
     */
    with(params) {
        for (const param of params) {
            switch (param.kind) {
                case types_1.OpKind.TRANSACTION:
                    this.withTransfer(param);
                    break;
                case types_1.OpKind.ORIGINATION:
                    this.withOrigination(param);
                    break;
                case types_1.OpKind.DELEGATION:
                    this.withDelegation(param);
                    break;
                case types_1.OpKind.INCREASE_PAID_STORAGE:
                    this.withIncreasePaidStorage(param);
                    break;
                default:
                    throw new core_1.InvalidOperationKindError(JSON.stringify(param.kind));
            }
        }
        return this;
    }
    /**
     *
     * @description Submit batch operation to wallet
     *
     */
    send() {
        return __awaiter(this, void 0, void 0, function* () {
            const ops = [];
            for (const op of this.operations) {
                ops.push(yield this.mapOperation(op));
            }
            const opHash = yield this.walletProvider.sendOperations(ops);
            return this.context.operationFactory.createBatchOperation(opHash);
        });
    }
}
exports.WalletOperationBatch = WalletOperationBatch;
class Wallet {
    constructor(context) {
        this.context = context;
        this.walletCommand = (send) => {
            return {
                send,
            };
        };
    }
    get walletProvider() {
        return this.context.walletProvider;
    }
    /**
     * @description Retrieve the PKH of the account that is currently in use by the wallet
     *
     * @param option Option to use while fetching the PKH.
     * If forceRefetch is specified the wallet provider implementation will refetch the PKH from the wallet
     */
    pkh({ forceRefetch } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._pkh || forceRefetch) {
                this._pkh = yield this.walletProvider.getPKH();
            }
            return this._pkh;
        });
    }
    /**
     *
     * @description Originate a new contract according to the script in parameters.
     *
     * @returns An operation handle with the result from the rpc node
     *
     * @param originateParams Originate operation parameter
     */
    originate(params) {
        return this.walletCommand(() => __awaiter(this, void 0, void 0, function* () {
            const mappedParams = yield this.walletProvider.mapOriginateParamsToWalletParams(() => this.context.parser.prepareCodeOrigination(Object.assign({}, params)));
            const opHash = yield this.walletProvider.sendOperations([mappedParams]);
            return this.context.operationFactory.createOriginationOperation(opHash);
        }));
    }
    /**
     *
     * @description Set the delegate for a contract.
     *
     * @returns An operation handle with the result from the rpc node
     *
     * @param delegateParams operation parameter
     */
    setDelegate(params) {
        var _a;
        const delegateValidation = utils_1.validateAddress((_a = params.delegate) !== null && _a !== void 0 ? _a : '');
        if (params.delegate && delegateValidation !== utils_1.ValidationResult.VALID) {
            throw new core_1.InvalidAddressError(params.delegate, utils_1.invalidDetail(delegateValidation));
        }
        return this.walletCommand(() => __awaiter(this, void 0, void 0, function* () {
            const mappedParams = yield this.walletProvider.mapDelegateParamsToWalletParams(() => __awaiter(this, void 0, void 0, function* () { return params; }));
            const opHash = yield this.walletProvider.sendOperations([mappedParams]);
            return this.context.operationFactory.createDelegationOperation(opHash);
        }));
    }
    /**
     *
     * @description Register the current address as delegate.
     *
     * @returns An operation handle with the result from the rpc node
     *
     */
    registerDelegate() {
        return this.walletCommand(() => __awaiter(this, void 0, void 0, function* () {
            const mappedParams = yield this.walletProvider.mapDelegateParamsToWalletParams(() => __awaiter(this, void 0, void 0, function* () {
                const delegate = yield this.pkh();
                return { delegate };
            }));
            const opHash = yield this.walletProvider.sendOperations([mappedParams]);
            return this.context.operationFactory.createDelegationOperation(opHash);
        }));
    }
    /**
     *
     * @description Transfer tezos tokens from current address to a specific address or call a smart contract.
     *
     * @returns A wallet command from which we can send the operation to the wallet
     *
     * @param params operation parameter
     */
    transfer(params) {
        const toValidation = utils_1.validateAddress(params.to);
        if (toValidation !== utils_1.ValidationResult.VALID) {
            throw new core_1.InvalidAddressError(params.to, utils_1.invalidDetail(toValidation));
        }
        return this.walletCommand(() => __awaiter(this, void 0, void 0, function* () {
            const mappedParams = yield this.walletProvider.mapTransferParamsToWalletParams(() => __awaiter(this, void 0, void 0, function* () { return params; }));
            const opHash = yield this.walletProvider.sendOperations([mappedParams]);
            return this.context.operationFactory.createTransactionOperation(opHash);
        }));
    }
    /**
     *
     * @description
     *
     * @returns
     *
     * @param params
     */
    increasePaidStorage(params) {
        const destinationValidation = utils_1.validateAddress(params.destination);
        if (destinationValidation !== utils_1.ValidationResult.VALID) {
            throw new core_1.InvalidAddressError(params.destination, utils_1.invalidDetail(destinationValidation));
        }
        return this.walletCommand(() => __awaiter(this, void 0, void 0, function* () {
            const mappedParams = yield this.walletProvider.mapIncreasePaidStorageWalletParams(() => __awaiter(this, void 0, void 0, function* () { return params; }));
            const opHash = yield this.walletProvider.sendOperations([mappedParams]);
            return this.context.operationFactory.createIncreasePaidStorageOperation(opHash);
        }));
    }
    /**
     *
     * @description Create a batch of operation
     *
     * @returns A batch object from which we can add more operation or send a command to the wallet to execute the batch
     *
     * @param params List of operation to initialize the batch with
     */
    batch(params) {
        const batch = new WalletOperationBatch(this.walletProvider, this.context);
        if (Array.isArray(params)) {
            batch.with(params);
        }
        return batch;
    }
    /**
     *
     * @description Create an smart contract abstraction for the address specified. Calling entrypoints with the returned
     * smart contract abstraction will leverage the wallet provider to make smart contract calls
     *
     * @param address Smart contract address
     * @throws {@link InvalidContractAddressError} If the contract address is not valid
     */
    at(address, contractAbstractionComposer = (x) => x) {
        return __awaiter(this, void 0, void 0, function* () {
            const addressValidation = utils_1.validateContractAddress(address);
            if (addressValidation !== utils_1.ValidationResult.VALID) {
                throw new core_1.InvalidContractAddressError(address, utils_1.invalidDetail(addressValidation));
            }
            const rpc = this.context.withExtensions().rpc;
            const readProvider = this.context.withExtensions().readProvider;
            const script = yield readProvider.getScript(address, 'head');
            const entrypoints = yield readProvider.getEntrypoints(address);
            const abs = new contract_1.ContractAbstraction(address, script, this, this.context.contract, entrypoints, rpc, readProvider);
            return contractAbstractionComposer(abs, this.context);
        });
    }
}
exports.Wallet = Wallet;
//# sourceMappingURL=wallet.js.map