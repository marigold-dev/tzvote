"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParameterSchema = void 0;
const createToken_1 = require("../tokens/createToken");
const token_1 = require("../tokens/token");
const or_1 = require("../tokens/or");
const option_1 = require("../tokens/option");
const errors_1 = require("./errors");
/**
 * @warn Our current smart contract abstraction feature is currently in preview. It's API is not final, and it may not cover every use case (yet). We will greatly appreciate any feedback on this feature.
 */
class ParameterSchema {
    /**
     * @description Return the schema of the parameter of a specific entry point
     * @throws {@link InvalidTokenError}
     */
    constructor(val) {
        this.root = createToken_1.createToken(val, 0);
    }
    /**
     *
     * @description Create an instance of ParameterSchema from a contract script
     *
     * @param val contract script obtained from the RPC
     * @returns ParameterSchema
     * @throws {InvalidRpcResponseError} If the RPC response is invalid
     */
    static fromRPCResponse(val) {
        if (!val) {
            throw new errors_1.InvalidRpcResponseError(val, 'the RPC response is empty');
        }
        if (!val.script) {
            throw new errors_1.InvalidRpcResponseError(val, 'the RPC response has no script');
        }
        if (!Array.isArray(val.script.code)) {
            throw new errors_1.InvalidRpcResponseError(val, 'The response.script.code should be an array');
        }
        const parameter = val.script.code.find((x) => 'prim' in x && x.prim === 'parameter');
        if (!parameter) {
            throw new errors_1.InvalidRpcResponseError(val, `The response.script.code should have an element of type {prim: "parameter"}`);
        }
        if (!Array.isArray(parameter.args)) {
            throw new errors_1.InvalidRpcResponseError(val, `The response.script.code has an element of type {prim: "parameter"}, but its args is not an array`);
        }
        return new ParameterSchema(parameter.args[0]);
    }
    /**
     * @description Check if the Contract parameter is multiple entry point or not
     */
    get isMultipleEntryPoint() {
        return (this.root instanceof or_1.OrToken ||
            (this.root instanceof option_1.OptionToken && this.root.subToken() instanceof or_1.OrToken));
    }
    /**
     * @description Check if the Contract parameter has an annotation or not
     */
    get hasAnnotation() {
        if (this.isMultipleEntryPoint) {
            return Object.keys(this.ExtractSchema())[0] !== '0';
        }
        else {
            return true;
        }
    }
    /**
     * @description Returns the javascript object equivalent of the Micheline value provided
     */
    Execute(val, semantics) {
        return this.root.Execute(val, semantics);
    }
    /**
     * @description Returns a micheline formatted object for the values provided
     * @throws {@link TokenValidationError}
     * @throws {@link ParameterEncodingError}
     */
    Encode(...args) {
        try {
            return this.root.Encode(args.reverse());
        }
        catch (ex) {
            if (ex instanceof token_1.TokenValidationError) {
                throw ex;
            }
            throw new errors_1.ParameterEncodingError('Unable to encode parameter', this.root, args, ex);
        }
    }
    /**
     * @description Returns a micheline formatted object for the javascript object provided
     * @throws {@link TokenValidationError}
     * @throws {@link ParameterEncodingError}
     */
    EncodeObject(value, semantics) {
        try {
            return this.root.EncodeObject(value, semantics);
        }
        catch (ex) {
            if (ex instanceof token_1.TokenValidationError) {
                throw ex;
            }
            throw new errors_1.ParameterEncodingError('Unable to encode parameter object', this.root, value, ex);
        }
    }
    /**
     * @deprecated ExtractSchema has been deprecated in favor of generateSchema
     *
     */
    ExtractSchema() {
        return this.root.ExtractSchema();
    }
    /**
     * @description Produce a schema grouping together all the entry points of a contract.
     */
    generateSchema() {
        return this.root.generateSchema();
    }
    ExtractSignatures() {
        return this.root.ExtractSignature();
    }
}
exports.ParameterSchema = ParameterSchema;
//# sourceMappingURL=parameter.js.map