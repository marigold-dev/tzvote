import { ec, curve } from 'elliptic';
import { ExtendedPrivateKey } from './index';
import BN from 'bn.js';
export declare type CurveName = 'p256' | 'secp256k1';
interface KeyPair extends ec.KeyPair {
    priv: BN | null;
    pub: curve.base.BasePoint | null;
}
export declare class PrivateKey implements ExtendedPrivateKey {
    readonly chainCode: Uint8Array;
    readonly keyPair: KeyPair;
    /**
     *
     * @param priv key pair priv (BN) pub (curve.base.BasePint) if applicable
     * @param chainCode slice 32->n HMAC hash key and seedkey (first instance curve default seedKey. after hmac value slice 32->n)
     */
    constructor(priv: ec.KeyPair, chainCode: Uint8Array);
    /**
     * @param seedSrc result of Bip39.mnemonicToSeed
     * @param curve known supported curve p256 or secp256k1
     * @returns instance of PrivateKey non-HD keys derived
     * @throws {@link InvalidBitSize} | {@link InvalidCurveError} | {@link InvalidSeedLengthError}
     */
    static fromSeed(seedSrc: Uint8Array | string, curve: CurveName): PrivateKey;
    /**
     *
     * @param index derivation path item pre-hardened if applicable ie: 44' -> 2^31 + 44
     * @returns child PrivateKey of the current PrivateKey
     */
    derive(index: number): PrivateKey;
    /**
     *
     * @param path pre-hardened (if applicable) derivation path items ie 44'/1729'/0/0 -> 2^31 + 44/2^31 + 1729/0/0
     * @returns final child of the full HD keys derivation
     */
    derivePath(path: Iterable<number>): PrivateKey;
    /**
     *
     * @returns Uint8Array (if contains a private key)
     * @throws {@link InvalidKeyError}
     */
    bytes(): Uint8Array;
}
export {};
