"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSecretKey = void 0;
const utils_1 = require("@taquito/utils");
const ed25519_1 = require("./derivation-tools/ed25519");
const ecdsa_1 = require("./derivation-tools/ecdsa");
const derivation_tools_1 = require("./derivation-tools");
const errors_1 = require("./errors");
// bip32 when supported add to @param curve bip25519
/**
 *
 * @param seed bip39.mnemonicToSeed
 * @param derivationPath Tezos Requirement 44'/1729' for HD key address default 44'/1729'/0'/0'
 * @param curve 'ed25519' | 'secp256k1' | 'p256''
 * @returns final Derivation of HD keys tezos Secret key
 * @throws {@link InvalidCurveError} | {@link ToBeImplemented}
 */
const generateSecretKey = (seed, derivationPath, curve) => {
    const path = derivation_tools_1.Path.fromString(derivationPath);
    let node;
    switch (curve) {
        case 'ed25519': {
            node = ed25519_1.PrivateKey.fromSeed(seed).derivePath(path);
            const sk = utils_1.b58cencode(node.seed().slice(0, 32), utils_1.prefix.edsk2);
            return sk;
        }
        case 'secp256k1':
        case 'p256': {
            const prefixType = curve === 'secp256k1' ? utils_1.prefix.spsk : utils_1.prefix.p2sk;
            let privKey = ecdsa_1.PrivateKey.fromSeed(seed, curve);
            privKey = privKey.derivePath(path);
            const uint8arr = new Uint8Array(privKey.keyPair.getPrivate().toArray());
            const sk = utils_1.b58cencode(uint8arr, prefixType);
            return sk;
        }
        case 'bip25519': {
            throw new errors_1.ToBeImplemented();
        }
        default: {
            throw new errors_1.InvalidCurveError(`Unsupported curve "${curve}" expecting one of the following "ed25519", "secp256k1", "p256"`);
        }
    }
};
exports.generateSecretKey = generateSecretKey;
//# sourceMappingURL=helpers.js.map