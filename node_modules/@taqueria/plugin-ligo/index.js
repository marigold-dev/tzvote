"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// index.ts
var import_node_sdk9 = require("@taqueria/node-sdk");

// createContract.ts
var import_node_sdk = require("@taqueria/node-sdk");
var import_promises = require("fs/promises");

// ligo_templates.ts
var mligo_template = `
type storage = int

type parameter =
  Increment of int
| Decrement of int
| Reset

type return = operation list * storage

// Two entrypoints

let add (store, delta : storage * int) : storage = store + delta
let sub (store, delta : storage * int) : storage = store - delta

(* Main access point that dispatches to the entrypoints according to
   the smart contract parameter. *)
   
let main (action, store : parameter * storage) : return =
 ([] : operation list),    // No operations
 (match action with
   Increment (n) -> add (store, n)
 | Decrement (n) -> sub (store, n)
 | Reset         -> 0)
`;
var pascaligo_template = `
type storage is int

type parameter is
  Increment of int
| Decrement of int
| Reset

type return is list (operation) * storage

// Two entrypoints

function add (const store : storage; const delta : int) : storage is 
  store + delta

function sub (const store : storage; const delta : int) : storage is 
  store - delta

(* Main access point that dispatches to the entrypoints according to
   the smart contract parameter. *)
   
function main (const action : parameter; const store : storage) : return is
 ((nil : list (operation)),    // No operations
  case action of [
    Increment (n) -> add (store, n)
  | Decrement (n) -> sub (store, n)
  | Reset         -> 0
  ])
`;
var religo_template = `
type storage = int;

type parameter =
  Increment (int)
| Decrement (int)
| Reset;

type return = (list (operation), storage);

// Two entrypoints

let add = ((store, delta) : (storage, int)) : storage => store + delta;
let sub = ((store, delta) : (storage, int)) : storage => store - delta;

/* Main access point that dispatches to the entrypoints according to
   the smart contract parameter. */
   
let main = ((action, store) : (parameter, storage)) : return => {
 (([] : list (operation)),    // No operations
 (switch (action) {
  | Increment (n) => add ((store, n))
  | Decrement (n) => sub ((store, n))
  | Reset         => 0}))
};
`;
var jsligo_template = `
type storage = int;

type parameter =
  ["Increment", int]
| ["Decrement", int]
| ["Reset"];

type ret = [list<operation>, storage];

// Two entrypoints

const add = ([store, delta] : [storage, int]) : storage => store + delta;
const sub = ([store, delta] : [storage, int]) : storage => store - delta;

/* Main access point that dispatches to the entrypoints according to
   the smart contract parameter. */

const main = ([action, store] : [parameter, storage]) : ret => {
 return [list([]) as list<operation>,    // No operations
 match (action, {
  Increment:(n: int) => add ([store, n]),
  Decrement:(n: int) => sub ([store, n]),
  Reset    :()  => 0})]
};
`;

// createContract.ts
var getLigoTemplate = async (contractName, syntax) => {
  const matchResult = contractName.match(/\.[^.]+$/);
  const ext = matchResult ? matchResult[0].substring(1) : null;
  if (syntax === "mligo")
    return mligo_template;
  if (syntax === "ligo")
    return pascaligo_template;
  if (syntax === "religo")
    return religo_template;
  if (syntax === "jsligo")
    return jsligo_template;
  if (syntax === void 0) {
    if (ext === "mligo")
      return mligo_template;
    if (ext === "ligo")
      return pascaligo_template;
    if (ext === "religo")
      return religo_template;
    if (ext === "jsligo")
      return jsligo_template;
    return (0, import_node_sdk.sendAsyncErr)(
      `Unable to infer LIGO syntax from "${contractName}". Please specify a LIGO syntax via the --syntax option`
    );
  } else {
    return (0, import_node_sdk.sendAsyncErr)(`"${syntax}" is not a valid syntax. Please specify a valid LIGO syntax`);
  }
};
var createContract = (args) => {
  const unsafeOpts = args;
  const contractName = unsafeOpts.sourceFileName;
  const syntax = unsafeOpts.syntax;
  const contractsDir = `${args.config.projectDir}/${args.config.contractsDir}`;
  return getLigoTemplate(contractName, syntax).then((ligo_template) => (0, import_promises.writeFile)(`${contractsDir}/${contractName}`, ligo_template));
};
var createContract_default = createContract;

// main.ts
var import_node_sdk8 = require("@taqueria/node-sdk");

// common.ts
var import_node_sdk2 = require("@taqueria/node-sdk");
var import_path = require("path");
var LIGO_DEFAULT_IMAGE = "ligolang/ligo:0.69.0";
var LIGO_IMAGE_ENV_VAR = "TAQ_LIGO_IMAGE";
var getLigoDockerImage = () => (0, import_node_sdk2.getDockerImage)(LIGO_DEFAULT_IMAGE, LIGO_IMAGE_ENV_VAR);
var getInputFilenameAbsPath = (parsedArgs, sourceFile) => (0, import_path.join)(parsedArgs.config.projectDir, parsedArgs.config.contractsDir ?? "contracts", sourceFile);
var getInputFilenameRelPath = (parsedArgs, sourceFile) => (0, import_path.join)(parsedArgs.config.contractsDir ?? "contracts", sourceFile);
var emitExternalError = (err, sourceFile) => {
  (0, import_node_sdk2.sendErr)(`
=== Error messages for ${sourceFile} ===`);
  err instanceof Error ? (0, import_node_sdk2.sendErr)(err.message.replace(/Command failed.+?\n/, "")) : (0, import_node_sdk2.sendErr)(err);
  (0, import_node_sdk2.sendErr)(`
===`);
};

// compile.ts
var import_node_sdk3 = require("@taqueria/node-sdk");
var import_promises2 = require("fs/promises");
var import_path2 = require("path");
var COMPILE_ERR_MSG = "Not compiled";
var isStorageKind = (exprKind) => exprKind === "storage" || exprKind === "default_storage";
var isLIGOFile = (sourceFile) => /.+\.(ligo|religo|mligo|jsligo)$/.test(sourceFile);
var isStorageListFile = (sourceFile) => /.+\.(storageList|storages)\.(ligo|religo|mligo|jsligo)$/.test(sourceFile);
var isParameterListFile = (sourceFile) => /.+\.(parameterList|parameters)\.(ligo|religo|mligo|jsligo)$/.test(sourceFile);
var isContractFile = (sourceFile) => isLIGOFile(sourceFile) && !isStorageListFile(sourceFile) && !isParameterListFile(sourceFile);
var getModuleName = async (parsedArgs, sourceFile) => {
  const fileContent = await (0, import_promises2.readFile)(getInputFilenameAbsPath(parsedArgs, sourceFile), "utf8");
  if (fileContent.includes("@entry") && fileContent.includes("module")) {
    const match = fileContent.match(/module ([^\s]+)/);
    return match ? match[1] : void 0;
  }
  return void 0;
};
var extractExt = (path) => {
  const matchResult = path.match(/\.(ligo|religo|mligo|jsligo)$/);
  return matchResult ? matchResult[0] : "";
};
var removeExt = (path) => {
  const extRegex = new RegExp(extractExt(path));
  return path.replace(extRegex, "");
};
var isOutputFormatJSON = (parsedArgs) => parsedArgs.json;
var getOutputContractFilename = (parsedArgs, sourceFile) => {
  const outputFile = (0, import_path2.basename)(sourceFile, (0, import_path2.extname)(sourceFile));
  const ext = isOutputFormatJSON(parsedArgs) ? ".json" : ".tz";
  return (0, import_path2.join)((0, import_node_sdk3.getArtifactsDir)(parsedArgs), `${outputFile}${ext}`);
};
var getContractNameForExpr = (sourceFile, exprKind) => {
  try {
    return isStorageKind(exprKind) ? sourceFile.match(/.+(?=\.(?:storageList|storages)\.(ligo|religo|mligo|jsligo))/).join(".") : sourceFile.match(/.+(?=\.(?:parameterList|parameters)\.(ligo|religo|mligo|jsligo))/).join(".");
  } catch (err) {
    throw new Error(`Something went wrong internally when dealing with filename format: ${err}`);
  }
};
var getOutputExprFilename = (parsedArgs, sourceFile, exprKind, exprName) => {
  const contractName = (0, import_path2.basename)(getContractNameForExpr(sourceFile, exprKind), (0, import_path2.extname)(sourceFile));
  const ext = isOutputFormatJSON(parsedArgs) ? ".json" : ".tz";
  const outputFile = exprKind === "default_storage" ? `${contractName}.default_storage${ext}` : `${contractName}.${exprKind}.${exprName}${ext}`;
  return (0, import_path2.join)((0, import_node_sdk3.getArtifactsDir)(parsedArgs), `${outputFile}`);
};
var getCompileContractCmd = async (parsedArgs, sourceFile) => {
  const projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;
  if (!projectDir)
    throw `No project directory provided`;
  const baseCmd = `DOCKER_DEFAULT_PLATFORM=linux/amd64 docker run --rm -v "${projectDir}":/project -w /project -u $(id -u):$(id -g) ${getLigoDockerImage()} compile contract`;
  const inputFile = getInputFilenameRelPath(parsedArgs, sourceFile);
  const outputFile = `-o ${getOutputContractFilename(parsedArgs, sourceFile)}`;
  const flags = isOutputFormatJSON(parsedArgs) ? " --michelson-format json " : "";
  const moduleName = await getModuleName(parsedArgs, sourceFile);
  const entryFlag = moduleName ? `-m ${moduleName}` : "";
  const cmd = `${baseCmd} ${inputFile} ${outputFile} ${flags}${entryFlag}`;
  return cmd;
};
var getCompileExprCmd = (parsedArgs, sourceFile, exprKind, exprName) => {
  const projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;
  if (!projectDir)
    throw `No project directory provided`;
  const compilerType = isStorageKind(exprKind) ? "storage" : "parameter";
  const baseCmd = `DOCKER_DEFAULT_PLATFORM=linux/amd64 docker run --rm -v "${projectDir}":/project -w /project -u $(id -u):$(id -g) ${getLigoDockerImage()} compile ${compilerType}`;
  const inputFile = getInputFilenameRelPath(parsedArgs, sourceFile);
  const outputFile = `-o ${getOutputExprFilename(parsedArgs, sourceFile, exprKind, exprName)}`;
  const flags = isOutputFormatJSON(parsedArgs) ? " --michelson-format json " : "";
  const cmd = `${baseCmd} ${inputFile} ${exprName} ${outputFile} ${flags}`;
  return cmd;
};
var compileContract = async (parsedArgs, sourceFile) => {
  try {
    await (0, import_node_sdk3.getArch)();
    const cmd = await getCompileContractCmd(parsedArgs, sourceFile);
    const { stderr } = await (0, import_node_sdk3.execCmd)(cmd);
    if (stderr.length > 0)
      (0, import_node_sdk3.sendWarn)(stderr);
    return {
      contract: sourceFile,
      artifact: getOutputContractFilename(parsedArgs, sourceFile)
    };
  } catch (err) {
    emitExternalError(err, sourceFile);
    return {
      contract: sourceFile,
      artifact: COMPILE_ERR_MSG
    };
  }
};
var compileExpr = (parsedArgs, sourceFile, exprKind) => (exprName) => (0, import_node_sdk3.getArch)().then(() => getCompileExprCmd(parsedArgs, sourceFile, exprKind, exprName)).then(import_node_sdk3.execCmd).then(({ stderr }) => {
  if (stderr.length > 0)
    (0, import_node_sdk3.sendWarn)(stderr);
  const artifactName = getOutputExprFilename(parsedArgs, sourceFile, exprKind, exprName);
  return {
    contract: sourceFile,
    artifact: artifactName
  };
}).catch((err) => {
  emitExternalError(err, sourceFile);
  return {
    contract: sourceFile,
    artifact: COMPILE_ERR_MSG
  };
});
var getExprNames = (parsedArgs, sourceFile) => (0, import_promises2.readFile)(getInputFilenameAbsPath(parsedArgs, sourceFile), "utf8").then((data) => data.match(/(?<=\n\s*(let|const)\s+)[a-zA-Z0-9_]+/g) ?? []);
var compileExprs = (parsedArgs, sourceFile, exprKind) => getExprNames(parsedArgs, sourceFile).then((exprNames) => {
  if (exprNames.length === 0)
    return [];
  const firstExprName = exprNames.slice(0, 1)[0];
  const restExprNames = exprNames.slice(1, exprNames.length);
  const firstExprKind = isStorageKind(exprKind) ? "default_storage" : "parameter";
  const restExprKind = isStorageKind(exprKind) ? "storage" : "parameter";
  const firstExprResult = compileExpr(parsedArgs, sourceFile, firstExprKind)(firstExprName);
  const restExprResults = restExprNames.map(compileExpr(parsedArgs, sourceFile, restExprKind));
  return Promise.all([firstExprResult].concat(restExprResults));
}).catch((err) => {
  emitExternalError(err, sourceFile);
  return [{
    contract: sourceFile,
    artifact: `No ${isStorageKind(exprKind) ? "storage" : "parameter"} expressions compiled`
  }];
}).then(
  (results) => results.length > 0 ? results : [{
    contract: sourceFile,
    artifact: `No ${isStorageKind(exprKind) ? "storage" : "parameter"} expressions found`
  }]
).then(mergeArtifactsOutput(sourceFile));
var tryLegacyStorageNamingConvention = (parsedArgs, sourceFile) => {
  const storageListFile = `${removeExt(sourceFile)}.storages${extractExt(sourceFile)}`;
  const storageListFilename = getInputFilenameAbsPath(parsedArgs, storageListFile);
  return (0, import_promises2.access)(storageListFilename).then(() => {
    (0, import_node_sdk3.sendWarn)(
      `Warning: The naming convention of "<CONTRACT>.storages.<EXTENSION>" is deprecated and renamed to "<CONTRACT>.storageList.<EXTENSION>". Please adjust your storage file names accordingly
`
    );
    return compileExprs(parsedArgs, storageListFile, "storage");
  });
};
var tryLegacyParameterNamingConvention = (parsedArgs, sourceFile) => {
  const parameterListFile = `${removeExt(sourceFile)}.parameters${extractExt(sourceFile)}`;
  const parameterListFilename = getInputFilenameAbsPath(parsedArgs, parameterListFile);
  return (0, import_promises2.access)(parameterListFilename).then(() => {
    (0, import_node_sdk3.sendWarn)(
      `Warning: The naming convention of "<CONTRACT>.parameters.<EXTENSION>" is deprecated and renamed to "<CONTRACT>.parameterList.<EXTENSION>". Please adjust your parameter file names accordingly
`
    );
    return compileExprs(parsedArgs, parameterListFile, "parameter");
  });
};
var initContentForStorage = (sourceFile) => {
  const linkToContract = `#include "${sourceFile}"

`;
  const instruction = "// Define your initial storage values as a list of LIGO variable definitions,\n// the first of which will be considered the default value to be used for origination later on\n";
  const ext = extractExt(sourceFile);
  let syntax = "";
  if (ext === ".ligo")
    syntax = "// E.g. const aStorageValue : aStorageType = 10;\n\n";
  else if (ext === ".religo")
    syntax = "// E.g. let aStorageValue : aStorageType = 10;\n\n";
  else if (ext === ".mligo")
    syntax = "// E.g. let aStorageValue : aStorageType = 10\n\n";
  else if (ext === ".jsligo")
    syntax = "// E.g. const aStorageValue : aStorageType = 10;\n\n";
  return linkToContract + instruction + syntax;
};
var initContentForParameter = (sourceFile) => {
  const linkToContract = `#include "${sourceFile}"

`;
  const instruction = "// Define your parameter values as a list of LIGO variable definitions\n";
  const ext = extractExt(sourceFile);
  let syntax = "";
  if (ext === ".ligo")
    syntax = "// E.g. const aParameterValue : aParameterType = Increment(1);\n\n";
  else if (ext === ".religo")
    syntax = "// E.g. let aParameterValue : aParameterType = (Increment (1));\n\n";
  else if (ext === ".mligo")
    syntax = "// E.g. let aParameterValue : aParameterType = Increment 1\n\n";
  else if (ext === ".jsligo")
    syntax = "// E.g. const aParameterValue : aParameterType = (Increment (1));\n\n";
  return linkToContract + instruction + syntax;
};
var compileContractWithStorageAndParameter = async (parsedArgs, sourceFile) => {
  const contractCompileResult = await compileContract(parsedArgs, sourceFile);
  if (contractCompileResult.artifact === COMPILE_ERR_MSG)
    return [contractCompileResult];
  const storageListFile = `${removeExt(sourceFile)}.storageList${extractExt(sourceFile)}`;
  const storageListFilename = getInputFilenameAbsPath(parsedArgs, storageListFile);
  const storageCompileResult = await (0, import_promises2.access)(storageListFilename).then(() => compileExprs(parsedArgs, storageListFile, "storage")).catch(() => tryLegacyStorageNamingConvention(parsedArgs, sourceFile)).catch(() => {
    (0, import_node_sdk3.sendWarn)(
      `Note: storage file associated with "${sourceFile}" can't be found, so "${storageListFile}" has been created for you. Use this file to define all initial storage values for this contract
`
    );
    (0, import_promises2.writeFile)(storageListFilename, initContentForStorage(sourceFile), "utf8");
  });
  const parameterListFile = `${removeExt(sourceFile)}.parameterList${extractExt(sourceFile)}`;
  const parameterListFilename = getInputFilenameAbsPath(parsedArgs, parameterListFile);
  const parameterCompileResult = await (0, import_promises2.access)(parameterListFilename).then(() => compileExprs(parsedArgs, parameterListFile, "parameter")).catch(() => tryLegacyParameterNamingConvention(parsedArgs, sourceFile)).catch(() => {
    (0, import_node_sdk3.sendWarn)(
      `Note: parameter file associated with "${sourceFile}" can't be found, so "${parameterListFile}" has been created for you. Use this file to define all parameter values for this contract
`
    );
    (0, import_promises2.writeFile)(parameterListFilename, initContentForParameter(sourceFile), "utf8");
  });
  let compileResults = [contractCompileResult];
  if (storageCompileResult)
    compileResults = compileResults.concat(storageCompileResult);
  if (parameterCompileResult)
    compileResults = compileResults.concat(parameterCompileResult);
  return compileResults;
};
var mergeArtifactsOutput = (sourceFile) => (tableRows) => {
  const artifactsOutput = tableRows.reduce(
    (acc, row) => row.artifact === COMPILE_ERR_MSG ? acc : `${acc}${row.artifact}
`,
    ""
  );
  return [{
    contract: sourceFile,
    artifact: artifactsOutput
  }];
};
var compile = (parsedArgs) => {
  const sourceFile = parsedArgs.sourceFile;
  let p;
  if (isStorageListFile(sourceFile))
    p = compileExprs(parsedArgs, sourceFile, "storage");
  else if (isParameterListFile(sourceFile))
    p = compileExprs(parsedArgs, sourceFile, "parameter");
  else if (isContractFile(sourceFile))
    p = compileContractWithStorageAndParameter(parsedArgs, sourceFile);
  else {
    return (0, import_node_sdk3.sendAsyncErr)(
      `${sourceFile} doesn't have a valid LIGO extension ('.ligo', '.religo', '.mligo' or '.jsligo')`
    );
  }
  return p.then(import_node_sdk3.sendJsonRes).catch((err) => (0, import_node_sdk3.sendErr)(err, false));
};
var compile_default = compile;

// compile-all.ts
var import_node_sdk4 = require("@taqueria/node-sdk");
var import_fast_glob = __toESM(require("fast-glob"));
var import_promises3 = require("fs/promises");
var import_path3 = require("path");
var isMainContract = async (parsedArgs, contractFilename) => {
  if (/storageList\.\w{0,2}ligo$/.test(contractFilename))
    return false;
  const fileContent = await (0, import_promises3.readFile)(getInputFilenameAbsPath(parsedArgs, contractFilename), "utf8");
  const entryOrMainFunctionRegex = /@entry|((const|let|function)\s+main)/g;
  return entryOrMainFunctionRegex.test(fileContent);
};
var parseIncludes = async (parsedArgs, contractFilename) => {
  const fileContent = await (0, import_promises3.readFile)(getInputFilenameAbsPath(parsedArgs, contractFilename), "utf8");
  const includeRegex = /#include\s+"([^"]+\.m?ligo)"/g;
  let match;
  const includes = [];
  while ((match = includeRegex.exec(fileContent)) !== null) {
    includes.push(match[1]);
  }
  return includes;
};
var buildDependencyGraph = async (parsedArgs, contractFilenames) => {
  const graph = /* @__PURE__ */ new Map();
  for (const filename of contractFilenames) {
    const includes = await parseIncludes(parsedArgs, filename);
    graph.set(filename, new Set(includes));
  }
  return graph;
};
var visit = (node, graph, visited, stack) => {
  if (stack.has(node))
    return [true, visited];
  if (!visited.has(node)) {
    const newVisited = new Set(visited).add(node);
    const newStack = new Set(stack).add(node);
    const [circular, updatedVisited] = Array.from(graph.get(node) || []).reduce(
      ([circularFound, vSet], dependency) => {
        const [result, v] = visit(dependency, graph, vSet, newStack);
        return [circularFound || result, v];
      },
      [false, newVisited]
    );
    if (!circular)
      return [false, updatedVisited];
  }
  return [false, visited];
};
var detectCircularDependencies = (graph) => {
  const { safeFiles, circularFiles, visited } = Array.from(graph.keys()).reduce(
    (acc, filename) => {
      const [isCircular, updatedVisited] = visit(
        filename,
        graph,
        acc.visited,
        /* @__PURE__ */ new Set()
      );
      if (isCircular) {
        acc.circularFiles.push(filename);
      } else {
        acc.safeFiles.push(filename);
      }
      acc.visited = updatedVisited;
      return acc;
    },
    { safeFiles: [], circularFiles: [], visited: /* @__PURE__ */ new Set() }
  );
  return { safeFiles, circularFiles };
};
var compileAll = async (parsedArgs) => {
  let p = [];
  const contractFilenames = await (0, import_fast_glob.default)(
    ["**/*.ligo", "**/*.religo", "**/*.mligo", "**/*.jsligo"],
    {
      cwd: (0, import_path3.join)(parsedArgs.config.projectDir, parsedArgs.config.contractsDir ?? "contracts"),
      absolute: false
    }
  );
  const dependencyGraph = await buildDependencyGraph(parsedArgs, contractFilenames);
  const { safeFiles, circularFiles } = detectCircularDependencies(dependencyGraph);
  for (const filename of safeFiles) {
    if (await isMainContract(parsedArgs, filename)) {
      p.push(compileContractWithStorageAndParameter(parsedArgs, filename));
    }
  }
  return Promise.all(p).then((tables) => tables.flat()).then((table) => {
    if (circularFiles.length > 0) {
      console.warn(
        "Warning: Circular dependencies detected in the following files. They have been skipped:"
      );
      console.warn(circularFiles.join(", "));
    }
    return table;
  }).then(import_node_sdk4.sendJsonRes).catch((err) => (0, import_node_sdk4.sendErr)(err, false));
};
var compile_all_default = compileAll;

// ligo.ts
var import_node_sdk5 = require("@taqueria/node-sdk");
var import_node_sdk6 = require("@taqueria/node-sdk");
var import_path4 = require("path");
var getArbitraryLigoCmd = (parsedArgs, uid, gid, userArgs) => {
  const projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;
  if (!projectDir)
    throw `No project directory provided`;
  const userMap = uid && gid ? `${uid}:${gid}` : uid;
  const userMapArgs = uid ? ["-u", userMap] : [];
  const binary = "docker";
  const baseArgs = [
    "run",
    "--rm",
    "-v",
    `${projectDir}:/project`,
    "-w",
    "/project",
    ...userMapArgs,
    getLigoDockerImage()
  ];
  const processedUserArgs = userArgs.split(" ").map((arg) => arg.startsWith("\\-") ? arg.substring(1) : arg).filter(
    (arg) => arg
  );
  const args = baseArgs.concat(processedUserArgs);
  const envVars = { "DOCKER_DEFAULT_PLATFORM": "linux/amd64" };
  return [
    [binary, ...args].join(" "),
    envVars
  ];
};
var ensureEsyExists = async (parsedArgs) => {
  const esyJsonPath = (0, import_path4.join)(parsedArgs.projectDir, "esy.json");
  try {
    return await (0, import_node_sdk6.readJsonFile)(esyJsonPath);
  } catch {
    return await (0, import_node_sdk6.writeJsonFile)(esyJsonPath)({});
  }
};
var runArbitraryLigoCmd = (parsedArgs, cmd) => ensureEsyExists(parsedArgs).then(import_node_sdk5.getArch).then(async () => {
  const uid = await (0, import_node_sdk5.execCmd)("id -u");
  const gid = await (0, import_node_sdk5.execCmd)("id -g");
  return [uid.stdout.trim(), gid.stdout.trim()];
}).then(([uid, gid]) => getArbitraryLigoCmd(parsedArgs, uid, gid, cmd)).then(([cmd2, envVars]) => (0, import_node_sdk5.spawnCmd)(cmd2, envVars)).then(
  (code) => code !== null && code === 0 ? `Command "${cmd}" ran successfully by LIGO` : `Command "${cmd}" failed. Please check your command`
).catch((err) => (0, import_node_sdk5.sendAsyncErr)(`An internal error has occurred: ${err.message}`));
var ligo = (parsedArgs) => {
  const args = parsedArgs.command;
  return runArbitraryLigoCmd(parsedArgs, args).then(import_node_sdk5.sendRes).catch((err) => (0, import_node_sdk5.sendAsyncErr)(err, false));
};
var ligo_default = ligo;

// test.ts
var import_node_sdk7 = require("@taqueria/node-sdk");
var getTestContractCmd = (parsedArgs, sourceFile) => {
  const projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;
  if (!projectDir)
    throw `No project directory provided`;
  const baseCmd = `DOCKER_DEFAULT_PLATFORM=linux/amd64 docker run --rm -v "${projectDir}":/project -w /project -u $(id -u):$(id -g) ${getLigoDockerImage()} run test`;
  const inputFile = getInputFilenameRelPath(parsedArgs, sourceFile);
  const cmd = `${baseCmd} ${inputFile}`;
  return cmd;
};
var testContract = (parsedArgs, sourceFile) => (0, import_node_sdk7.getArch)().then(() => getTestContractCmd(parsedArgs, sourceFile)).then(import_node_sdk7.execCmd).then(({ stdout, stderr }) => {
  if (stderr.length > 0)
    (0, import_node_sdk7.sendWarn)(stderr);
  const result = "\u{1F389} All tests passed \u{1F389}";
  return {
    contract: sourceFile,
    testResults: stdout.length > 0 ? `${stdout}
${result}` : result
  };
}).catch((err) => {
  emitExternalError(err, sourceFile);
  return {
    contract: sourceFile,
    testResults: "Some tests failed :("
  };
});
var test = (parsedArgs) => {
  const sourceFile = parsedArgs.sourceFile;
  if (!sourceFile)
    return (0, import_node_sdk7.sendAsyncErr)(`No source file provided`);
  return testContract(parsedArgs, sourceFile).then((result) => [result]).then(import_node_sdk7.sendJsonRes).catch(
    (err) => (0, import_node_sdk7.sendAsyncErr)(err, false)
  );
};
var test_default = test;

// main.ts
var main = (parsedArgs) => {
  const unsafeOpts = parsedArgs;
  switch (unsafeOpts.task) {
    case "ligo":
      return ligo_default(unsafeOpts);
    case "compile":
      return compile_default(unsafeOpts);
    case "compile-all":
      return compile_all_default(unsafeOpts);
    case "test":
      return test_default(parsedArgs);
    case "get-image":
      return (0, import_node_sdk8.sendAsyncRes)(getLigoDockerImage());
    default:
      return (0, import_node_sdk8.sendAsyncErr)(`${unsafeOpts.task} is not an understood task by the LIGO plugin`);
  }
};
var main_default = main;

// index.ts
import_node_sdk9.Plugin.create((i18n) => ({
  schema: "1.0",
  version: "0.1",
  alias: "ligo",
  tasks: [
    import_node_sdk9.Task.create({
      task: "ligo",
      command: "ligo",
      description: "This task allows you to run arbitrary LIGO native commands. Note that they might not benefit from the abstractions provided by Taqueria",
      options: [
        import_node_sdk9.Option.create({
          shortFlag: "c",
          flag: "command",
          type: "string",
          description: "The command to be passed to the underlying LIGO binary, wrapped in quotes",
          required: true
        })
      ],
      handler: "proxy",
      encoding: "none"
    }),
    import_node_sdk9.Task.create({
      task: "compile",
      command: "compile <sourceFile>",
      aliases: ["c", "compile-ligo"],
      description: "Compile a smart contract written in a LIGO syntax to Michelson code, along with its associated storage/parameter list files if they are found",
      options: [
        import_node_sdk9.Option.create({
          flag: "json",
          boolean: true,
          description: "Emit JSON-encoded Michelson"
        })
      ],
      handler: "proxy",
      encoding: "json"
    }),
    import_node_sdk9.Task.create({
      task: "compile-all",
      command: "compile-all",
      description: "Compile all main smart contracts written in a LIGO syntax to Michelson code, along with their associated storage/parameter list files if they are found",
      options: [
        import_node_sdk9.Option.create({
          flag: "json",
          boolean: true,
          description: "Emit JSON-encoded Michelson"
        })
      ],
      handler: "proxy",
      encoding: "json"
    }),
    import_node_sdk9.Task.create({
      task: "test",
      command: "test <sourceFile>",
      description: "Test a smart contract written in LIGO",
      handler: "proxy",
      encoding: "json"
    }),
    import_node_sdk9.Task.create({
      task: "get-image",
      command: "get-image",
      description: "Gets the name of the image to be used",
      handler: "proxy",
      hidden: true
    })
  ],
  templates: [
    import_node_sdk9.Template.create({
      template: "contract",
      command: "contract <sourceFileName>",
      description: "Create a LIGO contract with boilerplate code",
      positionals: [
        import_node_sdk9.PositionalArg.create({
          placeholder: "sourceFileName",
          type: "string",
          description: "The name of the LIGO contract to generate"
        })
      ],
      options: [
        import_node_sdk9.Option.create({
          shortFlag: "s",
          flag: "syntax",
          type: "string",
          description: "The syntax used in the contract"
        })
      ],
      handler: createContract_default
    })
  ],
  proxy: main_default
}), process.argv);
//# sourceMappingURL=index.js.map