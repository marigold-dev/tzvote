{"version":3,"sources":["index.ts","createContract.ts","ligo_templates.ts","main.ts","common.ts","compile.ts","compile-all.ts","ligo.ts","test.ts"],"sourcesContent":["import { Option, Plugin, PositionalArg, Task, Template } from '@taqueria/node-sdk';\nimport createContract from './createContract';\nimport main from './main';\n\nPlugin.create(i18n => ({\n\tschema: '1.0',\n\tversion: '0.1',\n\talias: 'ligo',\n\ttasks: [\n\t\tTask.create({\n\t\t\ttask: 'ligo',\n\t\t\tcommand: 'ligo',\n\t\t\tdescription:\n\t\t\t\t'This task allows you to run arbitrary LIGO native commands. Note that they might not benefit from the abstractions provided by Taqueria',\n\t\t\toptions: [\n\t\t\t\tOption.create({\n\t\t\t\t\tshortFlag: 'c',\n\t\t\t\t\tflag: 'command',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdescription: 'The command to be passed to the underlying LIGO binary, wrapped in quotes',\n\t\t\t\t\trequired: true,\n\t\t\t\t}),\n\t\t\t],\n\t\t\thandler: 'proxy',\n\t\t\tencoding: 'none',\n\t\t}),\n\t\tTask.create({\n\t\t\ttask: 'compile',\n\t\t\tcommand: 'compile <sourceFile>',\n\t\t\taliases: ['c', 'compile-ligo'],\n\t\t\tdescription:\n\t\t\t\t'Compile a smart contract written in a LIGO syntax to Michelson code, along with its associated storage/parameter list files if they are found',\n\t\t\toptions: [\n\t\t\t\tOption.create({\n\t\t\t\t\tflag: 'json',\n\t\t\t\t\tboolean: true,\n\t\t\t\t\tdescription: 'Emit JSON-encoded Michelson',\n\t\t\t\t}),\n\t\t\t],\n\t\t\thandler: 'proxy',\n\t\t\tencoding: 'json',\n\t\t}),\n\t\tTask.create({\n\t\t\ttask: 'compile-all',\n\t\t\tcommand: 'compile-all',\n\t\t\tdescription:\n\t\t\t\t'Compile all main smart contracts written in a LIGO syntax to Michelson code, along with their associated storage/parameter list files if they are found',\n\t\t\toptions: [\n\t\t\t\tOption.create({\n\t\t\t\t\tflag: 'json',\n\t\t\t\t\tboolean: true,\n\t\t\t\t\tdescription: 'Emit JSON-encoded Michelson',\n\t\t\t\t}),\n\t\t\t],\n\t\t\thandler: 'proxy',\n\t\t\tencoding: 'json',\n\t\t}),\n\t\tTask.create({\n\t\t\ttask: 'test',\n\t\t\tcommand: 'test <sourceFile>',\n\t\t\tdescription: 'Test a smart contract written in LIGO',\n\t\t\thandler: 'proxy',\n\t\t\tencoding: 'json',\n\t\t}),\n\t\tTask.create({\n\t\t\ttask: 'get-image',\n\t\t\tcommand: 'get-image',\n\t\t\tdescription: 'Gets the name of the image to be used',\n\t\t\thandler: 'proxy',\n\t\t\thidden: true,\n\t\t}),\n\t],\n\ttemplates: [\n\t\tTemplate.create({\n\t\t\ttemplate: 'contract',\n\t\t\tcommand: 'contract <sourceFileName>',\n\t\t\tdescription: 'Create a LIGO contract with boilerplate code',\n\t\t\tpositionals: [\n\t\t\t\tPositionalArg.create({\n\t\t\t\t\tplaceholder: 'sourceFileName',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdescription: 'The name of the LIGO contract to generate',\n\t\t\t\t}),\n\t\t\t],\n\t\t\toptions: [\n\t\t\t\tOption.create({\n\t\t\t\t\tshortFlag: 's',\n\t\t\t\t\tflag: 'syntax',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdescription: 'The syntax used in the contract',\n\t\t\t\t}),\n\t\t\t],\n\t\t\thandler: createContract,\n\t\t}),\n\t],\n\tproxy: main,\n}), process.argv);\n","import { sendAsyncErr } from '@taqueria/node-sdk';\nimport { RequestArgs } from '@taqueria/node-sdk';\nimport { writeFile } from 'fs/promises';\nimport { jsligo_template, mligo_template, pascaligo_template, religo_template } from './ligo_templates';\n\ninterface Opts extends RequestArgs.t {\n\tsourceFileName?: string;\n\tsyntax?: string;\n}\n\nconst getLigoTemplate = async (contractName: string, syntax: string | undefined): Promise<string> => {\n\tconst matchResult = contractName.match(/\\.[^.]+$/);\n\tconst ext = matchResult ? matchResult[0].substring(1) : null;\n\n\tif (syntax === 'mligo') return mligo_template;\n\tif (syntax === 'ligo') return pascaligo_template;\n\tif (syntax === 'religo') return religo_template;\n\tif (syntax === 'jsligo') return jsligo_template;\n\n\tif (syntax === undefined) {\n\t\tif (ext === 'mligo') return mligo_template;\n\t\tif (ext === 'ligo') return pascaligo_template;\n\t\tif (ext === 'religo') return religo_template;\n\t\tif (ext === 'jsligo') return jsligo_template;\n\t\treturn sendAsyncErr(\n\t\t\t`Unable to infer LIGO syntax from \"${contractName}\". Please specify a LIGO syntax via the --syntax option`,\n\t\t);\n\t} else {\n\t\treturn sendAsyncErr(`\"${syntax}\" is not a valid syntax. Please specify a valid LIGO syntax`);\n\t}\n};\n\nconst createContract = (args: RequestArgs.t) => {\n\tconst unsafeOpts = args as unknown as Opts;\n\tconst contractName = unsafeOpts.sourceFileName as string;\n\tconst syntax = unsafeOpts.syntax;\n\tconst contractsDir = `${args.config.projectDir}/${args.config.contractsDir}`;\n\treturn getLigoTemplate(contractName, syntax)\n\t\t.then(ligo_template => writeFile(`${contractsDir}/${contractName}`, ligo_template));\n};\n\nexport default createContract;\n","export const mligo_template = `\ntype storage = int\n\ntype parameter =\n  Increment of int\n| Decrement of int\n| Reset\n\ntype return = operation list * storage\n\n// Two entrypoints\n\nlet add (store, delta : storage * int) : storage = store + delta\nlet sub (store, delta : storage * int) : storage = store - delta\n\n(* Main access point that dispatches to the entrypoints according to\n   the smart contract parameter. *)\n   \nlet main (action, store : parameter * storage) : return =\n ([] : operation list),    // No operations\n (match action with\n   Increment (n) -> add (store, n)\n | Decrement (n) -> sub (store, n)\n | Reset         -> 0)\n`;\n\nexport const pascaligo_template = `\ntype storage is int\n\ntype parameter is\n  Increment of int\n| Decrement of int\n| Reset\n\ntype return is list (operation) * storage\n\n// Two entrypoints\n\nfunction add (const store : storage; const delta : int) : storage is \n  store + delta\n\nfunction sub (const store : storage; const delta : int) : storage is \n  store - delta\n\n(* Main access point that dispatches to the entrypoints according to\n   the smart contract parameter. *)\n   \nfunction main (const action : parameter; const store : storage) : return is\n ((nil : list (operation)),    // No operations\n  case action of [\n    Increment (n) -> add (store, n)\n  | Decrement (n) -> sub (store, n)\n  | Reset         -> 0\n  ])\n`;\n\nexport const religo_template = `\ntype storage = int;\n\ntype parameter =\n  Increment (int)\n| Decrement (int)\n| Reset;\n\ntype return = (list (operation), storage);\n\n// Two entrypoints\n\nlet add = ((store, delta) : (storage, int)) : storage => store + delta;\nlet sub = ((store, delta) : (storage, int)) : storage => store - delta;\n\n/* Main access point that dispatches to the entrypoints according to\n   the smart contract parameter. */\n   \nlet main = ((action, store) : (parameter, storage)) : return => {\n (([] : list (operation)),    // No operations\n (switch (action) {\n  | Increment (n) => add ((store, n))\n  | Decrement (n) => sub ((store, n))\n  | Reset         => 0}))\n};\n`;\n\nexport const jsligo_template = `\ntype storage = int;\n\ntype parameter =\n  [\"Increment\", int]\n| [\"Decrement\", int]\n| [\"Reset\"];\n\ntype ret = [list<operation>, storage];\n\n// Two entrypoints\n\nconst add = ([store, delta] : [storage, int]) : storage => store + delta;\nconst sub = ([store, delta] : [storage, int]) : storage => store - delta;\n\n/* Main access point that dispatches to the entrypoints according to\n   the smart contract parameter. */\n\nconst main = ([action, store] : [parameter, storage]) : ret => {\n return [list([]) as list<operation>,    // No operations\n match (action, {\n  Increment:(n: int) => add ([store, n]),\n  Decrement:(n: int) => sub ([store, n]),\n  Reset    :()  => 0})]\n};\n`;\n","import { RequestArgs, sendAsyncErr, sendAsyncRes } from '@taqueria/node-sdk';\nimport { getLigoDockerImage, IntersectionOpts as Opts } from './common';\nimport compile from './compile';\nimport compileAll from './compile-all';\nimport ligo from './ligo';\nimport test from './test';\n\nconst main = (parsedArgs: RequestArgs.t): Promise<void> => {\n\tconst unsafeOpts = parsedArgs as unknown as Opts;\n\tswitch (unsafeOpts.task) {\n\t\tcase 'ligo':\n\t\t\treturn ligo(unsafeOpts);\n\t\tcase 'compile':\n\t\t\treturn compile(unsafeOpts);\n\t\tcase 'compile-all':\n\t\t\treturn compileAll(unsafeOpts);\n\t\tcase 'test':\n\t\t\treturn test(parsedArgs);\n\t\tcase 'get-image':\n\t\t\treturn sendAsyncRes(getLigoDockerImage());\n\t\tdefault:\n\t\t\treturn sendAsyncErr(`${unsafeOpts.task} is not an understood task by the LIGO plugin`);\n\t}\n};\n\nexport default main;\n","import { getDockerImage, sendErr } from '@taqueria/node-sdk';\nimport { ProxyTaskArgs, RequestArgs } from '@taqueria/node-sdk/types';\nimport { join } from 'path';\n\nexport interface LigoOpts extends ProxyTaskArgs.t {\n\tcommand: string;\n}\n\nexport interface CompileOpts extends ProxyTaskArgs.t {\n\tsourceFile: string;\n\tjson: boolean;\n}\n\nexport interface CompileAllOpts extends ProxyTaskArgs.t {\n\tjson: boolean;\n}\n\nexport interface TestOpts extends RequestArgs.t {\n\ttask?: string;\n\tsourceFile?: string;\n}\n\nexport type IntersectionOpts = LigoOpts & CompileOpts & CompileAllOpts & TestOpts;\n\ntype UnionOpts = LigoOpts | CompileOpts | CompileAllOpts | TestOpts;\n\n// Should point to the latest stable version, so it needs to be updated as part of our release process.\nconst LIGO_DEFAULT_IMAGE = 'ligolang/ligo:0.69.0';\n\nconst LIGO_IMAGE_ENV_VAR = 'TAQ_LIGO_IMAGE';\n\nexport const getLigoDockerImage = (): string => getDockerImage(LIGO_DEFAULT_IMAGE, LIGO_IMAGE_ENV_VAR);\n\nexport const getInputFilenameAbsPath = (parsedArgs: UnionOpts, sourceFile: string): string =>\n\tjoin(parsedArgs.config.projectDir, parsedArgs.config.contractsDir ?? 'contracts', sourceFile);\n\nexport const getInputFilenameRelPath = (parsedArgs: UnionOpts, sourceFile: string): string =>\n\tjoin(parsedArgs.config.contractsDir ?? 'contracts', sourceFile);\n\nexport const emitExternalError = (err: unknown, sourceFile: string): void => {\n\tsendErr(`\\n=== Error messages for ${sourceFile} ===`);\n\terr instanceof Error ? sendErr(err.message.replace(/Command failed.+?\\n/, '')) : sendErr(err as any);\n\tsendErr(`\\n===`);\n};\n","import { execCmd, getArch, getArtifactsDir, sendAsyncErr, sendErr, sendJsonRes, sendWarn } from '@taqueria/node-sdk';\nimport { access, readFile, writeFile } from 'fs/promises';\nimport { basename, extname, join } from 'path';\nimport {\n\tCompileOpts as Opts,\n\temitExternalError,\n\tgetInputFilenameAbsPath,\n\tgetInputFilenameRelPath,\n\tgetLigoDockerImage,\n} from './common';\n\nexport type TableRow = { contract: string; artifact: string };\n\nexport type ExprKind = 'storage' | 'default_storage' | 'parameter';\n\nconst COMPILE_ERR_MSG: string = 'Not compiled';\n\nconst isStorageKind = (exprKind: ExprKind): boolean => exprKind === 'storage' || exprKind === 'default_storage';\n\nconst isLIGOFile = (sourceFile: string): boolean => /.+\\.(ligo|religo|mligo|jsligo)$/.test(sourceFile);\n\nconst isStorageListFile = (sourceFile: string): boolean =>\n\t/.+\\.(storageList|storages)\\.(ligo|religo|mligo|jsligo)$/.test(sourceFile);\n\nconst isParameterListFile = (sourceFile: string): boolean =>\n\t/.+\\.(parameterList|parameters)\\.(ligo|religo|mligo|jsligo)$/.test(sourceFile);\n\nconst isContractFile = (sourceFile: string): boolean =>\n\tisLIGOFile(sourceFile) && !isStorageListFile(sourceFile) && !isParameterListFile(sourceFile);\n\nconst getModuleName = async (parsedArgs: Opts, sourceFile: string): Promise<string | undefined> => {\n\tconst fileContent = await readFile(getInputFilenameAbsPath(parsedArgs, sourceFile), 'utf8');\n\tif (fileContent.includes('@entry') && fileContent.includes('module')) {\n\t\tconst match = fileContent.match(/module ([^\\s]+)/);\n\t\treturn match ? match[1] : undefined;\n\t}\n\treturn undefined;\n};\n\nconst extractExt = (path: string): string => {\n\tconst matchResult = path.match(/\\.(ligo|religo|mligo|jsligo)$/);\n\treturn matchResult ? matchResult[0] : '';\n};\n\nconst removeExt = (path: string): string => {\n\tconst extRegex = new RegExp(extractExt(path));\n\treturn path.replace(extRegex, '');\n};\n\nconst isOutputFormatJSON = (parsedArgs: Opts): boolean => parsedArgs.json;\n\nconst getOutputContractFilename = (parsedArgs: Opts, sourceFile: string): string => {\n\tconst outputFile = basename(sourceFile, extname(sourceFile));\n\tconst ext = isOutputFormatJSON(parsedArgs) ? '.json' : '.tz';\n\treturn join(getArtifactsDir(parsedArgs), `${outputFile}${ext}`);\n};\n\n// Get the contract name that the storage/parameter file is associated with\n// e.g. If sourceFile is token.storageList.mligo, then it'll return token.mligo\nconst getContractNameForExpr = (sourceFile: string, exprKind: ExprKind): string => {\n\ttry {\n\t\treturn isStorageKind(exprKind)\n\t\t\t? sourceFile.match(/.+(?=\\.(?:storageList|storages)\\.(ligo|religo|mligo|jsligo))/)!.join('.')\n\t\t\t: sourceFile.match(/.+(?=\\.(?:parameterList|parameters)\\.(ligo|religo|mligo|jsligo))/)!.join('.');\n\t} catch (err) {\n\t\tthrow new Error(`Something went wrong internally when dealing with filename format: ${err}`);\n\t}\n};\n\n// If sourceFile is token.storageList.mligo, then it'll return token.storage.{storageName}.tz\nconst getOutputExprFilename = (parsedArgs: Opts, sourceFile: string, exprKind: ExprKind, exprName: string): string => {\n\tconst contractName = basename(getContractNameForExpr(sourceFile, exprKind), extname(sourceFile));\n\tconst ext = isOutputFormatJSON(parsedArgs) ? '.json' : '.tz';\n\tconst outputFile = exprKind === 'default_storage'\n\t\t? `${contractName}.default_storage${ext}`\n\t\t: `${contractName}.${exprKind}.${exprName}${ext}`;\n\treturn join(getArtifactsDir(parsedArgs), `${outputFile}`);\n};\n\nconst getCompileContractCmd = async (parsedArgs: Opts, sourceFile: string): Promise<string> => {\n\tconst projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;\n\tif (!projectDir) throw `No project directory provided`;\n\tconst baseCmd =\n\t\t`DOCKER_DEFAULT_PLATFORM=linux/amd64 docker run --rm -v \\\"${projectDir}\\\":/project -w /project -u $(id -u):$(id -g) ${getLigoDockerImage()} compile contract`;\n\tconst inputFile = getInputFilenameRelPath(parsedArgs, sourceFile);\n\tconst outputFile = `-o ${getOutputContractFilename(parsedArgs, sourceFile)}`;\n\tconst flags = isOutputFormatJSON(parsedArgs) ? ' --michelson-format json ' : '';\n\tconst moduleName = await getModuleName(parsedArgs, sourceFile);\n\tconst entryFlag = moduleName ? `-m ${moduleName}` : '';\n\tconst cmd = `${baseCmd} ${inputFile} ${outputFile} ${flags}${entryFlag}`;\n\treturn cmd;\n};\n\nconst getCompileExprCmd = (parsedArgs: Opts, sourceFile: string, exprKind: ExprKind, exprName: string): string => {\n\tconst projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;\n\tif (!projectDir) throw `No project directory provided`;\n\tconst compilerType = isStorageKind(exprKind) ? 'storage' : 'parameter';\n\tconst baseCmd =\n\t\t`DOCKER_DEFAULT_PLATFORM=linux/amd64 docker run --rm -v \\\"${projectDir}\\\":/project -w /project -u $(id -u):$(id -g) ${getLigoDockerImage()} compile ${compilerType}`;\n\tconst inputFile = getInputFilenameRelPath(parsedArgs, sourceFile);\n\tconst outputFile = `-o ${getOutputExprFilename(parsedArgs, sourceFile, exprKind, exprName)}`;\n\tconst flags = isOutputFormatJSON(parsedArgs) ? ' --michelson-format json ' : '';\n\tconst cmd = `${baseCmd} ${inputFile} ${exprName} ${outputFile} ${flags}`;\n\treturn cmd;\n};\n\nconst compileContract = async (parsedArgs: Opts, sourceFile: string): Promise<TableRow> => {\n\ttry {\n\t\tawait getArch();\n\t\tconst cmd = await getCompileContractCmd(parsedArgs, sourceFile);\n\t\tconst { stderr } = await execCmd(cmd);\n\t\tif (stderr.length > 0) sendWarn(stderr);\n\t\treturn {\n\t\t\tcontract: sourceFile,\n\t\t\tartifact: getOutputContractFilename(parsedArgs, sourceFile),\n\t\t};\n\t} catch (err) {\n\t\temitExternalError(err, sourceFile);\n\t\treturn {\n\t\t\tcontract: sourceFile,\n\t\t\tartifact: COMPILE_ERR_MSG,\n\t\t};\n\t}\n};\n\nconst compileExpr = (parsedArgs: Opts, sourceFile: string, exprKind: ExprKind) =>\n\t(exprName: string): Promise<TableRow> =>\n\t\tgetArch()\n\t\t\t.then(() => getCompileExprCmd(parsedArgs, sourceFile, exprKind, exprName))\n\t\t\t.then(execCmd)\n\t\t\t.then(({ stderr }) => {\n\t\t\t\tif (stderr.length > 0) sendWarn(stderr);\n\t\t\t\tconst artifactName = getOutputExprFilename(parsedArgs, sourceFile, exprKind, exprName);\n\t\t\t\treturn {\n\t\t\t\t\tcontract: sourceFile,\n\t\t\t\t\tartifact: artifactName,\n\t\t\t\t};\n\t\t\t})\n\t\t\t.catch(err => {\n\t\t\t\temitExternalError(err, sourceFile);\n\t\t\t\treturn {\n\t\t\t\t\tcontract: sourceFile,\n\t\t\t\t\tartifact: COMPILE_ERR_MSG,\n\t\t\t\t};\n\t\t\t});\n\nconst getExprNames = (parsedArgs: Opts, sourceFile: string): Promise<string[]> =>\n\treadFile(getInputFilenameAbsPath(parsedArgs, sourceFile), 'utf8')\n\t\t.then(data => data.match(/(?<=\\n\\s*(let|const)\\s+)[a-zA-Z0-9_]+/g) ?? []);\n\nconst compileExprs = (parsedArgs: Opts, sourceFile: string, exprKind: ExprKind): Promise<TableRow[]> =>\n\tgetExprNames(parsedArgs, sourceFile)\n\t\t.then(exprNames => {\n\t\t\tif (exprNames.length === 0) return [];\n\t\t\tconst firstExprName = exprNames.slice(0, 1)[0];\n\t\t\tconst restExprNames = exprNames.slice(1, exprNames.length);\n\t\t\tconst firstExprKind = isStorageKind(exprKind) ? 'default_storage' : 'parameter';\n\t\t\tconst restExprKind = isStorageKind(exprKind) ? 'storage' : 'parameter';\n\t\t\tconst firstExprResult = compileExpr(parsedArgs, sourceFile, firstExprKind)(firstExprName);\n\t\t\tconst restExprResults = restExprNames.map(compileExpr(parsedArgs, sourceFile, restExprKind));\n\t\t\treturn Promise.all([firstExprResult].concat(restExprResults));\n\t\t})\n\t\t.catch(err => {\n\t\t\temitExternalError(err, sourceFile);\n\t\t\treturn [{\n\t\t\t\tcontract: sourceFile,\n\t\t\t\tartifact: `No ${isStorageKind(exprKind) ? 'storage' : 'parameter'} expressions compiled`,\n\t\t\t}];\n\t\t})\n\t\t.then(results =>\n\t\t\tresults.length > 0 ? results : [{\n\t\t\t\tcontract: sourceFile,\n\t\t\t\tartifact: `No ${isStorageKind(exprKind) ? 'storage' : 'parameter'} expressions found`,\n\t\t\t}]\n\t\t)\n\t\t.then(mergeArtifactsOutput(sourceFile));\n\n// TODO: Just for backwards compatibility. Can be deleted in the future.\nconst tryLegacyStorageNamingConvention = (parsedArgs: Opts, sourceFile: string) => {\n\tconst storageListFile = `${removeExt(sourceFile)}.storages${extractExt(sourceFile)}`;\n\tconst storageListFilename = getInputFilenameAbsPath(parsedArgs, storageListFile);\n\treturn access(storageListFilename).then(() => {\n\t\tsendWarn(\n\t\t\t`Warning: The naming convention of \"<CONTRACT>.storages.<EXTENSION>\" is deprecated and renamed to \"<CONTRACT>.storageList.<EXTENSION>\". Please adjust your storage file names accordingly\\n`,\n\t\t);\n\t\treturn compileExprs(parsedArgs, storageListFile, 'storage');\n\t});\n};\n\n// TODO: Just for backwards compatibility. Can be deleted in the future.\nconst tryLegacyParameterNamingConvention = (parsedArgs: Opts, sourceFile: string) => {\n\tconst parameterListFile = `${removeExt(sourceFile)}.parameters${extractExt(sourceFile)}`;\n\tconst parameterListFilename = getInputFilenameAbsPath(parsedArgs, parameterListFile);\n\treturn access(parameterListFilename).then(() => {\n\t\tsendWarn(\n\t\t\t`Warning: The naming convention of \"<CONTRACT>.parameters.<EXTENSION>\" is deprecated and renamed to \"<CONTRACT>.parameterList.<EXTENSION>\". Please adjust your parameter file names accordingly\\n`,\n\t\t);\n\t\treturn compileExprs(parsedArgs, parameterListFile, 'parameter');\n\t});\n};\n\nconst initContentForStorage = (sourceFile: string): string => {\n\tconst linkToContract = `#include \"${sourceFile}\"\\n\\n`;\n\n\tconst instruction =\n\t\t'// Define your initial storage values as a list of LIGO variable definitions,\\n// the first of which will be considered the default value to be used for origination later on\\n';\n\n\tconst ext = extractExt(sourceFile);\n\tlet syntax = '';\n\tif (ext === '.ligo') syntax = '// E.g. const aStorageValue : aStorageType = 10;\\n\\n';\n\telse if (ext === '.religo') syntax = '// E.g. let aStorageValue : aStorageType = 10;\\n\\n';\n\telse if (ext === '.mligo') syntax = '// E.g. let aStorageValue : aStorageType = 10\\n\\n';\n\telse if (ext === '.jsligo') syntax = '// E.g. const aStorageValue : aStorageType = 10;\\n\\n';\n\n\treturn linkToContract + instruction + syntax;\n};\n\nconst initContentForParameter = (sourceFile: string): string => {\n\tconst linkToContract = `#include \"${sourceFile}\"\\n\\n`;\n\n\tconst instruction = '// Define your parameter values as a list of LIGO variable definitions\\n';\n\n\tconst ext = extractExt(sourceFile);\n\tlet syntax = '';\n\tif (ext === '.ligo') syntax = '// E.g. const aParameterValue : aParameterType = Increment(1);\\n\\n';\n\telse if (ext === '.religo') syntax = '// E.g. let aParameterValue : aParameterType = (Increment (1));\\n\\n';\n\telse if (ext === '.mligo') syntax = '// E.g. let aParameterValue : aParameterType = Increment 1\\n\\n';\n\telse if (ext === '.jsligo') syntax = '// E.g. const aParameterValue : aParameterType = (Increment (1));\\n\\n';\n\n\treturn linkToContract + instruction + syntax;\n};\n\nexport const compileContractWithStorageAndParameter = async (\n\tparsedArgs: Opts,\n\tsourceFile: string,\n): Promise<TableRow[]> => {\n\tconst contractCompileResult = await compileContract(parsedArgs, sourceFile);\n\tif (contractCompileResult.artifact === COMPILE_ERR_MSG) return [contractCompileResult];\n\n\tconst storageListFile = `${removeExt(sourceFile)}.storageList${extractExt(sourceFile)}`;\n\tconst storageListFilename = getInputFilenameAbsPath(parsedArgs, storageListFile);\n\tconst storageCompileResult = await (access(storageListFilename)\n\t\t.then(() => compileExprs(parsedArgs, storageListFile, 'storage'))\n\t\t.catch(() => tryLegacyStorageNamingConvention(parsedArgs, sourceFile))\n\t\t.catch(() => {\n\t\t\tsendWarn(\n\t\t\t\t`Note: storage file associated with \"${sourceFile}\" can't be found, so \"${storageListFile}\" has been created for you. Use this file to define all initial storage values for this contract\\n`,\n\t\t\t);\n\t\t\twriteFile(storageListFilename, initContentForStorage(sourceFile), 'utf8');\n\t\t}));\n\n\tconst parameterListFile = `${removeExt(sourceFile)}.parameterList${extractExt(sourceFile)}`;\n\tconst parameterListFilename = getInputFilenameAbsPath(parsedArgs, parameterListFile);\n\tconst parameterCompileResult = await (access(parameterListFilename)\n\t\t.then(() => compileExprs(parsedArgs, parameterListFile, 'parameter'))\n\t\t.catch(() => tryLegacyParameterNamingConvention(parsedArgs, sourceFile))\n\t\t.catch(() => {\n\t\t\tsendWarn(\n\t\t\t\t`Note: parameter file associated with \"${sourceFile}\" can't be found, so \"${parameterListFile}\" has been created for you. Use this file to define all parameter values for this contract\\n`,\n\t\t\t);\n\t\t\twriteFile(parameterListFilename, initContentForParameter(sourceFile), 'utf8');\n\t\t}));\n\n\tlet compileResults: TableRow[] = [contractCompileResult];\n\tif (storageCompileResult) compileResults = compileResults.concat(storageCompileResult);\n\tif (parameterCompileResult) compileResults = compileResults.concat(parameterCompileResult);\n\treturn compileResults;\n};\n\n/*\nCompiling storage/parameter file amounts to compiling multiple expressions in that file,\nresulting in multiple rows with the same file name but different artifact names.\nThis will merge these rows into one row with just one mention of the file name.\ne.g.\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Contract                â”‚ Artifact                                    â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ hello.storageList.mligo â”‚ artifacts/hello.default_storage.storage1.tz â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ hello.storageList.mligo â”‚ artifacts/hello.storage.storage2.tz         â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\t\t\t\t\t\t\t\tversus\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Contract                â”‚ Artifact                                    â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ hello.storageList.mligo â”‚ artifacts/hello.default_storage.storage1.tz â”‚\nâ”‚                         â”‚ artifacts/hello.storage.storage2.tz         â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n*/\nconst mergeArtifactsOutput = (sourceFile: string) =>\n\t(tableRows: TableRow[]): TableRow[] => {\n\t\tconst artifactsOutput = tableRows.reduce(\n\t\t\t(acc: string, row: TableRow) => row.artifact === COMPILE_ERR_MSG ? acc : `${acc}${row.artifact}\\n`,\n\t\t\t'',\n\t\t);\n\t\treturn [{\n\t\t\tcontract: sourceFile,\n\t\t\tartifact: artifactsOutput,\n\t\t}];\n\t};\n\nconst compile = (parsedArgs: Opts): Promise<void> => {\n\tconst sourceFile = parsedArgs.sourceFile!;\n\tlet p: Promise<TableRow[]>;\n\tif (isStorageListFile(sourceFile)) p = compileExprs(parsedArgs, sourceFile, 'storage');\n\telse if (isParameterListFile(sourceFile)) p = compileExprs(parsedArgs, sourceFile, 'parameter');\n\telse if (isContractFile(sourceFile)) p = compileContractWithStorageAndParameter(parsedArgs, sourceFile);\n\telse {\n\t\treturn sendAsyncErr(\n\t\t\t`${sourceFile} doesn't have a valid LIGO extension ('.ligo', '.religo', '.mligo' or '.jsligo')`,\n\t\t);\n\t}\n\treturn p.then(sendJsonRes).catch(err => sendErr(err, false));\n};\n\nexport default compile;\nexport const ___TEST___ = {\n\tgetContractNameForExpr,\n\tgetOutputExprFilename,\n};\n","import { sendErr, sendJsonRes } from '@taqueria/node-sdk';\nimport glob from 'fast-glob';\nimport { readFile } from 'fs/promises';\nimport { join } from 'path';\nimport { CompileAllOpts as Opts, CompileOpts, getInputFilenameAbsPath } from './common';\nimport { compileContractWithStorageAndParameter, TableRow } from './compile';\n\nconst isMainContract = async (parsedArgs: Opts, contractFilename: string): Promise<boolean> => {\n\tif (/storageList\\.\\w{0,2}ligo$/.test(contractFilename)) return false;\n\tconst fileContent = await readFile(getInputFilenameAbsPath(parsedArgs, contractFilename), 'utf8');\n\tconst entryOrMainFunctionRegex = /@entry|((const|let|function)\\s+main)/g;\n\treturn entryOrMainFunctionRegex.test(fileContent);\n};\n\n// Helper function to parse includes from a LIGO file\nconst parseIncludes = async (parsedArgs: Opts, contractFilename: string): Promise<string[]> => {\n\tconst fileContent = await readFile(getInputFilenameAbsPath(parsedArgs, contractFilename), 'utf8');\n\tconst includeRegex = /#include\\s+\"([^\"]+\\.m?ligo)\"/g;\n\tlet match;\n\tconst includes: string[] = [];\n\n\twhile ((match = includeRegex.exec(fileContent)) !== null) {\n\t\tincludes.push(match[1]);\n\t}\n\n\treturn includes;\n};\n\n// Helper function to build the dependency graph\nconst buildDependencyGraph = async (\n\tparsedArgs: Opts,\n\tcontractFilenames: string[],\n): Promise<Map<string, Set<string>>> => {\n\tconst graph = new Map<string, Set<string>>();\n\n\tfor (const filename of contractFilenames) {\n\t\tconst includes = await parseIncludes(parsedArgs, filename);\n\t\tgraph.set(filename, new Set(includes));\n\t}\n\n\treturn graph;\n};\n\nconst visit = (\n\tnode: string,\n\tgraph: Map<string, Set<string>>,\n\tvisited: Set<string>,\n\tstack: Set<string>,\n): [boolean, Set<string>] => {\n\tif (stack.has(node)) return [true, visited]; // Circular dependency detected\n\n\tif (!visited.has(node)) {\n\t\tconst newVisited = new Set(visited).add(node);\n\t\tconst newStack = new Set(stack).add(node);\n\n\t\tconst [circular, updatedVisited] = Array.from(graph.get(node) || []).reduce<[boolean, Set<string>]>(\n\t\t\t([circularFound, vSet], dependency) => {\n\t\t\t\tconst [result, v] = visit(dependency, graph, vSet, newStack);\n\t\t\t\treturn [circularFound || result, v];\n\t\t\t},\n\t\t\t[false, newVisited],\n\t\t);\n\n\t\tif (!circular) return [false, updatedVisited];\n\t}\n\n\treturn [false, visited];\n};\n\nconst detectCircularDependencies = (\n\tgraph: Map<string, Set<string>>,\n): { safeFiles: string[]; circularFiles: string[] } => {\n\tconst { safeFiles, circularFiles, visited } = Array.from(graph.keys()).reduce<{\n\t\tsafeFiles: string[];\n\t\tcircularFiles: string[];\n\t\tvisited: Set<string>;\n\t}>(\n\t\t(acc, filename) => {\n\t\t\tconst [isCircular, updatedVisited] = visit(\n\t\t\t\tfilename,\n\t\t\t\tgraph,\n\t\t\t\tacc.visited,\n\t\t\t\tnew Set<string>(),\n\t\t\t);\n\t\t\tif (isCircular) {\n\t\t\t\tacc.circularFiles.push(filename);\n\t\t\t} else {\n\t\t\t\tacc.safeFiles.push(filename);\n\t\t\t}\n\t\t\tacc.visited = updatedVisited;\n\t\t\treturn acc;\n\t\t},\n\t\t{ safeFiles: [], circularFiles: [], visited: new Set<string>() },\n\t);\n\n\treturn { safeFiles, circularFiles };\n};\n\nconst compileAll = async (parsedArgs: Opts): Promise<void> => {\n\tlet p: Promise<TableRow[]>[] = [];\n\n\tconst contractFilenames = await glob(\n\t\t['**/*.ligo', '**/*.religo', '**/*.mligo', '**/*.jsligo'],\n\t\t{\n\t\t\tcwd: join(parsedArgs.config.projectDir, parsedArgs.config.contractsDir ?? 'contracts'),\n\t\t\tabsolute: false,\n\t\t},\n\t);\n\n\tconst dependencyGraph = await buildDependencyGraph(parsedArgs, contractFilenames);\n\tconst { safeFiles, circularFiles } = detectCircularDependencies(dependencyGraph);\n\n\tfor (const filename of safeFiles) {\n\t\tif (await isMainContract(parsedArgs, filename)) {\n\t\t\tp.push(compileContractWithStorageAndParameter(parsedArgs as CompileOpts, filename));\n\t\t}\n\t}\n\n\treturn Promise.all(p)\n\t\t.then(tables => tables.flat())\n\t\t.then(table => {\n\t\t\tif (circularFiles.length > 0) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'Warning: Circular dependencies detected in the following files. They have been skipped:',\n\t\t\t\t);\n\t\t\t\tconsole.warn(circularFiles.join(', '));\n\t\t\t}\n\t\t\treturn table;\n\t\t})\n\t\t.then(sendJsonRes)\n\t\t.catch(err => sendErr(err, false));\n};\n\nexport default compileAll;\n","import { execCmd, getArch, sendAsyncErr, sendRes, spawnCmd } from '@taqueria/node-sdk';\nimport { readJsonFile, writeJsonFile } from '@taqueria/node-sdk';\nimport { join } from 'path';\nimport { getLigoDockerImage, LigoOpts as Opts } from './common';\n\nconst getArbitraryLigoCmd = (\n\tparsedArgs: Opts,\n\tuid: string,\n\tgid: string,\n\tuserArgs: string,\n): [string, Record<string, string>] => {\n\tconst projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;\n\tif (!projectDir) throw `No project directory provided`;\n\n\tconst userMap = uid && gid ? `${uid}:${gid}` : uid;\n\tconst userMapArgs = uid ? ['-u', userMap] : [];\n\n\tconst binary = 'docker';\n\tconst baseArgs = [\n\t\t'run',\n\t\t'--rm',\n\t\t'-v',\n\t\t`${projectDir}:/project`,\n\t\t'-w',\n\t\t'/project',\n\t\t...userMapArgs,\n\t\tgetLigoDockerImage(),\n\t];\n\tconst processedUserArgs = userArgs.split(' ').map(arg => arg.startsWith('\\\\-') ? arg.substring(1) : arg).filter(arg =>\n\t\targ\n\t);\n\tconst args = baseArgs.concat(processedUserArgs);\n\tconst envVars = { 'DOCKER_DEFAULT_PLATFORM': 'linux/amd64' };\n\treturn [\n\t\t[binary, ...args].join(' '),\n\t\tenvVars,\n\t];\n};\n\nconst ensureEsyExists = async (parsedArgs: Opts): Promise<string> => {\n\tconst esyJsonPath = join(parsedArgs.projectDir, 'esy.json');\n\n\ttry {\n\t\treturn await readJsonFile(esyJsonPath);\n\t} catch {\n\t\treturn await writeJsonFile(esyJsonPath)({});\n\t}\n};\n\nconst runArbitraryLigoCmd = (parsedArgs: Opts, cmd: string): Promise<string> =>\n\tensureEsyExists(parsedArgs)\n\t\t.then(getArch)\n\t\t.then(async () => {\n\t\t\tconst uid = await execCmd('id -u');\n\t\t\tconst gid = await execCmd('id -g');\n\t\t\treturn [uid.stdout.trim(), gid.stdout.trim()];\n\t\t})\n\t\t.then(([uid, gid]) => getArbitraryLigoCmd(parsedArgs, uid, gid, cmd))\n\t\t.then(([cmd, envVars]) => spawnCmd(cmd, envVars))\n\t\t.then(code =>\n\t\t\tcode !== null && code === 0\n\t\t\t\t? `Command \"${cmd}\" ran successfully by LIGO`\n\t\t\t\t: `Command \"${cmd}\" failed. Please check your command`\n\t\t)\n\t\t.catch(err => sendAsyncErr(`An internal error has occurred: ${err.message}`));\n\nconst ligo = (parsedArgs: Opts): Promise<void> => {\n\tconst args = parsedArgs.command;\n\treturn runArbitraryLigoCmd(parsedArgs, args).then(sendRes).catch(err => sendAsyncErr(err, false));\n};\n\nexport default ligo;\n","import { execCmd, getArch, sendAsyncErr, sendJsonRes, sendWarn } from '@taqueria/node-sdk';\nimport { emitExternalError, getInputFilenameRelPath, getLigoDockerImage, TestOpts as Opts } from './common';\n\ntype TableRow = { contract: string; testResults: string };\n\nconst getTestContractCmd = (parsedArgs: Opts, sourceFile: string): string => {\n\tconst projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;\n\tif (!projectDir) throw `No project directory provided`;\n\tconst baseCmd =\n\t\t`DOCKER_DEFAULT_PLATFORM=linux/amd64 docker run --rm -v \\\"${projectDir}\\\":/project -w /project -u $(id -u):$(id -g) ${getLigoDockerImage()} run test`;\n\tconst inputFile = getInputFilenameRelPath(parsedArgs, sourceFile);\n\tconst cmd = `${baseCmd} ${inputFile}`;\n\treturn cmd;\n};\n\nconst testContract = (parsedArgs: Opts, sourceFile: string): Promise<TableRow> =>\n\tgetArch()\n\t\t.then(() => getTestContractCmd(parsedArgs, sourceFile))\n\t\t.then(execCmd)\n\t\t.then(({ stdout, stderr }) => {\n\t\t\tif (stderr.length > 0) sendWarn(stderr);\n\t\t\tconst result = 'ðŸŽ‰ All tests passed ðŸŽ‰';\n\t\t\treturn {\n\t\t\t\tcontract: sourceFile,\n\t\t\t\ttestResults: stdout.length > 0 ? `${stdout}\\n${result}` : result,\n\t\t\t};\n\t\t})\n\t\t.catch(err => {\n\t\t\temitExternalError(err, sourceFile);\n\t\t\treturn {\n\t\t\t\tcontract: sourceFile,\n\t\t\t\ttestResults: 'Some tests failed :(',\n\t\t\t};\n\t\t});\n\nconst test = (parsedArgs: Opts): Promise<void> => {\n\tconst sourceFile = parsedArgs.sourceFile;\n\tif (!sourceFile) return sendAsyncErr(`No source file provided`);\n\treturn testContract(parsedArgs, sourceFile).then(result => [result]).then(sendJsonRes).catch(err =>\n\t\tsendAsyncErr(err, false)\n\t);\n};\n\nexport default test;\n"],"mappings":"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","names":["import_node_sdk","import_node_sdk","import_node_sdk","import_node_sdk","import_promises","import_path","import_node_sdk","import_promises","import_path","glob","import_node_sdk","import_path","cmd","import_node_sdk"]}