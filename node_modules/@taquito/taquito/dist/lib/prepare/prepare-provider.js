"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _counters;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrepareProvider = void 0;
const rpc_1 = require("@taquito/rpc");
const types_1 = require("../operations/types");
const constants_1 = require("../constants");
const utils_1 = require("@taquito/utils");
const error_1 = require("../error");
const contract_1 = require("../contract");
const rpc_batch_provider_1 = require("../batch/rpc-batch-provider");
/**
 * @description PrepareProvider is a utility class to output the prepared format of an operation
 */
class PrepareProvider {
    constructor(context) {
        this.context = context;
        _counters.set(this, void 0);
        __classPrivateFieldSet(this, _counters, {});
    }
    get rpc() {
        return this.context.rpc;
    }
    get signer() {
        return this.context.signer;
    }
    get estimate() {
        return this.context.estimate;
    }
    get parser() {
        return this.context.parser;
    }
    getPkh() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.context.signer.publicKeyHash();
        });
    }
    getBlockHash() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.context.readProvider.getBlockHash('head~2');
        });
    }
    getProtocolHash() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.context.readProvider.getNextProtocol('head');
        });
    }
    getHeadCounter(pkh) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return (_a = this.context.readProvider.getCounter(pkh, 'head')) !== null && _a !== void 0 ? _a : '0';
        });
    }
    getFee(op, pkh, headCounter) {
        if (!__classPrivateFieldGet(this, _counters)[pkh] || __classPrivateFieldGet(this, _counters)[pkh] < headCounter) {
            __classPrivateFieldGet(this, _counters)[pkh] = headCounter;
        }
        const opCounter = ++__classPrivateFieldGet(this, _counters)[pkh];
        return {
            counter: `${opCounter}`,
            fee: typeof op.fee === 'undefined' ? '0' : `${op.fee}`,
            gas_limit: typeof op.gas_limit === 'undefined' ? '0' : `${op.gas_limit}`,
            storage_limit: typeof op.storage_limit === 'undefined' ? '0' : `${op.storage_limit}`,
        };
    }
    getSource(op, pkh, source) {
        return { source: typeof op.source === 'undefined' ? source || pkh : op.source };
    }
    buildEstimates(estimate) {
        return {
            fee: estimate.suggestedFeeMutez,
            gasLimit: estimate.gasLimit,
            storageLimit: estimate.storageLimit,
        };
    }
    addRevealOperationIfNeeded(operation, publicKeyHash) {
        return __awaiter(this, void 0, void 0, function* () {
            if (types_1.isOpRequireReveal(operation)) {
                const ops = [operation];
                const publicKey = yield this.signer.publicKey();
                const estimateReveal = yield this.estimate.reveal();
                if (estimateReveal) {
                    const estimatedReveal = this.buildEstimates(estimateReveal);
                    ops.unshift(yield contract_1.createRevealOperation(Object.assign({}, estimatedReveal), publicKeyHash, publicKey));
                    return ops;
                }
            }
            return operation;
        });
    }
    convertIntoArray(op) {
        if (Array.isArray(op)) {
            return [...op];
        }
        else {
            return [op];
        }
    }
    constructOpContents(ops, headCounter, pkh, source, currentVotingPeriod) {
        return ops.map((op) => {
            switch (op.kind) {
                case rpc_1.OpKind.ACTIVATION:
                case rpc_1.OpKind.DRAIN_DELEGATE:
                    return Object.assign({}, op);
                case rpc_1.OpKind.ORIGINATION:
                    return Object.assign(Object.assign(Object.assign(Object.assign({}, op), { balance: typeof op.balance !== 'undefined' ? `${op.balance}` : '0' }), this.getSource(op, pkh, source)), this.getFee(op, pkh, headCounter));
                case rpc_1.OpKind.TRANSACTION: {
                    const cops = Object.assign(Object.assign(Object.assign(Object.assign({}, op), { amount: typeof op.amount !== 'undefined' ? `${op.amount}` : '0' }), this.getSource(op, pkh, source)), this.getFee(op, pkh, headCounter));
                    if (cops.source.toLowerCase().startsWith('kt1')) {
                        throw new utils_1.DeprecationError(`KT1 addresses are not supported as source since ${constants_1.Protocols.PsBabyM1}`);
                    }
                    return cops;
                }
                case rpc_1.OpKind.REVEAL:
                case rpc_1.OpKind.DELEGATION:
                case rpc_1.OpKind.REGISTER_GLOBAL_CONSTANT:
                case rpc_1.OpKind.TX_ROLLUP_ORIGINATION:
                case rpc_1.OpKind.TX_ROLLUP_SUBMIT_BATCH:
                case rpc_1.OpKind.UPDATE_CONSENSUS_KEY:
                    return Object.assign(Object.assign(Object.assign({}, op), this.getSource(op, pkh, source)), this.getFee(op, pkh, headCounter));
                case rpc_1.OpKind.TRANSFER_TICKET:
                    return Object.assign(Object.assign(Object.assign(Object.assign({}, op), { ticket_amount: `${op.ticket_amount}` }), this.getSource(op, pkh, source)), this.getFee(op, pkh, headCounter));
                case rpc_1.OpKind.INCREASE_PAID_STORAGE:
                    return Object.assign(Object.assign(Object.assign(Object.assign({}, op), { amount: `${op.amount}` }), this.getSource(op, pkh, source)), this.getFee(op, pkh, headCounter));
                case rpc_1.OpKind.BALLOT:
                    if (currentVotingPeriod === undefined) {
                        throw new error_1.RPCResponseError(`Failed to get the current voting period index`);
                    }
                    return Object.assign(Object.assign({}, op), { period: currentVotingPeriod === null || currentVotingPeriod === void 0 ? void 0 : currentVotingPeriod.voting_period.index });
                case rpc_1.OpKind.PROPOSALS:
                    if (currentVotingPeriod === undefined) {
                        throw new error_1.RPCResponseError(`Failed to get the current voting period index`);
                    }
                    return Object.assign(Object.assign({}, op), { period: currentVotingPeriod === null || currentVotingPeriod === void 0 ? void 0 : currentVotingPeriod.voting_period.index });
                default:
                    throw new utils_1.InvalidOperationKindError(op.kind);
            }
        });
    }
    /**
     *
     * @description Method to prepare a reveal operation
     * @param operation RPCOperation object or RPCOperation array
     * @param source string or undefined source pkh
     * @returns a PreparedOperation object
     */
    reveal(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const pkh = yield this.signer.publicKeyHash();
            const estimate = yield this.estimate.reveal(params);
            if (estimate) {
                const estimates = this.buildEstimates(estimate);
                const op = yield contract_1.createRevealOperation(Object.assign({}, estimates), pkh, yield this.signer.publicKey());
                const ops = this.convertIntoArray(op);
                const hash = yield this.getBlockHash();
                const protocol = yield this.getProtocolHash();
                const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
                const contents = this.constructOpContents(ops, headCounter, pkh);
                return {
                    opOb: {
                        branch: hash,
                        contents,
                        protocol,
                    },
                    counter: headCounter,
                };
            }
            else {
                throw new contract_1.RevealOperationError(`The publicKeyHash '${pkh}' has already been revealed.`);
            }
        });
    }
    /**
     *
     * @description Method to prepare an origination operation
     * @param operation RPCOperation object or RPCOperation array
     * @param source string or undefined source pkh
     * @returns a PreparedOperation object
     */
    originate(params, source) {
        return __awaiter(this, void 0, void 0, function* () {
            const pkh = yield this.signer.publicKeyHash();
            const estimate = yield this.estimate.originate(params);
            const estimates = this.buildEstimates(estimate);
            const op = yield contract_1.createOriginationOperation(yield this.context.parser.prepareCodeOrigination(Object.assign(Object.assign({}, params), estimates)));
            const operation = yield this.addRevealOperationIfNeeded(op, pkh);
            const ops = this.convertIntoArray(operation);
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            const contents = this.constructOpContents(ops, headCounter, pkh, source);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare a transaction operation
     * @param operation RPCOperation object or RPCOperation array
     * @param source string or undefined source pkh
     * @returns a PreparedOperation object
     */
    transaction(params, source) {
        return __awaiter(this, void 0, void 0, function* () {
            const pkh = yield this.signer.publicKeyHash();
            const estimate = yield this.estimate.transfer(params);
            const estimates = this.buildEstimates(estimate);
            const op = yield contract_1.createTransferOperation(Object.assign(Object.assign({}, params), estimates));
            const operation = yield this.addRevealOperationIfNeeded(op, pkh);
            const ops = this.convertIntoArray(operation);
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            const contents = this.constructOpContents(ops, headCounter, pkh, source);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare a delegation operation
     * @param operation RPCOperation object or RPCOperation array
     * @param source string or undefined source pkh
     * @returns a PreparedOperation object
     */
    delegation(params, source) {
        return __awaiter(this, void 0, void 0, function* () {
            const pkh = yield this.signer.publicKeyHash();
            const estimate = yield this.estimate.setDelegate(params);
            const estimates = this.buildEstimates(estimate);
            const op = yield contract_1.createSetDelegateOperation(Object.assign(Object.assign({}, params), estimates));
            const operation = yield this.addRevealOperationIfNeeded(op, pkh);
            const ops = this.convertIntoArray(operation);
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            const contents = this.constructOpContents(ops, headCounter, pkh, source);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare a register_global_constant operation
     * @param operation RPCOperation object or RPCOperation array
     * @param source string or undefined source pkh
     * @returns a PreparedOperation object
     */
    registerGlobalConstant(params, source) {
        return __awaiter(this, void 0, void 0, function* () {
            const pkh = yield this.signer.publicKeyHash();
            const estimate = yield this.estimate.registerGlobalConstant(params);
            const estimates = this.buildEstimates(estimate);
            const op = yield contract_1.createRegisterGlobalConstantOperation(Object.assign(Object.assign({}, params), estimates));
            const operation = yield this.addRevealOperationIfNeeded(op, pkh);
            const ops = this.convertIntoArray(operation);
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            const contents = this.constructOpContents(ops, headCounter, pkh, source);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare a tx_rollup_origination operation
     * @param operation RPCOperation object or RPCOperation array
     * @param source string or undefined source pkh
     * @returns a PreparedOperation object
     */
    txRollupOrigination(params, source) {
        return __awaiter(this, void 0, void 0, function* () {
            const pkh = yield this.signer.publicKeyHash();
            const estimate = yield this.estimate.txRollupOriginate(params);
            const estimates = this.buildEstimates(estimate);
            const op = yield contract_1.createTxRollupOriginationOperation(Object.assign(Object.assign({}, params), estimates));
            const operation = yield this.addRevealOperationIfNeeded(op, pkh);
            const ops = this.convertIntoArray(operation);
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            const contents = this.constructOpContents(ops, headCounter, pkh, source);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare a tx_rollup_submit_batch operation
     * @param operation RPCOperation object or RPCOperation array
     * @param source string or undefined source pkh
     * @returns a PreparedOperation object
     */
    txRollupSubmitBatch(params, source) {
        return __awaiter(this, void 0, void 0, function* () {
            const pkh = yield this.signer.publicKeyHash();
            const estimate = yield this.estimate.txRollupSubmitBatch(params);
            const estimates = this.buildEstimates(estimate);
            const op = yield contract_1.createTxRollupBatchOperation(Object.assign(Object.assign({}, params), estimates));
            const operation = yield this.addRevealOperationIfNeeded(op, pkh);
            const ops = this.convertIntoArray(operation);
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            const contents = this.constructOpContents(ops, headCounter, pkh, source);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare an update_consensus_key operation
     * @param operation RPCOperation object or RPCOperation array
     * @param source string or undefined source pkh
     * @returns a PreparedOperation object
     */
    updateConsensusKey(params, source) {
        return __awaiter(this, void 0, void 0, function* () {
            const pkh = yield this.signer.publicKeyHash();
            const estimate = yield this.estimate.updateConsensusKey(params);
            const estimates = this.buildEstimates(estimate);
            const op = yield contract_1.createUpdateConsensusKeyOperation(Object.assign(Object.assign({}, params), estimates));
            const operation = yield this.addRevealOperationIfNeeded(op, pkh);
            const ops = this.convertIntoArray(operation);
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            const contents = this.constructOpContents(ops, headCounter, pkh, source);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare an increase_paid_storage operation
     * @param operation RPCOperation object or RPCOperation array
     * @param source string or undefined source pkh
     * @returns a PreparedOperation object
     */
    increasePaidStorage(params, source) {
        return __awaiter(this, void 0, void 0, function* () {
            const pkh = yield this.signer.publicKeyHash();
            const estimate = yield this.estimate.increasePaidStorage(params);
            const estimates = this.buildEstimates(estimate);
            const op = yield contract_1.createIncreasePaidStorageOperation(Object.assign(Object.assign({}, params), estimates));
            const operation = yield this.addRevealOperationIfNeeded(op, pkh);
            const ops = this.convertIntoArray(operation);
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            const contents = this.constructOpContents(ops, headCounter, pkh, source);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare a ballot operation
     * @param operation RPCOperation object or RPCOperation array
     * @returns a PreparedOperation object
     */
    ballot(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const pkh = yield this.signer.publicKeyHash();
            const op = yield contract_1.createBallotOperation(Object.assign({}, params));
            const ops = this.convertIntoArray(op);
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            let currentVotingPeriod;
            try {
                currentVotingPeriod = yield this.rpc.getCurrentPeriod();
            }
            catch (e) {
                throw new error_1.RPCResponseError('Failed to get the current voting period index');
            }
            const contents = this.constructOpContents(ops, headCounter, pkh, undefined, currentVotingPeriod);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare a proposals operation
     * @param operation RPCOperation object or RPCOperation array
     * @returns a PreparedOperation object
     */
    proposals(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const pkh = yield this.signer.publicKeyHash();
            const op = yield contract_1.createProposalsOperation(Object.assign({}, params));
            const ops = this.convertIntoArray(op);
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            let currentVotingPeriod;
            try {
                currentVotingPeriod = yield this.rpc.getCurrentPeriod();
            }
            catch (e) {
                throw new error_1.RPCResponseError('Failed to get the current voting period index');
            }
            const contents = this.constructOpContents(ops, headCounter, pkh, undefined, currentVotingPeriod);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare a drain_delegate operation
     * @param operation RPCOperation object or RPCOperation array
     * @returns a PreparedOperation object
     */
    drainDelegate(params, source) {
        return __awaiter(this, void 0, void 0, function* () {
            const pkh = yield this.signer.publicKeyHash();
            const op = yield contract_1.createDrainDelegateOperation(Object.assign({}, params));
            const ops = this.convertIntoArray(op);
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            const contents = this.constructOpContents(ops, headCounter, pkh, source);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare a transfer_ticket operation
     * @param operation RPCOperation object or RPCOperation array
     * @param source string or undefined source pkh
     * @returns a PreparedOperation object
     */
    transferTicket(params, source) {
        return __awaiter(this, void 0, void 0, function* () {
            const pkh = yield this.signer.publicKeyHash();
            const estimate = yield this.estimate.transferTicket(params);
            const estimates = this.buildEstimates(estimate);
            const op = yield contract_1.createTransferTicketOperation(Object.assign(Object.assign({}, params), estimates));
            const operation = yield this.addRevealOperationIfNeeded(op, pkh);
            const ops = this.convertIntoArray(operation);
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            const contents = this.constructOpContents(ops, headCounter, pkh, source);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare a batch operation
     * @param operation RPCOperation object or RPCOperation array
     * @returns a PreparedOperation object
     */
    batch(batchParams) {
        return __awaiter(this, void 0, void 0, function* () {
            // const ops = this.convertIntoArray(operation);
            const pkh = yield this.signer.publicKeyHash();
            const batch = new rpc_batch_provider_1.OperationBatch(this.context, this.estimate);
            if (Array.isArray(batchParams)) {
                batch.with(batchParams);
            }
            const ops = yield batch.toPrepare();
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            const contents = this.constructOpContents(ops, headCounter, pkh);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare a batch operation
     * @param operation RPCOperation object or RPCOperation array
     * @returns a PreparedOperation object
     */
    contractCall(contractMethod) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            const pkh = yield this.signer.publicKeyHash();
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            const params = contractMethod.toTransferParams();
            const estimate = yield this.estimate.transfer(params);
            const ops = [
                {
                    kind: rpc_1.OpKind.TRANSACTION,
                    fee: (_a = params.fee) !== null && _a !== void 0 ? _a : estimate.suggestedFeeMutez,
                    gas_limit: (_b = params.gasLimit) !== null && _b !== void 0 ? _b : estimate.gasLimit,
                    storage_limit: (_c = params.storageLimit) !== null && _c !== void 0 ? _c : estimate.storageLimit,
                    amount: String(params.amount),
                    destination: params.to,
                },
            ];
            const contents = this.constructOpContents(ops, headCounter, pkh);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
}
exports.PrepareProvider = PrepareProvider;
_counters = new WeakMap();
//# sourceMappingURL=prepare-provider.js.map