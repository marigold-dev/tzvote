(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@stablelib/nacl'), require('@stablelib/blake2b'), require('@taquito/utils'), require('typedarray-to-buffer'), require('@stablelib/ed25519'), require('elliptic'), require('pbkdf2'), require('bip39'), require('@stablelib/hmac'), require('@stablelib/sha512'), require('bn.js')) :
    typeof define === 'function' && define.amd ? define(['exports', '@stablelib/nacl', '@stablelib/blake2b', '@taquito/utils', 'typedarray-to-buffer', '@stablelib/ed25519', 'elliptic', 'pbkdf2', 'bip39', '@stablelib/hmac', '@stablelib/sha512', 'bn.js'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.taquitoSigner = {}, global.nacl, global.blake2b, global.utils, global.toBuffer, global.ed25519$1, global.elliptic, global.pbkdf2, global.Bip39, global.hmac, global.sha512, global.BN));
})(this, (function (exports, nacl, blake2b, utils, toBuffer, ed25519$1, elliptic, pbkdf2, Bip39, hmac, sha512, BN) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        }
        n["default"] = e;
        return Object.freeze(n);
    }

    var toBuffer__default = /*#__PURE__*/_interopDefaultLegacy(toBuffer);
    var elliptic__default = /*#__PURE__*/_interopDefaultLegacy(elliptic);
    var pbkdf2__default = /*#__PURE__*/_interopDefaultLegacy(pbkdf2);
    var Bip39__namespace = /*#__PURE__*/_interopNamespace(Bip39);
    var BN__default = /*#__PURE__*/_interopDefaultLegacy(BN);

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    /**
     * @description Provide signing logic for ed25519 curve based key (tz1)
     */
    class Tz1 {
        /**
         *
         * @param key Encoded private key
         * @param encrypted Is the private key encrypted
         * @param decrypt Decrypt function
         */
        constructor(key, encrypted, decrypt) {
            this.key = key;
            const keyPrefix = key.substr(0, encrypted ? 5 : 4);
            if (!utils.isValidPrefix(keyPrefix)) {
                throw new utils.InvalidKeyError(key, 'Key contains invalid prefix');
            }
            this._key = decrypt(utils.b58cdecode(this.key, utils.prefix[keyPrefix]));
            this._publicKey = this._key.slice(32);
            if (!this._key) {
                throw new utils.InvalidKeyError(key, 'Unable to decode');
            }
            this.isInit = this.init();
        }
        init() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._key.length !== 64) {
                    const { publicKey, secretKey } = ed25519$1.generateKeyPairFromSeed(new Uint8Array(this._key));
                    this._publicKey = publicKey;
                    this._key = secretKey;
                }
                return true;
            });
        }
        /**
         *
         * @param bytes Bytes to sign
         * @param bytesHash Blake2b hash of the bytes to sign
         */
        sign(bytes, bytesHash) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.isInit;
                const signature = ed25519$1.sign(new Uint8Array(this._key), new Uint8Array(bytesHash));
                const signatureBuffer = toBuffer__default["default"](signature);
                const sbytes = bytes + utils.buf2hex(signatureBuffer);
                return {
                    bytes,
                    sig: utils.b58cencode(signature, utils.prefix.sig),
                    prefixSig: utils.b58cencode(signature, utils.prefix.edsig),
                    sbytes,
                };
            });
        }
        /**
         * @returns Encoded public key
         */
        publicKey() {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.isInit;
                return utils.b58cencode(this._publicKey, utils.prefix['edpk']);
            });
        }
        /**
         * @returns Encoded public key hash
         */
        publicKeyHash() {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.isInit;
                return utils.b58cencode(blake2b.hash(new Uint8Array(this._publicKey), 20), utils.prefix.tz1);
            });
        }
        /**
         * @returns Encoded private key
         */
        secretKey() {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.isInit;
                let key = this._key;
                const { secretKey } = ed25519$1.generateKeyPairFromSeed(new Uint8Array(key).slice(0, 32));
                key = toBuffer__default["default"](secretKey);
                return utils.b58cencode(key, utils.prefix[`edsk`]);
            });
        }
    }

    const pref = {
        p256: {
            pk: utils.prefix['p2pk'],
            sk: utils.prefix['p2sk'],
            pkh: utils.prefix.tz3,
            sig: utils.prefix.p2sig,
        },
        secp256k1: {
            pk: utils.prefix['sppk'],
            sk: utils.prefix['spsk'],
            pkh: utils.prefix.tz2,
            sig: utils.prefix.spsig,
        },
    };
    /**
     * @description Provide signing logic for elliptic curve based key (tz2, tz3)
     */
    class ECKey {
        /**
         *
         * @param curve Curve to use with the key
         * @param key Encoded private key
         * @param encrypted Is the private key encrypted
         * @param decrypt Decrypt function
         */
        constructor(curve, key, encrypted, decrypt) {
            this.curve = curve;
            this.key = key;
            const keyPrefix = key.substr(0, encrypted ? 5 : 4);
            if (!utils.isValidPrefix(keyPrefix)) {
                throw new utils.InvalidKeyError(key, 'Key contains invalid prefix');
            }
            this._key = decrypt(utils.b58cdecode(this.key, utils.prefix[keyPrefix]));
            const keyPair = new elliptic__default["default"].ec(this.curve).keyFromPrivate(this._key);
            const keyPairY = keyPair.getPublic().getY().toArray();
            const parityByte = keyPairY.length < 32 ? keyPairY[keyPairY.length - 1] : keyPairY[31];
            const pref = parityByte % 2 ? 3 : 2;
            const pad = new Array(32).fill(0);
            this._publicKey = toBuffer__default["default"](new Uint8Array([pref].concat(pad.concat(keyPair.getPublic().getX().toArray()).slice(-32))));
        }
        /**
         *
         * @param bytes Bytes to sign
         * @param bytesHash Blake2b hash of the bytes to sign
         */
        sign(bytes, bytesHash) {
            return __awaiter(this, void 0, void 0, function* () {
                const key = new elliptic__default["default"].ec(this.curve).keyFromPrivate(this._key);
                const sig = key.sign(bytesHash, { canonical: true });
                const signature = sig.r.toString('hex', 64) + sig.s.toString('hex', 64);
                const sbytes = bytes + signature;
                return {
                    bytes,
                    sig: utils.b58cencode(signature, utils.prefix.sig),
                    prefixSig: utils.b58cencode(signature, pref[this.curve].sig),
                    sbytes,
                };
            });
        }
        /**
         * @returns Encoded public key
         */
        publicKey() {
            return __awaiter(this, void 0, void 0, function* () {
                return utils.b58cencode(this._publicKey, pref[this.curve].pk);
            });
        }
        /**
         * @returns Encoded public key hash
         */
        publicKeyHash() {
            return __awaiter(this, void 0, void 0, function* () {
                return utils.b58cencode(blake2b.hash(new Uint8Array(this._publicKey), 20), pref[this.curve].pkh);
            });
        }
        /**
         * @returns Encoded private key
         */
        secretKey() {
            return __awaiter(this, void 0, void 0, function* () {
                const key = this._key;
                return utils.b58cencode(key, pref[this.curve].sk);
            });
        }
    }
    /**
     * @description Tz3 key class using the p256 curve
     */
    const Tz3 = ECKey.bind(null, 'p256');
    /**
     * @description Tz2 key class using the secp256k1 curve
     */
    const Tz2 = ECKey.bind(null, 'secp256k1');

    class InvalidDerivationPathError extends Error {
        constructor(message) {
            super(message);
            this.message = message;
            this.name = 'InvalidDerivationPathError';
        }
    }
    class InvalidMnemonicError extends Error {
        constructor(message) {
            super(message);
            this.message = message;
            this.name = 'InvalidMnemonicError';
        }
    }
    class InvalidBitSize extends Error {
        constructor(message) {
            super(message);
            this.message = message;
            this.name = 'InvalidBitSize';
        }
    }
    class InvalidCurveError extends Error {
        constructor(curve) {
            super(`This Curve is not supported: ${curve}`);
            this.curve = curve;
            this.name = 'InvalidCurveError';
        }
    }
    class InvalidSeedLengthError extends Error {
        constructor(seedLength) {
            super(`The seed has an invalid length: ${seedLength}`);
            this.seedLength = seedLength;
            this.name = 'InvalidSeedLengthError';
        }
    }
    class PrivateKeyError extends Error {
        constructor(message) {
            super(message);
            this.message = message;
            this.name = 'PrivateKeyError';
        }
    }
    class ToBeImplemented extends Error {
        constructor() {
            super('This feature is under developement');
            this.name = 'ToBeImplemented';
        }
    }

    function parseHex(s) {
        const res = [];
        for (let i = 0; i < s.length; i += 2) {
            const ss = s.slice(i, i + 2);
            const x = parseInt(ss, 16);
            if (Number.isNaN(x)) {
                throw new utils.InvalidHexStringError(`invalid hexadecimal number ${ss}`);
            }
            res.push(x);
        }
        return new Uint8Array(res);
    }

    /* eslint-disable @typescript-eslint/no-this-alias */
    const seedKey = {
        p256: 'Nist256p1 seed',
        secp256k1: 'Bitcoin seed',
    };
    // MinSeedSize is the minimal allowed seed byte length
    const minSeedSize$1 = 16;
    // MaxSeedSize is the maximal allowed seed byte length
    const maxSeedSize$1 = 64;
    class PrivateKey$1 {
        /**
         *
         * @param priv key pair priv (BN) pub (curve.base.BasePint) if applicable
         * @param chainCode slice 32->n HMAC hash key and seedkey (first instance curve default seedKey. after hmac value slice 32->n)
         */
        constructor(priv, chainCode) {
            this.chainCode = chainCode;
            this.keyPair = priv;
        }
        /**
         * @param seedSrc result of Bip39.mnemonicToSeed
         * @param curve known supported curve p256 or secp256k1
         * @returns instance of PrivateKey non-HD keys derived
         */
        static fromSeed(seedSrc, curve) {
            var _a, _b;
            let seed = typeof seedSrc === 'string' ? parseHex(seedSrc) : seedSrc;
            if (seed.length < minSeedSize$1 || seed.length > maxSeedSize$1) {
                throw new InvalidSeedLengthError(seed.length);
            }
            if (!Object.prototype.hasOwnProperty.call(seedKey, curve)) {
                throw new InvalidCurveError(`unknown curve ${curve}`);
            }
            const c = new elliptic.ec(curve);
            if (((_a = c.n) === null || _a === void 0 ? void 0 : _a.bitLength()) !== 256) {
                throw new InvalidBitSize(`invalid curve bit size ${(_b = c.n) === null || _b === void 0 ? void 0 : _b.bitLength()}`);
            }
            const key = new TextEncoder().encode(seedKey[curve]);
            let d = null;
            let chain = new Uint8Array();
            let i = 0;
            while (i === 0) {
                const sum = new hmac.HMAC(sha512.SHA512, key).update(seed).digest();
                d = new BN__default["default"](sum.subarray(0, 32));
                chain = sum.subarray(32);
                if (d.isZero() || d.cmp(c.n) >= 0) {
                    seed = sum;
                }
                else {
                    i++;
                }
            }
            const keyPair = c.keyPair({});
            keyPair.priv = d;
            return new PrivateKey$1(keyPair, chain);
        }
        /**
         *
         * @param index derivation path item pre-hardened if applicable ie: 44' -> 2^31 + 44
         * @returns child PrivateKey of the current PrivateKey
         */
        derive(index) {
            const data = new Uint8Array(37);
            if ((index & Hard) !== 0) {
                // hardened derivation
                data.set(this.keyPair.getPrivate().toArray(), 1);
            }
            else {
                data.set(this.keyPair.getPublic().encodeCompressed(), 0);
            }
            new DataView(data.buffer).setUint32(33, index);
            let d = new BN__default["default"](0);
            let chain = new Uint8Array;
            let i = 0;
            while (i === 0) {
                const sum = new hmac.HMAC(sha512.SHA512, this.chainCode).update(data).digest();
                d = new BN__default["default"](sum.subarray(0, 32));
                chain = sum.subarray(32);
                if (this.keyPair.ec.n && d.cmp(this.keyPair.ec.n) < 0) {
                    d = d.add(this.keyPair.getPrivate()).mod(this.keyPair.ec.n);
                    if (!d.isZero()) {
                        i++;
                    }
                }
                data.set(chain, 1);
                data[0] = 1;
            }
            const keyPair = this.keyPair.ec.keyPair({});
            keyPair.priv = d;
            return new PrivateKey$1(keyPair, chain);
        }
        /**
         *
         * @param path pre-hardened (if applicable) derivation path items ie 44'/1729'/0/0 -> 2^31 + 44/2^31 + 1729/0/0
         * @returns final child of the full HD keys derivation
         */
        derivePath(path) {
            let key = this;
            for (const x of path) {
                key = key.derive(x);
            }
            return key;
        }
        /**
         *
         * @returns Uint8Array (if contains a private key)
         */
        bytes() {
            if (!this.keyPair.priv) {
                throw new PrivateKeyError('not a private key');
            }
            // pad to 32 bytes as toArray() length argument seems to be ignored (BN bug)
            const src = this.keyPair.priv.toArray();
            const out = new Uint8Array(32);
            out.set(src, out.length - src.length);
            return out;
        }
    }

    var ecdsa = /*#__PURE__*/Object.freeze({
        __proto__: null,
        PrivateKey: PrivateKey$1
    });

    const Hard = 0x80000000;
    class Path extends Array {
        static from(iterable) {
            return super.from(iterable).map((x) => x >>> 0);
        }
        /**
         *
         * @param s derivation path eg: 44'/1729'/0'/0'
         * @returns applied hardened values
         */
        static fromString(s) {
            if (s.length === 0) {
                return new Path();
            }
            let parts = s.split('/');
            const out = [];
            if (parts[0] === 'm') {
                parts = parts.slice(1);
            }
            for (let p of parts) {
                if (p.length === 0) {
                    throw new InvalidDerivationPathError(`invalid BIP32 path: ${s}`);
                }
                let h = 0;
                const last = p[p.length - 1];
                if (last === "'" || last === 'h' || last === 'H') {
                    h = Hard;
                    p = p.slice(0, p.length - 1);
                }
                const index = (parseInt(p, 10) | h) >>> 0;
                out.push(index);
            }
            return Path.from(out);
        }
    }

    /* eslint-disable @typescript-eslint/no-this-alias */
    // MinSeedSize is the minimal allowed seed byte length
    const minSeedSize = 16;
    // MaxSeedSize is the maximal allowed seed byte length
    const maxSeedSize = 64;
    const ed25519Key = 'ed25519 seed';
    class PrivateKey {
        /**
         *
         * @param priv generated keypair 0->32 private key 32->n public key
         * @param chainCode new HMAC hash with new key
         */
        constructor(priv, chainCode) {
            this.priv = priv;
            this.chainCode = chainCode;
        }
        /**
         *
         * @param seedSrc result of Bip39.mnemonicToSeed
         * @returns instance of PrivateKey
         */
        static fromSeed(seedSrc) {
            const seed = typeof seedSrc === 'string' ? parseHex(seedSrc) : seedSrc;
            if (seed.length < minSeedSize || seed.length > maxSeedSize) {
                throw new InvalidSeedLengthError(seed.length);
            }
            const key = new TextEncoder().encode(ed25519Key);
            const sum = new hmac.HMAC(sha512.SHA512, key).update(seed).digest();
            return new PrivateKey(ed25519$1.generateKeyPairFromSeed(sum.subarray(0, 32)).secretKey, sum.subarray(32));
        }
        /**
         *
         * @returns slice(0, 32) of current priv for new seed for next derived priv
         */
        seed() {
            return this.priv.subarray(0, 32);
        }
        /**
         * @index current derivation path item ie: 1729'
         * @returns derivation path child of original private key pair
         */
        derive(index) {
            if ((index & Hard) === 0) {
                throw new InvalidDerivationPathError('Non-hardened derivation path');
            }
            const data = new Uint8Array(37);
            data.set(this.seed(), 1);
            new DataView(data.buffer).setUint32(33, index);
            const sum = new hmac.HMAC(sha512.SHA512, this.chainCode).update(data).digest();
            return new PrivateKey(ed25519$1.generateKeyPairFromSeed(sum.subarray(0, 32)).secretKey, sum.subarray(32));
        }
        /**
         * @param path array of numbers pre adjusted for hardened paths ie: 44' -> 2^31 + 44
         * @returns final child of full derivation path private key pair
         */
        derivePath(path) {
            let key = this;
            for (const index of path) {
                key = key.derive(index);
            }
            return key;
        }
    }

    var ed25519 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        PrivateKey: PrivateKey
    });

    // bip32 when supported add to @param curve bip25519
    /**
     *
     * @param seed bip39.mnemonicToSeed
     * @param derivationPath Tezos Requirement 44'/1729' for HD key address default 44'/1729'/0'/0'
     * @param curve 'ed25519' | 'secp256k1' | 'p256''
     * @returns final Derivation of HD keys tezos Secret key
     */
    const generateSecretKey = (seed, derivationPath, curve) => {
        const path = Path.fromString(derivationPath);
        let node;
        switch (curve) {
            case 'ed25519': {
                node = PrivateKey.fromSeed(seed).derivePath(path);
                const sk = utils.b58cencode(node.seed().slice(0, 32), utils.prefix.edsk2);
                return sk;
            }
            case 'secp256k1':
            case 'p256': {
                const prefixType = curve === 'secp256k1' ? utils.prefix.spsk : utils.prefix.p2sk;
                let privKey = PrivateKey$1.fromSeed(seed, curve);
                privKey = privKey.derivePath(path);
                const uint8arr = new Uint8Array(privKey.keyPair.getPrivate().toArray());
                const sk = utils.b58cencode(uint8arr, prefixType);
                return sk;
            }
            case 'bip25519': {
                throw new ToBeImplemented();
            }
            default: {
                throw new InvalidCurveError(curve);
            }
        }
    };

    /**
     *
     * @description Import a key to sign operation with the side-effect of setting the Tezos instance to use the InMemorySigner provider
     *
     * @warn The JSON faucets are no longer available on https://teztnets.xyz/
     * @param toolkit The toolkit instance to attach a signer
     * @param privateKeyOrEmail Key to load in memory
     * @param passphrase If the key is encrypted passphrase to decrypt it
     * @param mnemonic Faucet mnemonic
     * @param secret Faucet secret
     */
    function importKey(toolkit, privateKeyOrEmail, passphrase, mnemonic, secret) {
        return __awaiter(this, void 0, void 0, function* () {
            if (privateKeyOrEmail && passphrase && mnemonic && secret) {
                const signer = InMemorySigner.fromFundraiser(privateKeyOrEmail, passphrase, mnemonic);
                toolkit.setProvider({ signer });
                const pkh = yield signer.publicKeyHash();
                let op;
                try {
                    op = yield toolkit.tz.activate(pkh, secret);
                }
                catch (ex) {
                    const isInvalidActivationError = ex && ex.body && /Invalid activation/.test(ex.body);
                    if (!isInvalidActivationError) {
                        throw ex;
                    }
                }
                if (op) {
                    yield op.confirmation();
                }
            }
            else {
                // Fallback to regular import
                const signer = yield InMemorySigner.fromSecretKey(privateKeyOrEmail, passphrase);
                toolkit.setProvider({ signer });
            }
        });
    }

    // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!
    const VERSION = {
        "commitHash": "178bea7c6a3b3c58f23163fcc72e28aa5f08702a",
        "version": "15.1.0"
    };

    /**
     *  @category Error
     *  @description Error that indicates an invalid passphrase being passed or used
     */
    class InvalidPassphraseError extends Error {
        constructor(message) {
            super(message);
            this.message = message;
            this.name = 'InvalidPassphraseError';
        }
    }
    /**
     * @description A local implementation of the signer. Will represent a Tezos account and be able to produce signature in its behalf
     *
     * @warn If running in production and dealing with tokens that have real value, it is strongly recommended to use a HSM backed signer so that private key material is not stored in memory or on disk
     *
     */
    class InMemorySigner {
        /**
         *
         * @param key Encoded private key
         * @param passphrase Passphrase to decrypt the private key if it is encrypted
         *
         */
        constructor(key, passphrase) {
            const encrypted = key.substring(2, 3) === 'e';
            let decrypt = (k) => k;
            if (encrypted) {
                if (!passphrase) {
                    throw new InvalidPassphraseError('Encrypted key provided without a passphrase.');
                }
                decrypt = (constructedKey) => {
                    const salt = toBuffer__default["default"](constructedKey.slice(0, 8));
                    const encryptedSk = constructedKey.slice(8);
                    const encryptionKey = pbkdf2__default["default"].pbkdf2Sync(passphrase, salt, 32768, 32, 'sha512');
                    return nacl.openSecretBox(new Uint8Array(encryptionKey), new Uint8Array(24), new Uint8Array(encryptedSk));
                };
            }
            switch (key.substr(0, 4)) {
                case 'edes':
                case 'edsk':
                    this._key = new Tz1(key, encrypted, decrypt);
                    break;
                case 'spsk':
                case 'spes':
                    this._key = new Tz2(key, encrypted, decrypt);
                    break;
                case 'p2sk':
                case 'p2es':
                    this._key = new Tz3(key, encrypted, decrypt);
                    break;
                default:
                    throw new utils.InvalidKeyError(key, 'Unsupported key type');
            }
        }
        static fromFundraiser(email, password, mnemonic) {
            if (!Bip39__namespace.validateMnemonic(mnemonic)) {
                throw new InvalidMnemonicError(`Invalid mnemonic: ${mnemonic}`);
            }
            const seed = Bip39__namespace.mnemonicToSeedSync(mnemonic, `${email}${password}`);
            const key = utils.b58cencode(seed.slice(0, 32), utils.prefix.edsk2);
            return new InMemorySigner(key);
        }
        static fromSecretKey(key, passphrase) {
            return __awaiter(this, void 0, void 0, function* () {
                return new InMemorySigner(key, passphrase);
            });
        }
        /**
         *
         * @description Instantiation of an InMemorySigner instance from a mnemonic
         * @param mnemonic 12-24 word mnemonic
         * @param password password used to encrypt the mnemonic to seed value
         * @param derivationPath default 44'/1729'/0'/0' (44'/1729' mandatory)
         * @param curve currently only supported for tz1, tz2, tz3 addresses. soon bip25519
         * @returns InMemorySigner
         */
        static fromMnemonic({ mnemonic, password = '', derivationPath = "44'/1729'/0'/0'", curve = 'ed25519' }) {
            // check if curve is defined if not default tz1
            if (!Bip39__namespace.validateMnemonic(mnemonic)) {
                // avoiding exposing mnemonic again in case of mistake making invalid
                throw new InvalidMnemonicError('Mnemonic provided is invalid');
            }
            const seed = Bip39__namespace.mnemonicToSeedSync(mnemonic, password);
            const sk = generateSecretKey(seed, derivationPath, curve);
            return new InMemorySigner(sk);
        }
        /**
         *
         * @param bytes Bytes to sign
         * @param watermark Watermark to append to the bytes
         */
        sign(bytes, watermark) {
            return __awaiter(this, void 0, void 0, function* () {
                let bb = utils.hex2buf(bytes);
                if (typeof watermark !== 'undefined') {
                    bb = utils.mergebuf(watermark, bb);
                }
                const bytesHash = blake2b.hash(bb, 32);
                return this._key.sign(bytes, bytesHash);
            });
        }
        /**
         * @returns Encoded public key
         */
        publicKey() {
            return __awaiter(this, void 0, void 0, function* () {
                return this._key.publicKey();
            });
        }
        /**
         * @returns Encoded public key hash
         */
        publicKeyHash() {
            return __awaiter(this, void 0, void 0, function* () {
                return this._key.publicKeyHash();
            });
        }
        /**
         * @returns Encoded private key
         */
        secretKey() {
            return __awaiter(this, void 0, void 0, function* () {
                return this._key.secretKey();
            });
        }
    }

    exports.ECDSA = ecdsa;
    exports.Ed25519 = ed25519;
    exports.Hard = Hard;
    exports.InMemorySigner = InMemorySigner;
    exports.InvalidPassphraseError = InvalidPassphraseError;
    exports.Path = Path;
    exports.VERSION = VERSION;
    exports.generateSecretKey = generateSecretKey;
    exports.importKey = importKey;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=taquito-signer.umd.js.map
