import { Curves } from './helpers';
export * from './import-key';
export { VERSION } from './version';
export * from './derivation-tools';
export * from './helpers';
/**
 *  @category Error
 *  @description Error that indicates an invalid passphrase being passed or used
 */
export declare class InvalidPassphraseError extends Error {
    message: string;
    name: string;
    constructor(message: string);
}
export interface FromMnemonicParams {
    mnemonic: string;
    password?: string;
    derivationPath?: string;
    curve?: Curves;
}
/**
 * @description A local implementation of the signer. Will represent a Tezos account and be able to produce signature in its behalf
 *
 * @warn If running in production and dealing with tokens that have real value, it is strongly recommended to use a HSM backed signer so that private key material is not stored in memory or on disk
 *
 */
export declare class InMemorySigner {
    private _key;
    static fromFundraiser(email: string, password: string, mnemonic: string): InMemorySigner;
    static fromSecretKey(key: string, passphrase?: string): Promise<InMemorySigner>;
    /**
     *
     * @description Instantiation of an InMemorySigner instance from a mnemonic
     * @param mnemonic 12-24 word mnemonic
     * @param password password used to encrypt the mnemonic to seed value
     * @param derivationPath default 44'/1729'/0'/0' (44'/1729' mandatory)
     * @param curve currently only supported for tz1, tz2, tz3 addresses. soon bip25519
     * @returns InMemorySigner
     */
    static fromMnemonic({ mnemonic, password, derivationPath, curve }: FromMnemonicParams): InMemorySigner;
    /**
     *
     * @param key Encoded private key
     * @param passphrase Passphrase to decrypt the private key if it is encrypted
     *
     */
    constructor(key: string, passphrase?: string);
    /**
     *
     * @param bytes Bytes to sign
     * @param watermark Watermark to append to the bytes
     */
    sign(bytes: string, watermark?: Uint8Array): Promise<{
        bytes: string;
        sig: string;
        prefixSig: string;
        sbytes: string;
    }>;
    /**
     * @returns Encoded public key
     */
    publicKey(): Promise<string>;
    /**
     * @returns Encoded public key hash
     */
    publicKeyHash(): Promise<string>;
    /**
     * @returns Encoded private key
     */
    secretKey(): Promise<string>;
}
