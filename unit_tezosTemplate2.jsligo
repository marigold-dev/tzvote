#include "tezosTemplate2.jsligo"

//util function
let assert_failure = (result : test_exec_result) : bool => {
  return match(result,{
    Success: (_ : nat) => false,
    Fail: ( tee : test_exec_error ) => { 
      Test.log (["Exception correctly caught", 
      match(tee,{
        Other: () =>"Other", 
        Rejected: (s:[michelson_program , address])=>("Cause : Rejected") })
      ]) ; 
      return true}
    })
  };
  
  let initial_storage = 
  {  name : "Which is the cutiest pokemon?",
  dateFrom : ("2022-01-01t00:00:00Z" as timestamp),  
  dateTo : ("2022-03-01t00:00:00Z" as timestamp),  
  options : list(["Mew","Pikachu"]) ,  
  votes : (Map.empty as map<address, string>), 
  results : (Map.empty as map<string, int>) } ;
  
  // create faucet
  let _1 = Test.reset_state ( 2 as nat, list([]) as list <tez> );
  let faucet = Test.nth_bootstrap_account(0);
  
 
  let initAccount = ([accList, k]: [list<address>, key]) : list<address> => {
      Test.log(k);
      let hk : key_hash = Crypto.hash_key(k);
      let c : contract<unit> = Tezos.implicit_account(hk);
      //set balance
      let _ : test_exec_result = Test.transfer_to_contract (c,unit,(1000 as tez));
      Test.log("New account");
      Test.log(Tezos.address(c));
      Test.log(Test.get_balance(Tezos.address(c)));
      return list([Tezos.address(c) , ...accList]); 
  };
  
  // account list
  let keys : list<key> = list([("edpkuBknW28nW72KG6RoHtYW7p12T6GKc7nAbwYX5m8Wd9sDVC9yav" as key)]);
  let addresses : list<address> = List.fold(initAccount, keys, list([]) as list<address>);


  let _3 = Test.set_baker(faucet);
  let _2 = Test.set_source(faucet);
  
  let [taddr, _, _] = Test.originate(main, initial_storage, (0 as tez));
  let contr = Test.to_contract(taddr);
  
  let _testOriginate = () : bool => {
    assert((Test.get_storage(taddr) as storage).name  == "Which is the cutiest pokemon?");
    assert((Test.get_storage(taddr) as storage).dateFrom  == ("2022-01-01t00:00:00Z" as timestamp));
    assert((Test.get_storage(taddr) as storage).dateTo  == ("2022-03-01t00:00:00Z" as timestamp));
    return true ;
  };
  
  let _testVote = ([s,o,k,voteCount] : [address,string,key_hash,int]) : bool => {
    Test.set_source(s);
    Test.log(s);
    Test.log(k);
    let status = Test.transfer_to_contract(contr, (Vote([o,k])), 1 as mutez);
    Test.log(status);
    let st = (Test.get_storage(taddr) as storage);
    Test.log(st);
    //assert(Option.unopt(Map.find_opt(s,st.votes))  == o);
    //assert(Option.unopt(Map.find_opt(o,st.results))  == voteCount);
    return true;
  };
  
  let _testVoteFail = ( [s,o,k] : [address,string,key_hash]) : bool => {
    Test.set_source(s);
    return assert_failure(Test.transfer_to_contract(contr, (Vote([o,k])), 1 as mutez));
  };
  
  let testOriginate = _testOriginate();
  
  
  let _currentTime = Test.set_now('2022-02-01T00:00:00Z' as timestamp);
  let testSender1VotePikachu = _testVote(Option.unopt (List.head_opt(addresses)),"Pikachu",Crypto.hash_key(Option.unopt (List.head_opt(keys))),1);
  
  /*
  
  //ovverride out of time
  let _oldTime = Test.set_now('2000-02-01T00:00:00Z' as timestamp);
  let testVoteOutOfDate = _testVoteFail(sender1,"Pikachu",sender1Key);
  //return to normal date
  let _currentTime = Test.set_now('2022-02-01T00:00:00Z' as timestamp);
  let testSender1VoteUnknownOption = _testVoteFail(sender1, "Batman",sender1Key);
  let testSender1VotePikachu = _testVote(sender1,"Pikachu",sender1Key,1);
  let testSender1VotePikachuAgainAndFail = _testVoteFail(sender1,"Pikachu",sender1Key);
  let testSender2VotePikachu = _testVote(sender2,"Pikachu",sender1Key,2);
  let testSender2VoteMewAndFail = _testVoteFail(sender2,"Mew",sender1Key);
  let testSender3VoteMew = _testVote(sender3,"Mew",sender1Key,1);
  */