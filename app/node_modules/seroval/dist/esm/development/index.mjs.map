{
  "version": 3,
  "sources": ["../../../src/compat.ts", "../../../src/get-identifier.ts", "../../../src/context.ts", "../../../src/assert.ts", "../../../src/quote.ts", "../../../src/tree/symbols.ts", "../../../src/tree/primitives.ts", "../../../src/tree/shared.ts", "../../../src/tree/async.ts", "../../../src/tree/deserialize.ts", "../../../src/tree/serialize.ts", "../../../src/tree/sync.ts", "../../../src/index.ts"],
  "sourcesContent": ["/* eslint-disable guard-for-in */\n/**\n * References\n * - https://kangax.github.io/compat-table/es6/\n * - MDN\n */\n\nexport const enum Feature {\n  AggregateError = 0x01,\n  ArrayPrototypeValues = 0x02,\n  ArrowFunction = 0x04,\n  BigInt = 0x08,\n  ErrorPrototypeStack = 0x10,\n  Map = 0x20,\n  MethodShorthand = 0x40,\n  ObjectAssign = 0x80,\n  Promise = 0x100,\n  Set = 0x200,\n  Symbol = 0x400,\n  TypedArray = 0x800,\n  BigIntTypedArray = 0x1000,\n}\n\nexport const ALL_ENABLED = 0x1FFF;\n", "// Written by https://github.com/DylanPiercey and is distributed under the MIT license.\nconst REF_START_CHARS = 'hjkmoquxzABCDEFGHIJKLNPQRTUVWXYZ$_'; // Avoids chars that could evaluate to a reserved word.\nconst REF_START_CHARS_LEN = REF_START_CHARS.length;\nconst REF_CHARS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_';\nconst REF_CHARS_LEN = REF_CHARS.length;\n\nexport default function getIdentifier(index: number) {\n  let mod = index % REF_START_CHARS_LEN;\n  let ref = REF_START_CHARS[mod];\n  index = (index - mod) / REF_START_CHARS_LEN;\n  while (index > 0) {\n    mod = index % REF_CHARS_LEN;\n    ref += REF_CHARS[mod];\n    index = (index - mod) / REF_CHARS_LEN;\n  }\n  return ref;\n}\n", "import { ALL_ENABLED } from './compat';\nimport getIdentifier from './get-identifier';\nimport { AsyncServerValue } from './types';\n\ninterface IndexAssignment {\n  t: 'index';\n  s: string;\n  k: undefined;\n  v: string;\n}\n\ninterface MapAssignment {\n  t: 'map';\n  s: string;\n  k: string;\n  v: string;\n}\n\ninterface SetAssignment {\n  t: 'set';\n  s: string;\n  k: undefined;\n  v: string;\n}\n\n// Array of assignments to be done (used for recursion)\nexport type Assignment =\n  | IndexAssignment\n  | MapAssignment\n  | SetAssignment;\n\nexport interface ParserContext {\n  refs: Map<unknown, number>;\n  markedRefs: Set<number>;\n  features: number;\n}\n\nexport interface SerializationContext {\n  stack: number[];\n  // Map tree refs to actual refs\n  validRefs: number[];\n  refSize: number;\n  // Refs that are...referenced\n  markedRefs: Set<number>;\n  // Variables\n  vars: string[];\n  // Array of assignments to be done (used for recursion)\n  assignments: Assignment[];\n  // Supported features\n  features: number;\n\n  valueMap: Map<number, AsyncServerValue>;\n}\n\nexport interface Options {\n  disabledFeatures: number;\n}\n\nconst DEFAULT_OPTIONS: Options = {\n  disabledFeatures: 0,\n};\n\nexport function createParserContext(options: Partial<Options> = {}): ParserContext {\n  // eslint-disable-next-line prefer-object-spread\n  const result = Object.assign({}, DEFAULT_OPTIONS, options || {});\n  return {\n    markedRefs: new Set(),\n    refs: new Map(),\n    features: ALL_ENABLED ^ result.disabledFeatures,\n  };\n}\n\nexport interface SerializationOptions {\n  markedRefs: number[] | Set<number>;\n  features: number;\n}\n\nexport function createSerializationContext(options: SerializationOptions): SerializationContext {\n  return {\n    stack: [],\n    vars: [],\n    assignments: [],\n    validRefs: [],\n    refSize: 0,\n    features: options.features,\n    markedRefs: new Set(options.markedRefs),\n    valueMap: new Map(),\n  };\n}\n\n/**\n * Increments the number of references the referenced value has\n */\nexport function markRef(ctx: ParserContext | SerializationContext, current: number) {\n  ctx.markedRefs.add(current);\n}\n/**\n * Creates the reference param (identifier) from the given reference ID\n * Calling this function means the value has been referenced somewhere\n */\nexport function getRefParam(ctx: SerializationContext, index: number) {\n  /**\n   * Creates a new reference ID from a given reference ID\n   * This new reference ID means that the reference itself\n   * has been referenced at least once, and is used to generate\n   * the variables\n   */\n  let actualIndex = ctx.validRefs[index];\n  if (actualIndex == null) {\n    actualIndex = ctx.refSize++;\n    ctx.validRefs[index] = actualIndex;\n  }\n  let identifier = ctx.vars[actualIndex];\n  if (identifier == null) {\n    identifier = getIdentifier(actualIndex);\n    ctx.vars[actualIndex] = identifier;\n  }\n  return identifier;\n}\n\nexport function getRootID(\n  ctx: ParserContext,\n  current: AsyncServerValue,\n) {\n  const ref = ctx.refs.get(current);\n  if (ref == null) {\n    return ctx.refs.size;\n  }\n  return ref;\n}\n\nexport function createRef(\n  ctx: ParserContext,\n  current: AsyncServerValue,\n) {\n  const ref = ctx.refs.get(current);\n  if (ref == null) {\n    const id = ctx.refs.size;\n    ctx.refs.set(current, id);\n    return id;\n  }\n  markRef(ctx, ref);\n  return ref;\n}\n", "export default function assert(cond: unknown, error: string): asserts cond {\n  if (!cond) {\n    throw new Error(error);\n  }\n}\n", "// Written by https://github.com/DylanPiercey and is distributed under the MIT license.\n// Creates a JavaScript double quoted string and escapes all characters\n// not listed as DoubleStringCharacters on\n// Also includes \"<\" to escape \"</script>\" and \"\\\" to avoid invalid escapes in the output.\n// http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.4\nexport default function quote(str: string) {\n  let result = '';\n  let lastPos = 0;\n  for (let i = 0, len = str.length; i < len; i++) {\n    let replacement;\n    switch (str[i]) {\n      case '\"':\n        replacement = '\\\\\"';\n        break;\n      case '\\\\':\n        replacement = '\\\\\\\\';\n        break;\n      case '<':\n        replacement = '\\\\x3C';\n        break;\n      case '\\n':\n        replacement = '\\\\n';\n        break;\n      case '\\r':\n        replacement = '\\\\r';\n        break;\n      case '\\u2028':\n        replacement = '\\\\u2028';\n        break;\n      case '\\u2029':\n        replacement = '\\\\u2029';\n        break;\n      default:\n        continue;\n    }\n    result += str.slice(lastPos, i) + replacement;\n    lastPos = i + 1;\n  }\n  if (lastPos === 0) {\n    result = str;\n  } else {\n    result += str.slice(lastPos);\n  }\n  return result;\n}\n\nexport function invQuote(str: string): string {\n  return str\n    .replace(/\\\\\"/g, '\"')\n    .replace(/\\\\\\\\/g, '\\\\')\n    .replace(/\\\\x3C/g, '<')\n    .replace(/\\\\n/g, '\\n')\n    .replace(/\\\\r/g, '\\r')\n    .replace(/\\\\u2028/g, '\\u2028')\n    .replace(/\\\\u2029/g, '\\u2029');\n}\n", "export const enum Symbols {\n  AsyncIterator,\n  HasInstance,\n  IsConcatSpreadable,\n  Iterator,\n  Match,\n  MatchAll,\n  Replace,\n  Search,\n  Species,\n  Split,\n  ToPrimitive,\n  ToStringTag,\n  Unscopables\n}\n\nexport const SYMBOL_STRING: Record<Symbols, string> = {\n  [Symbols.AsyncIterator]: 'Symbol.asyncIterator',\n  [Symbols.HasInstance]: 'Symbol.hasInstance',\n  [Symbols.IsConcatSpreadable]: 'Symbol.isConcatSpreadable',\n  [Symbols.Iterator]: 'Symbol.iterator',\n  [Symbols.Match]: 'Symbol.match',\n  [Symbols.MatchAll]: 'Symbol.matchAll',\n  [Symbols.Replace]: 'Symbol.replace',\n  [Symbols.Search]: 'Symbol.search',\n  [Symbols.Species]: 'Symbol.species',\n  [Symbols.Split]: 'Symbol.split',\n  [Symbols.ToPrimitive]: 'Symbol.toPrimitive',\n  [Symbols.ToStringTag]: 'Symbol.toStringTag',\n  [Symbols.Unscopables]: 'Symbol.unscopables',\n};\n\nexport const INV_SYMBOL_REF = {\n  [Symbol.asyncIterator]: Symbols.AsyncIterator,\n  [Symbol.hasInstance]: Symbols.HasInstance,\n  [Symbol.isConcatSpreadable]: Symbols.IsConcatSpreadable,\n  [Symbol.iterator]: Symbols.Iterator,\n  [Symbol.match]: Symbols.Match,\n  [Symbol.matchAll]: Symbols.MatchAll,\n  [Symbol.replace]: Symbols.Replace,\n  [Symbol.search]: Symbols.Search,\n  [Symbol.species]: Symbols.Species,\n  [Symbol.split]: Symbols.Split,\n  [Symbol.toPrimitive]: Symbols.ToPrimitive,\n  [Symbol.toStringTag]: Symbols.ToStringTag,\n  [Symbol.unscopables]: Symbols.Unscopables,\n};\n\nexport type WellKnownSymbols = keyof typeof INV_SYMBOL_REF;\n\nexport const SYMBOL_REF: Record<Symbols, WellKnownSymbols> = {\n  [Symbols.AsyncIterator]: Symbol.asyncIterator,\n  [Symbols.HasInstance]: Symbol.hasInstance,\n  [Symbols.IsConcatSpreadable]: Symbol.isConcatSpreadable,\n  [Symbols.Iterator]: Symbol.iterator,\n  [Symbols.Match]: Symbol.match,\n  [Symbols.MatchAll]: Symbol.matchAll,\n  [Symbols.Replace]: Symbol.replace,\n  [Symbols.Search]: Symbol.search,\n  [Symbols.Species]: Symbol.species,\n  [Symbols.Split]: Symbol.split,\n  [Symbols.ToPrimitive]: Symbol.toPrimitive,\n  [Symbols.ToStringTag]: Symbol.toStringTag,\n  [Symbols.Unscopables]: Symbol.unscopables,\n};\n", "import assert from '../assert';\nimport { Feature } from '../compat';\nimport { ParserContext } from '../context';\nimport quote from '../quote';\nimport { BigIntTypedArrayValue, TypedArrayValue } from '../types';\nimport { INV_SYMBOL_REF, WellKnownSymbols } from './symbols';\nimport {\n  SerovalBigIntNode,\n  SerovalBigIntTypedArrayNode,\n  SerovalBooleanNode,\n  SerovalDateNode,\n  SerovalInfinityNode,\n  SerovalNaNNode,\n  SerovalNegativeInfinityNode,\n  SerovalNegativeZeroNode,\n  SerovalNodeType,\n  SerovalNullNode,\n  SerovalNumberNode,\n  SerovalReferenceNode,\n  SerovalRegExpNode,\n  SerovalStringNode,\n  SerovalTypedArrayNode,\n  SerovalUndefinedNode,\n  SerovalWKSymbolNode,\n} from './types';\n\nexport const TRUE_NODE: SerovalBooleanNode = {\n  t: SerovalNodeType.Boolean,\n  i: undefined,\n  s: true,\n  l: undefined,\n  c: undefined,\n  m: undefined,\n  d: undefined,\n  a: undefined,\n  f: undefined,\n};\nexport const FALSE_NODE: SerovalBooleanNode = {\n  t: SerovalNodeType.Boolean,\n  i: undefined,\n  s: false,\n  l: undefined,\n  c: undefined,\n  m: undefined,\n  d: undefined,\n  a: undefined,\n  f: undefined,\n};\nexport const UNDEFINED_NODE: SerovalUndefinedNode = {\n  t: SerovalNodeType.Undefined,\n  i: undefined,\n  s: undefined,\n  l: undefined,\n  c: undefined,\n  m: undefined,\n  d: undefined,\n  a: undefined,\n  f: undefined,\n};\nexport const NULL_NODE: SerovalNullNode = {\n  t: SerovalNodeType.Null,\n  i: undefined,\n  s: undefined,\n  l: undefined,\n  c: undefined,\n  m: undefined,\n  d: undefined,\n  a: undefined,\n  f: undefined,\n};\nexport const NEG_ZERO_NODE: SerovalNegativeZeroNode = {\n  t: SerovalNodeType.NegativeZero,\n  i: undefined,\n  s: undefined,\n  l: undefined,\n  c: undefined,\n  m: undefined,\n  d: undefined,\n  a: undefined,\n  f: undefined,\n};\nexport const INFINITY_NODE: SerovalInfinityNode = {\n  t: SerovalNodeType.Infinity,\n  i: undefined,\n  s: undefined,\n  l: undefined,\n  c: undefined,\n  m: undefined,\n  d: undefined,\n  a: undefined,\n  f: undefined,\n};\nexport const NEG_INFINITY_NODE: SerovalNegativeInfinityNode = {\n  t: SerovalNodeType.NegativeInfinity,\n  i: undefined,\n  s: undefined,\n  l: undefined,\n  c: undefined,\n  m: undefined,\n  d: undefined,\n  a: undefined,\n  f: undefined,\n};\nexport const NAN_NODE: SerovalNaNNode = {\n  t: SerovalNodeType.NaN,\n  i: undefined,\n  s: undefined,\n  l: undefined,\n  c: undefined,\n  m: undefined,\n  d: undefined,\n  a: undefined,\n  f: undefined,\n};\n\nexport function createNumberNode(value: number): SerovalNumberNode {\n  return {\n    t: SerovalNodeType.Number,\n    i: undefined,\n    s: value,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    d: undefined,\n    a: undefined,\n    f: undefined,\n  };\n}\n\nexport function createStringNode(value: string): SerovalStringNode {\n  return {\n    t: SerovalNodeType.String,\n    i: undefined,\n    s: quote(value),\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    d: undefined,\n    a: undefined,\n    f: undefined,\n  };\n}\n\nexport function createBigIntNode(\n  ctx: ParserContext,\n  current: bigint,\n): SerovalBigIntNode {\n  assert(ctx.features & Feature.BigInt, 'Unsupported type \"BigInt\"');\n  return {\n    t: SerovalNodeType.BigInt,\n    i: undefined,\n    s: '' + current,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    d: undefined,\n    a: undefined,\n    f: undefined,\n  };\n}\n\nexport function createReferenceNode(id: number): SerovalReferenceNode {\n  return {\n    t: SerovalNodeType.Reference,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    d: undefined,\n    a: undefined,\n    f: undefined,\n  };\n}\n\nexport function createDateNode(id: number, current: Date): SerovalDateNode {\n  return {\n    t: SerovalNodeType.Date,\n    i: id,\n    s: current.toISOString(),\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    d: undefined,\n    f: undefined,\n    a: undefined,\n  };\n}\n\nexport function createRegExpNode(id: number, current: RegExp): SerovalRegExpNode {\n  return {\n    t: SerovalNodeType.RegExp,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: current.source,\n    m: current.flags,\n    d: undefined,\n    a: undefined,\n    f: undefined,\n  };\n}\n\nexport function createTypedArrayNode(\n  ctx: ParserContext,\n  id: number,\n  current: TypedArrayValue,\n): SerovalTypedArrayNode {\n  const constructor = current.constructor.name;\n  assert(ctx.features & Feature.TypedArray, `Unsupported value type \"${constructor}\"`);\n  const len = current.length;\n  const values = new Array<string>(len);\n  for (let i = 0; i < len; i++) {\n    values[i] = '' + current[i];\n  }\n  return {\n    t: SerovalNodeType.TypedArray,\n    i: id,\n    s: values,\n    l: current.byteOffset,\n    c: constructor,\n    m: undefined,\n    d: undefined,\n    a: undefined,\n    f: undefined,\n  };\n}\n\nconst BIGINT_FLAG = Feature.BigIntTypedArray | Feature.BigInt;\n\nexport function createBigIntTypedArrayNode(\n  ctx: ParserContext,\n  id: number,\n  current: BigIntTypedArrayValue,\n): SerovalBigIntTypedArrayNode {\n  const constructor = current.constructor.name;\n  assert(\n    (ctx.features & BIGINT_FLAG) === BIGINT_FLAG,\n    `Unsupported value type \"${constructor}\"`,\n  );\n  const len = current.length;\n  const values = new Array<string>(len);\n  for (let i = 0; i < len; i++) {\n    values[i] = '' + current[i];\n  }\n  return {\n    t: SerovalNodeType.BigIntTypedArray,\n    i: id,\n    s: values,\n    l: current.byteOffset,\n    c: constructor,\n    m: undefined,\n    d: undefined,\n    a: undefined,\n    f: undefined,\n  };\n}\n\nexport function createWKSymbolNode(\n  current: WellKnownSymbols,\n): SerovalWKSymbolNode {\n  return {\n    t: SerovalNodeType.WKSymbol,\n    i: undefined,\n    s: INV_SYMBOL_REF[current],\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    d: undefined,\n    a: undefined,\n    f: undefined,\n  };\n}\n", "import { Feature } from '../compat';\nimport { ParserContext } from '../context';\nimport {\n  AsyncServerValue,\n  ErrorValue,\n} from '../types';\n\nexport function getErrorConstructorName(error: ErrorValue) {\n  if (error instanceof EvalError) {\n    return 'EvalError';\n  }\n  if (error instanceof RangeError) {\n    return 'RangeError';\n  }\n  if (error instanceof ReferenceError) {\n    return 'ReferenceError';\n  }\n  if (error instanceof SyntaxError) {\n    return 'SyntaxError';\n  }\n  if (error instanceof TypeError) {\n    return 'TypeError';\n  }\n  if (error instanceof URIError) {\n    return 'URIError';\n  }\n  return 'Error';\n}\n\nexport function getErrorConstructor(errorName: string) {\n  switch (errorName) {\n    case 'Error': return Error;\n    case 'EvalError': return EvalError;\n    case 'RangeError': return RangeError;\n    case 'ReferenceError': return ReferenceError;\n    case 'SyntaxError': return SyntaxError;\n    case 'TypeError': return TypeError;\n    case 'URIError': return URIError;\n    default:\n      throw new Error(`Unknown Error constructor \"${errorName}\"`);\n  }\n}\n\nexport function getErrorOptions(\n  ctx: ParserContext,\n  error: Error,\n) {\n  let options: Record<string, any> | undefined;\n  const constructor = getErrorConstructorName(error);\n  // Name has been modified\n  if (error.name !== constructor) {\n    options = { name: error.name };\n  } else if (error.constructor.name !== constructor) {\n    // Otherwise, name is overriden because\n    // the Error class is extended\n    options = { name: error.constructor.name };\n  }\n  const names = Object.getOwnPropertyNames(error);\n  for (const name of names) {\n    if (name !== 'name' && name !== 'message') {\n      if (name === 'stack') {\n        if (ctx.features & Feature.ErrorPrototypeStack) {\n          options = options || {};\n          options[name] = error[name as keyof Error];\n        }\n      } else {\n        options = options || {};\n        options[name] = error[name as keyof Error];\n      }\n    }\n  }\n  return options;\n}\n\nexport function getIterableOptions(obj: Iterable<any>) {\n  const names = Object.getOwnPropertyNames(obj);\n  if (names.length) {\n    const options: Record<string, unknown> = {};\n    for (const name of names) {\n      options[name] = obj[name as unknown as keyof typeof obj];\n    }\n    return options;\n  }\n  return undefined;\n}\n\nexport function isIterable(\n  value: unknown,\n): value is Iterable<AsyncServerValue> {\n  if (!value || typeof value !== 'object') {\n    return false;\n  }\n  if (Array.isArray(value)) {\n    return false;\n  }\n  switch (value.constructor) {\n    case Map:\n    case Set:\n    case Int8Array:\n    case Int16Array:\n    case Int32Array:\n    case Uint8Array:\n    case Uint16Array:\n    case Uint32Array:\n    case Uint8ClampedArray:\n    case Float32Array:\n    case Float64Array:\n    case BigInt64Array:\n    case BigUint64Array:\n      return false;\n    default:\n      break;\n  }\n  return Symbol.iterator in value;\n}\n\nexport function getTypedArrayConstructor(name: string) {\n  switch (name) {\n    case 'Int8Array': return Int8Array;\n    case 'Int16Array': return Int16Array;\n    case 'Int32Array': return Int32Array;\n    case 'Uint8Array': return Uint8Array;\n    case 'Uint16Array': return Uint16Array;\n    case 'Uint32Array': return Uint32Array;\n    case 'Uint8ClampedArray': return Uint8ClampedArray;\n    case 'Float32Array': return Float32Array;\n    case 'Float64Array': return Float64Array;\n    case 'BigInt64Array': return BigInt64Array;\n    case 'BigUint64Array': return BigUint64Array;\n    default:\n      throw new Error(`Unknown TypedArray \"${name}\"`);\n  }\n}\n\nconst IDENTIFIER_CHECK = /^[$A-Z_][0-9A-Z_$]*$/i;\n\nexport function isValidIdentifier(name: string) {\n  const char = name[0];\n  return (\n    char === '$'\n    || char === '_'\n    || (char >= 'A' && char <= 'Z')\n    || (char >= 'a' && char <= 'z')\n  ) && IDENTIFIER_CHECK.test(name);\n}\n", "/* eslint-disable no-await-in-loop */\n/* eslint-disable @typescript-eslint/no-use-before-define */\nimport assert from '../assert';\nimport { Feature } from '../compat';\nimport { createRef, getRootID, ParserContext } from '../context';\nimport {\n  AsyncServerValue,\n  BigIntTypedArrayValue,\n  TypedArrayValue,\n} from '../types';\nimport {\n  createBigIntNode,\n  createBigIntTypedArrayNode,\n  createDateNode,\n  createNumberNode,\n  createReferenceNode,\n  createRegExpNode,\n  createStringNode,\n  createTypedArrayNode,\n  createWKSymbolNode,\n  FALSE_NODE,\n  INFINITY_NODE,\n  NAN_NODE,\n  NEG_INFINITY_NODE,\n  NEG_ZERO_NODE,\n  NULL_NODE,\n  TRUE_NODE,\n  UNDEFINED_NODE,\n} from './primitives';\nimport {\n  getErrorConstructorName,\n  getErrorOptions,\n  getIterableOptions,\n  isIterable,\n} from './shared';\nimport { INV_SYMBOL_REF } from './symbols';\nimport {\n  SerovalAggregateErrorNode,\n  SerovalArrayNode,\n  SerovalErrorNode,\n  SerovalIterableNode,\n  SerovalMapNode,\n  SerovalNode,\n  SerovalNodeType,\n  SerovalNullConstructorNode,\n  SerovalObjectNode,\n  SerovalObjectRecordNode,\n  SerovalPromiseNode,\n  SerovalSetNode,\n} from './types';\n\ntype ObjectLikeNode =\n  | SerovalObjectNode\n  | SerovalNullConstructorNode\n  | SerovalIterableNode\n  | SerovalPromiseNode;\n\ntype ObjectLikeValue =\n  | Record<string, AsyncServerValue>\n  | Iterable<AsyncServerValue>\n  | PromiseLike<AsyncServerValue>;\n\nasync function generateNodeList(\n  ctx: ParserContext,\n  current: AsyncServerValue[],\n) {\n  const size = current.length;\n  const nodes = new Array<SerovalNode>(size);\n  const deferred = new Array<AsyncServerValue>(size);\n  let item: AsyncServerValue;\n  for (let i = 0; i < size; i++) {\n    if (i in current) {\n      item = current[i];\n      if (isIterable(item)) {\n        deferred[i] = item;\n      } else {\n        nodes[i] = await parse(ctx, item);\n      }\n    }\n  }\n  for (let i = 0; i < size; i++) {\n    if (i in deferred) {\n      nodes[i] = await parse(ctx, deferred[i]);\n    }\n  }\n  return nodes;\n}\n\nasync function generateArrayNode(\n  ctx: ParserContext,\n  id: number,\n  current: AsyncServerValue[],\n): Promise<SerovalArrayNode> {\n  return {\n    t: SerovalNodeType.Array,\n    i: id,\n    s: undefined,\n    l: current.length,\n    c: undefined,\n    m: undefined,\n    d: undefined,\n    a: await generateNodeList(ctx, current),\n    f: undefined,\n  };\n}\n\nasync function generateMapNode(\n  ctx: ParserContext,\n  id: number,\n  current: Map<AsyncServerValue, AsyncServerValue>,\n): Promise<SerovalMapNode> {\n  assert(ctx.features & Feature.Map, 'Unsupported type \"Map\"');\n  const len = current.size;\n  const keyNodes = new Array<SerovalNode>(len);\n  const valueNodes = new Array<SerovalNode>(len);\n  const deferredKey = new Array<AsyncServerValue>(len);\n  const deferredValue = new Array<AsyncServerValue>(len);\n  let deferredSize = 0;\n  let nodeSize = 0;\n  for (const [key, value] of current.entries()) {\n    // Either key or value might be an iterable\n    if (isIterable(key) || isIterable(value)) {\n      deferredKey[deferredSize] = key;\n      deferredValue[deferredSize] = value;\n      deferredSize++;\n    } else {\n      keyNodes[nodeSize] = await parse(ctx, key);\n      valueNodes[nodeSize] = await parse(ctx, value);\n      nodeSize++;\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    keyNodes[nodeSize + i] = await parse(ctx, deferredKey[i]);\n    valueNodes[nodeSize + i] = await parse(ctx, deferredValue[i]);\n  }\n  return {\n    t: SerovalNodeType.Map,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    d: { k: keyNodes, v: valueNodes, s: len },\n    a: undefined,\n    f: undefined,\n  };\n}\n\nasync function generateSetNode(\n  ctx: ParserContext,\n  id: number,\n  current: Set<AsyncServerValue>,\n): Promise<SerovalSetNode> {\n  assert(ctx.features & Feature.Set, 'Unsupported type \"Set\"');\n  const len = current.size;\n  const nodes = new Array<SerovalNode>(len);\n  const deferred = new Array<AsyncServerValue>(len);\n  let deferredSize = 0;\n  let nodeSize = 0;\n  for (const item of current.keys()) {\n    // Iterables are lazy, so the evaluation must be deferred\n    if (isIterable(item)) {\n      deferred[deferredSize++] = item;\n    } else {\n      nodes[nodeSize++] = await parse(ctx, item);\n    }\n  }\n  // Parse deferred items\n  for (let i = 0; i < deferredSize; i++) {\n    nodes[nodeSize + i] = await parse(ctx, deferred[i]);\n  }\n  return {\n    t: SerovalNodeType.Set,\n    i: id,\n    s: undefined,\n    l: len,\n    c: undefined,\n    m: undefined,\n    d: undefined,\n    a: nodes,\n    f: undefined,\n  };\n}\n\nasync function generateProperties(\n  ctx: ParserContext,\n  properties: Record<string, AsyncServerValue>,\n): Promise<SerovalObjectRecordNode> {\n  const keys = Object.keys(properties);\n  const size = keys.length;\n  const keyNodes = new Array<string>(size);\n  const valueNodes = new Array<SerovalNode>(size);\n  const deferredKeys = new Array<string>(size);\n  const deferredValues = new Array<AsyncServerValue>(size);\n  let deferredSize = 0;\n  let nodesSize = 0;\n  let item: AsyncServerValue;\n  for (const key of keys) {\n    item = properties[key];\n    if (isIterable(item)) {\n      deferredKeys[deferredSize] = key;\n      deferredValues[deferredSize] = item;\n      deferredSize++;\n    } else {\n      keyNodes[nodesSize] = key;\n      valueNodes[nodesSize] = await parse(ctx, item);\n      nodesSize++;\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    keyNodes[nodesSize + i] = deferredKeys[i];\n    valueNodes[nodesSize + i] = await parse(ctx, deferredValues[i]);\n  }\n  return {\n    k: keyNodes,\n    v: valueNodes,\n    s: size,\n  };\n}\n\nasync function generateIterableNode(\n  ctx: ParserContext,\n  id: number,\n  current: Iterable<AsyncServerValue>,\n): Promise<SerovalIterableNode> {\n  assert(ctx.features & Feature.Symbol, 'Unsupported type \"Iterable\"');\n  const options = getIterableOptions(current);\n  const array = Array.from(current);\n  return {\n    t: SerovalNodeType.Iterable,\n    i: id,\n    s: undefined,\n    l: array.length,\n    c: undefined,\n    m: undefined,\n    // Parse options first before the items\n    d: options\n      ? await generateProperties(ctx, options as Record<string, AsyncServerValue>)\n      : undefined,\n    a: await generateNodeList(ctx, array),\n    f: undefined,\n  };\n}\n\nasync function generatePromiseNode(\n  ctx: ParserContext,\n  id: number,\n  current: PromiseLike<AsyncServerValue>,\n): Promise<SerovalPromiseNode> {\n  assert(ctx.features & Feature.Promise, 'Unsupported type \"Promise\"');\n  return current.then(async (value) => ({\n    t: SerovalNodeType.Promise,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    // Parse options first before the items\n    d: undefined,\n    a: undefined,\n    f: await parse(ctx, value),\n  }));\n}\n\nasync function generateObjectNode(\n  ctx: ParserContext,\n  id: number,\n  current: ObjectLikeValue,\n  empty: boolean,\n): Promise<ObjectLikeNode> {\n  if (Symbol.iterator in current) {\n    return generateIterableNode(ctx, id, current);\n  }\n  if ('then' in current && typeof current.then === 'function') {\n    return generatePromiseNode(ctx, id, current as PromiseLike<AsyncServerValue>);\n  }\n  return {\n    t: empty ? SerovalNodeType.NullConstructor : SerovalNodeType.Object,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    d: await generateProperties(ctx, current as Record<string, AsyncServerValue>),\n    a: undefined,\n    f: undefined,\n  };\n}\n\nasync function generateAggregateErrorNode(\n  ctx: ParserContext,\n  id: number,\n  current: AggregateError,\n): Promise<SerovalAggregateErrorNode> {\n  const options = getErrorOptions(ctx, current);\n  const optionsNode = options\n    ? await generateProperties(ctx, options)\n    : undefined;\n  return {\n    t: SerovalNodeType.AggregateError,\n    i: id,\n    s: undefined,\n    l: current.errors.length,\n    c: undefined,\n    m: current.message,\n    d: optionsNode,\n    a: await generateNodeList(ctx, current.errors as AsyncServerValue[]),\n    f: undefined,\n  };\n}\n\nasync function generateErrorNode(\n  ctx: ParserContext,\n  id: number,\n  current: Error,\n): Promise<SerovalErrorNode> {\n  const options = getErrorOptions(ctx, current);\n  const optionsNode = options\n    ? await generateProperties(ctx, options)\n    : undefined;\n  return {\n    t: SerovalNodeType.Error,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: getErrorConstructorName(current),\n    m: current.message,\n    d: optionsNode,\n    a: undefined,\n    f: undefined,\n  };\n}\n\nasync function parse(\n  ctx: ParserContext,\n  current: AsyncServerValue,\n): Promise<SerovalNode> {\n  switch (typeof current) {\n    case 'boolean':\n      return current ? TRUE_NODE : FALSE_NODE;\n    case 'undefined':\n      return UNDEFINED_NODE;\n    case 'string':\n      return createStringNode(current);\n    case 'number':\n      switch (current) {\n        case Infinity: return INFINITY_NODE;\n        case -Infinity: return NEG_INFINITY_NODE;\n        default: break;\n      }\n      // eslint-disable-next-line no-self-compare\n      if (current !== current) {\n        return NAN_NODE;\n      }\n      if (Object.is(current, -0)) {\n        return NEG_ZERO_NODE;\n      }\n      return createNumberNode(current);\n    case 'bigint':\n      return createBigIntNode(ctx, current);\n    case 'object': {\n      if (!current) {\n        return NULL_NODE;\n      }\n      // Non-primitive values needs a reference ID\n      // mostly because the values themselves are stateful\n      const id = createRef(ctx, current);\n      if (ctx.markedRefs.has(id)) {\n        return createReferenceNode(id);\n      }\n      if (Array.isArray(current)) {\n        return generateArrayNode(ctx, id, current);\n      }\n      switch (current.constructor) {\n        case Date:\n          return createDateNode(id, current as Date);\n        case RegExp:\n          return createRegExpNode(id, current as RegExp);\n        case Promise:\n          return generatePromiseNode(ctx, id, current as Promise<AsyncServerValue>);\n        case Int8Array:\n        case Int16Array:\n        case Int32Array:\n        case Uint8Array:\n        case Uint16Array:\n        case Uint32Array:\n        case Uint8ClampedArray:\n        case Float32Array:\n        case Float64Array:\n          return createTypedArrayNode(ctx, id, current as TypedArrayValue);\n        case BigInt64Array:\n        case BigUint64Array:\n          return createBigIntTypedArrayNode(ctx, id, current as BigIntTypedArrayValue);\n        case Map:\n          return generateMapNode(\n            ctx,\n            id,\n            current as Map<AsyncServerValue, AsyncServerValue>,\n          );\n        case Set:\n          return generateSetNode(\n            ctx,\n            id,\n            current as Set<AsyncServerValue>,\n          );\n        case Object:\n          return generateObjectNode(\n            ctx,\n            id,\n            current as Record<string, AsyncServerValue>,\n            false,\n          );\n        case undefined:\n          return generateObjectNode(\n            ctx,\n            id,\n            current as Record<string, AsyncServerValue>,\n            true,\n          );\n        case AggregateError:\n          if (ctx.features & Feature.AggregateError) {\n            return generateAggregateErrorNode(ctx, id, current as AggregateError);\n          }\n          return generateErrorNode(ctx, id, current as AggregateError);\n        case Error:\n        case EvalError:\n        case RangeError:\n        case ReferenceError:\n        case SyntaxError:\n        case TypeError:\n        case URIError:\n          return generateErrorNode(ctx, id, current as Error);\n        default:\n          break;\n      }\n      if (current instanceof AggregateError) {\n        if (ctx.features & Feature.AggregateError) {\n          return generateAggregateErrorNode(ctx, id, current);\n        }\n        return generateErrorNode(ctx, id, current);\n      }\n      if (current instanceof Error) {\n        return generateErrorNode(ctx, id, current);\n      }\n      if (current instanceof Promise) {\n        return generatePromiseNode(ctx, id, current);\n      }\n      // Generator functions don't have a global constructor\n      if (Symbol.iterator in current) {\n        return generateIterableNode(ctx, id, current);\n      }\n      // For Promise-like objects\n      if ('then' in current && typeof current.then === 'function') {\n        return generatePromiseNode(ctx, id, current as PromiseLike<AsyncServerValue>);\n      }\n      throw new Error('Unsupported type');\n    }\n    case 'symbol':\n      assert(ctx.features & Feature.Symbol, 'Unsupported type \"symbol\"');\n      assert(current in INV_SYMBOL_REF, 'seroval only supports well-known symbols');\n      return createWKSymbolNode(current);\n    default:\n      throw new Error('Unsupported type');\n  }\n}\n\nexport default async function parseAsync(\n  ctx: ParserContext,\n  current: AsyncServerValue,\n) {\n  const result = await parse(ctx, current);\n  const isObject = result.t === SerovalNodeType.Object\n    || result.t === SerovalNodeType.Iterable;\n  return [result, getRootID(ctx, current), isObject] as const;\n}\n", "/* eslint-disable @typescript-eslint/no-use-before-define */\nimport {\n  SerializationContext,\n} from '../context';\nimport { invQuote } from '../quote';\nimport { AsyncServerValue } from '../types';\nimport { getErrorConstructor, getTypedArrayConstructor } from './shared';\nimport { SYMBOL_REF } from './symbols';\nimport {\n  SerovalAggregateErrorNode,\n  SerovalArrayNode,\n  SerovalBigIntTypedArrayNode,\n  SerovalErrorNode,\n  SerovalIterableNode,\n  SerovalMapNode,\n  SerovalNode,\n  SerovalNodeType,\n  SerovalNullConstructorNode,\n  SerovalObjectNode,\n  SerovalObjectRecordNode,\n  SerovalPromiseNode,\n  SerovalSetNode,\n  SerovalTypedArrayNode,\n} from './types';\n\nfunction assignRef<T extends AsyncServerValue>(\n  ctx: SerializationContext,\n  index: number,\n  value: T,\n) {\n  ctx.valueMap.set(index, value);\n  return value;\n}\n\nfunction deserializeNodeList(\n  ctx: SerializationContext,\n  node: SerovalArrayNode | SerovalIterableNode | SerovalAggregateErrorNode,\n  result: AsyncServerValue[],\n) {\n  let item: SerovalNode;\n  for (let i = 0, len = node.a.length; i < len; i++) {\n    item = node.a[i];\n    if (item) {\n      result[i] = deserializeTree(ctx, item);\n    }\n  }\n  return result;\n}\n\nfunction deserializeArray(\n  ctx: SerializationContext,\n  node: SerovalArrayNode,\n) {\n  const result: AsyncServerValue[] = assignRef(\n    ctx,\n    node.i,\n    new Array<AsyncServerValue>(node.l),\n  );\n  ctx.stack.push(node.i);\n  deserializeNodeList(ctx, node, result);\n  ctx.stack.pop();\n  return result;\n}\n\nfunction deserializeProperties(\n  ctx: SerializationContext,\n  node: SerovalObjectRecordNode,\n  result: Record<string, AsyncServerValue>,\n) {\n  if (node.s === 0) {\n    return {};\n  }\n  for (let i = 0; i < node.s; i++) {\n    result[node.k[i]] = deserializeTree(ctx, node.v[i]);\n  }\n  return result;\n}\n\nfunction deserializeNullConstructor(\n  ctx: SerializationContext,\n  node: SerovalNullConstructorNode,\n) {\n  const result = assignRef(ctx, node.i, Object.create(null) as Record<string, AsyncServerValue>);\n  ctx.stack.push(node.i);\n  deserializeProperties(ctx, node.d, result);\n  ctx.stack.pop();\n  return result;\n}\n\nfunction deserializeObject(\n  ctx: SerializationContext,\n  node: SerovalObjectNode,\n) {\n  const result = assignRef(ctx, node.i, {} as Record<string, AsyncServerValue>);\n  ctx.stack.push(node.i);\n  deserializeProperties(ctx, node.d, result);\n  ctx.stack.pop();\n  return result;\n}\n\nfunction deserializeSet(\n  ctx: SerializationContext,\n  node: SerovalSetNode,\n) {\n  const result = assignRef(ctx, node.i, new Set<AsyncServerValue>());\n  ctx.stack.push(node.i);\n  for (let i = 0, len = node.a.length; i < len; i++) {\n    result.add(deserializeTree(ctx, node.a[i]));\n  }\n  ctx.stack.pop();\n  return result;\n}\n\nfunction deserializeMap(\n  ctx: SerializationContext,\n  node: SerovalMapNode,\n) {\n  const result = assignRef(\n    ctx,\n    node.i,\n    new Map<AsyncServerValue, AsyncServerValue>(),\n  );\n  ctx.stack.push(node.i);\n  for (let i = 0; i < node.d.s; i++) {\n    result.set(\n      deserializeTree(ctx, node.d.k[i]),\n      deserializeTree(ctx, node.d.v[i]),\n    );\n  }\n  ctx.stack.pop();\n  return result;\n}\n\ntype AssignableValue = AggregateError | Error | Iterable<AsyncServerValue>\ntype AssignableNode = SerovalAggregateErrorNode | SerovalErrorNode | SerovalIterableNode;\n\nfunction deserializeDictionary<T extends AssignableValue>(\n  ctx: SerializationContext,\n  node: AssignableNode,\n  result: T,\n) {\n  if (node.d) {\n    ctx.stack.push(node.i);\n    const fields = deserializeProperties(ctx, node.d, {});\n    ctx.stack.pop();\n    Object.assign(result, fields);\n  }\n  return result;\n}\n\nfunction deserializeAggregateError(\n  ctx: SerializationContext,\n  node: SerovalAggregateErrorNode,\n) {\n  // Serialize the required arguments\n  const result = assignRef(ctx, node.i, new AggregateError([], node.m));\n  ctx.stack.push(node.i);\n  result.errors = deserializeNodeList(ctx, node, new Array<AsyncServerValue>(node.l));\n  ctx.stack.pop();\n  // `AggregateError` might've been extended\n  // either through class or custom properties\n  // Make sure to assign extra properties\n  return deserializeDictionary(ctx, node, result);\n}\n\nfunction deserializeError(\n  ctx: SerializationContext,\n  node: SerovalErrorNode,\n) {\n  const ErrorConstructor = getErrorConstructor(node.c);\n  const result = assignRef(ctx, node.i, new ErrorConstructor(node.m));\n  return deserializeDictionary(ctx, node, result);\n}\n\ninterface Deferred {\n  resolve(value: AsyncServerValue): void;\n  promise: Promise<AsyncServerValue>;\n}\n\nfunction createDeferred(): Deferred {\n  let resolver: Deferred['resolve'];\n  return {\n    resolve(v) {\n      resolver(v);\n    },\n    promise: new Promise((res) => {\n      resolver = res as Deferred['resolve'];\n    }),\n  };\n}\n\nfunction deserializePromise(\n  ctx: SerializationContext,\n  node: SerovalPromiseNode,\n) {\n  const deferred = createDeferred();\n  const result = assignRef(ctx, node.i, deferred.promise);\n  deferred.resolve(deserializeTree(ctx, node.f));\n  return result;\n}\n\nfunction deserializeTypedArray(\n  ctx: SerializationContext,\n  node: SerovalTypedArrayNode | SerovalBigIntTypedArrayNode,\n) {\n  const TypedArray = getTypedArrayConstructor(node.c);\n  const dummy = new TypedArray();\n  const result = assignRef(ctx, node.i, new TypedArray(\n    dummy.buffer,\n    node.l,\n  ));\n  for (let i = 0, len = node.s.length; i < len; i++) {\n    result[i] = node.t === SerovalNodeType.BigIntTypedArray\n      ? BigInt(node.s[i])\n      : Number(node.s[i]);\n  }\n  return result;\n}\n\nfunction deserializeIterable(\n  ctx: SerializationContext,\n  node: SerovalIterableNode,\n) {\n  const values: AsyncServerValue[] = [];\n  deserializeNodeList(ctx, node, values);\n  const result = assignRef(ctx, node.i, {\n    [Symbol.iterator]: () => values.values(),\n  });\n  return deserializeDictionary(ctx, node, result);\n}\n\nexport default function deserializeTree(\n  ctx: SerializationContext,\n  node: SerovalNode,\n): AsyncServerValue {\n  switch (node.t) {\n    case SerovalNodeType.Number:\n    case SerovalNodeType.Boolean:\n      return node.s;\n    case SerovalNodeType.String:\n      return invQuote(node.s);\n    case SerovalNodeType.Undefined:\n      return undefined;\n    case SerovalNodeType.Null:\n      return null;\n    case SerovalNodeType.NegativeZero:\n      return -0;\n    case SerovalNodeType.Infinity:\n      return Infinity;\n    case SerovalNodeType.NegativeInfinity:\n      return -Infinity;\n    case SerovalNodeType.NaN:\n      return NaN;\n    case SerovalNodeType.BigInt:\n      return BigInt(node.s);\n    case SerovalNodeType.Reference:\n      return ctx.valueMap.get(node.i);\n    case SerovalNodeType.Array:\n      return deserializeArray(ctx, node);\n    case SerovalNodeType.Object:\n      return deserializeObject(ctx, node);\n    case SerovalNodeType.NullConstructor:\n      return deserializeNullConstructor(ctx, node);\n    case SerovalNodeType.Date:\n      return assignRef(ctx, node.i, new Date(node.s));\n    case SerovalNodeType.RegExp:\n      return assignRef(ctx, node.i, new RegExp(node.c, node.m));\n    case SerovalNodeType.Set:\n      return deserializeSet(ctx, node);\n    case SerovalNodeType.Map:\n      return deserializeMap(ctx, node);\n    case SerovalNodeType.BigIntTypedArray:\n    case SerovalNodeType.TypedArray:\n      return deserializeTypedArray(ctx, node);\n    case SerovalNodeType.AggregateError:\n      return deserializeAggregateError(ctx, node);\n    case SerovalNodeType.Error:\n      return deserializeError(ctx, node);\n    case SerovalNodeType.Iterable:\n      return deserializeIterable(ctx, node);\n    case SerovalNodeType.Promise:\n      return deserializePromise(ctx, node);\n    case SerovalNodeType.WKSymbol:\n      return SYMBOL_REF[node.s];\n    default:\n      throw new Error('Unsupported type');\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { Feature } from '../compat';\nimport {\n  SerializationContext,\n  Assignment,\n  getRefParam,\n  markRef,\n} from '../context';\nimport quote from '../quote';\nimport { isValidIdentifier } from './shared';\nimport { SYMBOL_STRING } from './symbols';\nimport {\n  SerovalAggregateErrorNode,\n  SerovalArrayNode,\n  SerovalBigIntTypedArrayNode,\n  SerovalErrorNode,\n  SerovalIterableNode,\n  SerovalMapNode,\n  SerovalNode,\n  SerovalNodeType,\n  SerovalNullConstructorNode,\n  SerovalObjectNode,\n  SerovalObjectRecordNode,\n  SerovalPromiseNode,\n  SerovalReferenceNode,\n  SerovalSetNode,\n  SerovalTypedArrayNode,\n} from './types';\n\nfunction getAssignmentExpression(assignment: Assignment): string {\n  switch (assignment.t) {\n    case 'index':\n      return assignment.s + '=' + assignment.v;\n    case 'map':\n      return assignment.s + '.set(' + assignment.k + ',' + assignment.v + ')';\n    case 'set':\n      return assignment.s + '.add(' + assignment.v + ')';\n    default:\n      return '';\n  }\n}\n\nfunction mergeAssignments(assignments: Assignment[]) {\n  const newAssignments = [];\n  let current = assignments[0];\n  let prev = current;\n  let item: Assignment;\n  for (let i = 1, len = assignments.length; i < len; i++) {\n    item = assignments[i];\n    if (item.t === prev.t) {\n      switch (item.t) {\n        case 'index':\n          if (item.v === prev.v) {\n            // Merge if the right-hand value is the same\n            // saves at least 2 chars\n            current = {\n              t: 'index',\n              s: item.s,\n              k: undefined,\n              v: getAssignmentExpression(current),\n            };\n          } else {\n            // Different assignment, push current\n            newAssignments.push(current);\n            current = item;\n          }\n          break;\n        case 'map':\n          if (item.s === prev.s) {\n            // Maps has chaining methods, merge if source is the same\n            current = {\n              t: 'map',\n              s: getAssignmentExpression(current),\n              k: item.k,\n              v: item.v,\n            };\n          } else {\n            // Different assignment, push current\n            newAssignments.push(current);\n            current = item;\n          }\n          break;\n        case 'set':\n          if (item.s === prev.s) {\n            // Sets has chaining methods too\n            current = {\n              t: 'set',\n              s: getAssignmentExpression(current),\n              k: undefined,\n              v: item.v,\n            };\n          } else {\n            // Different assignment, push current\n            newAssignments.push(current);\n            current = item;\n          }\n          break;\n        default:\n          break;\n      }\n    } else {\n      newAssignments.push(current);\n      current = item;\n    }\n    prev = item;\n  }\n\n  newAssignments.push(current);\n\n  return newAssignments;\n}\n\nfunction resolveAssignments(assignments: Assignment[]) {\n  if (assignments.length) {\n    let result = '';\n    const merged = mergeAssignments(assignments);\n    for (let i = 0, len = merged.length; i < len; i++) {\n      result += getAssignmentExpression(merged[i]) + ',';\n    }\n    return result;\n  }\n  return undefined;\n}\n\nexport function resolvePatches(ctx: SerializationContext) {\n  return resolveAssignments(ctx.assignments);\n}\n\n/**\n * Generates the inlined assignment for the reference\n * This is different from the assignments array as this one\n * signifies creation rather than mutation\n */\n\nfunction createAssignment(\n  ctx: SerializationContext,\n  source: string,\n  value: string,\n) {\n  ctx.assignments.push({\n    t: 'index',\n    s: source,\n    k: undefined,\n    v: value,\n  });\n}\n\nfunction createSetAdd(\n  ctx: SerializationContext,\n  ref: number,\n  value: string,\n) {\n  markRef(ctx, ref);\n  ctx.assignments.push({\n    t: 'set',\n    s: getRefParam(ctx, ref),\n    k: undefined,\n    v: value,\n  });\n}\n\nfunction createMapSet(\n  ctx: SerializationContext,\n  ref: number,\n  key: string,\n  value: string,\n) {\n  markRef(ctx, ref);\n  ctx.assignments.push({\n    t: 'map',\n    s: getRefParam(ctx, ref),\n    k: key,\n    v: value,\n  });\n}\n\nfunction createArrayAssign(\n  ctx: SerializationContext,\n  ref: number,\n  index: number | string,\n  value: string,\n) {\n  markRef(ctx, ref);\n  createAssignment(ctx, getRefParam(ctx, ref) + '[' + index + ']', value);\n}\n\nfunction createObjectAssign(\n  ctx: SerializationContext,\n  ref: number,\n  key: string,\n  value: string,\n) {\n  markRef(ctx, ref);\n  createAssignment(ctx, getRefParam(ctx, ref) + '.' + key, value);\n}\n\nfunction assignRef(\n  ctx: SerializationContext,\n  index: number,\n  value: string,\n) {\n  if (ctx.markedRefs.has(index)) {\n    return getRefParam(ctx, index) + '=' + value;\n  }\n  return value;\n}\n\nfunction isReferenceInStack(\n  ctx: SerializationContext,\n  node: SerovalNode,\n): node is SerovalReferenceNode {\n  return node.t === SerovalNodeType.Reference && ctx.stack.includes(node.i);\n}\n\nfunction serializeNodeList(\n  ctx: SerializationContext,\n  node: SerovalArrayNode | SerovalIterableNode | SerovalAggregateErrorNode,\n) {\n  // This is different than Map and Set\n  // because we also need to serialize\n  // the holes of the Array\n  const size = node.l;\n  let values = '';\n  let item: SerovalNode;\n  let isHoley = false;\n  for (let i = 0; i < size; i++) {\n    if (i !== 0) {\n      // Add an empty item\n      values += ',';\n    }\n    item = node.a[i];\n    // Check if index is a hole\n    if (item) {\n      // Check if item is a parent\n      if (isReferenceInStack(ctx, item)) {\n        createArrayAssign(ctx, node.i, i, getRefParam(ctx, item.i));\n        isHoley = true;\n      } else {\n        values += serializeTree(ctx, item);\n        isHoley = false;\n      }\n    } else {\n      isHoley = true;\n    }\n  }\n  return '[' + values + (isHoley ? ',]' : ']');\n}\n\nfunction serializeArray(\n  ctx: SerializationContext,\n  node: SerovalArrayNode,\n) {\n  ctx.stack.push(node.i);\n  const result = serializeNodeList(ctx, node);\n  ctx.stack.pop();\n  return assignRef(ctx, node.i, result);\n}\n\nfunction serializeProperties(\n  ctx: SerializationContext,\n  sourceID: number,\n  node: SerovalObjectRecordNode,\n) {\n  if (node.s === 0) {\n    return '{}';\n  }\n  let result = '';\n  ctx.stack.push(sourceID);\n  let key: string;\n  let val: SerovalNode;\n  let check: number;\n  let isIdentifier: boolean;\n  let refParam: string;\n  let hasPrev = false;\n  for (let i = 0; i < node.s; i++) {\n    key = node.k[i];\n    val = node.v[i];\n    check = Number(key);\n    // Test if key is a valid number or JS identifier\n    // so that we don't have to serialize the key and wrap with brackets\n    isIdentifier = check >= 0 || isValidIdentifier(key);\n    if (isReferenceInStack(ctx, val)) {\n      refParam = getRefParam(ctx, val.i);\n      if (isIdentifier && Number.isNaN(check)) {\n        createObjectAssign(ctx, sourceID, key, refParam);\n      } else {\n        createArrayAssign(ctx, sourceID, isIdentifier ? key : ('\"' + quote(key) + '\"'), refParam);\n      }\n    } else {\n      result += (hasPrev ? ',' : '')\n        + (isIdentifier ? key : ('\"' + quote(key) + '\"'))\n        + ':' + serializeTree(ctx, val);\n      hasPrev = true;\n    }\n  }\n  ctx.stack.pop();\n  return '{' + result + '}';\n}\n\nfunction serializeWithObjectAssign(\n  ctx: SerializationContext,\n  value: SerovalObjectRecordNode,\n  id: number,\n  serialized: string,\n) {\n  const fields = serializeProperties(ctx, id, value);\n  if (fields !== '{}') {\n    return 'Object.assign(' + serialized + ',' + fields + ')';\n  }\n  return serialized;\n}\n\nfunction serializeAssignments(\n  ctx: SerializationContext,\n  sourceID: number,\n  node: SerovalObjectRecordNode,\n) {\n  ctx.stack.push(sourceID);\n  const mainAssignments: Assignment[] = [];\n  let parentStack: number[];\n  let refParam: string;\n  let key: string;\n  let check: number;\n  let parentAssignment: Assignment[];\n  let isIdentifier: boolean;\n  for (let i = 0; i < node.s; i++) {\n    parentStack = ctx.stack;\n    ctx.stack = [];\n    refParam = serializeTree(ctx, node.v[i]);\n    ctx.stack = parentStack;\n    key = node.k[i];\n    check = Number(key);\n    parentAssignment = ctx.assignments;\n    ctx.assignments = mainAssignments;\n    // Test if key is a valid number or JS identifier\n    // so that we don't have to serialize the key and wrap with brackets\n    isIdentifier = check >= 0 || isValidIdentifier(key);\n    if (isIdentifier && Number.isNaN(check)) {\n      createObjectAssign(ctx, sourceID, key, refParam);\n    } else {\n      createArrayAssign(ctx, sourceID, isIdentifier ? key : ('\"' + quote(key) + '\"'), refParam);\n    }\n    ctx.assignments = parentAssignment;\n  }\n  ctx.stack.pop();\n  return resolveAssignments(mainAssignments);\n}\n\nfunction serializeDictionary(\n  ctx: SerializationContext,\n  i: number,\n  d: SerovalObjectRecordNode | undefined,\n  init: string,\n) {\n  if (d) {\n    if (ctx.features & Feature.ObjectAssign) {\n      init = serializeWithObjectAssign(ctx, d, i, init);\n    } else {\n      markRef(ctx, i);\n      const assignments = serializeAssignments(ctx, i, d);\n      if (assignments) {\n        return '(' + assignRef(ctx, i, init) + ',' + assignments + getRefParam(ctx, i) + ')';\n      }\n    }\n  }\n  return assignRef(ctx, i, init);\n}\n\nfunction serializeNullConstructor(\n  ctx: SerializationContext,\n  node: SerovalNullConstructorNode,\n) {\n  return serializeDictionary(ctx, node.i, node.d, 'Object.create(null)');\n}\n\nfunction serializeObject(\n  ctx: SerializationContext,\n  node: SerovalObjectNode,\n) {\n  return assignRef(ctx, node.i, serializeProperties(ctx, node.i, node.d));\n}\n\nfunction serializeSet(\n  ctx: SerializationContext,\n  node: SerovalSetNode,\n) {\n  let serialized = 'new Set';\n  const size = node.l;\n  if (size) {\n    let result = '';\n    ctx.stack.push(node.i);\n    let item: SerovalNode;\n    let hasPrev = false;\n    for (let i = 0; i < size; i++) {\n      item = node.a[i];\n      if (isReferenceInStack(ctx, item)) {\n        createSetAdd(ctx, node.i, getRefParam(ctx, item.i));\n      } else {\n        // Push directly\n        result += (hasPrev ? ',' : '') + serializeTree(ctx, item);\n        hasPrev = true;\n      }\n    }\n    ctx.stack.pop();\n    if (result) {\n      serialized += '([' + result + '])';\n    }\n  }\n  return assignRef(ctx, node.i, serialized);\n}\n\nfunction serializeMap(\n  ctx: SerializationContext,\n  node: SerovalMapNode,\n) {\n  let serialized = 'new Map';\n  if (node.d.s) {\n    let result = '';\n    ctx.stack.push(node.i);\n    let key: SerovalNode;\n    let val: SerovalNode;\n    let keyRef: string;\n    let valueRef: string;\n    let parent: number[];\n    let hasPrev = false;\n    for (let i = 0; i < node.d.s; i++) {\n      // Check if key is a parent\n      key = node.d.k[i];\n      val = node.d.v[i];\n      if (isReferenceInStack(ctx, key)) {\n        // Create reference for the map instance\n        keyRef = getRefParam(ctx, key.i);\n        // Check if value is a parent\n        if (isReferenceInStack(ctx, val)) {\n          valueRef = getRefParam(ctx, val.i);\n          // Register an assignment since\n          // both key and value are a parent of this\n          // Map instance\n          createMapSet(ctx, node.i, keyRef, valueRef);\n        } else {\n          // Reset the stack\n          // This is required because the serialized\n          // value is no longer part of the expression\n          // tree and has been moved to the deferred\n          // assignment\n          parent = ctx.stack;\n          ctx.stack = [];\n          createMapSet(ctx, node.i, keyRef, serializeTree(ctx, val));\n          ctx.stack = parent;\n        }\n      } else if (isReferenceInStack(ctx, val)) {\n        // Create ref for the Map instance\n        valueRef = getRefParam(ctx, val.i);\n        // Reset stack for the key serialization\n        parent = ctx.stack;\n        ctx.stack = [];\n        createMapSet(ctx, node.i, serializeTree(ctx, key), valueRef);\n        ctx.stack = parent;\n      } else {\n        result += (hasPrev ? ',[' : '[') + serializeTree(ctx, key) + ',' + serializeTree(ctx, val) + ']';\n        hasPrev = true;\n      }\n    }\n    ctx.stack.pop();\n    // Check if there are any values\n    // so that the empty Map constructor\n    // can be used instead\n    if (result) {\n      serialized += '([' + result + '])';\n    }\n  }\n  return assignRef(ctx, node.i, serialized);\n}\n\nfunction serializeAggregateError(\n  ctx: SerializationContext,\n  node: SerovalAggregateErrorNode,\n) {\n  // Serialize the required arguments\n  ctx.stack.push(node.i);\n  const serialized = 'new AggregateError(' + serializeNodeList(ctx, node) + ',\"' + quote(node.m) + '\")';\n  ctx.stack.pop();\n  // `AggregateError` might've been extended\n  // either through class or custom properties\n  // Make sure to assign extra properties\n  return serializeDictionary(ctx, node.i, node.d, serialized);\n}\n\nfunction serializeError(\n  ctx: SerializationContext,\n  node: SerovalErrorNode,\n) {\n  const serialized = 'new ' + node.c + '(\"' + quote(node.m) + '\")';\n  return serializeDictionary(ctx, node.i, node.d, serialized);\n}\n\nfunction serializePromise(\n  ctx: SerializationContext,\n  node: SerovalPromiseNode,\n) {\n  let serialized: string;\n  // Check if resolved value is a parent expression\n  if (isReferenceInStack(ctx, node.f)) {\n    // A Promise trick, reference the value\n    // inside the `then` expression so that\n    // the Promise evaluates after the parent\n    // has initialized\n    const ref = getRefParam(ctx, node.f.i);\n    if (ctx.features & Feature.ArrowFunction) {\n      serialized = 'Promise.resolve().then(()=>' + ref + ')';\n    } else {\n      serialized = 'Promise.resolve().then(function(){return ' + ref + '})';\n    }\n  } else {\n    ctx.stack.push(node.i);\n    const result = serializeTree(ctx, node.f);\n    ctx.stack.pop();\n    // just inline the value/reference here\n    serialized = 'Promise.resolve(' + result + ')';\n  }\n  return assignRef(ctx, node.i, serialized);\n}\n\nfunction serializeTypedArray(\n  ctx: SerializationContext,\n  node: SerovalTypedArrayNode | SerovalBigIntTypedArrayNode,\n) {\n  let result = '';\n  const isBigInt = node.t === SerovalNodeType.BigIntTypedArray;\n  for (let i = 0, len = node.s.length; i < len; i++) {\n    result += (i !== 0 ? ',' : '') + node.s[i] + (isBigInt ? 'n' : '');\n  }\n  const args = '[' + result + ']' + (node.l !== 0 ? (',' + node.l) : '');\n  return assignRef(ctx, node.i, 'new ' + node.c + '(' + args + ')');\n}\n\nfunction serializeIterable(\n  ctx: SerializationContext,\n  node: SerovalIterableNode,\n) {\n  const parent = ctx.stack;\n  ctx.stack = [];\n  const values = serializeNodeList(ctx, node);\n  ctx.stack = parent;\n  let serialized = values;\n  if (ctx.features & Feature.ArrayPrototypeValues) {\n    serialized += '.values()';\n  } else {\n    serialized += '[Symbol.iterator]()';\n  }\n  if (ctx.features & Feature.ArrowFunction) {\n    serialized = '{[Symbol.iterator]:()=>' + serialized + '}';\n  } else if (ctx.features & Feature.MethodShorthand) {\n    serialized = '{[Symbol.iterator](){return ' + serialized + '}}';\n  } else {\n    serialized = '{[Symbol.iterator]:function(){return ' + serialized + '}}';\n  }\n  return serializeDictionary(ctx, node.i, node.d, serialized);\n}\n\nexport default function serializeTree(\n  ctx: SerializationContext,\n  node: SerovalNode,\n): string {\n  switch (node.t) {\n    case SerovalNodeType.Number:\n      return '' + node.s;\n    case SerovalNodeType.String:\n      return '\"' + node.s + '\"';\n    case SerovalNodeType.Boolean:\n      return node.s ? '!0' : '!1';\n    case SerovalNodeType.Undefined:\n      return 'void 0';\n    case SerovalNodeType.Null:\n      return 'null';\n    case SerovalNodeType.NegativeZero:\n      return '-0';\n    case SerovalNodeType.Infinity:\n      return '1/0';\n    case SerovalNodeType.NegativeInfinity:\n      return '-1/0';\n    case SerovalNodeType.NaN:\n      return 'NaN';\n    case SerovalNodeType.BigInt:\n      return node.s + 'n';\n    case SerovalNodeType.Reference:\n      return getRefParam(ctx, node.i);\n    case SerovalNodeType.Array:\n      return serializeArray(ctx, node);\n    case SerovalNodeType.Object:\n      return serializeObject(ctx, node);\n    case SerovalNodeType.NullConstructor:\n      return serializeNullConstructor(ctx, node);\n    case SerovalNodeType.Date:\n      return assignRef(ctx, node.i, 'new Date(\"' + node.s + '\")');\n    case SerovalNodeType.RegExp:\n      return assignRef(ctx, node.i, '/' + node.c + '/' + node.m);\n    case SerovalNodeType.Set:\n      return serializeSet(ctx, node);\n    case SerovalNodeType.Map:\n      return serializeMap(ctx, node);\n    case SerovalNodeType.BigIntTypedArray:\n    case SerovalNodeType.TypedArray:\n      return serializeTypedArray(ctx, node);\n    case SerovalNodeType.AggregateError:\n      return serializeAggregateError(ctx, node);\n    case SerovalNodeType.Error:\n      return serializeError(ctx, node);\n    case SerovalNodeType.Iterable:\n      return serializeIterable(ctx, node);\n    case SerovalNodeType.Promise:\n      return serializePromise(ctx, node);\n    case SerovalNodeType.WKSymbol:\n      return SYMBOL_STRING[node.s];\n    default:\n      throw new Error('Unsupported type');\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-use-before-define */\nimport assert from '../assert';\nimport { Feature } from '../compat';\nimport { createRef, getRootID, ParserContext } from '../context';\nimport { BigIntTypedArrayValue, ServerValue, TypedArrayValue } from '../types';\nimport {\n  createBigIntNode,\n  createBigIntTypedArrayNode,\n  createDateNode,\n  createNumberNode,\n  createReferenceNode,\n  createRegExpNode,\n  createStringNode,\n  createTypedArrayNode,\n  createWKSymbolNode,\n  FALSE_NODE,\n  INFINITY_NODE,\n  NAN_NODE,\n  NEG_INFINITY_NODE,\n  NEG_ZERO_NODE,\n  NULL_NODE,\n  TRUE_NODE,\n  UNDEFINED_NODE,\n} from './primitives';\nimport {\n  getErrorConstructorName,\n  getErrorOptions,\n  getIterableOptions,\n  isIterable,\n} from './shared';\nimport { INV_SYMBOL_REF } from './symbols';\nimport {\n  SerovalAggregateErrorNode,\n  SerovalArrayNode,\n  SerovalErrorNode,\n  SerovalIterableNode,\n  SerovalMapNode,\n  SerovalNode,\n  SerovalNodeType,\n  SerovalNullConstructorNode,\n  SerovalObjectNode,\n  SerovalObjectRecordNode,\n  SerovalSetNode,\n} from './types';\n\ntype ObjectLikeNode = SerovalObjectNode | SerovalNullConstructorNode | SerovalIterableNode;\n\nfunction generateNodeList(ctx: ParserContext, current: ServerValue[]) {\n  const size = current.length;\n  const nodes = new Array<SerovalNode>(size);\n  const deferred = new Array<ServerValue>(size);\n  let item: ServerValue;\n  for (let i = 0; i < size; i++) {\n    if (i in current) {\n      item = current[i];\n      if (isIterable(item)) {\n        deferred[i] = item;\n      } else {\n        nodes[i] = parse(ctx, item);\n      }\n    }\n  }\n  for (let i = 0; i < size; i++) {\n    if (i in deferred) {\n      nodes[i] = parse(ctx, deferred[i]);\n    }\n  }\n  return nodes;\n}\n\nfunction generateArrayNode(\n  ctx: ParserContext,\n  id: number,\n  current: ServerValue[],\n): SerovalArrayNode {\n  return {\n    t: SerovalNodeType.Array,\n    i: id,\n    s: undefined,\n    l: current.length,\n    c: undefined,\n    m: undefined,\n    d: undefined,\n    a: generateNodeList(ctx, current),\n    f: undefined,\n  };\n}\n\nfunction generateMapNode(\n  ctx: ParserContext,\n  id: number,\n  current: Map<ServerValue, ServerValue>,\n): SerovalMapNode {\n  assert(ctx.features & Feature.Map, 'Unsupported type \"Map\"');\n  const len = current.size;\n  const keyNodes = new Array<SerovalNode>(len);\n  const valueNodes = new Array<SerovalNode>(len);\n  const deferredKey = new Array<ServerValue>(len);\n  const deferredValue = new Array<ServerValue>(len);\n  let deferredSize = 0;\n  let nodeSize = 0;\n  for (const [key, value] of current.entries()) {\n    // Either key or value might be an iterable\n    if (isIterable(key) || isIterable(value)) {\n      deferredKey[deferredSize] = key;\n      deferredValue[deferredSize] = value;\n      deferredSize++;\n    } else {\n      keyNodes[nodeSize] = parse(ctx, key);\n      valueNodes[nodeSize] = parse(ctx, value);\n      nodeSize++;\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    keyNodes[nodeSize + i] = parse(ctx, deferredKey[i]);\n    valueNodes[nodeSize + i] = parse(ctx, deferredValue[i]);\n  }\n  return {\n    t: SerovalNodeType.Map,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    d: { k: keyNodes, v: valueNodes, s: len },\n    a: undefined,\n    f: undefined,\n  };\n}\n\nfunction generateSetNode(\n  ctx: ParserContext,\n  id: number,\n  current: Set<ServerValue>,\n): SerovalSetNode {\n  assert(ctx.features & Feature.Set, 'Unsupported type \"Set\"');\n  const len = current.size;\n  const nodes = new Array<SerovalNode>(len);\n  const deferred = new Array<ServerValue>(len);\n  let deferredSize = 0;\n  let nodeSize = 0;\n  for (const item of current.keys()) {\n    // Iterables are lazy, so the evaluation must be deferred\n    if (isIterable(item)) {\n      deferred[deferredSize++] = item;\n    } else {\n      nodes[nodeSize++] = parse(ctx, item);\n    }\n  }\n  // Parse deferred items\n  for (let i = 0; i < deferredSize; i++) {\n    nodes[nodeSize + i] = parse(ctx, deferred[i]);\n  }\n  return {\n    t: SerovalNodeType.Set,\n    i: id,\n    s: undefined,\n    l: len,\n    c: undefined,\n    m: undefined,\n    d: undefined,\n    a: nodes,\n    f: undefined,\n  };\n}\n\nfunction generateProperties(\n  ctx: ParserContext,\n  properties: Record<string, ServerValue>,\n): SerovalObjectRecordNode {\n  const keys = Object.keys(properties);\n  const size = keys.length;\n  const keyNodes = new Array<string>(size);\n  const valueNodes = new Array<SerovalNode>(size);\n  const deferredKeys = new Array<string>(size);\n  const deferredValues = new Array<ServerValue>(size);\n  let deferredSize = 0;\n  let nodesSize = 0;\n  let item: ServerValue;\n  for (const key of keys) {\n    item = properties[key];\n    if (isIterable(item)) {\n      deferredKeys[deferredSize] = key;\n      deferredValues[deferredSize] = item;\n      deferredSize++;\n    } else {\n      keyNodes[nodesSize] = key;\n      valueNodes[nodesSize] = parse(ctx, item);\n      nodesSize++;\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    keyNodes[nodesSize + i] = deferredKeys[i];\n    valueNodes[nodesSize + i] = parse(ctx, deferredValues[i]);\n  }\n  return {\n    k: keyNodes,\n    v: valueNodes,\n    s: size,\n  };\n}\n\nfunction generateIterableNode(\n  ctx: ParserContext,\n  id: number,\n  current: Iterable<ServerValue>,\n): SerovalIterableNode {\n  assert(ctx.features & Feature.Symbol, 'Unsupported type \"Iterable\"');\n  const options = getIterableOptions(current);\n  const array = Array.from(current);\n  return {\n    t: SerovalNodeType.Iterable,\n    i: id,\n    s: undefined,\n    l: array.length,\n    c: undefined,\n    m: undefined,\n    // Parse options first before the items\n    d: options\n      ? generateProperties(ctx, options as Record<string, ServerValue>)\n      : undefined,\n    a: generateNodeList(ctx, array),\n    f: undefined,\n  };\n}\n\nfunction generateObjectNode(\n  ctx: ParserContext,\n  id: number,\n  current: Record<string, ServerValue> | Iterable<ServerValue>,\n  empty: boolean,\n): ObjectLikeNode {\n  if (Symbol.iterator in current) {\n    return generateIterableNode(ctx, id, current);\n  }\n  return {\n    t: empty ? SerovalNodeType.NullConstructor : SerovalNodeType.Object,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    d: generateProperties(ctx, current),\n    a: undefined,\n    f: undefined,\n  };\n}\n\nfunction generateAggregateErrorNode(\n  ctx: ParserContext,\n  id: number,\n  current: AggregateError,\n): SerovalAggregateErrorNode {\n  const options = getErrorOptions(ctx, current);\n  const optionsNode = options\n    ? generateProperties(ctx, options)\n    : undefined;\n  return {\n    t: SerovalNodeType.AggregateError,\n    i: id,\n    s: undefined,\n    l: current.errors.length,\n    c: undefined,\n    m: current.message,\n    d: optionsNode,\n    a: generateNodeList(ctx, current.errors as ServerValue[]),\n    f: undefined,\n  };\n}\n\nfunction generateErrorNode(\n  ctx: ParserContext,\n  id: number,\n  current: Error,\n): SerovalErrorNode {\n  const options = getErrorOptions(ctx, current);\n  const optionsNode = options\n    ? generateProperties(ctx, options)\n    : undefined;\n  return {\n    t: SerovalNodeType.Error,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: getErrorConstructorName(current),\n    m: current.message,\n    d: optionsNode,\n    a: undefined,\n    f: undefined,\n  };\n}\n\nfunction parse(\n  ctx: ParserContext,\n  current: ServerValue,\n): SerovalNode {\n  switch (typeof current) {\n    case 'boolean':\n      return current ? TRUE_NODE : FALSE_NODE;\n    case 'undefined':\n      return UNDEFINED_NODE;\n    case 'string':\n      return createStringNode(current);\n    case 'number':\n      switch (current) {\n        case Infinity: return INFINITY_NODE;\n        case -Infinity: return NEG_INFINITY_NODE;\n        default: break;\n      }\n      // eslint-disable-next-line no-self-compare\n      if (current !== current) {\n        return NAN_NODE;\n      }\n      if (Object.is(current, -0)) {\n        return NEG_ZERO_NODE;\n      }\n      return createNumberNode(current);\n    case 'bigint':\n      return createBigIntNode(ctx, current);\n    case 'object': {\n      if (!current) {\n        return NULL_NODE;\n      }\n      // Non-primitive values needs a reference ID\n      // mostly because the values themselves are stateful\n      const id = createRef(ctx, current);\n      if (ctx.markedRefs.has(id)) {\n        return createReferenceNode(id);\n      }\n      if (Array.isArray(current)) {\n        return generateArrayNode(ctx, id, current);\n      }\n      switch (current.constructor) {\n        case Date:\n          return createDateNode(id, current as Date);\n        case RegExp:\n          return createRegExpNode(id, current as RegExp);\n        case Int8Array:\n        case Int16Array:\n        case Int32Array:\n        case Uint8Array:\n        case Uint16Array:\n        case Uint32Array:\n        case Uint8ClampedArray:\n        case Float32Array:\n        case Float64Array:\n          return createTypedArrayNode(ctx, id, current as TypedArrayValue);\n        case BigInt64Array:\n        case BigUint64Array:\n          return createBigIntTypedArrayNode(ctx, id, current as BigIntTypedArrayValue);\n        case Map:\n          return generateMapNode(ctx, id, current as Map<ServerValue, ServerValue>);\n        case Set:\n          return generateSetNode(ctx, id, current as Set<ServerValue>);\n        case Object:\n          return generateObjectNode(ctx, id, current as Record<string, ServerValue>, false);\n        case undefined:\n          return generateObjectNode(ctx, id, current as Record<string, ServerValue>, true);\n        case AggregateError:\n          if (ctx.features & Feature.AggregateError) {\n            return generateAggregateErrorNode(ctx, id, current as AggregateError);\n          }\n          return generateErrorNode(ctx, id, current as AggregateError);\n        case Error:\n        case EvalError:\n        case RangeError:\n        case ReferenceError:\n        case SyntaxError:\n        case TypeError:\n        case URIError:\n          return generateErrorNode(ctx, id, current as Error);\n        default:\n          break;\n      }\n      if (current instanceof AggregateError) {\n        if (ctx.features & Feature.AggregateError) {\n          return generateAggregateErrorNode(ctx, id, current);\n        }\n        return generateErrorNode(ctx, id, current);\n      }\n      if (current instanceof Error) {\n        return generateErrorNode(ctx, id, current);\n      }\n      // Generator functions don't have a global constructor\n      if (Symbol.iterator in current) {\n        return generateIterableNode(ctx, id, current);\n      }\n      throw new Error('Unsupported type');\n    }\n    case 'symbol':\n      assert(ctx.features & Feature.Symbol, 'Unsupported type \"symbol\"');\n      assert(current in INV_SYMBOL_REF, 'seroval only supports well-known symbols');\n      return createWKSymbolNode(current);\n    default:\n      throw new Error('Unsupported type');\n  }\n}\n\nexport default function parseSync(\n  ctx: ParserContext,\n  current: ServerValue,\n) {\n  const result = parse(ctx, current);\n  const isObject = result.t === SerovalNodeType.Object\n    || result.t === SerovalNodeType.Iterable;\n  return [result, getRootID(ctx, current), isObject] as const;\n}\n", "/* eslint-disable no-await-in-loop */\nimport { Feature } from './compat';\nimport {\n  SerializationContext,\n  getRefParam,\n  Options,\n  createParserContext,\n  createSerializationContext,\n} from './context';\nimport parseAsync from './tree/async';\nimport deserializeTree from './tree/deserialize';\nimport serializeTree, { resolvePatches } from './tree/serialize';\nimport parseSync from './tree/sync';\nimport { SerovalNode } from './tree/types';\nimport {\n  AsyncServerValue,\n  PrimitiveValue,\n  ServerValue,\n  CommonServerValue,\n  SemiPrimitiveValue,\n  ErrorValue,\n} from './types';\n\nexport {\n  AsyncServerValue,\n  ServerValue,\n  PrimitiveValue,\n  CommonServerValue,\n  SemiPrimitiveValue,\n  ErrorValue,\n  Feature,\n};\n\nfunction finalize(\n  ctx: SerializationContext,\n  rootID: number,\n  isObject: boolean,\n  result: string,\n) {\n  // Shared references detected\n  if (ctx.vars.length) {\n    const patches = resolvePatches(ctx);\n    let body = result;\n    if (patches) {\n      // Get (or create) a ref from the source\n      const index = getRefParam(ctx, rootID);\n      body = result + ',' + patches + index;\n      if (!result.startsWith(index + '=')) {\n        body = index + '=' + body;\n      }\n    }\n    let params = ctx.vars.length > 1\n      ? ctx.vars.join(',')\n      : ctx.vars[0];\n    // Source is probably already assigned\n    if (ctx.features & Feature.ArrowFunction) {\n      params = ctx.vars.length > 1 || ctx.vars.length === 0\n        ? '(' + params + ')'\n        : params;\n      return '(' + params + '=>(' + body + '))()';\n    }\n    return '(function(' + params + '){return ' + body + '})()';\n  }\n  if (isObject) {\n    return '(' + result + ')';\n  }\n  return result;\n}\n\nexport function serialize<T extends ServerValue>(\n  source: T,\n  options?: Partial<Options>,\n) {\n  const ctx = createParserContext(options);\n  const [tree, rootID, isObject] = parseSync(ctx, source);\n  const serial = createSerializationContext(ctx);\n  const result = serializeTree(serial, tree);\n  return finalize(serial, rootID, isObject, result);\n}\n\nexport async function serializeAsync<T extends AsyncServerValue>(\n  source: T,\n  options?: Partial<Options>,\n) {\n  const ctx = createParserContext(options);\n  const [tree, rootID, isObject] = await parseAsync(ctx, source);\n  const serial = createSerializationContext(ctx);\n  const result = serializeTree(serial, tree);\n  return finalize(serial, rootID, isObject, result);\n}\n\nexport function deserialize<T extends AsyncServerValue>(source: string): T {\n  // eslint-disable-next-line no-eval\n  return (0, eval)(source) as T;\n}\n\nexport interface SerovalJSON {\n  t: SerovalNode,\n  r: number,\n  i: boolean,\n  f: number,\n  m: number[],\n}\n\nexport function toJSON<T extends ServerValue>(\n  source: T,\n  options?: Partial<Options>,\n): SerovalJSON {\n  const ctx = createParserContext(options);\n  const [tree, root, isObject] = parseSync(ctx, source);\n  return {\n    t: tree,\n    r: root,\n    i: isObject,\n    f: ctx.features,\n    m: Array.from(ctx.markedRefs),\n  };\n}\n\nexport async function toJSONAsync<T extends AsyncServerValue>(\n  source: T,\n  options?: Partial<Options>,\n): Promise<SerovalJSON> {\n  const ctx = createParserContext(options);\n  const [tree, root, isObject] = await parseAsync(ctx, source);\n  return {\n    t: tree,\n    r: root,\n    i: isObject,\n    f: ctx.features,\n    m: Array.from(ctx.markedRefs),\n  };\n}\n\nexport function compileJSON(source: SerovalJSON): string {\n  const serial = createSerializationContext({\n    features: source.f,\n    markedRefs: source.m,\n  });\n  const result = serializeTree(serial, source.t);\n  return finalize(serial, source.r, source.i, result);\n}\n\nexport function fromJSON<T extends AsyncServerValue>(source: SerovalJSON): T {\n  const serial = createSerializationContext({\n    features: source.f,\n    markedRefs: source.m,\n  });\n  return deserializeTree(serial, source.t) as T;\n}\n\nexport default serialize;\n"],
  "mappings": "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",
  "names": ["Feature", "assignRef", "generateNodeList", "parse", "generateArrayNode", "generateMapNode", "generateSetNode", "generateProperties", "generateIterableNode", "generateObjectNode", "generateAggregateErrorNode", "generateErrorNode"]
}
