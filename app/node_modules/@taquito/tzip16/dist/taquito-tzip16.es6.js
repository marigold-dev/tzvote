import { HttpBackend } from '@taquito/http-utils';
import { Schema, ParameterSchema } from '@taquito/michelson-encoder';
import { bytes2Char } from '@taquito/utils';
export { bytes2Char, char2Bytes } from '@taquito/utils';
import { TaquitoError, ParameterValidationError, TezosToolkitConfigError, InvalidViewParameterError } from '@taquito/core';
export { InvalidViewParameterError } from '@taquito/core';
import { validateAndExtractFailwith, ViewSimulationError, BigMapAbstraction } from '@taquito/taquito';
import BigNumber from 'bignumber.js';
import CryptoJS from 'crypto-js';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

class HttpHandler {
    constructor() {
        this.httpBackend = new HttpBackend();
    }
    getMetadata(_contractAbstraction, { protocol, location }, _context) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.httpBackend.createRequest({
                url: `${protocol}:${decodeURIComponent(location)}`,
                method: 'GET',
                headers: {
                    'Content-Type': 'text/plain; charset=utf-8'
                },
                json: false
            });
        });
    }
}

/**
 *  @category Error
 *  @description Error that indicates missing big map metadata (non compliance to the TZIP-16 standard)
 */
class BigMapContractMetadataNotFoundError extends TaquitoError {
    constructor(invalidBigMapId) {
        super();
        this.invalidBigMapId = invalidBigMapId;
        this.name = 'BigMapContractMetadataNotFoundError';
        this.message =
            'Non-compliance with the TZIP-016 standard. No big map named metadata was found in the contract storage.';
    }
}
/**
 *  @category Error
 *  @description Error that indicates missing metadata in storage
 */
class ContractMetadataNotFoundError extends TaquitoError {
    constructor(info) {
        super();
        this.info = info;
        this.name = 'ContractMetadataNotFoundError';
        this.message = `No metadata was found in the contract storage. ${info}`;
    }
}
/**
 *  @category Error
 *  @description Error that indicates missing URI (non compliance to the TZIP-16 standard)
 */
class UriNotFoundError extends TaquitoError {
    constructor() {
        super();
        this.name = 'UriNotFoundError';
        this.message =
            'Non-compliance with the TZIP-016 standard. No URI found in the contract storage.';
    }
}
/**
 *  @category Error
 *  @description Error that indicates an invalid URI (non compliance to the TZIP-16 standard)
 */
class InvalidUriError extends TaquitoError {
    constructor(uri) {
        super();
        this.uri = uri;
        this.name = 'InvalidUriError';
        this.message = `Non-compliance with the TZIP-016 standard. The URI is invalid: ${uri}.`;
    }
}
/**
 *  @category Error
 *  @description Error that indicates invalid metadata (non compliance to the TZIP-16 standard)
 */
class InvalidContractMetadataError extends TaquitoError {
    constructor(invalidMetadata) {
        super();
        this.invalidMetadata = invalidMetadata;
        this.name = 'InvalidContractMetadataError';
        this.message = `The metadata found at the pointed ressource are not compliant with tzip16 standard: ${invalidMetadata}.`;
    }
}
/**
 *  @category Error
 *  @description Error that indicates the uri protocol being passed or used is not supported
 */
class ProtocolNotSupportedError extends ParameterValidationError {
    constructor(protocol) {
        super();
        this.protocol = protocol;
        this.name = 'ProtocolNotSupportedError';
        this.message = `The protocol found in the URI is not supported: ${protocol}.`;
    }
}
/**
 *  @category Error
 *  @description Error that indicates the metadata type is invalid (non compliance to the TZIP-16 standard)
 */
class InvalidContractMetadataTypeError extends TaquitoError {
    constructor() {
        super();
        this.name = 'InvalidContractMetadataTypeError';
        this.message =
            'Non-compliance with the TZIP-016 standard. The type of metadata should be bytes.';
    }
}
/**
 *  @category Error
 *  @description Error that indicates metadata provider being unconfigured in the TezosToolkit instance
 */
class UnconfiguredContractMetadataProviderError extends TezosToolkitConfigError {
    constructor() {
        super();
        this.name = 'UnconfiguredContractMetadataProviderError';
        this.message =
            'No metadata provider has been configured. The default one can be configured by calling addExtension(new Tzip16Module()) on your TezosToolkit instance.';
    }
}
/**
 *  @category Error
 *  @description Error that indicates a forbidden instruction being found inside the View code
 */
class ForbiddenInstructionInViewCodeError extends TaquitoError {
    constructor(instruction) {
        super();
        this.instruction = instruction;
        this.name = 'ForbiddenInstructionInViewCodeError';
        this.message = `Error found in the code of the view. It contains a forbidden instruction: ${instruction}.`;
    }
}
/**
 *  @category Error
 *  @description Error that indicates parameters are being passed when it is not required
 */
class NoParameterExpectedError extends ParameterValidationError {
    constructor(viewName, args) {
        super();
        this.viewName = viewName;
        this.args = args;
        this.name = 'NoParameterExpectedError';
        this.message = `${viewName} Received ${args.length} arguments while expecting no parameter or 'Unit'`;
    }
}

const typeOfValueToFind = {
    prim: 'big_map',
    args: [{ prim: 'string' }, { prim: 'bytes' }],
    annots: ['%metadata'],
};
class TezosStorageHandler {
    constructor() {
        this.TEZOS_STORAGE_REGEX = /^(?:\/\/(KT1\w{33})(?:\.(.+))?\/)?([\w|%]+)$/;
    }
    getMetadata(contractAbstraction, { location }, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const parsedTezosStorageUri = this.parseTezosStorageUri(location);
            if (!parsedTezosStorageUri) {
                throw new InvalidUriError(`tezos-storage:${location}`);
            }
            const script = yield context.readProvider.getScript(parsedTezosStorageUri.contractAddress || contractAbstraction.address, 'head');
            const bigMapId = Schema.fromRPCResponse({ script }).FindFirstInTopLevelPair(script.storage, typeOfValueToFind);
            if (!bigMapId || !bigMapId.int) {
                throw new BigMapContractMetadataNotFoundError(bigMapId);
            }
            const bytes = yield context.contract.getBigMapKeyByID(bigMapId.int.toString(), parsedTezosStorageUri.path, new Schema(typeOfValueToFind));
            if (!bytes) {
                throw new ContractMetadataNotFoundError(`No '${parsedTezosStorageUri.path}' key found in the big map %metadata of the contract ${parsedTezosStorageUri.contractAddress || contractAbstraction.address}`);
            }
            if (!/^[0-9a-fA-F]*$/.test(bytes)) {
                throw new InvalidContractMetadataTypeError();
            }
            return bytes2Char(bytes);
        });
    }
    /**
     * @description Extract the smart contract address, the network and the path pointing to the metadata from the uri
     * @returns an object which contains the properties allowing to find where the metadata are located or it returns undefined if the uri is not valid
     * @param tezosStorageURI URI (without the tezos-storage prefix)
     */
    parseTezosStorageUri(tezosStorageURI) {
        const extractor = this.TEZOS_STORAGE_REGEX.exec(tezosStorageURI);
        if (!extractor)
            return;
        return {
            contractAddress: extractor[1],
            network: extractor[2],
            path: decodeURIComponent(extractor[3]),
        };
    }
}

class IpfsHttpHandler {
    constructor(ipfsGatheway) {
        this.httpBackend = new HttpBackend();
        this._ipfsGateway = ipfsGatheway ? ipfsGatheway : 'ipfs.io';
    }
    getMetadata(_contractAbstraction, { location }, _context) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.httpBackend.createRequest({
                url: `https://${this._ipfsGateway}/ipfs/${location.substring(2)}/`,
                method: 'GET',
                headers: {
                    'Content-Type': 'text/plain; charset=utf-8'
                },
                json: false
            });
        });
    }
}

var ViewImplementationType;
(function (ViewImplementationType) {
    ViewImplementationType["MICHELSON_STORAGE"] = "michelsonStorageView";
    ViewImplementationType["REST_API_QUERY"] = "restApiQuery";
})(ViewImplementationType || (ViewImplementationType = {}));

class MichelsonStorageView {
    constructor(viewName, contract, rpc, readProvider, returnType, code, viewParameterType) {
        this.viewName = viewName;
        this.contract = contract;
        this.rpc = rpc;
        this.readProvider = readProvider;
        this.returnType = returnType;
        this.code = code;
        this.viewParameterType = viewParameterType;
        this.validateArgs = (args, schema, viewName) => {
            const sigs = schema.ExtractSignatures();
            if (!sigs.find((x) => x.length === args.length)) {
                throw new InvalidViewParameterError(viewName, sigs, args);
            }
        };
    }
    /**
     * @description According to the tzip-16 standard, the following instructions must not be used in the code of the view:
     * 'AMOUNT', 'CREATE_CONTRACT', 'SENDER', 'SET_DELEGATE', 'SOURCE', and 'TRANSFER_TOKENS'
     * The method throw an error if an illegal instruction is found
     */
    findForbiddenInstructionInViewCodeError(code) {
        const illegalInstructions = [
            'AMOUNT',
            'CREATE_CONTRACT',
            'SENDER',
            'SET_DELEGATE',
            'SOURCE',
            'TRANSFER_TOKENS',
        ];
        for (const forbiddenInstruction of illegalInstructions) {
            for (const instruction of code) {
                if (instruction.prim === forbiddenInstruction) {
                    throw new ForbiddenInstructionInViewCodeError(forbiddenInstruction);
                }
                if (instruction.args && instruction.args.length !== 0) {
                    this.findForbiddenInstructionInViewCodeError(instruction.args);
                }
            }
        }
    }
    /**
     * @description According to the tzip-16 standard, in the first version of the specification, the instruction SELF should only be used before ADDRESS
     * The method throws an error is the instruction SELF is present, but not followed by ADDRESS
     */
    illegalUseOfSelfInstruction(code) {
        for (const instruction of code) {
            if (instruction.prim === 'SELF') {
                const index = code.indexOf(instruction);
                const nextInstruction = code[index + 1] ? code[index + 1].prim : undefined;
                if (nextInstruction !== 'ADDRESS') {
                    throw new ForbiddenInstructionInViewCodeError('the instruction SELF should only be used before ADDRESS');
                }
            }
            if (instruction.args && instruction.args.length !== 0) {
                this.illegalUseOfSelfInstruction(instruction.args);
            }
        }
    }
    /**
     * @description Loops through the view's code and replace SELF, BALANCE, NOW, and CHAIN_ID with Michelson expressions that match the current context, if applicable.
     */
    adaptViewCodeToContext(code, contractBalance, blockTimeStamp, chainId) {
        const instructionsToReplace = {
            SELF: [
                { prim: 'PUSH', args: [{ prim: 'address' }, { string: this.contract.address }] },
                { prim: 'CONTRACT', args: [{ prim: 'unit' }] },
                { prim: 'IF_NONE', args: [[{ prim: 'UNIT' }, { prim: 'FAILWITH' }], []] },
            ],
            BALANCE: [{ prim: 'PUSH', args: [{ prim: 'mutez' }, { int: contractBalance }] }],
            NOW: [{ prim: 'PUSH', args: [{ prim: 'timestamp' }, { string: blockTimeStamp }] }],
            CHAIN_ID: [{ prim: 'PUSH', args: [{ prim: 'string' }, { string: chainId }] }],
        };
        code.forEach((x, i) => {
            for (const instruction in instructionsToReplace) {
                if (x.prim === instruction) {
                    code[i] = Object(instructionsToReplace)[instruction];
                }
                if (x.args && x.args.length !== 0) {
                    this.adaptViewCodeToContext(x.args, contractBalance, blockTimeStamp, chainId);
                }
            }
        });
        return code;
    }
    formatArgsAndParameter(argView) {
        let args = argView;
        let viewParameterType = this.viewParameterType;
        if (!viewParameterType) {
            viewParameterType = { args: [], prim: 'unit', annots: [] };
        }
        if (viewParameterType.prim === 'unit') {
            if (args.length === 0) {
                args = ['Unit'];
            }
            if (args.length !== 0 && args[0] !== 'Unit') {
                throw new NoParameterExpectedError(this.viewName, argView);
            }
        }
        const parameterViewSchema = new ParameterSchema(viewParameterType);
        this.validateArgs(args, parameterViewSchema, this.viewName);
        const arg = parameterViewSchema.Encode(...args);
        return { arg, viewParameterType };
    }
    executeView(...args) {
        return __awaiter(this, void 0, void 0, function* () {
            // validate view code against tzip-16 specifications
            this.findForbiddenInstructionInViewCodeError(this.code);
            this.illegalUseOfSelfInstruction(this.code);
            const { arg, viewParameterType } = this.formatArgsAndParameter(args);
            const storageType = this.contract.script.code.find((x) => x.prim === 'storage');
            const storageArgs = storageType.args[0];
            // currentContext
            const storageValue = yield this.readProvider.getStorage(this.contract.address, 'head');
            const chainId = yield this.readProvider.getChainId();
            const contractBalance = (yield this.readProvider.getBalance(this.contract.address, 'head')).toString();
            const blockTimestamp = yield this.readProvider.getBlockTimestamp('head');
            const code = this.adaptViewCodeToContext(this.code, contractBalance, blockTimestamp, chainId);
            if (!this.viewParameterType) {
                code.unshift({ prim: 'CDR' });
            }
            const viewScript = {
                script: [
                    { prim: 'parameter', args: [{ prim: 'pair', args: [viewParameterType, storageArgs] }] },
                    { prim: 'storage', args: [{ prim: 'option', args: [this.returnType] }] },
                    {
                        prim: 'code',
                        args: [
                            [
                                { prim: 'CAR' },
                                code,
                                { prim: 'SOME' },
                                { prim: 'NIL', args: [{ prim: 'operation' }] },
                                { prim: 'PAIR' },
                            ],
                        ],
                    },
                ],
                storage: { prim: 'None' },
                input: { prim: 'Pair', args: [arg, storageValue] },
                amount: '0',
                chain_id: chainId,
                balance: '0',
            };
            let result;
            try {
                result = yield this.rpc.runCode(viewScript);
            }
            catch (error) {
                const failWith = validateAndExtractFailwith(error);
                throw failWith
                    ? new ViewSimulationError(`The simulation of the Michelson view failed with: ${JSON.stringify(failWith)}`, this.viewName, failWith, error)
                    : error;
            }
            const viewResultSchema = new ParameterSchema(this.returnType);
            return viewResultSchema.Execute(result.storage.args[0]);
        });
    }
}

class ViewFactory {
    getView(viewName, rpc, readProvider, contract, viewImplementation) {
        if (this.isMichelsonStorageView(viewImplementation)) {
            const viewValues = viewImplementation[ViewImplementationType.MICHELSON_STORAGE];
            if (!viewValues.returnType || !viewValues.code) {
                console.warn(`${viewName} is missing mandatory code or returnType property therefore it will be skipped.`);
                return;
            }
            return () => {
                const view = new MichelsonStorageView(viewName, contract, rpc, readProvider, viewValues.returnType, viewValues.code, viewValues.parameter);
                return view;
            };
        }
    }
    getImplementationType(viewImplementation) {
        return Object.keys(viewImplementation)[0];
    }
    isMichelsonStorageView(viewImplementation) {
        return (this.getImplementationType(viewImplementation) === ViewImplementationType.MICHELSON_STORAGE);
    }
}

const metadataBigMapType = {
    prim: 'big_map',
    args: [{ prim: 'string' }, { prim: 'bytes' }],
    annots: ['%metadata'],
};
class Tzip16ContractAbstraction {
    constructor(constractAbstraction, context) {
        this.constractAbstraction = constractAbstraction;
        this.context = context;
        this._viewFactory = new ViewFactory();
        this._metadataViewsObject = {};
        this._metadataProvider = context.metadataProvider;
    }
    findMetadataBigMap() {
        return __awaiter(this, void 0, void 0, function* () {
            const metadataBigMapId = this.constractAbstraction.schema.FindFirstInTopLevelPair(yield this.context.readProvider.getStorage(this.constractAbstraction.address, 'head'), metadataBigMapType);
            if (!metadataBigMapId || !metadataBigMapId.int) {
                throw new BigMapContractMetadataNotFoundError(metadataBigMapId);
            }
            return new BigMapAbstraction(new BigNumber(metadataBigMapId['int']), new Schema(metadataBigMapType), this.context.contract);
        });
    }
    getUriOrFail() {
        return __awaiter(this, void 0, void 0, function* () {
            const metadataBigMap = yield this.findMetadataBigMap();
            const uri = yield metadataBigMap.get('');
            if (!uri) {
                throw new UriNotFoundError();
            }
            return uri;
        });
    }
    /**
     * @description Return an object containing the metadata, the uri, an optional integrity check result and an optional sha256 hash
     */
    getMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._metadataProvider) {
                throw new UnconfiguredContractMetadataProviderError();
            }
            if (!this._metadataEnvelope) {
                const uri = yield this.getUriOrFail();
                this._metadataEnvelope = yield this._metadataProvider.provideMetadata(this.constractAbstraction, bytes2Char(uri), this.context);
            }
            return this._metadataEnvelope;
        });
    }
    metadataName() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._metadataEnvelope) {
                yield this.getMetadata();
            }
            return this._metadataEnvelope.metadata.name;
        });
    }
    metadataDescription() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._metadataEnvelope)
                yield this.getMetadata();
            return this._metadataEnvelope.metadata.description;
        });
    }
    metadataVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._metadataEnvelope)
                yield this.getMetadata();
            return this._metadataEnvelope.metadata.version;
        });
    }
    metadataLicense() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._metadataEnvelope)
                yield this.getMetadata();
            return this._metadataEnvelope.metadata.license;
        });
    }
    metadataAuthors() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._metadataEnvelope)
                yield this.getMetadata();
            return this._metadataEnvelope.metadata.authors;
        });
    }
    metadataHomepage() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._metadataEnvelope)
                yield this.getMetadata();
            return this._metadataEnvelope.metadata.homepage;
        });
    }
    metadataSource() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._metadataEnvelope)
                yield this.getMetadata();
            return this._metadataEnvelope.metadata.source;
        });
    }
    metadataInterfaces() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._metadataEnvelope)
                yield this.getMetadata();
            return this._metadataEnvelope.metadata.interfaces;
        });
    }
    metadataErrors() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._metadataEnvelope)
                yield this.getMetadata();
            return this._metadataEnvelope.metadata.errors;
        });
    }
    metadataViews() {
        return __awaiter(this, void 0, void 0, function* () {
            if (Object.keys(this._metadataViewsObject).length === 0) {
                yield this.initializeMetadataViewsList();
            }
            return this._metadataViewsObject;
        });
    }
    initializeMetadataViewsList() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { metadata } = yield this.getMetadata();
            const metadataViews = {};
            (_a = metadata.views) === null || _a === void 0 ? void 0 : _a.forEach((view) => this.createViewImplementations(view, metadataViews));
            this._metadataViewsObject = metadataViews;
        });
    }
    generateIndexedViewName(viewName, metadataViews) {
        let i = 1;
        if (viewName in metadataViews) {
            while (`${viewName}${i}` in metadataViews) {
                i++;
            }
            viewName = `${viewName}${i}`;
        }
        return viewName;
    }
    createViewImplementations(view, metadataViews) {
        var _a;
        for (const viewImplementation of (_a = view === null || view === void 0 ? void 0 : view.implementations) !== null && _a !== void 0 ? _a : []) {
            if (view.name) {
                // when views have the same name, add an index at the end of the name
                const viewName = this.generateIndexedViewName(view.name, metadataViews);
                const metadataView = this._viewFactory.getView(viewName, this.context.rpc, this.context.readProvider, this.constractAbstraction, viewImplementation);
                if (metadataView) {
                    metadataViews[viewName] = metadataView;
                }
                else {
                    console.warn(`Skipped generating ${viewName} because the view has an unsupported type: ${this._viewFactory.getImplementationType(viewImplementation)}`);
                }
            }
        }
    }
}

const ABSTRACTION_KEY = Symbol('Tzip16ContractAbstractionObjectKey');
function tzip16(abs, context) {
    return Object.assign(abs, {
        // namespace tzip16
        tzip16() {
            if (!this[ABSTRACTION_KEY]) {
                this[ABSTRACTION_KEY] = new Tzip16ContractAbstraction(this, context);
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this[ABSTRACTION_KEY];
        },
    });
}

function calculateSHA256Hash(preimage) {
    return CryptoJS.SHA256(preimage).toString(CryptoJS.enc.Hex);
}

/**
 * @description: Metadata Provider
 */
class MetadataProvider {
    constructor(handlers) {
        this.handlers = handlers;
        this.PROTOCOL_REGEX = /(?:sha256:\/\/0x(.*)\/)?(https?|ipfs|tezos-storage):(.*)/;
    }
    /**
     * @description Fetch the metadata by using the appropriate handler based on the protcol found in the URI
     * @returns an object which contains the uri, the metadata, an optional integrity check result and an optional SHA256 hash
     * @param _contractAbstraction the contract abstraction which contains the URI in its storage
     * @param _uri the decoded uri found in the storage
     * @param context the TezosToolkit Context
     */
    provideMetadata(contractAbstraction, uri, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const uriInfo = this.extractProtocolInfo(uri);
            if (!uriInfo || !uriInfo.location) {
                throw new InvalidUriError(uri);
            }
            const handler = this.handlers.get(uriInfo.protocol);
            if (!handler) {
                throw new ProtocolNotSupportedError(uriInfo.protocol);
            }
            const metadata = yield handler.getMetadata(contractAbstraction, uriInfo, context);
            const sha256Hash = calculateSHA256Hash(metadata);
            let metadataJSON;
            try {
                metadataJSON = JSON.parse(metadata);
            }
            catch (ex) {
                throw new InvalidContractMetadataError(metadata);
            }
            return {
                uri,
                metadata: metadataJSON,
                integrityCheckResult: uriInfo.sha256hash ? uriInfo.sha256hash === sha256Hash : undefined,
                sha256Hash: uriInfo.sha256hash ? sha256Hash : undefined,
            };
        });
    }
    extractProtocolInfo(_uri) {
        const extractor = this.PROTOCOL_REGEX.exec(_uri);
        if (!extractor)
            return;
        return {
            sha256hash: extractor[1],
            protocol: extractor[2],
            location: extractor[3],
        };
    }
}

const DEFAULT_HANDLERS = new Map([
    ['http', new HttpHandler()],
    ['https', new HttpHandler()],
    ['tezos-storage', new TezosStorageHandler()],
    ['ipfs', new IpfsHttpHandler()]
]);
class Tzip16Module {
    constructor(metadataProvider) {
        this._metadataProvider = metadataProvider ? metadataProvider : new MetadataProvider(DEFAULT_HANDLERS);
    }
    configureContext(context) {
        Object.assign(context, { metadataProvider: this._metadataProvider });
    }
}

// IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!
const VERSION = {
    "commitHash": "b85fc404e34545a518215e449b3f1253f4520eec",
    "version": "17.2.0"
};

export { BigMapContractMetadataNotFoundError, ContractMetadataNotFoundError, DEFAULT_HANDLERS, ForbiddenInstructionInViewCodeError, HttpHandler, InvalidContractMetadataError, InvalidContractMetadataTypeError, InvalidUriError, IpfsHttpHandler, MetadataProvider, MichelsonStorageView, NoParameterExpectedError, ProtocolNotSupportedError, TezosStorageHandler, Tzip16ContractAbstraction, Tzip16Module, UnconfiguredContractMetadataProviderError, UriNotFoundError, VERSION, ViewFactory, ViewImplementationType, calculateSHA256Hash, tzip16 };
//# sourceMappingURL=taquito-tzip16.es6.js.map
