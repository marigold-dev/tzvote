(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@taquito/http-utils'), require('@taquito/michelson-encoder'), require('@taquito/utils'), require('@taquito/core'), require('@taquito/taquito'), require('bignumber.js'), require('crypto-js')) :
    typeof define === 'function' && define.amd ? define(['exports', '@taquito/http-utils', '@taquito/michelson-encoder', '@taquito/utils', '@taquito/core', '@taquito/taquito', 'bignumber.js', 'crypto-js'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.taquitoTzip16 = {}, global.httpUtils, global.michelsonEncoder, global.utils, global.core, global.taquito, global.BigNumber, global.CryptoJS));
})(this, (function (exports, httpUtils, michelsonEncoder, utils, core, taquito, BigNumber, CryptoJS) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    var BigNumber__default = /*#__PURE__*/_interopDefaultLegacy(BigNumber);
    var CryptoJS__default = /*#__PURE__*/_interopDefaultLegacy(CryptoJS);

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };

    class HttpHandler {
        constructor() {
            this.httpBackend = new httpUtils.HttpBackend();
        }
        getMetadata(_contractAbstraction, { protocol, location }, _context) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: `${protocol}:${decodeURIComponent(location)}`,
                    method: 'GET',
                    headers: {
                        'Content-Type': 'text/plain; charset=utf-8'
                    },
                    json: false
                });
            });
        }
    }

    /**
     *  @category Error
     *  @description Error that indicates missing big map metadata (non compliance to the TZIP-16 standard)
     */
    class BigMapContractMetadataNotFoundError extends core.TaquitoError {
        constructor(invalidBigMapId) {
            super();
            this.invalidBigMapId = invalidBigMapId;
            this.name = 'BigMapContractMetadataNotFoundError';
            this.message =
                'Non-compliance with the TZIP-016 standard. No big map named metadata was found in the contract storage.';
        }
    }
    /**
     *  @category Error
     *  @description Error that indicates missing metadata in storage
     */
    class ContractMetadataNotFoundError extends core.TaquitoError {
        constructor(info) {
            super();
            this.info = info;
            this.name = 'ContractMetadataNotFoundError';
            this.message = `No metadata was found in the contract storage. ${info}`;
        }
    }
    /**
     *  @category Error
     *  @description Error that indicates missing URI (non compliance to the TZIP-16 standard)
     */
    class UriNotFoundError extends core.TaquitoError {
        constructor() {
            super();
            this.name = 'UriNotFoundError';
            this.message =
                'Non-compliance with the TZIP-016 standard. No URI found in the contract storage.';
        }
    }
    /**
     *  @category Error
     *  @description Error that indicates an invalid URI (non compliance to the TZIP-16 standard)
     */
    class InvalidUriError extends core.TaquitoError {
        constructor(uri) {
            super();
            this.uri = uri;
            this.name = 'InvalidUriError';
            this.message = `Non-compliance with the TZIP-016 standard. The URI is invalid: ${uri}.`;
        }
    }
    /**
     *  @category Error
     *  @description Error that indicates invalid metadata (non compliance to the TZIP-16 standard)
     */
    class InvalidContractMetadataError extends core.TaquitoError {
        constructor(invalidMetadata) {
            super();
            this.invalidMetadata = invalidMetadata;
            this.name = 'InvalidContractMetadataError';
            this.message = `The metadata found at the pointed ressource are not compliant with tzip16 standard: ${invalidMetadata}.`;
        }
    }
    /**
     *  @category Error
     *  @description Error that indicates the uri protocol being passed or used is not supported
     */
    class ProtocolNotSupportedError extends core.ParameterValidationError {
        constructor(protocol) {
            super();
            this.protocol = protocol;
            this.name = 'ProtocolNotSupportedError';
            this.message = `The protocol found in the URI is not supported: ${protocol}.`;
        }
    }
    /**
     *  @category Error
     *  @description Error that indicates the metadata type is invalid (non compliance to the TZIP-16 standard)
     */
    class InvalidContractMetadataTypeError extends core.TaquitoError {
        constructor() {
            super();
            this.name = 'InvalidContractMetadataTypeError';
            this.message =
                'Non-compliance with the TZIP-016 standard. The type of metadata should be bytes.';
        }
    }
    /**
     *  @category Error
     *  @description Error that indicates metadata provider being unconfigured in the TezosToolkit instance
     */
    class UnconfiguredContractMetadataProviderError extends core.TezosToolkitConfigError {
        constructor() {
            super();
            this.name = 'UnconfiguredContractMetadataProviderError';
            this.message =
                'No metadata provider has been configured. The default one can be configured by calling addExtension(new Tzip16Module()) on your TezosToolkit instance.';
        }
    }
    /**
     *  @category Error
     *  @description Error that indicates a forbidden instruction being found inside the View code
     */
    class ForbiddenInstructionInViewCodeError extends core.TaquitoError {
        constructor(instruction) {
            super();
            this.instruction = instruction;
            this.name = 'ForbiddenInstructionInViewCodeError';
            this.message = `Error found in the code of the view. It contains a forbidden instruction: ${instruction}.`;
        }
    }
    /**
     *  @category Error
     *  @description Error that indicates parameters are being passed when it is not required
     */
    class NoParameterExpectedError extends core.ParameterValidationError {
        constructor(viewName, args) {
            super();
            this.viewName = viewName;
            this.args = args;
            this.name = 'NoParameterExpectedError';
            this.message = `${viewName} Received ${args.length} arguments while expecting no parameter or 'Unit'`;
        }
    }

    const typeOfValueToFind = {
        prim: 'big_map',
        args: [{ prim: 'string' }, { prim: 'bytes' }],
        annots: ['%metadata'],
    };
    class TezosStorageHandler {
        constructor() {
            this.TEZOS_STORAGE_REGEX = /^(?:\/\/(KT1\w{33})(?:\.(.+))?\/)?([\w|%]+)$/;
        }
        getMetadata(contractAbstraction, { location }, context) {
            return __awaiter(this, void 0, void 0, function* () {
                const parsedTezosStorageUri = this.parseTezosStorageUri(location);
                if (!parsedTezosStorageUri) {
                    throw new InvalidUriError(`tezos-storage:${location}`);
                }
                const script = yield context.readProvider.getScript(parsedTezosStorageUri.contractAddress || contractAbstraction.address, 'head');
                const bigMapId = michelsonEncoder.Schema.fromRPCResponse({ script }).FindFirstInTopLevelPair(script.storage, typeOfValueToFind);
                if (!bigMapId || !bigMapId.int) {
                    throw new BigMapContractMetadataNotFoundError(bigMapId);
                }
                const bytes = yield context.contract.getBigMapKeyByID(bigMapId.int.toString(), parsedTezosStorageUri.path, new michelsonEncoder.Schema(typeOfValueToFind));
                if (!bytes) {
                    throw new ContractMetadataNotFoundError(`No '${parsedTezosStorageUri.path}' key found in the big map %metadata of the contract ${parsedTezosStorageUri.contractAddress || contractAbstraction.address}`);
                }
                if (!/^[0-9a-fA-F]*$/.test(bytes)) {
                    throw new InvalidContractMetadataTypeError();
                }
                return utils.bytes2Char(bytes);
            });
        }
        /**
         * @description Extract the smart contract address, the network and the path pointing to the metadata from the uri
         * @returns an object which contains the properties allowing to find where the metadata are located or it returns undefined if the uri is not valid
         * @param tezosStorageURI URI (without the tezos-storage prefix)
         */
        parseTezosStorageUri(tezosStorageURI) {
            const extractor = this.TEZOS_STORAGE_REGEX.exec(tezosStorageURI);
            if (!extractor)
                return;
            return {
                contractAddress: extractor[1],
                network: extractor[2],
                path: decodeURIComponent(extractor[3]),
            };
        }
    }

    class IpfsHttpHandler {
        constructor(ipfsGatheway) {
            this.httpBackend = new httpUtils.HttpBackend();
            this._ipfsGateway = ipfsGatheway ? ipfsGatheway : 'ipfs.io';
        }
        getMetadata(_contractAbstraction, { location }, _context) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.httpBackend.createRequest({
                    url: `https://${this._ipfsGateway}/ipfs/${location.substring(2)}/`,
                    method: 'GET',
                    headers: {
                        'Content-Type': 'text/plain; charset=utf-8'
                    },
                    json: false
                });
            });
        }
    }

    exports.ViewImplementationType = void 0;
    (function (ViewImplementationType) {
        ViewImplementationType["MICHELSON_STORAGE"] = "michelsonStorageView";
        ViewImplementationType["REST_API_QUERY"] = "restApiQuery";
    })(exports.ViewImplementationType || (exports.ViewImplementationType = {}));

    class MichelsonStorageView {
        constructor(viewName, contract, rpc, readProvider, returnType, code, viewParameterType) {
            this.viewName = viewName;
            this.contract = contract;
            this.rpc = rpc;
            this.readProvider = readProvider;
            this.returnType = returnType;
            this.code = code;
            this.viewParameterType = viewParameterType;
            this.validateArgs = (args, schema, viewName) => {
                const sigs = schema.ExtractSignatures();
                if (!sigs.find((x) => x.length === args.length)) {
                    throw new core.InvalidViewParameterError(viewName, sigs, args);
                }
            };
        }
        /**
         * @description According to the tzip-16 standard, the following instructions must not be used in the code of the view:
         * 'AMOUNT', 'CREATE_CONTRACT', 'SENDER', 'SET_DELEGATE', 'SOURCE', and 'TRANSFER_TOKENS'
         * The method throw an error if an illegal instruction is found
         */
        findForbiddenInstructionInViewCodeError(code) {
            const illegalInstructions = [
                'AMOUNT',
                'CREATE_CONTRACT',
                'SENDER',
                'SET_DELEGATE',
                'SOURCE',
                'TRANSFER_TOKENS',
            ];
            for (const forbiddenInstruction of illegalInstructions) {
                for (const instruction of code) {
                    if (instruction.prim === forbiddenInstruction) {
                        throw new ForbiddenInstructionInViewCodeError(forbiddenInstruction);
                    }
                    if (instruction.args && instruction.args.length !== 0) {
                        this.findForbiddenInstructionInViewCodeError(instruction.args);
                    }
                }
            }
        }
        /**
         * @description According to the tzip-16 standard, in the first version of the specification, the instruction SELF should only be used before ADDRESS
         * The method throws an error is the instruction SELF is present, but not followed by ADDRESS
         */
        illegalUseOfSelfInstruction(code) {
            for (const instruction of code) {
                if (instruction.prim === 'SELF') {
                    const index = code.indexOf(instruction);
                    const nextInstruction = code[index + 1] ? code[index + 1].prim : undefined;
                    if (nextInstruction !== 'ADDRESS') {
                        throw new ForbiddenInstructionInViewCodeError('the instruction SELF should only be used before ADDRESS');
                    }
                }
                if (instruction.args && instruction.args.length !== 0) {
                    this.illegalUseOfSelfInstruction(instruction.args);
                }
            }
        }
        /**
         * @description Loops through the view's code and replace SELF, BALANCE, NOW, and CHAIN_ID with Michelson expressions that match the current context, if applicable.
         */
        adaptViewCodeToContext(code, contractBalance, blockTimeStamp, chainId) {
            const instructionsToReplace = {
                SELF: [
                    { prim: 'PUSH', args: [{ prim: 'address' }, { string: this.contract.address }] },
                    { prim: 'CONTRACT', args: [{ prim: 'unit' }] },
                    { prim: 'IF_NONE', args: [[{ prim: 'UNIT' }, { prim: 'FAILWITH' }], []] },
                ],
                BALANCE: [{ prim: 'PUSH', args: [{ prim: 'mutez' }, { int: contractBalance }] }],
                NOW: [{ prim: 'PUSH', args: [{ prim: 'timestamp' }, { string: blockTimeStamp }] }],
                CHAIN_ID: [{ prim: 'PUSH', args: [{ prim: 'string' }, { string: chainId }] }],
            };
            code.forEach((x, i) => {
                for (const instruction in instructionsToReplace) {
                    if (x.prim === instruction) {
                        code[i] = Object(instructionsToReplace)[instruction];
                    }
                    if (x.args && x.args.length !== 0) {
                        this.adaptViewCodeToContext(x.args, contractBalance, blockTimeStamp, chainId);
                    }
                }
            });
            return code;
        }
        formatArgsAndParameter(argView) {
            let args = argView;
            let viewParameterType = this.viewParameterType;
            if (!viewParameterType) {
                viewParameterType = { args: [], prim: 'unit', annots: [] };
            }
            if (viewParameterType.prim === 'unit') {
                if (args.length === 0) {
                    args = ['Unit'];
                }
                if (args.length !== 0 && args[0] !== 'Unit') {
                    throw new NoParameterExpectedError(this.viewName, argView);
                }
            }
            const parameterViewSchema = new michelsonEncoder.ParameterSchema(viewParameterType);
            this.validateArgs(args, parameterViewSchema, this.viewName);
            const arg = parameterViewSchema.Encode(...args);
            return { arg, viewParameterType };
        }
        executeView(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                // validate view code against tzip-16 specifications
                this.findForbiddenInstructionInViewCodeError(this.code);
                this.illegalUseOfSelfInstruction(this.code);
                const { arg, viewParameterType } = this.formatArgsAndParameter(args);
                const storageType = this.contract.script.code.find((x) => x.prim === 'storage');
                const storageArgs = storageType.args[0];
                // currentContext
                const storageValue = yield this.readProvider.getStorage(this.contract.address, 'head');
                const chainId = yield this.readProvider.getChainId();
                const contractBalance = (yield this.readProvider.getBalance(this.contract.address, 'head')).toString();
                const blockTimestamp = yield this.readProvider.getBlockTimestamp('head');
                const code = this.adaptViewCodeToContext(this.code, contractBalance, blockTimestamp, chainId);
                if (!this.viewParameterType) {
                    code.unshift({ prim: 'CDR' });
                }
                const viewScript = {
                    script: [
                        { prim: 'parameter', args: [{ prim: 'pair', args: [viewParameterType, storageArgs] }] },
                        { prim: 'storage', args: [{ prim: 'option', args: [this.returnType] }] },
                        {
                            prim: 'code',
                            args: [
                                [
                                    { prim: 'CAR' },
                                    code,
                                    { prim: 'SOME' },
                                    { prim: 'NIL', args: [{ prim: 'operation' }] },
                                    { prim: 'PAIR' },
                                ],
                            ],
                        },
                    ],
                    storage: { prim: 'None' },
                    input: { prim: 'Pair', args: [arg, storageValue] },
                    amount: '0',
                    chain_id: chainId,
                    balance: '0',
                };
                let result;
                try {
                    result = yield this.rpc.runCode(viewScript);
                }
                catch (error) {
                    const failWith = taquito.validateAndExtractFailwith(error);
                    throw failWith
                        ? new taquito.ViewSimulationError(`The simulation of the Michelson view failed with: ${JSON.stringify(failWith)}`, this.viewName, failWith, error)
                        : error;
                }
                const viewResultSchema = new michelsonEncoder.ParameterSchema(this.returnType);
                return viewResultSchema.Execute(result.storage.args[0]);
            });
        }
    }

    class ViewFactory {
        getView(viewName, rpc, readProvider, contract, viewImplementation) {
            if (this.isMichelsonStorageView(viewImplementation)) {
                const viewValues = viewImplementation[exports.ViewImplementationType.MICHELSON_STORAGE];
                if (!viewValues.returnType || !viewValues.code) {
                    console.warn(`${viewName} is missing mandatory code or returnType property therefore it will be skipped.`);
                    return;
                }
                return () => {
                    const view = new MichelsonStorageView(viewName, contract, rpc, readProvider, viewValues.returnType, viewValues.code, viewValues.parameter);
                    return view;
                };
            }
        }
        getImplementationType(viewImplementation) {
            return Object.keys(viewImplementation)[0];
        }
        isMichelsonStorageView(viewImplementation) {
            return (this.getImplementationType(viewImplementation) === exports.ViewImplementationType.MICHELSON_STORAGE);
        }
    }

    const metadataBigMapType = {
        prim: 'big_map',
        args: [{ prim: 'string' }, { prim: 'bytes' }],
        annots: ['%metadata'],
    };
    class Tzip16ContractAbstraction {
        constructor(constractAbstraction, context) {
            this.constractAbstraction = constractAbstraction;
            this.context = context;
            this._viewFactory = new ViewFactory();
            this._metadataViewsObject = {};
            this._metadataProvider = context.metadataProvider;
        }
        findMetadataBigMap() {
            return __awaiter(this, void 0, void 0, function* () {
                const metadataBigMapId = this.constractAbstraction.schema.FindFirstInTopLevelPair(yield this.context.readProvider.getStorage(this.constractAbstraction.address, 'head'), metadataBigMapType);
                if (!metadataBigMapId || !metadataBigMapId.int) {
                    throw new BigMapContractMetadataNotFoundError(metadataBigMapId);
                }
                return new taquito.BigMapAbstraction(new BigNumber__default["default"](metadataBigMapId['int']), new michelsonEncoder.Schema(metadataBigMapType), this.context.contract);
            });
        }
        getUriOrFail() {
            return __awaiter(this, void 0, void 0, function* () {
                const metadataBigMap = yield this.findMetadataBigMap();
                const uri = yield metadataBigMap.get('');
                if (!uri) {
                    throw new UriNotFoundError();
                }
                return uri;
            });
        }
        /**
         * @description Return an object containing the metadata, the uri, an optional integrity check result and an optional sha256 hash
         */
        getMetadata() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this._metadataProvider) {
                    throw new UnconfiguredContractMetadataProviderError();
                }
                if (!this._metadataEnvelope) {
                    const uri = yield this.getUriOrFail();
                    this._metadataEnvelope = yield this._metadataProvider.provideMetadata(this.constractAbstraction, utils.bytes2Char(uri), this.context);
                }
                return this._metadataEnvelope;
            });
        }
        metadataName() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this._metadataEnvelope) {
                    yield this.getMetadata();
                }
                return this._metadataEnvelope.metadata.name;
            });
        }
        metadataDescription() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this._metadataEnvelope)
                    yield this.getMetadata();
                return this._metadataEnvelope.metadata.description;
            });
        }
        metadataVersion() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this._metadataEnvelope)
                    yield this.getMetadata();
                return this._metadataEnvelope.metadata.version;
            });
        }
        metadataLicense() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this._metadataEnvelope)
                    yield this.getMetadata();
                return this._metadataEnvelope.metadata.license;
            });
        }
        metadataAuthors() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this._metadataEnvelope)
                    yield this.getMetadata();
                return this._metadataEnvelope.metadata.authors;
            });
        }
        metadataHomepage() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this._metadataEnvelope)
                    yield this.getMetadata();
                return this._metadataEnvelope.metadata.homepage;
            });
        }
        metadataSource() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this._metadataEnvelope)
                    yield this.getMetadata();
                return this._metadataEnvelope.metadata.source;
            });
        }
        metadataInterfaces() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this._metadataEnvelope)
                    yield this.getMetadata();
                return this._metadataEnvelope.metadata.interfaces;
            });
        }
        metadataErrors() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this._metadataEnvelope)
                    yield this.getMetadata();
                return this._metadataEnvelope.metadata.errors;
            });
        }
        metadataViews() {
            return __awaiter(this, void 0, void 0, function* () {
                if (Object.keys(this._metadataViewsObject).length === 0) {
                    yield this.initializeMetadataViewsList();
                }
                return this._metadataViewsObject;
            });
        }
        initializeMetadataViewsList() {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                const { metadata } = yield this.getMetadata();
                const metadataViews = {};
                (_a = metadata.views) === null || _a === void 0 ? void 0 : _a.forEach((view) => this.createViewImplementations(view, metadataViews));
                this._metadataViewsObject = metadataViews;
            });
        }
        generateIndexedViewName(viewName, metadataViews) {
            let i = 1;
            if (viewName in metadataViews) {
                while (`${viewName}${i}` in metadataViews) {
                    i++;
                }
                viewName = `${viewName}${i}`;
            }
            return viewName;
        }
        createViewImplementations(view, metadataViews) {
            var _a;
            for (const viewImplementation of (_a = view === null || view === void 0 ? void 0 : view.implementations) !== null && _a !== void 0 ? _a : []) {
                if (view.name) {
                    // when views have the same name, add an index at the end of the name
                    const viewName = this.generateIndexedViewName(view.name, metadataViews);
                    const metadataView = this._viewFactory.getView(viewName, this.context.rpc, this.context.readProvider, this.constractAbstraction, viewImplementation);
                    if (metadataView) {
                        metadataViews[viewName] = metadataView;
                    }
                    else {
                        console.warn(`Skipped generating ${viewName} because the view has an unsupported type: ${this._viewFactory.getImplementationType(viewImplementation)}`);
                    }
                }
            }
        }
    }

    const ABSTRACTION_KEY = Symbol('Tzip16ContractAbstractionObjectKey');
    function tzip16(abs, context) {
        return Object.assign(abs, {
            // namespace tzip16
            tzip16() {
                if (!this[ABSTRACTION_KEY]) {
                    this[ABSTRACTION_KEY] = new Tzip16ContractAbstraction(this, context);
                }
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                return this[ABSTRACTION_KEY];
            },
        });
    }

    function calculateSHA256Hash(preimage) {
        return CryptoJS__default["default"].SHA256(preimage).toString(CryptoJS__default["default"].enc.Hex);
    }

    /**
     * @description: Metadata Provider
     */
    class MetadataProvider {
        constructor(handlers) {
            this.handlers = handlers;
            this.PROTOCOL_REGEX = /(?:sha256:\/\/0x(.*)\/)?(https?|ipfs|tezos-storage):(.*)/;
        }
        /**
         * @description Fetch the metadata by using the appropriate handler based on the protcol found in the URI
         * @returns an object which contains the uri, the metadata, an optional integrity check result and an optional SHA256 hash
         * @param _contractAbstraction the contract abstraction which contains the URI in its storage
         * @param _uri the decoded uri found in the storage
         * @param context the TezosToolkit Context
         */
        provideMetadata(contractAbstraction, uri, context) {
            return __awaiter(this, void 0, void 0, function* () {
                const uriInfo = this.extractProtocolInfo(uri);
                if (!uriInfo || !uriInfo.location) {
                    throw new InvalidUriError(uri);
                }
                const handler = this.handlers.get(uriInfo.protocol);
                if (!handler) {
                    throw new ProtocolNotSupportedError(uriInfo.protocol);
                }
                const metadata = yield handler.getMetadata(contractAbstraction, uriInfo, context);
                const sha256Hash = calculateSHA256Hash(metadata);
                let metadataJSON;
                try {
                    metadataJSON = JSON.parse(metadata);
                }
                catch (ex) {
                    throw new InvalidContractMetadataError(metadata);
                }
                return {
                    uri,
                    metadata: metadataJSON,
                    integrityCheckResult: uriInfo.sha256hash ? uriInfo.sha256hash === sha256Hash : undefined,
                    sha256Hash: uriInfo.sha256hash ? sha256Hash : undefined,
                };
            });
        }
        extractProtocolInfo(_uri) {
            const extractor = this.PROTOCOL_REGEX.exec(_uri);
            if (!extractor)
                return;
            return {
                sha256hash: extractor[1],
                protocol: extractor[2],
                location: extractor[3],
            };
        }
    }

    const DEFAULT_HANDLERS = new Map([
        ['http', new HttpHandler()],
        ['https', new HttpHandler()],
        ['tezos-storage', new TezosStorageHandler()],
        ['ipfs', new IpfsHttpHandler()]
    ]);
    class Tzip16Module {
        constructor(metadataProvider) {
            this._metadataProvider = metadataProvider ? metadataProvider : new MetadataProvider(DEFAULT_HANDLERS);
        }
        configureContext(context) {
            Object.assign(context, { metadataProvider: this._metadataProvider });
        }
    }

    // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!
    const VERSION = {
        "commitHash": "b85fc404e34545a518215e449b3f1253f4520eec",
        "version": "17.2.0"
    };

    Object.defineProperty(exports, 'bytes2Char', {
        enumerable: true,
        get: function () { return utils.bytes2Char; }
    });
    Object.defineProperty(exports, 'char2Bytes', {
        enumerable: true,
        get: function () { return utils.char2Bytes; }
    });
    Object.defineProperty(exports, 'InvalidViewParameterError', {
        enumerable: true,
        get: function () { return core.InvalidViewParameterError; }
    });
    exports.BigMapContractMetadataNotFoundError = BigMapContractMetadataNotFoundError;
    exports.ContractMetadataNotFoundError = ContractMetadataNotFoundError;
    exports.DEFAULT_HANDLERS = DEFAULT_HANDLERS;
    exports.ForbiddenInstructionInViewCodeError = ForbiddenInstructionInViewCodeError;
    exports.HttpHandler = HttpHandler;
    exports.InvalidContractMetadataError = InvalidContractMetadataError;
    exports.InvalidContractMetadataTypeError = InvalidContractMetadataTypeError;
    exports.InvalidUriError = InvalidUriError;
    exports.IpfsHttpHandler = IpfsHttpHandler;
    exports.MetadataProvider = MetadataProvider;
    exports.MichelsonStorageView = MichelsonStorageView;
    exports.NoParameterExpectedError = NoParameterExpectedError;
    exports.ProtocolNotSupportedError = ProtocolNotSupportedError;
    exports.TezosStorageHandler = TezosStorageHandler;
    exports.Tzip16ContractAbstraction = Tzip16ContractAbstraction;
    exports.Tzip16Module = Tzip16Module;
    exports.UnconfiguredContractMetadataProviderError = UnconfiguredContractMetadataProviderError;
    exports.UriNotFoundError = UriNotFoundError;
    exports.VERSION = VERSION;
    exports.ViewFactory = ViewFactory;
    exports.calculateSHA256Hash = calculateSHA256Hash;
    exports.tzip16 = tzip16;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=taquito-tzip16.umd.js.map
