"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TezosStorageHandler = void 0;
const michelson_encoder_1 = require("@taquito/michelson-encoder");
const utils_1 = require("@taquito/utils");
const errors_1 = require("../errors");
const typeOfValueToFind = {
    prim: 'big_map',
    args: [{ prim: 'string' }, { prim: 'bytes' }],
    annots: ['%metadata'],
};
class TezosStorageHandler {
    constructor() {
        this.TEZOS_STORAGE_REGEX = /^(?:\/\/(KT1\w{33})(?:\.(.+))?\/)?([\w|%]+)$/;
    }
    getMetadata(contractAbstraction, { location }, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const parsedTezosStorageUri = this.parseTezosStorageUri(location);
            if (!parsedTezosStorageUri) {
                throw new errors_1.InvalidUriError(`tezos-storage:${location}`);
            }
            const script = yield context.readProvider.getScript(parsedTezosStorageUri.contractAddress || contractAbstraction.address, 'head');
            const bigMapId = michelson_encoder_1.Schema.fromRPCResponse({ script }).FindFirstInTopLevelPair(script.storage, typeOfValueToFind);
            if (!bigMapId || !bigMapId.int) {
                throw new errors_1.BigMapContractMetadataNotFoundError(bigMapId);
            }
            const bytes = yield context.contract.getBigMapKeyByID(bigMapId.int.toString(), parsedTezosStorageUri.path, new michelson_encoder_1.Schema(typeOfValueToFind));
            if (!bytes) {
                throw new errors_1.ContractMetadataNotFoundError(`No '${parsedTezosStorageUri.path}' key found in the big map %metadata of the contract ${parsedTezosStorageUri.contractAddress || contractAbstraction.address}`);
            }
            if (!/^[0-9a-fA-F]*$/.test(bytes)) {
                throw new errors_1.InvalidContractMetadataTypeError();
            }
            return utils_1.bytes2Char(bytes);
        });
    }
    /**
     * @description Extract the smart contract address, the network and the path pointing to the metadata from the uri
     * @returns an object which contains the properties allowing to find where the metadata are located or it returns undefined if the uri is not valid
     * @param tezosStorageURI URI (without the tezos-storage prefix)
     */
    parseTezosStorageUri(tezosStorageURI) {
        const extractor = this.TEZOS_STORAGE_REGEX.exec(tezosStorageURI);
        if (!extractor)
            return;
        return {
            contractAddress: extractor[1],
            network: extractor[2],
            path: decodeURIComponent(extractor[3]),
        };
    }
}
exports.TezosStorageHandler = TezosStorageHandler;
//# sourceMappingURL=tezos-storage-handler.js.map