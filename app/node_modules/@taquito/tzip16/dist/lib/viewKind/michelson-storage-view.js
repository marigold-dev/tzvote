"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MichelsonStorageView = void 0;
const michelson_encoder_1 = require("@taquito/michelson-encoder");
const taquito_1 = require("@taquito/taquito");
const errors_1 = require("../errors");
const taquito_2 = require("@taquito/taquito");
const core_1 = require("@taquito/core");
class MichelsonStorageView {
    constructor(viewName, contract, rpc, readProvider, returnType, code, viewParameterType) {
        this.viewName = viewName;
        this.contract = contract;
        this.rpc = rpc;
        this.readProvider = readProvider;
        this.returnType = returnType;
        this.code = code;
        this.viewParameterType = viewParameterType;
        this.validateArgs = (args, schema, viewName) => {
            const sigs = schema.ExtractSignatures();
            if (!sigs.find((x) => x.length === args.length)) {
                throw new core_1.InvalidViewParameterError(viewName, sigs, args);
            }
        };
    }
    /**
     * @description According to the tzip-16 standard, the following instructions must not be used in the code of the view:
     * 'AMOUNT', 'CREATE_CONTRACT', 'SENDER', 'SET_DELEGATE', 'SOURCE', and 'TRANSFER_TOKENS'
     * The method throw an error if an illegal instruction is found
     */
    findForbiddenInstructionInViewCodeError(code) {
        const illegalInstructions = [
            'AMOUNT',
            'CREATE_CONTRACT',
            'SENDER',
            'SET_DELEGATE',
            'SOURCE',
            'TRANSFER_TOKENS',
        ];
        for (const forbiddenInstruction of illegalInstructions) {
            for (const instruction of code) {
                if (instruction.prim === forbiddenInstruction) {
                    throw new errors_1.ForbiddenInstructionInViewCodeError(forbiddenInstruction);
                }
                if (instruction.args && instruction.args.length !== 0) {
                    this.findForbiddenInstructionInViewCodeError(instruction.args);
                }
            }
        }
    }
    /**
     * @description According to the tzip-16 standard, in the first version of the specification, the instruction SELF should only be used before ADDRESS
     * The method throws an error is the instruction SELF is present, but not followed by ADDRESS
     */
    illegalUseOfSelfInstruction(code) {
        for (const instruction of code) {
            if (instruction.prim === 'SELF') {
                const index = code.indexOf(instruction);
                const nextInstruction = code[index + 1] ? code[index + 1].prim : undefined;
                if (nextInstruction !== 'ADDRESS') {
                    throw new errors_1.ForbiddenInstructionInViewCodeError('the instruction SELF should only be used before ADDRESS');
                }
            }
            if (instruction.args && instruction.args.length !== 0) {
                this.illegalUseOfSelfInstruction(instruction.args);
            }
        }
    }
    /**
     * @description Loops through the view's code and replace SELF, BALANCE, NOW, and CHAIN_ID with Michelson expressions that match the current context, if applicable.
     */
    adaptViewCodeToContext(code, contractBalance, blockTimeStamp, chainId) {
        const instructionsToReplace = {
            SELF: [
                { prim: 'PUSH', args: [{ prim: 'address' }, { string: this.contract.address }] },
                { prim: 'CONTRACT', args: [{ prim: 'unit' }] },
                { prim: 'IF_NONE', args: [[{ prim: 'UNIT' }, { prim: 'FAILWITH' }], []] },
            ],
            BALANCE: [{ prim: 'PUSH', args: [{ prim: 'mutez' }, { int: contractBalance }] }],
            NOW: [{ prim: 'PUSH', args: [{ prim: 'timestamp' }, { string: blockTimeStamp }] }],
            CHAIN_ID: [{ prim: 'PUSH', args: [{ prim: 'string' }, { string: chainId }] }],
        };
        code.forEach((x, i) => {
            for (const instruction in instructionsToReplace) {
                if (x.prim === instruction) {
                    code[i] = Object(instructionsToReplace)[instruction];
                }
                if (x.args && x.args.length !== 0) {
                    this.adaptViewCodeToContext(x.args, contractBalance, blockTimeStamp, chainId);
                }
            }
        });
        return code;
    }
    formatArgsAndParameter(argView) {
        let args = argView;
        let viewParameterType = this.viewParameterType;
        if (!viewParameterType) {
            viewParameterType = { args: [], prim: 'unit', annots: [] };
        }
        if (viewParameterType.prim === 'unit') {
            if (args.length === 0) {
                args = ['Unit'];
            }
            if (args.length !== 0 && args[0] !== 'Unit') {
                throw new errors_1.NoParameterExpectedError(this.viewName, argView);
            }
        }
        const parameterViewSchema = new michelson_encoder_1.ParameterSchema(viewParameterType);
        this.validateArgs(args, parameterViewSchema, this.viewName);
        const arg = parameterViewSchema.Encode(...args);
        return { arg, viewParameterType };
    }
    executeView(...args) {
        return __awaiter(this, void 0, void 0, function* () {
            // validate view code against tzip-16 specifications
            this.findForbiddenInstructionInViewCodeError(this.code);
            this.illegalUseOfSelfInstruction(this.code);
            const { arg, viewParameterType } = this.formatArgsAndParameter(args);
            const storageType = this.contract.script.code.find((x) => x.prim === 'storage');
            const storageArgs = storageType.args[0];
            // currentContext
            const storageValue = yield this.readProvider.getStorage(this.contract.address, 'head');
            const chainId = yield this.readProvider.getChainId();
            const contractBalance = (yield this.readProvider.getBalance(this.contract.address, 'head')).toString();
            const blockTimestamp = yield this.readProvider.getBlockTimestamp('head');
            const code = this.adaptViewCodeToContext(this.code, contractBalance, blockTimestamp, chainId);
            if (!this.viewParameterType) {
                code.unshift({ prim: 'CDR' });
            }
            const viewScript = {
                script: [
                    { prim: 'parameter', args: [{ prim: 'pair', args: [viewParameterType, storageArgs] }] },
                    { prim: 'storage', args: [{ prim: 'option', args: [this.returnType] }] },
                    {
                        prim: 'code',
                        args: [
                            [
                                { prim: 'CAR' },
                                code,
                                { prim: 'SOME' },
                                { prim: 'NIL', args: [{ prim: 'operation' }] },
                                { prim: 'PAIR' },
                            ],
                        ],
                    },
                ],
                storage: { prim: 'None' },
                input: { prim: 'Pair', args: [arg, storageValue] },
                amount: '0',
                chain_id: chainId,
                balance: '0',
            };
            let result;
            try {
                result = yield this.rpc.runCode(viewScript);
            }
            catch (error) {
                const failWith = taquito_2.validateAndExtractFailwith(error);
                throw failWith
                    ? new taquito_1.ViewSimulationError(`The simulation of the Michelson view failed with: ${JSON.stringify(failWith)}`, this.viewName, failWith, error)
                    : error;
            }
            const viewResultSchema = new michelson_encoder_1.ParameterSchema(this.returnType);
            return viewResultSchema.Execute(result.storage.args[0]);
        });
    }
}
exports.MichelsonStorageView = MichelsonStorageView;
//# sourceMappingURL=michelson-storage-view.js.map