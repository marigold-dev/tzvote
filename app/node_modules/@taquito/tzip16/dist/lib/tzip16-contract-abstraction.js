"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tzip16ContractAbstraction = void 0;
const taquito_1 = require("@taquito/taquito");
const utils_1 = require("@taquito/utils");
const errors_1 = require("./errors");
const bignumber_js_1 = require("bignumber.js");
const michelson_encoder_1 = require("@taquito/michelson-encoder");
const viewFactory_1 = require("./viewKind/viewFactory");
const metadataBigMapType = {
    prim: 'big_map',
    args: [{ prim: 'string' }, { prim: 'bytes' }],
    annots: ['%metadata'],
};
class Tzip16ContractAbstraction {
    constructor(constractAbstraction, context) {
        this.constractAbstraction = constractAbstraction;
        this.context = context;
        this._viewFactory = new viewFactory_1.ViewFactory();
        this._metadataViewsObject = {};
        this._metadataProvider = context.metadataProvider;
    }
    findMetadataBigMap() {
        return __awaiter(this, void 0, void 0, function* () {
            const metadataBigMapId = this.constractAbstraction.schema.FindFirstInTopLevelPair(yield this.context.readProvider.getStorage(this.constractAbstraction.address, 'head'), metadataBigMapType);
            if (!metadataBigMapId || !metadataBigMapId.int) {
                throw new errors_1.BigMapContractMetadataNotFoundError(metadataBigMapId);
            }
            return new taquito_1.BigMapAbstraction(new bignumber_js_1.default(metadataBigMapId['int']), new michelson_encoder_1.Schema(metadataBigMapType), this.context.contract);
        });
    }
    getUriOrFail() {
        return __awaiter(this, void 0, void 0, function* () {
            const metadataBigMap = yield this.findMetadataBigMap();
            const uri = yield metadataBigMap.get('');
            if (!uri) {
                throw new errors_1.UriNotFoundError();
            }
            return uri;
        });
    }
    /**
     * @description Return an object containing the metadata, the uri, an optional integrity check result and an optional sha256 hash
     */
    getMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._metadataProvider) {
                throw new errors_1.UnconfiguredContractMetadataProviderError();
            }
            if (!this._metadataEnvelope) {
                const uri = yield this.getUriOrFail();
                this._metadataEnvelope = yield this._metadataProvider.provideMetadata(this.constractAbstraction, utils_1.bytes2Char(uri), this.context);
            }
            return this._metadataEnvelope;
        });
    }
    metadataName() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._metadataEnvelope) {
                yield this.getMetadata();
            }
            return this._metadataEnvelope.metadata.name;
        });
    }
    metadataDescription() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._metadataEnvelope)
                yield this.getMetadata();
            return this._metadataEnvelope.metadata.description;
        });
    }
    metadataVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._metadataEnvelope)
                yield this.getMetadata();
            return this._metadataEnvelope.metadata.version;
        });
    }
    metadataLicense() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._metadataEnvelope)
                yield this.getMetadata();
            return this._metadataEnvelope.metadata.license;
        });
    }
    metadataAuthors() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._metadataEnvelope)
                yield this.getMetadata();
            return this._metadataEnvelope.metadata.authors;
        });
    }
    metadataHomepage() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._metadataEnvelope)
                yield this.getMetadata();
            return this._metadataEnvelope.metadata.homepage;
        });
    }
    metadataSource() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._metadataEnvelope)
                yield this.getMetadata();
            return this._metadataEnvelope.metadata.source;
        });
    }
    metadataInterfaces() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._metadataEnvelope)
                yield this.getMetadata();
            return this._metadataEnvelope.metadata.interfaces;
        });
    }
    metadataErrors() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._metadataEnvelope)
                yield this.getMetadata();
            return this._metadataEnvelope.metadata.errors;
        });
    }
    metadataViews() {
        return __awaiter(this, void 0, void 0, function* () {
            if (Object.keys(this._metadataViewsObject).length === 0) {
                yield this.initializeMetadataViewsList();
            }
            return this._metadataViewsObject;
        });
    }
    initializeMetadataViewsList() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { metadata } = yield this.getMetadata();
            const metadataViews = {};
            (_a = metadata.views) === null || _a === void 0 ? void 0 : _a.forEach((view) => this.createViewImplementations(view, metadataViews));
            this._metadataViewsObject = metadataViews;
        });
    }
    generateIndexedViewName(viewName, metadataViews) {
        let i = 1;
        if (viewName in metadataViews) {
            while (`${viewName}${i}` in metadataViews) {
                i++;
            }
            viewName = `${viewName}${i}`;
        }
        return viewName;
    }
    createViewImplementations(view, metadataViews) {
        var _a;
        for (const viewImplementation of (_a = view === null || view === void 0 ? void 0 : view.implementations) !== null && _a !== void 0 ? _a : []) {
            if (view.name) {
                // when views have the same name, add an index at the end of the name
                const viewName = this.generateIndexedViewName(view.name, metadataViews);
                const metadataView = this._viewFactory.getView(viewName, this.context.rpc, this.context.readProvider, this.constractAbstraction, viewImplementation);
                if (metadataView) {
                    metadataViews[viewName] = metadataView;
                }
                else {
                    console.warn(`Skipped generating ${viewName} because the view has an unsupported type: ${this._viewFactory.getImplementationType(viewImplementation)}`);
                }
            }
        }
    }
}
exports.Tzip16ContractAbstraction = Tzip16ContractAbstraction;
//# sourceMappingURL=tzip16-contract-abstraction.js.map