"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataProvider = void 0;
const errors_1 = require("./errors");
const tzip16_utils_1 = require("./tzip16-utils");
/**
 * @description: Metadata Provider
 */
class MetadataProvider {
    constructor(handlers) {
        this.handlers = handlers;
        this.PROTOCOL_REGEX = /(?:sha256:\/\/0x(.*)\/)?(https?|ipfs|tezos-storage):(.*)/;
    }
    /**
     * @description Fetch the metadata by using the appropriate handler based on the protcol found in the URI
     * @returns an object which contains the uri, the metadata, an optional integrity check result and an optional SHA256 hash
     * @param _contractAbstraction the contract abstraction which contains the URI in its storage
     * @param _uri the decoded uri found in the storage
     * @param context the TezosToolkit Context
     */
    provideMetadata(contractAbstraction, uri, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const uriInfo = this.extractProtocolInfo(uri);
            if (!uriInfo || !uriInfo.location) {
                throw new errors_1.InvalidUriError(uri);
            }
            const handler = this.handlers.get(uriInfo.protocol);
            if (!handler) {
                throw new errors_1.ProtocolNotSupportedError(uriInfo.protocol);
            }
            const metadata = yield handler.getMetadata(contractAbstraction, uriInfo, context);
            const sha256Hash = tzip16_utils_1.calculateSHA256Hash(metadata);
            let metadataJSON;
            try {
                metadataJSON = JSON.parse(metadata);
            }
            catch (ex) {
                throw new errors_1.InvalidContractMetadataError(metadata);
            }
            return {
                uri,
                metadata: metadataJSON,
                integrityCheckResult: uriInfo.sha256hash ? uriInfo.sha256hash === sha256Hash : undefined,
                sha256Hash: uriInfo.sha256hash ? sha256Hash : undefined,
            };
        });
    }
    extractProtocolInfo(_uri) {
        const extractor = this.PROTOCOL_REGEX.exec(_uri);
        if (!extractor)
            return;
        return {
            sha256hash: extractor[1],
            protocol: extractor[2],
            location: extractor[3],
        };
    }
}
exports.MetadataProvider = MetadataProvider;
//# sourceMappingURL=metadata-provider.js.map