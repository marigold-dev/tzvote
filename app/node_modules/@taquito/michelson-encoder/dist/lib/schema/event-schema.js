"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventSchema = void 0;
const storage_1 = require("./storage");
class EventSchema {
    constructor(tag, type) {
        this.tag = tag;
        this.type = type;
    }
    static fromMichelineValue(val) {
        var _a, _b;
        return new EventSchema((_a = val.annots) === null || _a === void 0 ? void 0 : _a[0], (_b = val.args) === null || _b === void 0 ? void 0 : _b[0]);
    }
    static fromRPCResponse(val) {
        const allEventSchema = [];
        val.script.code.forEach((code) => {
            if (!('prim' in code) ||
                code.prim !== 'code' ||
                !('args' in code) ||
                !code.args) {
                return;
            }
            allEventSchema.push(...EventSchema.extractEventsRecursively(code.args));
        });
        return EventSchema.removeDuplicates(allEventSchema);
    }
    static removeDuplicates(events) {
        const uniqueEvents = [];
        events.forEach((event) => {
            const idx = uniqueEvents.findIndex((e) => e.tag === event.tag && storage_1.deepEqual(e.type, event.type));
            if (idx === -1) {
                uniqueEvents.push(event);
            }
        });
        return uniqueEvents;
    }
    static extractEventsRecursively(code) {
        if (Array.isArray(code)) {
            return code.flatMap((c) => EventSchema.extractEventsRecursively(c));
        }
        if (!('prim' in code)) {
            return [];
        }
        if (code.prim === 'EMIT') {
            return [EventSchema.fromMichelineValue(code)];
        }
        if (!('args' in code) || !code.args) {
            return [];
        }
        return code.args.flatMap((c) => EventSchema.extractEventsRecursively(c));
    }
}
exports.EventSchema = EventSchema;
//# sourceMappingURL=event-schema.js.map