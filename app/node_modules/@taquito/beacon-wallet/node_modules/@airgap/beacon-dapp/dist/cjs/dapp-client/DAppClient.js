"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DAppClient = void 0;
var axios_1 = require("axios");
var bs58check = require("bs58check");
var events_1 = require("../events");
var beacon_types_1 = require("@airgap/beacon-types");
var beacon_core_1 = require("@airgap/beacon-core");
var beacon_utils_1 = require("@airgap/beacon-utils");
var beacon_message_events_1 = require("../beacon-message-events");
var tzkt_blockexplorer_1 = require("../utils/tzkt-blockexplorer");
var beacon_dapp_1 = require("@airgap/beacon-dapp");
var DappPostMessageTransport_1 = require("../transports/DappPostMessageTransport");
var DappP2PTransport_1 = require("../transports/DappP2PTransport");
var DappWalletConnectTransport_1 = require("../transports/DappWalletConnectTransport");
var beacon_transport_postmessage_1 = require("@airgap/beacon-transport-postmessage");
var beacon_ui_1 = require("@airgap/beacon-ui");
var beacon_utils_2 = require("@airgap/beacon-utils");
var logger = new beacon_core_1.Logger('DAppClient');
/**
 * @publicapi
 *
 * The DAppClient has to be used in decentralized applications. It handles all the logic related to connecting to beacon-compatible
 * wallets and sending requests.
 *
 * @category DApp
 */
var DAppClient = /** @class */ (function (_super) {
    __extends(DAppClient, _super);
    function DAppClient(config) {
        var _this = this;
        var _a, _b, _c, _d, _e, _f, _g, _h;
        _this = _super.call(this, __assign({ storage: config && config.storage ? config.storage : new beacon_core_1.LocalStorage() }, config)) || this;
        _this.events = new beacon_dapp_1.BeaconEventHandler();
        /**
         * A map of requests that are currently "open", meaning we have sent them to a wallet and are still awaiting a response.
         */
        _this.openRequests = new Map();
        /**
         * The currently active account. For all requests that are associated to a specific request (operation request, signing request),
         * the active account is used to determine the network and destination wallet
         */
        _this._activeAccount = new beacon_utils_1.ExposedPromise();
        /**
         * The currently active peer. This is used to address a peer in case the active account is not set. (Eg. for permission requests)
         */
        _this._activePeer = new beacon_utils_1.ExposedPromise();
        _this.blockchains = new Map();
        _this.description = config.description;
        _this.wcProjectId = ((_a = config.walletConnectOptions) === null || _a === void 0 ? void 0 : _a.projectId) || '24469fd0a06df227b6e5f7dc7de0ff4f';
        _this.wcRelayUrl = (_b = config.walletConnectOptions) === null || _b === void 0 ? void 0 : _b.relayUrl;
        _this.featuredWallets = config.featuredWallets;
        _this.events = new beacon_dapp_1.BeaconEventHandler(config.eventHandlers, (_c = config.disableDefaultEvents) !== null && _c !== void 0 ? _c : false);
        _this.blockExplorer = (_d = config.blockExplorer) !== null && _d !== void 0 ? _d : new tzkt_blockexplorer_1.TzktBlockExplorer();
        _this.network = (_e = config.network) !== null && _e !== void 0 ? _e : { type: (_f = config.preferredNetwork) !== null && _f !== void 0 ? _f : beacon_types_1.NetworkType.MAINNET };
        (0, beacon_ui_1.setColorMode)((_g = config.colorMode) !== null && _g !== void 0 ? _g : beacon_types_1.ColorMode.LIGHT);
        _this.disclaimerText = config.disclaimerText;
        _this.errorMessages = (_h = config.errorMessages) !== null && _h !== void 0 ? _h : {};
        _this.appMetadataManager = new beacon_core_1.AppMetadataManager(_this.storage);
        _this.activeAccountLoaded = _this.storage
            .get(beacon_types_1.StorageKey.ACTIVE_ACCOUNT)
            .then(function (activeAccountIdentifier) { return __awaiter(_this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!activeAccountIdentifier) return [3 /*break*/, 3];
                        _a = this.setActiveAccount;
                        return [4 /*yield*/, this.accountManager.getAccount(activeAccountIdentifier)];
                    case 1: return [4 /*yield*/, _a.apply(this, [_b.sent()])];
                    case 2:
                        _b.sent();
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, this.setActiveAccount(undefined)];
                    case 4:
                        _b.sent();
                        _b.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        }); })
            .catch(function (storageError) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.setActiveAccount(undefined)];
                    case 1:
                        _a.sent();
                        console.error(storageError);
                        return [2 /*return*/];
                }
            });
        }); });
        _this.handleResponse = function (message, connectionInfo) { return __awaiter(_this, void 0, void 0, function () {
            var openRequest, typedMessage, _a, _b, _c, appMetadata, relevantTransport, _d, _e, peers, peer, typedMessage, _f, _g, _h, relevantTransport, _j, _k, peers, peer;
            var _l, _m;
            var _o, _p, _q;
            return __generator(this, function (_r) {
                switch (_r.label) {
                    case 0:
                        openRequest = this.openRequests.get(message.id);
                        console.log('### openRequest ###', openRequest);
                        logger.log('handleResponse', 'Received message', message, connectionInfo);
                        console.log('### message ###', JSON.stringify(message));
                        console.log('### connectionInfo ###', connectionInfo);
                        if (!(message.version === '3')) return [3 /*break*/, 19];
                        typedMessage = message;
                        if (!(openRequest && typedMessage.message.type === beacon_types_1.BeaconMessageType.Acknowledge)) return [3 /*break*/, 2];
                        this.analytics.track('event', 'DAppClient', 'Acknowledge received from Wallet');
                        logger.log("acknowledge message received for ".concat(message.id));
                        console.timeLog(message.id, 'acknowledge');
                        _b = (_a = this.events)
                            .emit;
                        _c = [events_1.BeaconEvent.ACKNOWLEDGE_RECEIVED];
                        _l = {
                            message: typedMessage.message,
                            extraInfo: {}
                        };
                        return [4 /*yield*/, this.getWalletInfo()];
                    case 1:
                        _b.apply(_a, _c.concat([(_l.walletInfo = _r.sent(),
                                _l)]))
                            .catch(console.error);
                        return [3 /*break*/, 18];
                    case 2:
                        if (!openRequest) return [3 /*break*/, 5];
                        appMetadata = typedMessage.message /* Why is this unkown cast needed? */.blockchainData.appMetadata;
                        if (!(typedMessage.message.type === beacon_types_1.BeaconMessageType.PermissionResponse && appMetadata)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.appMetadataManager.addAppMetadata(appMetadata)];
                    case 3:
                        _r.sent();
                        _r.label = 4;
                    case 4:
                        console.timeLog(typedMessage.id, 'response');
                        console.timeEnd(typedMessage.id);
                        if (typedMessage.message.type === beacon_types_1.BeaconMessageType.Error) {
                            openRequest.reject(typedMessage.message);
                        }
                        else {
                            openRequest.resolve({ message: message, connectionInfo: connectionInfo });
                        }
                        this.openRequests.delete(typedMessage.id);
                        return [3 /*break*/, 18];
                    case 5:
                        if (!(typedMessage.message.type === beacon_types_1.BeaconMessageType.Disconnect)) return [3 /*break*/, 17];
                        this.analytics.track('event', 'DAppClient', 'Disconnect received from Wallet');
                        if (!(connectionInfo.origin === beacon_types_1.Origin.P2P)) return [3 /*break*/, 6];
                        _d = this.p2pTransport;
                        return [3 /*break*/, 10];
                    case 6:
                        if (!((_o = this.postMessageTransport) !== null && _o !== void 0)) return [3 /*break*/, 7];
                        _e = _o;
                        return [3 /*break*/, 9];
                    case 7: return [4 /*yield*/, this.transport];
                    case 8:
                        _e = (_r.sent());
                        _r.label = 9;
                    case 9:
                        _d = _e;
                        _r.label = 10;
                    case 10:
                        relevantTransport = _d;
                        if (!relevantTransport) return [3 /*break*/, 16];
                        return [4 /*yield*/, relevantTransport.getPeers()];
                    case 11:
                        peers = _r.sent();
                        peer = peers.find(function (peerEl) { return peerEl.senderId === message.senderId; });
                        if (!peer) return [3 /*break*/, 15];
                        return [4 /*yield*/, relevantTransport.removePeer(peer)];
                    case 12:
                        _r.sent();
                        return [4 /*yield*/, this.removeAccountsForPeers([peer])];
                    case 13:
                        _r.sent();
                        return [4 /*yield*/, this.events.emit(events_1.BeaconEvent.CHANNEL_CLOSED)];
                    case 14:
                        _r.sent();
                        return [3 /*break*/, 16];
                    case 15:
                        logger.error('handleDisconnect', 'cannot find peer for sender ID', message.senderId);
                        _r.label = 16;
                    case 16: return [3 /*break*/, 18];
                    case 17:
                        logger.error('handleResponse', 'no request found for id ', message.id, message);
                        _r.label = 18;
                    case 18: return [3 /*break*/, 37];
                    case 19:
                        typedMessage = message;
                        if (!(openRequest && typedMessage.type === beacon_types_1.BeaconMessageType.Acknowledge)) return [3 /*break*/, 21];
                        logger.log("acknowledge message received for ".concat(message.id));
                        this.analytics.track('event', 'DAppClient', 'Acknowledge received from Wallet');
                        console.timeLog(message.id, 'acknowledge');
                        _g = (_f = this.events)
                            .emit;
                        _h = [events_1.BeaconEvent.ACKNOWLEDGE_RECEIVED];
                        _m = {
                            message: typedMessage,
                            extraInfo: {}
                        };
                        return [4 /*yield*/, this.getWalletInfo()];
                    case 20:
                        _g.apply(_f, _h.concat([(_m.walletInfo = _r.sent(),
                                _m)]))
                            .catch(console.error);
                        return [3 /*break*/, 37];
                    case 21:
                        if (!openRequest) return [3 /*break*/, 24];
                        if (!(typedMessage.type === beacon_types_1.BeaconMessageType.PermissionResponse &&
                            typedMessage.appMetadata)) return [3 /*break*/, 23];
                        return [4 /*yield*/, this.appMetadataManager.addAppMetadata(typedMessage.appMetadata)];
                    case 22:
                        _r.sent();
                        _r.label = 23;
                    case 23:
                        console.timeLog(typedMessage.id, 'response');
                        console.timeEnd(typedMessage.id);
                        if (typedMessage.type === beacon_types_1.BeaconMessageType.Error || message.errorType) {
                            // TODO: Remove "any" once we remove support for v1 wallets
                            openRequest.reject(typedMessage);
                        }
                        else {
                            openRequest.resolve({ message: message, connectionInfo: connectionInfo });
                        }
                        this.openRequests.delete(typedMessage.id);
                        return [3 /*break*/, 37];
                    case 24:
                        if (!(typedMessage.type === beacon_types_1.BeaconMessageType.Disconnect ||
                            ((_p = message === null || message === void 0 ? void 0 : message.typedMessage) === null || _p === void 0 ? void 0 : _p.type) === beacon_types_1.BeaconMessageType.Disconnect) // TODO: TYPE
                        ) return [3 /*break*/, 36]; // TODO: TYPE
                        this.analytics.track('event', 'DAppClient', 'Disconnect received from Wallet');
                        if (!(connectionInfo.origin === beacon_types_1.Origin.P2P)) return [3 /*break*/, 25];
                        _j = this.p2pTransport;
                        return [3 /*break*/, 29];
                    case 25:
                        if (!((_q = this.postMessageTransport) !== null && _q !== void 0)) return [3 /*break*/, 26];
                        _k = _q;
                        return [3 /*break*/, 28];
                    case 26: return [4 /*yield*/, this.transport];
                    case 27:
                        _k = (_r.sent());
                        _r.label = 28;
                    case 28:
                        _j = _k;
                        _r.label = 29;
                    case 29:
                        relevantTransport = _j;
                        if (!relevantTransport) return [3 /*break*/, 35];
                        return [4 /*yield*/, relevantTransport.getPeers()];
                    case 30:
                        peers = _r.sent();
                        peer = peers.find(function (peerEl) { return peerEl.senderId === message.senderId; });
                        if (!peer) return [3 /*break*/, 34];
                        return [4 /*yield*/, relevantTransport.removePeer(peer)];
                    case 31:
                        _r.sent();
                        return [4 /*yield*/, this.removeAccountsForPeers([peer])];
                    case 32:
                        _r.sent();
                        return [4 /*yield*/, this.events.emit(events_1.BeaconEvent.CHANNEL_CLOSED)];
                    case 33:
                        _r.sent();
                        return [3 /*break*/, 35];
                    case 34:
                        logger.error('handleDisconnect', 'cannot find peer for sender ID', message.senderId);
                        _r.label = 35;
                    case 35: return [3 /*break*/, 37];
                    case 36:
                        logger.error('handleResponse', 'no request found for id ', message.id, message);
                        _r.label = 37;
                    case 37: return [2 /*return*/];
                }
            });
        }); };
        return _this;
    }
    DAppClient.prototype.initInternalTransports = function () {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var keyPair, wcOptions;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, this.keyPair];
                    case 1:
                        keyPair = _c.sent();
                        if (this.postMessageTransport || this.p2pTransport || this.walletConnectTransport) {
                            return [2 /*return*/];
                        }
                        this.postMessageTransport = new DappPostMessageTransport_1.DappPostMessageTransport(this.name, keyPair, this.storage);
                        return [4 /*yield*/, this.addListener(this.postMessageTransport)];
                    case 2:
                        _c.sent();
                        this.p2pTransport = new DappP2PTransport_1.DappP2PTransport(this.name, keyPair, this.storage, this.matrixNodes, this.iconUrl, this.appUrl);
                        return [4 /*yield*/, this.addListener(this.p2pTransport)];
                    case 3:
                        _c.sent();
                        wcOptions = {
                            projectId: this.wcProjectId,
                            relayUrl: this.wcRelayUrl,
                            metadata: {
                                name: this.name,
                                description: (_a = this.description) !== null && _a !== void 0 ? _a : '',
                                url: (_b = this.appUrl) !== null && _b !== void 0 ? _b : '',
                                icons: this.iconUrl ? [this.iconUrl] : []
                            }
                        };
                        this.walletConnectTransport = new DappWalletConnectTransport_1.DappWalletConnectTransport(this.name, keyPair, this.storage, wcOptions);
                        return [4 /*yield*/, this.addListener(this.walletConnectTransport)];
                    case 4:
                        _c.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    DAppClient.prototype.init = function (transport) {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (this._initPromise) {
                            return [2 /*return*/, this._initPromise];
                        }
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.activeAccountLoaded];
                    case 2:
                        _b.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        _a = _b.sent();
                        return [3 /*break*/, 4];
                    case 4:
                        this._initPromise = new Promise(function (resolve) { return __awaiter(_this, void 0, void 0, function () {
                            var _a, _b, _c, _d, _e, activeAccount, stopListening_1, origin_1, _f, _g, _h, p2pTransport_1, postMessageTransport_1, walletConnectTransport_1;
                            var _this = this;
                            return __generator(this, function (_j) {
                                switch (_j.label) {
                                    case 0:
                                        if (!transport) return [3 /*break*/, 3];
                                        return [4 /*yield*/, this.addListener(transport)];
                                    case 1:
                                        _j.sent();
                                        _a = resolve;
                                        return [4 /*yield*/, _super.prototype.init.call(this, transport)];
                                    case 2:
                                        _a.apply(void 0, [_j.sent()]);
                                        return [3 /*break*/, 18];
                                    case 3:
                                        if (!this._transport.isSettled()) return [3 /*break*/, 8];
                                        return [4 /*yield*/, this.transport];
                                    case 4: return [4 /*yield*/, (_j.sent()).connect()];
                                    case 5:
                                        _j.sent();
                                        _b = resolve;
                                        _d = (_c = _super.prototype.init).call;
                                        _e = [this];
                                        return [4 /*yield*/, this.transport];
                                    case 6: return [4 /*yield*/, _d.apply(_c, _e.concat([_j.sent()]))];
                                    case 7:
                                        _b.apply(void 0, [_j.sent()]);
                                        return [3 /*break*/, 18];
                                    case 8: return [4 /*yield*/, this.getActiveAccount()];
                                    case 9:
                                        activeAccount = _j.sent();
                                        stopListening_1 = function () {
                                            if (_this.postMessageTransport) {
                                                _this.postMessageTransport.stopListeningForNewPeers().catch(console.error);
                                            }
                                            if (_this.p2pTransport) {
                                                _this.p2pTransport.stopListeningForNewPeers().catch(console.error);
                                            }
                                            if (_this.walletConnectTransport) {
                                                _this.walletConnectTransport.stopListeningForNewPeers().catch(console.error);
                                            }
                                        };
                                        return [4 /*yield*/, this.initInternalTransports()];
                                    case 10:
                                        _j.sent();
                                        if (!this.postMessageTransport || !this.p2pTransport || !this.walletConnectTransport) {
                                            return [2 /*return*/];
                                        }
                                        this.postMessageTransport.connect().then().catch(console.error);
                                        if (!(activeAccount && activeAccount.origin)) return [3 /*break*/, 17];
                                        origin_1 = activeAccount.origin.type;
                                        if (!(origin_1 === beacon_types_1.Origin.EXTENSION)) return [3 /*break*/, 12];
                                        _f = resolve;
                                        return [4 /*yield*/, _super.prototype.init.call(this, this.postMessageTransport)];
                                    case 11:
                                        _f.apply(void 0, [_j.sent()]);
                                        return [3 /*break*/, 16];
                                    case 12:
                                        if (!(origin_1 === beacon_types_1.Origin.P2P)) return [3 /*break*/, 14];
                                        _g = resolve;
                                        return [4 /*yield*/, _super.prototype.init.call(this, this.p2pTransport)];
                                    case 13:
                                        _g.apply(void 0, [_j.sent()]);
                                        return [3 /*break*/, 16];
                                    case 14:
                                        if (!(origin_1 === beacon_types_1.Origin.WALLETCONNECT)) return [3 /*break*/, 16];
                                        _h = resolve;
                                        return [4 /*yield*/, _super.prototype.init.call(this, this.walletConnectTransport)];
                                    case 15:
                                        _h.apply(void 0, [_j.sent()]);
                                        _j.label = 16;
                                    case 16: return [3 /*break*/, 18];
                                    case 17:
                                        p2pTransport_1 = this.p2pTransport;
                                        postMessageTransport_1 = this.postMessageTransport;
                                        walletConnectTransport_1 = this.walletConnectTransport;
                                        postMessageTransport_1
                                            .listenForNewPeer(function (peer) {
                                            logger.log('init', 'postmessage transport peer connected', peer);
                                            _this.analytics.track('event', 'DAppClient', 'Extension connected', {
                                                peerName: peer.name
                                            });
                                            _this.events
                                                .emit(events_1.BeaconEvent.PAIR_SUCCESS, peer)
                                                .catch(function (emitError) { return console.warn(emitError); });
                                            _this.setActivePeer(peer).catch(console.error);
                                            _this.setTransport(_this.postMessageTransport).catch(console.error);
                                            stopListening_1();
                                            resolve(beacon_types_1.TransportType.POST_MESSAGE);
                                        })
                                            .catch(console.error);
                                        p2pTransport_1
                                            .listenForNewPeer(function (peer) {
                                            logger.log('init', 'p2p transport peer connected', peer);
                                            _this.analytics.track('event', 'DAppClient', 'Beacon Wallet connected', {
                                                peerName: peer.name
                                            });
                                            _this.events
                                                .emit(events_1.BeaconEvent.PAIR_SUCCESS, peer)
                                                .catch(function (emitError) { return console.warn(emitError); });
                                            _this.setActivePeer(peer).catch(console.error);
                                            _this.setTransport(_this.p2pTransport).catch(console.error);
                                            stopListening_1();
                                            resolve(beacon_types_1.TransportType.P2P);
                                        })
                                            .catch(console.error);
                                        walletConnectTransport_1
                                            .listenForNewPeer(function (peer) {
                                            logger.log('init', 'walletconnect transport peer connected', peer);
                                            _this.analytics.track('event', 'DAppClient', 'WalletConnect Wallet connected', {
                                                peerName: peer.name
                                            });
                                            _this.events
                                                .emit(events_1.BeaconEvent.PAIR_SUCCESS, peer)
                                                .catch(function (emitError) { return console.warn(emitError); });
                                            _this.setActivePeer(peer).catch(console.error);
                                            _this.setTransport(_this.walletConnectTransport).catch(console.error);
                                            stopListening_1();
                                            resolve(beacon_types_1.TransportType.WALLETCONNECT);
                                        })
                                            .catch(console.error);
                                        beacon_transport_postmessage_1.PostMessageTransport.getAvailableExtensions()
                                            .then(function (extensions) { return __awaiter(_this, void 0, void 0, function () {
                                            return __generator(this, function (_a) {
                                                this.analytics.track('event', 'DAppClient', 'Extensions detected', { extensions: extensions });
                                                return [2 /*return*/];
                                            });
                                        }); })
                                            .catch(function (error) {
                                            _this._initPromise = undefined;
                                            console.error(error);
                                        });
                                        this.events
                                            .emit(events_1.BeaconEvent.PAIR_INIT, {
                                            p2pPeerInfo: function () {
                                                p2pTransport_1.connect().then().catch(console.error);
                                                return p2pTransport_1.getPairingRequestInfo();
                                            },
                                            postmessagePeerInfo: function () { return postMessageTransport_1.getPairingRequestInfo(); },
                                            walletConnectPeerInfo: function () { return walletConnectTransport_1.getPairingRequestInfo(); },
                                            networkType: this.network.type,
                                            abortedHandler: function () {
                                                console.log('ABORTED');
                                                _this._initPromise = undefined;
                                            },
                                            disclaimerText: this.disclaimerText,
                                            analytics: this.analytics,
                                            featuredWallets: this.featuredWallets
                                        })
                                            .catch(function (emitError) { return console.warn(emitError); });
                                        _j.label = 18;
                                    case 18: return [2 /*return*/];
                                }
                            });
                        }); });
                        return [2 /*return*/, this._initPromise];
                }
            });
        });
    };
    /**
     * Returns the active account
     */
    DAppClient.prototype.getActiveAccount = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this._activeAccount.promise];
            });
        });
    };
    /**
     * Sets the active account
     *
     * @param account The account that will be set as the active account
     */
    DAppClient.prototype.setActiveAccount = function (account) {
        return __awaiter(this, void 0, void 0, function () {
            var origin_2, peer;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this._activeAccount.isSettled()) {
                            // If the promise has already been resolved we need to create a new one.
                            this._activeAccount = beacon_utils_1.ExposedPromise.resolve(account);
                        }
                        else {
                            this._activeAccount.resolve(account);
                        }
                        if (!account) return [3 /*break*/, 10];
                        origin_2 = account.origin.type;
                        return [4 /*yield*/, this.initInternalTransports()
                            // Select the transport that matches the active account
                        ];
                    case 1:
                        _a.sent();
                        if (!(origin_2 === beacon_types_1.Origin.EXTENSION)) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.setTransport(this.postMessageTransport)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 7];
                    case 3:
                        if (!(origin_2 === beacon_types_1.Origin.P2P)) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.setTransport(this.p2pTransport)];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 7];
                    case 5:
                        if (!(origin_2 === beacon_types_1.Origin.WALLETCONNECT)) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.setTransport(this.walletConnectTransport)];
                    case 6:
                        _a.sent();
                        _a.label = 7;
                    case 7: return [4 /*yield*/, this.getPeer(account)];
                    case 8:
                        peer = _a.sent();
                        return [4 /*yield*/, this.setActivePeer(peer)];
                    case 9:
                        _a.sent();
                        return [3 /*break*/, 13];
                    case 10: return [4 /*yield*/, this.setActivePeer(undefined)];
                    case 11:
                        _a.sent();
                        return [4 /*yield*/, this.setTransport(undefined)];
                    case 12:
                        _a.sent();
                        _a.label = 13;
                    case 13: return [4 /*yield*/, this.storage.set(beacon_types_1.StorageKey.ACTIVE_ACCOUNT, account ? account.accountIdentifier : undefined)];
                    case 14:
                        _a.sent();
                        return [4 /*yield*/, this.events.emit(events_1.BeaconEvent.ACTIVE_ACCOUNT_SET, account)];
                    case 15:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Clear the active account
     */
    DAppClient.prototype.clearActiveAccount = function () {
        return this.setActiveAccount();
    };
    DAppClient.prototype.setColorMode = function (colorMode) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (0, beacon_ui_1.setColorMode)(colorMode)];
            });
        });
    };
    DAppClient.prototype.getColorMode = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (0, beacon_ui_1.getColorMode)()];
            });
        });
    };
    /**
     * @deprecated
     *
     * Use getOwnAppMetadata instead
     */
    DAppClient.prototype.getAppMetadata = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.getOwnAppMetadata()];
            });
        });
    };
    DAppClient.prototype.showPrepare = function () {
        return __awaiter(this, void 0, void 0, function () {
            var walletInfo;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (function () { return __awaiter(_this, void 0, void 0, function () {
                            var _a;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        _b.trys.push([0, 2, , 3]);
                                        return [4 /*yield*/, this.getWalletInfo()];
                                    case 1: return [2 /*return*/, _b.sent()];
                                    case 2:
                                        _a = _b.sent();
                                        return [2 /*return*/, undefined];
                                    case 3: return [2 /*return*/];
                                }
                            });
                        }); })()];
                    case 1:
                        walletInfo = _a.sent();
                        return [4 /*yield*/, this.events.emit(events_1.BeaconEvent.SHOW_PREPARE, { walletInfo: walletInfo })];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    DAppClient.prototype.hideUI = function (elements) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.events.emit(events_1.BeaconEvent.HIDE_UI, elements)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Will remove the account from the local storage and set a new active account if necessary.
     *
     * @param accountIdentifier ID of the account
     */
    DAppClient.prototype.removeAccount = function (accountIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            var removeAccountResult, activeAccount;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        removeAccountResult = _super.prototype.removeAccount.call(this, accountIdentifier);
                        return [4 /*yield*/, this.getActiveAccount()];
                    case 1:
                        activeAccount = _a.sent();
                        if (!(activeAccount && activeAccount.accountIdentifier === accountIdentifier)) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.setActiveAccount(undefined)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2 /*return*/, removeAccountResult];
                }
            });
        });
    };
    /**
     * Remove all accounts and set active account to undefined
     */
    DAppClient.prototype.removeAllAccounts = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, _super.prototype.removeAllAccounts.call(this)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.setActiveAccount(undefined)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes a peer and all the accounts that have been connected through that peer
     *
     * @param peer Peer to be removed
     */
    DAppClient.prototype.removePeer = function (peer, sendDisconnectToPeer) {
        if (sendDisconnectToPeer === void 0) { sendDisconnectToPeer = false; }
        return __awaiter(this, void 0, void 0, function () {
            var transport, removePeerResult;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.transport];
                    case 1:
                        transport = _a.sent();
                        removePeerResult = transport.removePeer(peer);
                        return [4 /*yield*/, this.removeAccountsForPeers([peer])];
                    case 2:
                        _a.sent();
                        if (!sendDisconnectToPeer) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.sendDisconnectToPeer(peer, transport)];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4: return [2 /*return*/, removePeerResult];
                }
            });
        });
    };
    /**
     * Remove all peers and all accounts that have been connected through those peers
     */
    DAppClient.prototype.removeAllPeers = function (sendDisconnectToPeers) {
        if (sendDisconnectToPeers === void 0) { sendDisconnectToPeers = false; }
        return __awaiter(this, void 0, void 0, function () {
            var transport, peers, removePeerResult, disconnectPromises;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.transport];
                    case 1:
                        transport = _a.sent();
                        return [4 /*yield*/, transport.getPeers()];
                    case 2:
                        peers = _a.sent();
                        removePeerResult = transport.removeAllPeers();
                        return [4 /*yield*/, this.removeAccountsForPeers(peers)];
                    case 3:
                        _a.sent();
                        if (!sendDisconnectToPeers) return [3 /*break*/, 5];
                        disconnectPromises = peers.map(function (peer) { return _this.sendDisconnectToPeer(peer, transport); });
                        return [4 /*yield*/, Promise.all(disconnectPromises)];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5: return [2 /*return*/, removePeerResult];
                }
            });
        });
    };
    /**
     * Allows the user to subscribe to specific events that are fired in the SDK
     *
     * @param internalEvent The event to subscribe to
     * @param eventCallback The callback that will be called when the event occurs
     */
    DAppClient.prototype.subscribeToEvent = function (internalEvent, eventCallback) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.events.on(internalEvent, eventCallback)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Check if we have permissions to send the specific message type to the active account.
     * If no active account is set, only permission requests are allowed.
     *
     * @param type The type of the message
     */
    DAppClient.prototype.checkPermissions = function (type) {
        return __awaiter(this, void 0, void 0, function () {
            var activeAccount, permissions;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (type === beacon_types_1.BeaconMessageType.PermissionRequest) {
                            return [2 /*return*/, true];
                        }
                        return [4 /*yield*/, this.getActiveAccount()];
                    case 1:
                        activeAccount = _a.sent();
                        if (!!activeAccount) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.sendInternalError('No active account set!')];
                    case 2: throw _a.sent();
                    case 3:
                        permissions = activeAccount.scopes;
                        switch (type) {
                            case beacon_types_1.BeaconMessageType.OperationRequest:
                                return [2 /*return*/, permissions.includes(beacon_types_1.PermissionScope.OPERATION_REQUEST)];
                            case beacon_types_1.BeaconMessageType.SignPayloadRequest:
                                return [2 /*return*/, permissions.includes(beacon_types_1.PermissionScope.SIGN)
                                    // TODO: ENCRYPTION
                                    // case BeaconMessageType.EncryptPayloadRequest:
                                    //   return permissions.includes(PermissionScope.ENCRYPT)
                                ];
                            // TODO: ENCRYPTION
                            // case BeaconMessageType.EncryptPayloadRequest:
                            //   return permissions.includes(PermissionScope.ENCRYPT)
                            case beacon_types_1.BeaconMessageType.BroadcastRequest:
                                return [2 /*return*/, true];
                            default:
                                return [2 /*return*/, false];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    DAppClient.prototype.sendNotification = function (title, message, payload, protocolIdentifier) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function () {
            var activeAccount, url;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4 /*yield*/, this.getActiveAccount()];
                    case 1:
                        activeAccount = _d.sent();
                        if (!activeAccount ||
                            (activeAccount &&
                                !activeAccount.scopes.includes(beacon_types_1.PermissionScope.NOTIFICATION) &&
                                !activeAccount.notification)) {
                            throw new Error('notification permissions not given');
                        }
                        if (!((_a = activeAccount.notification) === null || _a === void 0 ? void 0 : _a.token)) {
                            throw new Error('No AccessToken');
                        }
                        url = (_b = activeAccount.notification) === null || _b === void 0 ? void 0 : _b.apiUrl;
                        if (!url) {
                            throw new Error('No Push URL set');
                        }
                        return [2 /*return*/, this.sendNotificationWithAccessToken({
                                url: url,
                                recipient: activeAccount.address,
                                title: title,
                                body: message,
                                payload: payload,
                                protocolIdentifier: protocolIdentifier,
                                accessToken: (_c = activeAccount.notification) === null || _c === void 0 ? void 0 : _c.token
                            })];
                }
            });
        });
    };
    DAppClient.prototype.addBlockchain = function (chain) {
        this.blockchains.set(chain.identifier, chain);
        chain.getWalletLists().then(function (walletLists) {
            (0, beacon_ui_1.setDesktopList)(walletLists.desktopList);
            (0, beacon_ui_1.setExtensionList)(walletLists.extensionList);
            (0, beacon_ui_1.setWebList)(walletLists.webList);
            (0, beacon_ui_1.setiOSList)(walletLists.iOSList);
        });
    };
    DAppClient.prototype.removeBlockchain = function (chainIdentifier) {
        this.blockchains.delete(chainIdentifier);
    };
    /** Generic messages */
    DAppClient.prototype.permissionRequest = function (input) {
        return __awaiter(this, void 0, void 0, function () {
            var blockchain, request, _a, _b, _c, response, connectionInfo, partialAccountInfos, accountInfo, _d, _e, _f, _g;
            var _h, _j, _k, _l;
            var _this = this;
            return __generator(this, function (_m) {
                switch (_m.label) {
                    case 0:
                        console.log('PERMISSION REQUEST');
                        blockchain = this.blockchains.get(input.blockchainIdentifier);
                        if (!blockchain) {
                            throw new Error("Blockchain \"".concat(input.blockchainIdentifier, "\" not supported by dAppClient"));
                        }
                        _a = [__assign({}, input)];
                        _h = { type: beacon_types_1.BeaconMessageType.PermissionRequest };
                        _b = [__assign({}, input.blockchainData)];
                        _j = {};
                        return [4 /*yield*/, this.getOwnAppMetadata()];
                    case 1:
                        request = __assign.apply(void 0, _a.concat([(_h.blockchainData = __assign.apply(void 0, _b.concat([(_j.appMetadata = _m.sent(), _j)])), _h)]));
                        console.log('REQUESTION PERMIMISSION V3', 'xxx', request);
                        return [4 /*yield*/, this.makeRequestV3(request).catch(function (_requestError) { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    throw new Error('TODO');
                                });
                            }); })];
                    case 2:
                        _c = _m.sent(), response = _c.message, connectionInfo = _c.connectionInfo;
                        console.log('RESPONSE V3', response, connectionInfo);
                        return [4 /*yield*/, blockchain.getAccountInfosFromPermissionResponse(response.message)];
                    case 3:
                        partialAccountInfos = _m.sent();
                        accountInfo = {
                            accountIdentifier: partialAccountInfos[0].accountId,
                            senderId: response.senderId,
                            origin: {
                                type: connectionInfo.origin,
                                id: connectionInfo.id
                            },
                            address: partialAccountInfos[0].address,
                            publicKey: partialAccountInfos[0].publicKey,
                            scopes: response.message.blockchainData.scopes,
                            connectedAt: new Date().getTime(),
                            chainData: response.message.blockchainData
                        };
                        return [4 /*yield*/, this.accountManager.addAccount(accountInfo)];
                    case 4:
                        _m.sent();
                        return [4 /*yield*/, this.setActiveAccount(accountInfo)];
                    case 5:
                        _m.sent();
                        _e = (_d = blockchain).handleResponse;
                        _k = {
                            request: request,
                            account: accountInfo,
                            output: response,
                            blockExplorer: this.blockExplorer,
                            connectionContext: connectionInfo
                        };
                        return [4 /*yield*/, this.getWalletInfo()];
                    case 6: return [4 /*yield*/, _e.apply(_d, [(_k.walletInfo = _m.sent(),
                                _k)])];
                    case 7:
                        _m.sent();
                        _f = this.notifySuccess;
                        _g = [request];
                        _l = {
                            account: accountInfo,
                            output: {
                                address: partialAccountInfos[0].address,
                                network: { type: beacon_types_1.NetworkType.MAINNET },
                                scopes: [beacon_types_1.PermissionScope.OPERATION_REQUEST]
                            },
                            blockExplorer: this.blockExplorer,
                            connectionContext: connectionInfo
                        };
                        return [4 /*yield*/, this.getWalletInfo()];
                    case 8: return [4 /*yield*/, _f.apply(this, _g.concat([(_l.walletInfo = _m.sent(),
                                _l)]))
                        // return output
                    ];
                    case 9:
                        _m.sent();
                        // return output
                        return [2 /*return*/, response.message];
                }
            });
        });
    };
    DAppClient.prototype.request = function (input) {
        return __awaiter(this, void 0, void 0, function () {
            var blockchain, activeAccount, request, _a, response, connectionInfo, _b, _c;
            var _d;
            var _this = this;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        console.log('REQUEST', input);
                        blockchain = this.blockchains.get(input.blockchainIdentifier);
                        if (!blockchain) {
                            throw new Error("Blockchain \"".concat(blockchain, "\" not supported by dAppClient"));
                        }
                        return [4 /*yield*/, blockchain.validateRequest(input)];
                    case 1:
                        _e.sent();
                        return [4 /*yield*/, this.getActiveAccount()];
                    case 2:
                        activeAccount = _e.sent();
                        if (!!activeAccount) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.sendInternalError('No active account!')];
                    case 3: throw _e.sent();
                    case 4:
                        request = __assign(__assign({}, input), { type: beacon_types_1.BeaconMessageType.BlockchainRequest, accountId: activeAccount.accountIdentifier });
                        return [4 /*yield*/, this.makeRequestV3(request).catch(function (requestError) { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    console.error(requestError);
                                    throw new Error('TODO');
                                });
                            }); })];
                    case 5:
                        _a = _e.sent(), response = _a.message, connectionInfo = _a.connectionInfo;
                        _c = (_b = blockchain).handleResponse;
                        _d = {
                            request: request,
                            account: activeAccount,
                            output: response,
                            blockExplorer: this.blockExplorer,
                            connectionContext: connectionInfo
                        };
                        return [4 /*yield*/, this.getWalletInfo()];
                    case 6: return [4 /*yield*/, _c.apply(_b, [(_d.walletInfo = _e.sent(),
                                _d)])];
                    case 7:
                        _e.sent();
                        return [2 /*return*/, response.message];
                }
            });
        });
    };
    /**
     * Send a permission request to the DApp. This should be done as the first step. The wallet will respond
     * with an publicKey and permissions that were given. The account returned will be set as the "activeAccount"
     * and will be used for the following requests.
     *
     * @param input The message details we need to prepare the PermissionRequest message.
     */
    DAppClient.prototype.requestPermissions = function (input) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var request, _b, message, connectionInfo, publicKey, address, walletKey, accountInfo, output, _c, _d;
            var _e, _f, _g;
            var _this = this;
            return __generator(this, function (_h) {
                switch (_h.label) {
                    case 0:
                        // Add error message for deprecation of network
                        // TODO: Remove when we remove deprecated preferredNetwork
                        if ((input === null || input === void 0 ? void 0 : input.network) !== undefined && this.network.type !== ((_a = input === null || input === void 0 ? void 0 : input.network) === null || _a === void 0 ? void 0 : _a.type)) {
                            console.error('[BEACON] The network specified in the DAppClient constructor does not match the network set in the permission request. Please set the network in the constructor. Setting it during the Permission Request is deprecated.');
                        }
                        _e = {};
                        return [4 /*yield*/, this.getOwnAppMetadata()];
                    case 1:
                        request = (_e.appMetadata = _h.sent(),
                            _e.type = beacon_types_1.BeaconMessageType.PermissionRequest,
                            _e.network = this.network,
                            _e.scopes = input && input.scopes
                                ? input.scopes
                                : [beacon_types_1.PermissionScope.OPERATION_REQUEST, beacon_types_1.PermissionScope.SIGN],
                            _e);
                        this.analytics.track('event', 'DAppClient', 'Permission requested');
                        return [4 /*yield*/, this.makeRequest(request).catch(function (requestError) { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, this.handleRequestError(request, requestError)];
                                        case 1: throw _a.sent();
                                    }
                                });
                            }); })
                            // TODO: Migration code. Remove sometime after 1.0.0 release.
                        ];
                    case 2:
                        _b = _h.sent(), message = _b.message, connectionInfo = _b.connectionInfo;
                        return [4 /*yield*/, (0, beacon_utils_1.prefixPublicKey)(message.publicKey || message.pubkey || message.pubKey)];
                    case 3:
                        publicKey = _h.sent();
                        return [4 /*yield*/, (0, beacon_utils_1.getAddressFromPublicKey)(publicKey)];
                    case 4:
                        address = _h.sent();
                        console.log('######## MESSAGE #######');
                        console.log(message);
                        return [4 /*yield*/, this.storage.get(beacon_types_1.StorageKey.LAST_SELECTED_WALLET)];
                    case 5:
                        walletKey = _h.sent();
                        _f = {};
                        return [4 /*yield*/, (0, beacon_core_1.getAccountIdentifier)(address, message.network)];
                    case 6:
                        accountInfo = (_f.accountIdentifier = _h.sent(),
                            _f.senderId = message.senderId,
                            _f.origin = {
                                type: connectionInfo.origin,
                                id: connectionInfo.id
                            },
                            _f.walletKey = walletKey,
                            _f.address = address,
                            _f.publicKey = publicKey,
                            _f.network = message.network,
                            _f.scopes = message.scopes,
                            _f.threshold = message.threshold,
                            _f.notification = message.notification,
                            _f.connectedAt = new Date().getTime(),
                            _f);
                        console.log('######## ACCOUNT INFO #######');
                        console.log(JSON.stringify(accountInfo));
                        return [4 /*yield*/, this.accountManager.addAccount(accountInfo)];
                    case 7:
                        _h.sent();
                        return [4 /*yield*/, this.setActiveAccount(accountInfo)];
                    case 8:
                        _h.sent();
                        output = __assign(__assign({}, message), { walletKey: walletKey, address: address, accountInfo: accountInfo });
                        _c = this.notifySuccess;
                        _d = [request];
                        _g = {
                            account: accountInfo,
                            output: output,
                            blockExplorer: this.blockExplorer,
                            connectionContext: connectionInfo
                        };
                        return [4 /*yield*/, this.getWalletInfo()];
                    case 9: return [4 /*yield*/, _c.apply(this, _d.concat([(_g.walletInfo = _h.sent(),
                                _g)]))];
                    case 10:
                        _h.sent();
                        this.analytics.track('event', 'DAppClient', 'Permission received', { address: address });
                        return [2 /*return*/, output];
                }
            });
        });
    };
    /**
     * This method will send a "SignPayloadRequest" to the wallet. This method is meant to be used to sign
     * arbitrary data (eg. a string). It will return the signature in the format of "edsig..."
     *
     * @param input The message details we need to prepare the SignPayloadRequest message.
     */
    DAppClient.prototype.requestSignPayload = function (input) {
        return __awaiter(this, void 0, void 0, function () {
            var activeAccount, payload, signingType, request, _a, message, connectionInfo, _b, _c;
            var _d;
            var _this = this;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (!!input.payload) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.sendInternalError('Payload must be provided')];
                    case 1: throw _e.sent();
                    case 2: return [4 /*yield*/, this.getActiveAccount()];
                    case 3:
                        activeAccount = _e.sent();
                        if (!!activeAccount) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.sendInternalError('No active account!')];
                    case 4: throw _e.sent();
                    case 5:
                        payload = input.payload;
                        if (typeof payload !== 'string') {
                            throw new Error('Payload must be a string');
                        }
                        signingType = (function () {
                            switch (input.signingType) {
                                case beacon_types_1.SigningType.OPERATION:
                                    if (!payload.startsWith('03')) {
                                        throw new Error('When using signing type "OPERATION", the payload must start with prefix "03"');
                                    }
                                    return beacon_types_1.SigningType.OPERATION;
                                case beacon_types_1.SigningType.MICHELINE:
                                    if (!payload.startsWith('05')) {
                                        throw new Error('When using signing type "MICHELINE", the payload must start with prefix "05"');
                                    }
                                    return beacon_types_1.SigningType.MICHELINE;
                                case beacon_types_1.SigningType.RAW:
                                default:
                                    return beacon_types_1.SigningType.RAW;
                            }
                        })();
                        this.analytics.track('event', 'DAppClient', 'Signature requested');
                        request = {
                            type: beacon_types_1.BeaconMessageType.SignPayloadRequest,
                            signingType: signingType,
                            payload: payload,
                            sourceAddress: input.sourceAddress || activeAccount.address
                        };
                        return [4 /*yield*/, this.makeRequest(request).catch(function (requestError) { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, this.handleRequestError(request, requestError)];
                                        case 1: throw _a.sent();
                                    }
                                });
                            }); })];
                    case 6:
                        _a = _e.sent(), message = _a.message, connectionInfo = _a.connectionInfo;
                        _b = this.notifySuccess;
                        _c = [request];
                        _d = {
                            account: activeAccount,
                            output: message,
                            connectionContext: connectionInfo
                        };
                        return [4 /*yield*/, this.getWalletInfo()];
                    case 7: return [4 /*yield*/, _b.apply(this, _c.concat([(_d.walletInfo = _e.sent(),
                                _d)]))];
                    case 8:
                        _e.sent();
                        this.analytics.track('event', 'DAppClient', 'Signature response');
                        return [2 /*return*/, message];
                }
            });
        });
    };
    /**
     * This method will send an "EncryptPayloadRequest" to the wallet. This method is meant to be used to encrypt or decrypt
     * arbitrary data (eg. a string). It will return the encrypted or decrypted payload
     *
     * @param input The message details we need to prepare the EncryptPayloadRequest message.
     */
    // TODO: ENCRYPTION
    // public async requestEncryptPayload(
    //   input: RequestEncryptPayloadInput
    // ): Promise<EncryptPayloadResponseOutput> {
    //   if (!input.payload) {
    //     throw await this.sendInternalError('Payload must be provided')
    //   }
    //   const activeAccount: AccountInfo | undefined = await this.getActiveAccount()
    //   if (!activeAccount) {
    //     throw await this.sendInternalError('No active account!')
    //   }
    //   const payload = input.payload
    //   if (typeof payload !== 'string') {
    //     throw new Error('Payload must be a string')
    //   }
    //   if (typeof input.encryptionCryptoOperation === 'undefined') {
    //     throw new Error('encryptionCryptoOperation must be defined')
    //   }
    //   if (typeof input.encryptionType === 'undefined') {
    //     throw new Error('encryptionType must be defined')
    //   }
    //   const request: EncryptPayloadRequestInput = {
    //     type: BeaconMessageType.EncryptPayloadRequest,
    //     cryptoOperation: input.encryptionCryptoOperation,
    //     encryptionType: input.encryptionType,
    //     payload,
    //     sourceAddress: input.sourceAddress || activeAccount.address
    //   }
    //   const { message, connectionInfo } = await this.makeRequest<
    //     EncryptPayloadRequest,
    //     EncryptPayloadResponse
    //   >(request).catch(async (requestError: ErrorResponse) => {
    //     throw await this.handleRequestError(request, requestError)
    //   })
    //   await this.notifySuccess(request, {
    //     account: activeAccount,
    //     output: message,
    //     connectionContext: connectionInfo,
    //     walletInfo: await this.getWalletInfo()
    //   })
    //   return message
    // }
    /**
     * This method sends an OperationRequest to the wallet. This method should be used for all kinds of operations,
     * eg. transaction or delegation. Not all properties have to be provided. Data like "counter" and fees will be
     * fetched and calculated by the wallet (but they can still be provided if required).
     *
     * @param input The message details we need to prepare the OperationRequest message.
     */
    DAppClient.prototype.requestOperation = function (input) {
        return __awaiter(this, void 0, void 0, function () {
            var activeAccount, request, _a, message, connectionInfo, _b, _c;
            var _d;
            var _this = this;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (!!input.operationDetails) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.sendInternalError('Operation details must be provided')];
                    case 1: throw _e.sent();
                    case 2: return [4 /*yield*/, this.getActiveAccount()];
                    case 3:
                        activeAccount = _e.sent();
                        if (!!activeAccount) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.sendInternalError('No active account!')];
                    case 4: throw _e.sent();
                    case 5:
                        request = {
                            type: beacon_types_1.BeaconMessageType.OperationRequest,
                            network: activeAccount.network || this.network,
                            operationDetails: input.operationDetails,
                            sourceAddress: activeAccount.address || ''
                        };
                        this.analytics.track('event', 'DAppClient', 'Operation requested');
                        return [4 /*yield*/, this.makeRequest(request).catch(function (requestError) { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, this.handleRequestError(request, requestError)];
                                        case 1: throw _a.sent();
                                    }
                                });
                            }); })];
                    case 6:
                        _a = _e.sent(), message = _a.message, connectionInfo = _a.connectionInfo;
                        _b = this.notifySuccess;
                        _c = [request];
                        _d = {
                            account: activeAccount,
                            output: message,
                            blockExplorer: this.blockExplorer,
                            connectionContext: connectionInfo
                        };
                        return [4 /*yield*/, this.getWalletInfo()];
                    case 7: return [4 /*yield*/, _b.apply(this, _c.concat([(_d.walletInfo = _e.sent(),
                                _d)]))];
                    case 8:
                        _e.sent();
                        this.analytics.track('event', 'DAppClient', 'Operation response');
                        return [2 /*return*/, message];
                }
            });
        });
    };
    /**
     * Sends a "BroadcastRequest" to the wallet. This method can be used to inject an already signed transaction
     * to the network.
     *
     * @param input The message details we need to prepare the BroadcastRequest message.
     */
    DAppClient.prototype.requestBroadcast = function (input) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var request, _b, message, connectionInfo, _c, _d;
            var _e;
            var _this = this;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        if (!!input.signedTransaction) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.sendInternalError('Signed transaction must be provided')];
                    case 1: throw _f.sent();
                    case 2:
                        // Add error message for deprecation of network
                        // TODO: Remove when we remove deprecated preferredNetwork
                        if (input.network !== undefined && this.network.type !== ((_a = input.network) === null || _a === void 0 ? void 0 : _a.type)) {
                            console.error('[BEACON] The network specified in the DAppClient constructor does not match the network set in the broadcast request. Please set the network in the constructor. Setting it during the Broadcast Request is deprecated.');
                        }
                        request = {
                            type: beacon_types_1.BeaconMessageType.BroadcastRequest,
                            network: this.network,
                            signedTransaction: input.signedTransaction
                        };
                        this.analytics.track('event', 'DAppClient', 'Broadcast requested');
                        return [4 /*yield*/, this.makeRequest(request).catch(function (requestError) { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, this.handleRequestError(request, requestError)];
                                        case 1: throw _a.sent();
                                    }
                                });
                            }); })];
                    case 3:
                        _b = _f.sent(), message = _b.message, connectionInfo = _b.connectionInfo;
                        _c = this.notifySuccess;
                        _d = [request];
                        _e = {
                            network: this.network,
                            output: message,
                            blockExplorer: this.blockExplorer,
                            connectionContext: connectionInfo
                        };
                        return [4 /*yield*/, this.getWalletInfo()];
                    case 4: return [4 /*yield*/, _c.apply(this, _d.concat([(_e.walletInfo = _f.sent(),
                                _e)]))];
                    case 5:
                        _f.sent();
                        this.analytics.track('event', 'DAppClient', 'Broadcast response');
                        return [2 /*return*/, message];
                }
            });
        });
    };
    DAppClient.prototype.setActivePeer = function (peer) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this._activePeer.isSettled()) {
                            // If the promise has already been resolved we need to create a new one.
                            this._activePeer = beacon_utils_1.ExposedPromise.resolve(peer);
                        }
                        else {
                            this._activePeer.resolve(peer);
                        }
                        if (!peer) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.initInternalTransports()];
                    case 1:
                        _a.sent();
                        if (!(peer.type === 'postmessage-pairing-response')) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.setTransport(this.postMessageTransport)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 3:
                        if (!(peer.type === 'p2p-pairing-response')) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.setTransport(this.p2pTransport)];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * A "setter" for when the transport needs to be changed.
     */
    DAppClient.prototype.setTransport = function (transport) {
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!transport) {
                            this._initPromise = undefined;
                        }
                        result = _super.prototype.setTransport.call(this, transport);
                        return [4 /*yield*/, this.events.emit(events_1.BeaconEvent.ACTIVE_TRANSPORT_SET, transport)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, result];
                }
            });
        });
    };
    /**
     * This method will emit an internal error message.
     *
     * @param errorMessage The error message to send.
     */
    DAppClient.prototype.sendInternalError = function (errorMessage) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.events.emit(events_1.BeaconEvent.INTERNAL_ERROR, { text: errorMessage })];
                    case 1:
                        _a.sent();
                        throw new Error(errorMessage);
                }
            });
        });
    };
    /**
     * This method will remove all accounts associated with a specific peer.
     *
     * @param peersToRemove An array of peers for which accounts should be removed
     */
    DAppClient.prototype.removeAccountsForPeers = function (peersToRemove) {
        return __awaiter(this, void 0, void 0, function () {
            var accounts, peerIdsToRemove, accountsToRemove, accountIdentifiersToRemove, activeAccount;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.accountManager.getAccounts()];
                    case 1:
                        accounts = _a.sent();
                        peerIdsToRemove = peersToRemove.map(function (peer) { return peer.senderId; });
                        accountsToRemove = accounts.filter(function (account) {
                            return peerIdsToRemove.includes(account.senderId);
                        });
                        accountIdentifiersToRemove = accountsToRemove.map(function (accountInfo) { return accountInfo.accountIdentifier; });
                        return [4 /*yield*/, this.accountManager.removeAccounts(accountIdentifiersToRemove)
                            // Check if one of the accounts that was removed was the active account and if yes, set it to undefined
                        ];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, this.getActiveAccount()];
                    case 3:
                        activeAccount = _a.sent();
                        if (!activeAccount) return [3 /*break*/, 5];
                        if (!accountIdentifiersToRemove.includes(activeAccount.accountIdentifier)) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.setActiveAccount(undefined)];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * This message handles errors that we receive from the wallet.
     *
     * @param request The request we sent
     * @param beaconError The error we received
     */
    DAppClient.prototype.handleRequestError = function (request, beaconError) {
        return __awaiter(this, void 0, void 0, function () {
            var buttons, actionCallback, peer, activeAccount, _a, _b, _c, _d;
            var _e;
            var _this = this;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        logger.error('handleRequestError', 'error response', beaconError);
                        if (!beaconError.errorType) return [3 /*break*/, 9];
                        buttons = [];
                        if (beaconError.errorType === beacon_types_1.BeaconErrorType.NO_PRIVATE_KEY_FOUND_ERROR) {
                            actionCallback = function () { return __awaiter(_this, void 0, void 0, function () {
                                var operationRequest, accountInfo, accountIdentifier;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            operationRequest = request;
                                            if (!(operationRequest.sourceAddress && operationRequest.network)) return [3 /*break*/, 4];
                                            return [4 /*yield*/, (0, beacon_core_1.getAccountIdentifier)(operationRequest.sourceAddress, operationRequest.network)];
                                        case 1:
                                            accountIdentifier = _a.sent();
                                            return [4 /*yield*/, this.getAccount(accountIdentifier)];
                                        case 2:
                                            accountInfo = _a.sent();
                                            if (!accountInfo) return [3 /*break*/, 4];
                                            return [4 /*yield*/, this.removeAccount(accountInfo.accountIdentifier)];
                                        case 3:
                                            _a.sent();
                                            _a.label = 4;
                                        case 4: return [2 /*return*/];
                                    }
                                });
                            }); };
                            buttons.push({ text: 'Remove account', actionCallback: actionCallback });
                        }
                        return [4 /*yield*/, this.getPeer()];
                    case 1:
                        peer = _f.sent();
                        return [4 /*yield*/, this.getActiveAccount()
                            // If we sent a permission request, received an error and there is no active account, we need to reset the DAppClient.
                            // This most likely means that the user rejected the first permission request after pairing a wallet, so we "forget" the paired wallet to allow the user to pair again.
                        ];
                    case 2:
                        activeAccount = _f.sent();
                        _a = request.type === beacon_types_1.BeaconMessageType.PermissionRequest;
                        if (!_a) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.getActiveAccount()];
                    case 3:
                        _a = (_f.sent()) === undefined;
                        _f.label = 4;
                    case 4:
                        if (!_a) return [3 /*break*/, 7];
                        this._initPromise = undefined;
                        this.postMessageTransport = undefined;
                        this.p2pTransport = undefined;
                        return [4 /*yield*/, this.setTransport()];
                    case 5:
                        _f.sent();
                        return [4 /*yield*/, this.setActivePeer()];
                    case 6:
                        _f.sent();
                        _f.label = 7;
                    case 7:
                        _c = (_b = this.events)
                            .emit;
                        _d = [beacon_message_events_1.messageEvents[request.type].error];
                        _e = {
                            errorResponse: beaconError
                        };
                        return [4 /*yield*/, this.getWalletInfo(peer, activeAccount)];
                    case 8:
                        _c.apply(_b, _d.concat([(_e.walletInfo = _f.sent(),
                                _e.errorMessages = this.errorMessages,
                                _e), buttons]))
                            .catch(function (emitError) { return logger.error('handleRequestError', emitError); });
                        throw beacon_core_1.BeaconError.getError(beaconError.errorType, beaconError.errorData);
                    case 9: throw beaconError;
                }
            });
        });
    };
    /**
     * This message will send an event when we receive a successful response to one of the requests we sent.
     *
     * @param request The request we sent
     * @param response The response we received
     */
    DAppClient.prototype.notifySuccess = function (request, response) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.events
                    .emit(beacon_message_events_1.messageEvents[request.type].success, response)
                    .catch(function (emitError) { return console.warn(emitError); });
                return [2 /*return*/];
            });
        });
    };
    DAppClient.prototype.getWalletInfo = function (peer, account) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var selectedAccount, _c, selectedPeer, _d, walletInfo, typedPeer, lowerCaseCompare, selectedApp, type, deeplink;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (!account) return [3 /*break*/, 1];
                        _c = account;
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, this.getActiveAccount()];
                    case 2:
                        _c = _e.sent();
                        _e.label = 3;
                    case 3:
                        selectedAccount = _c;
                        if (!peer) return [3 /*break*/, 4];
                        _d = peer;
                        return [3 /*break*/, 6];
                    case 4: return [4 /*yield*/, this.getPeer(selectedAccount)];
                    case 5:
                        _d = _e.sent();
                        _e.label = 6;
                    case 6:
                        selectedPeer = _d;
                        if (!selectedAccount) return [3 /*break*/, 8];
                        return [4 /*yield*/, this.appMetadataManager.getAppMetadata(selectedAccount.senderId)];
                    case 7:
                        walletInfo = _e.sent();
                        _e.label = 8;
                    case 8:
                        typedPeer = selectedPeer;
                        if (!walletInfo) {
                            walletInfo = {
                                name: typedPeer === null || typedPeer === void 0 ? void 0 : typedPeer.name,
                                icon: typedPeer === null || typedPeer === void 0 ? void 0 : typedPeer.icon
                            };
                        }
                        lowerCaseCompare = function (str1, str2) {
                            if (str1 && str2) {
                                return str1.toLowerCase() === str2.toLowerCase();
                            }
                            return false;
                        };
                        // TODO: Remove once all wallets send the icon?
                        if ((0, beacon_ui_1.getiOSList)().find(function (app) { return lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name); })) {
                            selectedApp = (0, beacon_ui_1.getiOSList)().find(function (app) { return lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name); });
                            type = 'mobile';
                        }
                        else if ((0, beacon_ui_1.getWebList)().find(function (app) { return lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name); })) {
                            selectedApp = (0, beacon_ui_1.getWebList)().find(function (app) { return lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name); });
                            type = 'web';
                        }
                        else if ((0, beacon_ui_1.getDesktopList)().find(function (app) { return lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name); })) {
                            selectedApp = (0, beacon_ui_1.getDesktopList)().find(function (app) { return lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name); });
                            type = 'desktop';
                        }
                        else if ((0, beacon_ui_1.getExtensionList)().find(function (app) { return lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name); })) {
                            selectedApp = (0, beacon_ui_1.getExtensionList)().find(function (app) { return lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name); });
                            type = 'extension';
                        }
                        if (selectedApp) {
                            deeplink = void 0;
                            if (selectedApp.hasOwnProperty('links')) {
                                deeplink = selectedApp.links[(_a = selectedAccount === null || selectedAccount === void 0 ? void 0 : selectedAccount.network.type) !== null && _a !== void 0 ? _a : this.network.type];
                            }
                            else if (selectedApp.hasOwnProperty('deepLink')) {
                                deeplink = selectedApp.deepLink;
                            }
                            return [2 /*return*/, {
                                    name: walletInfo.name,
                                    icon: (_b = walletInfo.icon) !== null && _b !== void 0 ? _b : selectedApp.logo,
                                    deeplink: deeplink,
                                    type: type
                                }];
                        }
                        return [2 /*return*/, walletInfo];
                }
            });
        });
    };
    DAppClient.prototype.getPeer = function (account) {
        var _a, _b, _c, _d, _e, _f;
        return __awaiter(this, void 0, void 0, function () {
            var peer, postMessagePeers, p2pPeers, walletConnectPeers, peers;
            return __generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        if (!account) return [3 /*break*/, 4];
                        logger.log('getPeer', 'We have an account', account);
                        return [4 /*yield*/, ((_a = this.postMessageTransport) === null || _a === void 0 ? void 0 : _a.getPeers())];
                    case 1:
                        postMessagePeers = (_b = (_g.sent())) !== null && _b !== void 0 ? _b : [];
                        return [4 /*yield*/, ((_c = this.p2pTransport) === null || _c === void 0 ? void 0 : _c.getPeers())];
                    case 2:
                        p2pPeers = (_d = (_g.sent())) !== null && _d !== void 0 ? _d : [];
                        return [4 /*yield*/, ((_e = this.walletConnectTransport) === null || _e === void 0 ? void 0 : _e.getPeers())];
                    case 3:
                        walletConnectPeers = (_f = (_g.sent())) !== null && _f !== void 0 ? _f : [];
                        peers = __spreadArray(__spreadArray(__spreadArray([], postMessagePeers, true), p2pPeers, true), walletConnectPeers, true);
                        logger.log('getPeer', 'Found peers', peers, account);
                        peer = peers.find(function (peerEl) { return peerEl.senderId === account.senderId; });
                        if (!peer) {
                            // We could not find an exact match for a sender, so we most likely received it over a relay
                            peer = peers.find(function (peerEl) { return peerEl.extensionId === account.origin.id; });
                        }
                        return [3 /*break*/, 6];
                    case 4: return [4 /*yield*/, this._activePeer.promise];
                    case 5:
                        peer = _g.sent();
                        logger.log('getPeer', 'Active peer', peer);
                        _g.label = 6;
                    case 6: return [2 /*return*/, peer];
                }
            });
        });
    };
    /**
     * This method handles sending of requests to the DApp. It makes sure that the DAppClient is initialized and connected
     * to the transport. After that rate limits and permissions will be checked, an ID is attached and the request is sent
     * to the DApp over the transport.
     *
     * @param requestInput The BeaconMessage to be sent to the wallet
     * @param account The account that the message will be sent to
     */
    DAppClient.prototype.makeRequest = function (requestInput) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var messageId, request, _b, exposed, payload, account, peer, walletInfo, sendError_1;
            var _c;
            var _this = this;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4 /*yield*/, (0, beacon_utils_1.generateGUID)()];
                    case 1:
                        messageId = _d.sent();
                        console.time(messageId);
                        logger.log('makeRequest', 'starting');
                        return [4 /*yield*/, this.init()];
                    case 2:
                        _d.sent();
                        console.timeLog(messageId, 'init done');
                        logger.log('makeRequest', 'after init');
                        return [4 /*yield*/, this.addRequestAndCheckIfRateLimited()];
                    case 3:
                        if (_d.sent()) {
                            this.events
                                .emit(events_1.BeaconEvent.LOCAL_RATE_LIMIT_REACHED)
                                .catch(function (emitError) { return console.warn(emitError); });
                            throw new Error('rate limit reached');
                        }
                        return [4 /*yield*/, this.checkPermissions(requestInput.type)];
                    case 4:
                        if (!(_d.sent())) {
                            this.events.emit(events_1.BeaconEvent.NO_PERMISSIONS).catch(function (emitError) { return console.warn(emitError); });
                            throw new Error('No permissions to send this request to wallet!');
                        }
                        if (!!this.beaconId) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.sendInternalError('BeaconID not defined')];
                    case 5: throw _d.sent();
                    case 6:
                        _c = { id: messageId, version: '2' };
                        _b = beacon_core_1.getSenderId;
                        return [4 /*yield*/, this.beaconId];
                    case 7: return [4 /*yield*/, _b.apply(void 0, [_d.sent()])];
                    case 8:
                        request = __assign.apply(void 0, [(_c.senderId = _d.sent(), _c), requestInput]);
                        exposed = new beacon_utils_1.ExposedPromise();
                        this.addOpenRequest(request.id, exposed);
                        return [4 /*yield*/, new beacon_core_1.Serializer().serialize(request)];
                    case 9:
                        payload = _d.sent();
                        return [4 /*yield*/, this.getActiveAccount()];
                    case 10:
                        account = _d.sent();
                        return [4 /*yield*/, this.getPeer(account)];
                    case 11:
                        peer = _d.sent();
                        return [4 /*yield*/, this.getWalletInfo(peer, account)];
                    case 12:
                        walletInfo = _d.sent();
                        logger.log('makeRequest', 'sending message', request);
                        console.timeLog(messageId, 'sending');
                        _d.label = 13;
                    case 13:
                        _d.trys.push([13, 16, , 17]);
                        return [4 /*yield*/, this.transport];
                    case 14: return [4 /*yield*/, (_d.sent()).send(payload, peer)];
                    case 15:
                        _d.sent();
                        return [3 /*break*/, 17];
                    case 16:
                        sendError_1 = _d.sent();
                        this.events.emit(events_1.BeaconEvent.INTERNAL_ERROR, {
                            text: 'Unable to send message. If this problem persists, please reset the connection and pair your wallet again.',
                            buttons: [
                                {
                                    text: 'Reset Connection',
                                    actionCallback: function () { return __awaiter(_this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0: return [4 /*yield*/, (0, beacon_ui_1.closeToast)()];
                                                case 1:
                                                    _a.sent();
                                                    this.disconnect();
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); }
                                }
                            ]
                        });
                        console.timeLog(messageId, 'send error');
                        throw sendError_1;
                    case 17:
                        console.timeLog(messageId, 'sent');
                        this.events
                            .emit(beacon_message_events_1.messageEvents[requestInput.type].sent, {
                            walletInfo: __assign(__assign({}, walletInfo), { name: (_a = walletInfo.name) !== null && _a !== void 0 ? _a : 'Wallet' }),
                            extraInfo: {
                                resetCallback: function () { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        this.disconnect();
                                        return [2 /*return*/];
                                    });
                                }); }
                            }
                        })
                            .catch(function (emitError) { return console.warn(emitError); });
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        return [2 /*return*/, exposed.promise]; // TODO: fix type
                }
            });
        });
    };
    /**
     * This method handles sending of requests to the DApp. It makes sure that the DAppClient is initialized and connected
     * to the transport. After that rate limits and permissions will be checked, an ID is attached and the request is sent
     * to the DApp over the transport.
     *
     * @param requestInput The BeaconMessage to be sent to the wallet
     * @param account The account that the message will be sent to
     */
    DAppClient.prototype.makeRequestV3 = function (requestInput) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var messageId, request, _b, exposed, payload, account, peer, walletInfo, sendError_2, index;
            var _c;
            var _this = this;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4 /*yield*/, (0, beacon_utils_1.generateGUID)()];
                    case 1:
                        messageId = _d.sent();
                        console.time(messageId);
                        logger.log('makeRequest', 'starting');
                        return [4 /*yield*/, this.init()];
                    case 2:
                        _d.sent();
                        console.timeLog(messageId, 'init done');
                        logger.log('makeRequest', 'after init');
                        return [4 /*yield*/, this.addRequestAndCheckIfRateLimited()];
                    case 3:
                        if (_d.sent()) {
                            this.events
                                .emit(events_1.BeaconEvent.LOCAL_RATE_LIMIT_REACHED)
                                .catch(function (emitError) { return console.warn(emitError); });
                            throw new Error('rate limit reached');
                        }
                        if (!!this.beaconId) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.sendInternalError('BeaconID not defined')];
                    case 4: throw _d.sent();
                    case 5:
                        _c = {
                            id: messageId,
                            version: '3'
                        };
                        _b = beacon_core_1.getSenderId;
                        return [4 /*yield*/, this.beaconId];
                    case 6: return [4 /*yield*/, _b.apply(void 0, [_d.sent()])];
                    case 7:
                        request = (_c.senderId = _d.sent(),
                            _c.message = requestInput,
                            _c);
                        exposed = new beacon_utils_1.ExposedPromise();
                        this.addOpenRequest(request.id, exposed);
                        return [4 /*yield*/, new beacon_core_1.Serializer().serialize(request)];
                    case 8:
                        payload = _d.sent();
                        return [4 /*yield*/, this.getActiveAccount()];
                    case 9:
                        account = _d.sent();
                        return [4 /*yield*/, this.getPeer(account)];
                    case 10:
                        peer = _d.sent();
                        return [4 /*yield*/, this.getWalletInfo(peer, account)];
                    case 11:
                        walletInfo = _d.sent();
                        logger.log('makeRequest', 'sending message', request);
                        console.timeLog(messageId, 'sending');
                        _d.label = 12;
                    case 12:
                        _d.trys.push([12, 15, , 16]);
                        return [4 /*yield*/, this.transport];
                    case 13: return [4 /*yield*/, (_d.sent()).send(payload, peer)];
                    case 14:
                        _d.sent();
                        return [3 /*break*/, 16];
                    case 15:
                        sendError_2 = _d.sent();
                        this.events.emit(events_1.BeaconEvent.INTERNAL_ERROR, {
                            text: 'Unable to send message. If this problem persists, please reset the connection and pair your wallet again.',
                            buttons: [
                                {
                                    text: 'Reset Connection',
                                    actionCallback: function () { return __awaiter(_this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0: return [4 /*yield*/, (0, beacon_ui_1.closeToast)()];
                                                case 1:
                                                    _a.sent();
                                                    this.disconnect();
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); }
                                }
                            ]
                        });
                        console.timeLog(messageId, 'send error');
                        throw sendError_2;
                    case 16:
                        console.timeLog(messageId, 'sent');
                        index = requestInput.type;
                        this.events
                            .emit(beacon_message_events_1.messageEvents[index].sent, {
                            walletInfo: __assign(__assign({}, walletInfo), { name: (_a = walletInfo.name) !== null && _a !== void 0 ? _a : 'Wallet' }),
                            extraInfo: {
                                resetCallback: function () { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        this.disconnect();
                                        return [2 /*return*/];
                                    });
                                }); }
                            }
                        })
                            .catch(function (emitError) { return console.warn(emitError); });
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        return [2 /*return*/, exposed.promise]; // TODO: fix type
                }
            });
        });
    };
    DAppClient.prototype.disconnect = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        this.postMessageTransport = undefined;
                        this.p2pTransport = undefined;
                        this.walletConnectTransport = undefined;
                        _b = (_a = Promise).all;
                        _c = [this.clearActiveAccount()];
                        return [4 /*yield*/, this.transport];
                    case 1: return [4 /*yield*/, _b.apply(_a, [_c.concat([(_d.sent()).disconnect()])])];
                    case 2:
                        _d.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Adds a requests to the "openRequests" set so we know what messages have already been answered/handled.
     *
     * @param id The ID of the message
     * @param promise A promise that resolves once the response for that specific message is received
     */
    DAppClient.prototype.addOpenRequest = function (id, promise) {
        logger.log('addOpenRequest', this.name, "adding request ".concat(id, " and waiting for answer"));
        this.openRequests.set(id, promise);
    };
    DAppClient.prototype.sendNotificationWithAccessToken = function (notification) {
        return __awaiter(this, void 0, void 0, function () {
            var url, recipient, title, body, payload, protocolIdentifier, accessToken, timestamp, keypair, rawPublicKey, prefix, publicKey, constructedString, bytes, payloadBytes, signature, notificationResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = notification.url, recipient = notification.recipient, title = notification.title, body = notification.body, payload = notification.payload, protocolIdentifier = notification.protocolIdentifier, accessToken = notification.accessToken;
                        timestamp = new Date().toISOString();
                        return [4 /*yield*/, this.keyPair];
                    case 1:
                        keypair = _a.sent();
                        rawPublicKey = keypair.publicKey;
                        prefix = Buffer.from(new Uint8Array([13, 15, 37, 217]));
                        publicKey = bs58check.encode(Buffer.concat([prefix, Buffer.from(rawPublicKey)]));
                        constructedString = [
                            'Tezos Signed Message: ',
                            recipient,
                            title,
                            body,
                            timestamp,
                            payload
                        ].join(' ');
                        bytes = (0, beacon_utils_1.toHex)(constructedString);
                        payloadBytes = '05' + '01' + bytes.length.toString(16).padStart(8, '0') + bytes;
                        return [4 /*yield*/, (0, beacon_utils_2.signMessage)(payloadBytes, {
                                secretKey: Buffer.from(keypair.secretKey)
                            })];
                    case 2:
                        signature = _a.sent();
                        return [4 /*yield*/, axios_1.default.post("".concat(url, "/send"), {
                                recipient: recipient,
                                title: title,
                                body: body,
                                timestamp: timestamp,
                                payload: payload,
                                accessToken: accessToken,
                                protocolIdentifier: protocolIdentifier,
                                sender: {
                                    name: this.name,
                                    publicKey: publicKey,
                                    signature: signature
                                }
                            })];
                    case 3:
                        notificationResponse = _a.sent();
                        return [2 /*return*/, notificationResponse.data];
                }
            });
        });
    };
    return DAppClient;
}(beacon_core_1.Client));
exports.DAppClient = DAppClient;
//# sourceMappingURL=DAppClient.js.map