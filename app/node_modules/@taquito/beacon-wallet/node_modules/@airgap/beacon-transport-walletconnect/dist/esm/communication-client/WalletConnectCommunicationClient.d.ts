import { CommunicationClient } from '@airgap/beacon-core';
import Client from '@walletconnect/sign-client';
import { SessionTypes, SignClientTypes } from '@walletconnect/types';
import { ConnectionContext, ExtendedWalletConnectPairingRequest, ExtendedWalletConnectPairingResponse, OperationRequest, SignPayloadRequest } from '@airgap/beacon-types';
export declare enum NetworkType {
    MAINNET = "mainnet",
    GHOSTNET = "ghostnet",
    MONDAYNET = "mondaynet",
    DAILYNET = "dailynet",
    KATHMANDUNET = "kathmandunet",
    LIMANET = "limanet"
}
export interface PermissionScopeParam {
    networks: NetworkType[];
    methods: PermissionScopeMethods[];
    events?: PermissionScopeEvents[];
}
export declare enum PermissionScopeMethods {
    GET_ACCOUNTS = "tezos_getAccounts",
    OPERATION_REQUEST = "tezos_send",
    SIGN = "tezos_sign"
}
export declare enum PermissionScopeEvents {
    CHAIN_CHANGED = "chainChanged",
    ACCOUNTS_CHANGED = "accountsChanged"
}
export declare class WalletConnectCommunicationClient extends CommunicationClient {
    private wcOptions;
    protected readonly activeListeners: Map<string, (message: string, context: ConnectionContext) => void>;
    protected readonly channelOpeningListeners: Map<string, (pairingResponse: ExtendedWalletConnectPairingResponse) => void>;
    private static instance;
    signClient: Client | undefined;
    private session;
    private activeAccount;
    private activeNetwork;
    private currentMessageId;
    constructor(wcOptions: SignClientTypes.Options);
    static getInstance(wcOptions: SignClientTypes.Options): WalletConnectCommunicationClient;
    listenForEncryptedMessage(senderPublicKey: string, messageCallback: (message: string, context: ConnectionContext) => void): Promise<void>;
    listenForChannelOpening(messageCallback: (pairingResponse: ExtendedWalletConnectPairingResponse) => void): Promise<void>;
    unsubscribeFromEncryptedMessages(): Promise<void>;
    unsubscribeFromEncryptedMessage(_senderPublicKey: string): Promise<void>;
    sendMessage(_message: string, _peer?: any): Promise<void>;
    requestPermissions(): Promise<void>;
    /**
     * @description Once the session is establish, send payload to be approved and signed by the wallet.
     * @error MissingRequiredScope is thrown if permission to sign payload was not granted
     */
    signPayload(signPayloadRequest: SignPayloadRequest): Promise<void>;
    /**
     * @description Once the session is established, send Tezos operations to be approved, signed and inject by the wallet.
     * @error MissingRequiredScope is thrown if permission to send operation was not granted
     */
    sendOperations(operationRequest: OperationRequest): Promise<void>;
    init(forceNewConnection?: boolean): Promise<string | undefined>;
    getPairingRequestInfo(): Promise<ExtendedWalletConnectPairingRequest>;
    private validateReceivedNamespace;
    private validateMethods;
    private validateEvents;
    private validateAccounts;
    private validateNetworkAndAccount;
    /**
     * @description Access the active network
     * @error ActiveNetworkUnspecified thorwn when there are multiple Tezos netwroks in the session and none is set as the active one
     */
    getActiveNetwork(): string;
    private setDefaultAccountAndNetwork;
    /**
     * @description Return all connected accounts from the active session
     * @error NotConnected if no active session
     */
    getAccounts(): string[];
    /**
     * @description Return all networks from the namespace of the active session
     * @error NotConnected if no active session
     */
    getNetworks(): string[];
    private getTezosNamespace;
    private getPermittedMethods;
    private getPermittedNetwork;
    private getTezosRequiredNamespace;
    private sendResponse;
    currentSession(): SessionTypes.Struct | undefined;
    private getSession;
    /**
     * @description Access the public key hash of the active account
     * @error ActiveAccountUnspecified thrown when there are multiple Tezos account in the session and none is set as the active one
     */
    getPKH(): Promise<string>;
    private clearState;
}
