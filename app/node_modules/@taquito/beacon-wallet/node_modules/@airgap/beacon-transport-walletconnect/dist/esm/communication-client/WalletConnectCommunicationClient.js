var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { BEACON_VERSION, CommunicationClient, Serializer } from '@airgap/beacon-core';
import { SignClient } from '@walletconnect/sign-client';
import { getSdkError } from '@walletconnect/utils';
import { ActiveAccountUnspecified, ActiveNetworkUnspecified, InvalidNetworkOrAccount, InvalidReceivedSessionNamespace, InvalidSession, MissingRequiredScope, NotConnected } from '../error';
import { BeaconErrorType, BeaconMessageType, Origin, PermissionScope } from '@airgap/beacon-types';
import { generateGUID } from '@airgap/beacon-utils';
const TEZOS_PLACEHOLDER = 'tezos';
export var NetworkType;
(function (NetworkType) {
    NetworkType["MAINNET"] = "mainnet";
    NetworkType["GHOSTNET"] = "ghostnet";
    NetworkType["MONDAYNET"] = "mondaynet";
    NetworkType["DAILYNET"] = "dailynet";
    NetworkType["KATHMANDUNET"] = "kathmandunet";
    NetworkType["LIMANET"] = "limanet";
})(NetworkType || (NetworkType = {}));
export var PermissionScopeMethods;
(function (PermissionScopeMethods) {
    PermissionScopeMethods["GET_ACCOUNTS"] = "tezos_getAccounts";
    PermissionScopeMethods["OPERATION_REQUEST"] = "tezos_send";
    PermissionScopeMethods["SIGN"] = "tezos_sign";
})(PermissionScopeMethods || (PermissionScopeMethods = {}));
export var PermissionScopeEvents;
(function (PermissionScopeEvents) {
    PermissionScopeEvents["CHAIN_CHANGED"] = "chainChanged";
    PermissionScopeEvents["ACCOUNTS_CHANGED"] = "accountsChanged";
})(PermissionScopeEvents || (PermissionScopeEvents = {}));
export class WalletConnectCommunicationClient extends CommunicationClient {
    constructor(wcOptions) {
        super();
        this.wcOptions = wcOptions;
        this.activeListeners = new Map();
        this.channelOpeningListeners = new Map();
    }
    static getInstance(wcOptions) {
        if (!WalletConnectCommunicationClient.instance) {
            WalletConnectCommunicationClient.instance = new WalletConnectCommunicationClient(wcOptions);
        }
        return WalletConnectCommunicationClient.instance;
    }
    listenForEncryptedMessage(senderPublicKey, messageCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.activeListeners.has(senderPublicKey)) {
                return;
            }
            const callbackFunction = (message, context) => __awaiter(this, void 0, void 0, function* () {
                messageCallback(message, context);
            });
            this.activeListeners.set(senderPublicKey, callbackFunction);
        });
    }
    listenForChannelOpening(messageCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            const callbackFunction = (pairingResponse) => __awaiter(this, void 0, void 0, function* () {
                messageCallback(pairingResponse);
            });
            this.channelOpeningListeners.set('channelOpening', callbackFunction);
        });
    }
    unsubscribeFromEncryptedMessages() {
        return __awaiter(this, void 0, void 0, function* () {
            // implementation
        });
    }
    unsubscribeFromEncryptedMessage(_senderPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            // implementation
        });
    }
    sendMessage(_message, _peer) {
        return __awaiter(this, void 0, void 0, function* () {
            const serializer = new Serializer();
            const message = (yield serializer.deserialize(_message));
            this.currentMessageId = message.id;
            if ((message === null || message === void 0 ? void 0 : message.type) === BeaconMessageType.PermissionRequest) {
                this.requestPermissions();
            }
            if ((message === null || message === void 0 ? void 0 : message.type) === BeaconMessageType.OperationRequest) {
                this.sendOperations(message);
            }
            if ((message === null || message === void 0 ? void 0 : message.type) === BeaconMessageType.SignPayloadRequest) {
                this.signPayload(message);
            }
        });
    }
    requestPermissions() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            console.log('#### Requesting permissions');
            const session = this.getSession();
            if (!this.getPermittedMethods().includes(PermissionScopeMethods.GET_ACCOUNTS)) {
                throw new MissingRequiredScope(PermissionScopeMethods.GET_ACCOUNTS);
            }
            const network = this.getActiveNetwork();
            console.log('#### Requesting public keys');
            // Get the public key from the wallet
            const result = yield ((_a = this.signClient) === null || _a === void 0 ? void 0 : _a.request({
                topic: session.topic,
                chainId: `${TEZOS_PLACEHOLDER}:${network}`,
                request: {
                    method: PermissionScopeMethods.GET_ACCOUNTS,
                    params: {}
                }
            }));
            console.log('##### GET ACCOUNTS', result);
            if (!result || result.length < 1) {
                throw new Error('No account shared by wallet');
            }
            if (result.some((account) => !account.pubkey)) {
                throw new Error('Public Key in `tezos_getAccounts` is empty!');
            }
            const permissionResponse = {
                type: BeaconMessageType.PermissionResponse,
                appMetadata: {
                    senderId: session.peer.publicKey,
                    name: session.peer.metadata.name,
                    icon: session.peer.metadata.icons[0]
                },
                publicKey: (_b = result[0]) === null || _b === void 0 ? void 0 : _b.pubkey,
                network: { type: NetworkType.MAINNET },
                scopes: [PermissionScope.SIGN, PermissionScope.OPERATION_REQUEST],
                id: this.currentMessageId
            };
            this.sendResponse(session, permissionResponse);
        });
    }
    /**
     * @description Once the session is establish, send payload to be approved and signed by the wallet.
     * @error MissingRequiredScope is thrown if permission to sign payload was not granted
     */
    signPayload(signPayloadRequest) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const session = this.getSession();
            if (!this.getPermittedMethods().includes(PermissionScopeMethods.SIGN)) {
                throw new MissingRequiredScope(PermissionScopeMethods.SIGN);
            }
            const network = this.getActiveNetwork();
            const account = yield this.getPKH();
            this.validateNetworkAndAccount(network, account);
            // TODO: Type
            (_a = this.signClient) === null || _a === void 0 ? void 0 : _a.request({
                topic: session.topic,
                chainId: `${TEZOS_PLACEHOLDER}:${network}`,
                request: {
                    method: PermissionScopeMethods.SIGN,
                    params: {
                        account: account,
                        payload: signPayloadRequest.payload
                    }
                }
            }).then((response) => {
                const signPayloadResponse = {
                    type: BeaconMessageType.SignPayloadResponse,
                    signingType: signPayloadRequest.signingType,
                    signature: response === null || response === void 0 ? void 0 : response.signature,
                    id: this.currentMessageId
                };
                this.sendResponse(session, signPayloadResponse);
            }).catch(() => __awaiter(this, void 0, void 0, function* () {
                const errorResponse = {
                    type: BeaconMessageType.Error,
                    id: this.currentMessageId,
                    errorType: BeaconErrorType.ABORTED_ERROR
                };
                this.sendResponse(session, errorResponse);
            }));
        });
    }
    /**
     * @description Once the session is established, send Tezos operations to be approved, signed and inject by the wallet.
     * @error MissingRequiredScope is thrown if permission to send operation was not granted
     */
    sendOperations(operationRequest) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const session = this.getSession();
            if (!this.getPermittedMethods().includes(PermissionScopeMethods.OPERATION_REQUEST)) {
                throw new MissingRequiredScope(PermissionScopeMethods.OPERATION_REQUEST);
            }
            const network = this.getActiveNetwork();
            const account = yield this.getPKH();
            this.validateNetworkAndAccount(network, account);
            (_a = this.signClient) === null || _a === void 0 ? void 0 : _a.request({
                topic: session.topic,
                chainId: `${TEZOS_PLACEHOLDER}:${network}`,
                request: {
                    method: PermissionScopeMethods.OPERATION_REQUEST,
                    params: {
                        account,
                        operations: operationRequest.operationDetails
                    }
                }
            }).then((response) => {
                var _a, _b, _c;
                const sendOperationResponse = {
                    type: BeaconMessageType.OperationResponse,
                    transactionHash: (_c = (_b = (_a = response.operationHash) !== null && _a !== void 0 ? _a : response.transactionHash) !== null && _b !== void 0 ? _b : response.hash) !== null && _c !== void 0 ? _c : '',
                    id: this.currentMessageId
                };
                this.sendResponse(session, sendOperationResponse);
            }).catch(() => __awaiter(this, void 0, void 0, function* () {
                const errorResponse = {
                    type: BeaconMessageType.Error,
                    id: this.currentMessageId,
                    errorType: BeaconErrorType.ABORTED_ERROR
                };
                this.sendResponse(session, errorResponse);
            }));
        });
    }
    init(forceNewConnection = false) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const connectParams = {
                permissionScope: {
                    networks: [NetworkType.MAINNET],
                    events: [],
                    methods: [
                        PermissionScopeMethods.GET_ACCOUNTS,
                        PermissionScopeMethods.OPERATION_REQUEST,
                        PermissionScopeMethods.SIGN
                    ]
                },
                pairingTopic: undefined
            };
            this.signClient = yield SignClient.init(this.wcOptions);
            let sessions = this.signClient.session.getAll();
            if (forceNewConnection) {
                for (let session of sessions) {
                    yield this.signClient.disconnect({
                        topic: session.topic,
                        reason: {
                            code: 0,
                            message: 'Force new connection'
                        }
                    });
                }
                this.clearState();
                sessions = this.signClient.session.getAll();
            }
            if (sessions && sessions.length > 0) {
                this.session = sessions[0];
                this.setDefaultAccountAndNetwork();
                return;
            }
            const { uri, approval } = yield this.signClient.connect({
                requiredNamespaces: {
                    [TEZOS_PLACEHOLDER]: {
                        chains: connectParams.permissionScope.networks.map((network) => `${TEZOS_PLACEHOLDER}:${network}`),
                        methods: connectParams.permissionScope.methods,
                        events: (_a = connectParams.permissionScope.events) !== null && _a !== void 0 ? _a : []
                    }
                },
                pairingTopic: connectParams.pairingTopic
            });
            approval().then((session) => __awaiter(this, void 0, void 0, function* () {
                var _b;
                this.session = (_b = this.session) !== null && _b !== void 0 ? _b : session;
                this.validateReceivedNamespace(connectParams.permissionScope, this.session.namespaces);
                this.setDefaultAccountAndNetwork();
                const pairingResponse = {
                    id: this.session.peer.publicKey,
                    type: 'walletconnect-pairing-response',
                    name: session.peer.metadata.name,
                    publicKey: session.peer.publicKey,
                    senderId: this.session.peer.publicKey,
                    extensionId: this.session.peer.metadata.name,
                    version: '3'
                };
                this.channelOpeningListeners.forEach((listener) => {
                    listener(pairingResponse);
                });
            }));
            return uri;
        });
    }
    getPairingRequestInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const uri = yield this.init(true);
            return {
                id: yield generateGUID(),
                type: 'walletconnect-pairing-request',
                name: 'WalletConnect',
                version: BEACON_VERSION,
                uri: uri,
                senderId: yield generateGUID(),
                publicKey: yield generateGUID()
            };
        });
    }
    validateReceivedNamespace(scope, receivedNamespaces) {
        if (receivedNamespaces[TEZOS_PLACEHOLDER]) {
            this.validateMethods(scope.methods, receivedNamespaces[TEZOS_PLACEHOLDER].methods);
            if (scope.events) {
                this.validateEvents(scope.events, receivedNamespaces['tezos'].events);
            }
            this.validateAccounts(scope.networks, receivedNamespaces[TEZOS_PLACEHOLDER].accounts);
        }
        else {
            this.clearState();
            throw new InvalidReceivedSessionNamespace('All namespaces must be approved', getSdkError('USER_REJECTED').code, 'incomplete', 'tezos');
        }
    }
    validateMethods(requiredMethods, receivedMethods) {
        const missingMethods = [];
        requiredMethods.forEach((method) => {
            if (!receivedMethods.includes(method)) {
                missingMethods.push(method);
            }
        });
        if (missingMethods.length > 0) {
            this.clearState();
            throw new InvalidReceivedSessionNamespace('All methods must be approved', getSdkError('USER_REJECTED_METHODS').code, 'incomplete', missingMethods);
        }
    }
    validateEvents(requiredEvents, receivedEvents) {
        const missingEvents = [];
        requiredEvents.forEach((method) => {
            if (!receivedEvents.includes(method)) {
                missingEvents.push(method);
            }
        });
        if (missingEvents.length > 0) {
            this.clearState();
            throw new InvalidReceivedSessionNamespace('All events must be approved', getSdkError('USER_REJECTED_EVENTS').code, 'incomplete', missingEvents);
        }
    }
    validateAccounts(requiredNetwork, receivedAccounts) {
        if (receivedAccounts.length === 0) {
            this.clearState();
            throw new InvalidReceivedSessionNamespace('Accounts must not be empty', getSdkError('USER_REJECTED_CHAINS').code, 'incomplete');
        }
        const receivedChains = [];
        const invalidChains = [];
        const missingChains = [];
        const invalidChainsNamespace = [];
        receivedAccounts.forEach((chain) => {
            const accountId = chain.split(':');
            if (accountId.length !== 3) {
                invalidChains.push(chain);
            }
            if (accountId[0] !== TEZOS_PLACEHOLDER) {
                invalidChainsNamespace.push(chain);
            }
            const network = accountId[1];
            if (!receivedChains.includes(network)) {
                receivedChains.push(network);
            }
        });
        if (invalidChains.length > 0) {
            this.clearState();
            throw new InvalidReceivedSessionNamespace('Accounts must be CAIP-10 compliant', getSdkError('USER_REJECTED_CHAINS').code, 'invalid', invalidChains);
        }
        if (invalidChainsNamespace.length > 0) {
            this.clearState();
            throw new InvalidReceivedSessionNamespace('Accounts must be defined in matching namespace', getSdkError('UNSUPPORTED_ACCOUNTS').code, 'invalid', invalidChainsNamespace);
        }
        requiredNetwork.forEach((network) => {
            if (!receivedChains.includes(network)) {
                missingChains.push(network);
            }
        });
        if (missingChains.length > 0) {
            this.clearState();
            throw new InvalidReceivedSessionNamespace('All chains must have at least one account', getSdkError('USER_REJECTED_CHAINS').code, 'incomplete', missingChains);
        }
    }
    validateNetworkAndAccount(network, account) {
        if (!this.getTezosNamespace().accounts.includes(`${TEZOS_PLACEHOLDER}:${network}:${account}`)) {
            throw new InvalidNetworkOrAccount(network, account);
        }
    }
    /**
     * @description Access the active network
     * @error ActiveNetworkUnspecified thorwn when there are multiple Tezos netwroks in the session and none is set as the active one
     */
    getActiveNetwork() {
        if (!this.activeNetwork) {
            this.getSession();
            throw new ActiveNetworkUnspecified();
        }
        return this.activeNetwork;
    }
    setDefaultAccountAndNetwork() {
        const activeAccount = this.getAccounts();
        if (activeAccount.length === 1) {
            this.activeAccount = activeAccount[0];
        }
        const activeNetwork = this.getNetworks();
        if (activeNetwork.length === 1) {
            this.activeNetwork = activeNetwork[0];
        }
    }
    /**
     * @description Return all connected accounts from the active session
     * @error NotConnected if no active session
     */
    getAccounts() {
        return this.getTezosNamespace().accounts.map((account) => account.split(':')[2]);
    }
    /**
     * @description Return all networks from the namespace of the active session
     * @error NotConnected if no active session
     */
    getNetworks() {
        return this.getPermittedNetwork();
    }
    getTezosNamespace() {
        if (TEZOS_PLACEHOLDER in this.getSession().namespaces) {
            return this.getSession().namespaces[TEZOS_PLACEHOLDER];
        }
        else {
            throw new InvalidSession('Tezos not found in namespaces');
        }
    }
    getPermittedMethods() {
        return this.getTezosRequiredNamespace().methods;
    }
    getPermittedNetwork() {
        return this.getTezosRequiredNamespace().chains.map((chain) => chain.split(':')[1]);
    }
    getTezosRequiredNamespace() {
        // TODO: Remove testing code
        return {
            chains: ['tezos:mainnet'],
            events: [],
            methods: ['tezos_getAccounts', 'tezos_send', 'tezos_sign']
        };
        // if (TEZOS_PLACEHOLDER in this.getSession().requiredNamespaces) {
        //   return this.getSession().requiredNamespaces[TEZOS_PLACEHOLDER] as {
        //     chains: string[]
        //     methods: string[]
        //     events: string[]
        //   }
        // } else {
        //   throw new InvalidSession('Tezos not found in requiredNamespaces')
        // }
    }
    sendResponse(session, partialResponse) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = Object.assign(Object.assign({}, partialResponse), { version: '2', senderId: session.peer.publicKey });
            const serializer = new Serializer();
            const serialized = yield serializer.serialize(response);
            this.activeListeners.forEach((listener) => {
                listener(serialized, {
                    origin: Origin.WALLETCONNECT,
                    id: this.currentMessageId
                });
            });
        });
    }
    currentSession() {
        return this.session;
    }
    getSession() {
        if (!this.session) {
            throw new NotConnected();
        }
        return this.session;
    }
    /**
     * @description Access the public key hash of the active account
     * @error ActiveAccountUnspecified thrown when there are multiple Tezos account in the session and none is set as the active one
     */
    getPKH() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.activeAccount) {
                this.getSession();
                throw new ActiveAccountUnspecified();
            }
            return this.activeAccount;
        });
    }
    clearState() {
        this.session = undefined;
        this.activeAccount = undefined;
        this.activeNetwork = undefined;
    }
}
//# sourceMappingURL=WalletConnectCommunicationClient.js.map