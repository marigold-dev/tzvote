"use strict";
/**
 * @packageDocumentation
 * @module @taquito/beacon-wallet
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BeaconWallet = exports.MissingRequiredScopes = exports.BeaconWalletNotInitialized = exports.VERSION = void 0;
const beacon_dapp_1 = require("@airgap/beacon-dapp");
const errors_1 = require("./errors");
const typedarray_to_buffer_1 = require("typedarray-to-buffer");
const taquito_1 = require("@taquito/taquito");
const utils_1 = require("@taquito/utils");
const core_1 = require("@taquito/core");
var version_1 = require("./version");
Object.defineProperty(exports, "VERSION", { enumerable: true, get: function () { return version_1.VERSION; } });
var errors_2 = require("./errors");
Object.defineProperty(exports, "BeaconWalletNotInitialized", { enumerable: true, get: function () { return errors_2.BeaconWalletNotInitialized; } });
Object.defineProperty(exports, "MissingRequiredScopes", { enumerable: true, get: function () { return errors_2.MissingRequiredScopes; } });
class BeaconWallet {
    constructor(options) {
        this.client = beacon_dapp_1.getDAppClientInstance(options);
    }
    validateRequiredScopesOrFail(permissionScopes, requiredScopes) {
        const mandatoryScope = new Set(requiredScopes);
        for (const scope of permissionScopes) {
            if (mandatoryScope.has(scope)) {
                mandatoryScope.delete(scope);
            }
        }
        if (mandatoryScope.size > 0) {
            throw new errors_1.MissingRequiredScopes(Array.from(mandatoryScope));
        }
    }
    requestPermissions(request) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.requestPermissions(request);
        });
    }
    getPKH() {
        return __awaiter(this, void 0, void 0, function* () {
            const account = yield this.client.getActiveAccount();
            if (!account) {
                throw new errors_1.BeaconWalletNotInitialized();
            }
            return account.address;
        });
    }
    mapTransferParamsToWalletParams(params) {
        return __awaiter(this, void 0, void 0, function* () {
            let walletParams;
            yield this.client.showPrepare();
            try {
                walletParams = yield params();
            }
            catch (err) {
                yield this.client.hideUI();
                throw err;
            }
            return this.removeDefaultParams(walletParams, yield taquito_1.createTransferOperation(this.formatParameters(walletParams)));
        });
    }
    mapIncreasePaidStorageWalletParams(params) {
        return __awaiter(this, void 0, void 0, function* () {
            let walletParams;
            yield this.client.showPrepare();
            try {
                walletParams = yield params();
            }
            catch (err) {
                yield this.client.hideUI();
                throw err;
            }
            return this.removeDefaultParams(walletParams, yield taquito_1.createIncreasePaidStorageOperation(this.formatParameters(walletParams)));
        });
    }
    mapOriginateParamsToWalletParams(params) {
        return __awaiter(this, void 0, void 0, function* () {
            let walletParams;
            yield this.client.showPrepare();
            try {
                walletParams = yield params();
            }
            catch (err) {
                yield this.client.hideUI();
                throw err;
            }
            return this.removeDefaultParams(walletParams, yield taquito_1.createOriginationOperation(this.formatParameters(walletParams)));
        });
    }
    mapDelegateParamsToWalletParams(params) {
        return __awaiter(this, void 0, void 0, function* () {
            let walletParams;
            yield this.client.showPrepare();
            try {
                walletParams = yield params();
            }
            catch (err) {
                yield this.client.hideUI();
                throw err;
            }
            return this.removeDefaultParams(walletParams, yield taquito_1.createSetDelegateOperation(this.formatParameters(walletParams)));
        });
    }
    formatParameters(params) {
        if (params.fee) {
            params.fee = params.fee.toString();
        }
        if (params.storageLimit) {
            params.storageLimit = params.storageLimit.toString();
        }
        if (params.gasLimit) {
            params.gasLimit = params.gasLimit.toString();
        }
        return params;
    }
    removeDefaultParams(params, operatedParams) {
        // If fee, storageLimit or gasLimit is undefined by user
        // in case of beacon wallet, dont override it by
        // defaults.
        if (!params.fee) {
            delete operatedParams.fee;
        }
        if (!params.storageLimit) {
            delete operatedParams.storage_limit;
        }
        if (!params.gasLimit) {
            delete operatedParams.gas_limit;
        }
        return operatedParams;
    }
    sendOperations(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const account = yield this.client.getActiveAccount();
            if (!account) {
                throw new errors_1.BeaconWalletNotInitialized();
            }
            const permissions = account.scopes;
            this.validateRequiredScopesOrFail(permissions, [beacon_dapp_1.PermissionScope.OPERATION_REQUEST]);
            const { transactionHash } = yield this.client.requestOperation({ operationDetails: params });
            return transactionHash;
        });
    }
    /**
     *
     * @description Removes all beacon values from the storage. After using this method, this instance is no longer usable.
     * You will have to instantiate a new BeaconWallet.
     */
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.destroy();
        });
    }
    /**
     *
     * @description This method removes the active account from local storage by setting it to undefined.
     */
    clearActiveAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.setActiveAccount();
        });
    }
    sign(bytes, watermark) {
        return __awaiter(this, void 0, void 0, function* () {
            let bb = utils_1.hex2buf(bytes);
            if (typeof watermark !== 'undefined') {
                bb = utils_1.mergebuf(watermark, bb);
            }
            const watermarkedBytes = utils_1.buf2hex(typedarray_to_buffer_1.default(bb));
            const signingType = this.getSigningType(watermark);
            if (signingType !== beacon_dapp_1.SigningType.OPERATION) {
                throw new core_1.UnsupportedActionError(`Taquito Beacon Wallet currently only supports signing operations, not ${signingType}`);
            }
            const { signature } = yield this.client.requestSignPayload({
                payload: watermarkedBytes,
                signingType,
            });
            return signature;
        });
    }
    getSigningType(watermark) {
        if (!watermark || watermark.length === 0) {
            return beacon_dapp_1.SigningType.RAW;
        }
        if (watermark.length === 1) {
            if (watermark[0] === 5) {
                return beacon_dapp_1.SigningType.MICHELINE;
            }
            if (watermark[0] === 3) {
                return beacon_dapp_1.SigningType.OPERATION;
            }
        }
        throw new Error(`Invalid watermark ${JSON.stringify(watermark)}`);
    }
    getPK() {
        return __awaiter(this, void 0, void 0, function* () {
            const account = yield this.client.getActiveAccount();
            if (!account) {
                throw new errors_1.BeaconWalletNotInitialized();
            }
            return account === null || account === void 0 ? void 0 : account.publicKey;
        });
    }
}
exports.BeaconWallet = BeaconWallet;
//# sourceMappingURL=taquito-beacon-wallet.js.map