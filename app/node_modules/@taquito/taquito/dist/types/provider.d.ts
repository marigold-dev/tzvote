import { OperationContentsAndResult, RPCRunOperationParam, RPCSimulateOperationParam, RpcClientInterface } from '@taquito/rpc';
import { Context } from './context';
import { ForgedBytes, ParamsWithKind, RPCOperation } from './operations/types';
import { PreparedOperation } from './prepare';
import { Estimate } from './estimate';
export declare abstract class Provider {
    protected context: Context;
    get rpc(): RpcClientInterface;
    get signer(): import("./taquito").Signer;
    constructor(context: Context);
    protected forge({ opOb: { branch, contents, protocol }, counter }: PreparedOperation): Promise<{
        opbytes: string;
        opOb: {
            branch: string;
            contents: import("@taquito/rpc").OperationContents[];
            protocol: string;
        };
        counter: number;
    }>;
    protected estimate<T extends {
        fee?: number;
        gasLimit?: number;
        storageLimit?: number;
    }>({ fee, gasLimit, storageLimit, ...rest }: T, estimator: (param: T) => Promise<Estimate>): Promise<{
        fee: number | undefined;
        gasLimit: number | undefined;
        storageLimit: number | undefined;
    }>;
    getRPCOp(param: ParamsWithKind): Promise<import("./operations/types").RPCTransferOperation | import("./operations/types").RPCOriginationOperation | import("./operations/types").RPCDelegateOperation | import("./operations/types").RPCRegisterGlobalConstantOperation | import("./operations/types").RPCIncreasePaidStorageOperation | import("./operations/types").RPCTransferTicketOperation | import("./operations/types").RPCSmartRollupAddMessagesOperation | import("./operations/types").RPCSmartRollupOriginateOperation>;
    protected runOperation(op: RPCRunOperationParam): Promise<{
        opResponse: import("@taquito/rpc").PreapplyResponse;
        op: RPCRunOperationParam;
        context: Context;
    }>;
    protected simulate(op: RPCSimulateOperationParam): Promise<{
        opResponse: import("@taquito/rpc").PreapplyResponse;
        op: RPCSimulateOperationParam;
        context: Context;
    }>;
    protected isRevealOpNeeded(op: RPCOperation[] | ParamsWithKind[], pkh: string): Promise<boolean>;
    protected isAccountRevealRequired(publicKeyHash: string): Promise<boolean>;
    protected isRevealRequiredForOpType(op: RPCOperation[] | ParamsWithKind[]): boolean;
    protected signAndInject(forgedBytes: ForgedBytes): Promise<{
        hash: string;
        forgedBytes: ForgedBytes;
        opResponse: OperationContentsAndResult[];
        context: Context;
    }>;
}
