"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var _counters;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrepareProvider = void 0;
const rpc_1 = require("@taquito/rpc");
const types_1 = require("../operations/types");
const constants_1 = require("../constants");
const errors_1 = require("../errors");
const core_1 = require("@taquito/core");
const contract_1 = require("../contract");
const provider_1 = require("../provider");
const bignumber_js_1 = require("bignumber.js");
const mergeLimits = (userDefinedLimit, defaultLimits) => {
    var _a, _b, _c;
    return {
        fee: (_a = userDefinedLimit.fee) !== null && _a !== void 0 ? _a : defaultLimits.fee,
        gasLimit: (_b = userDefinedLimit.gasLimit) !== null && _b !== void 0 ? _b : defaultLimits.gasLimit,
        storageLimit: (_c = userDefinedLimit.storageLimit) !== null && _c !== void 0 ? _c : defaultLimits.storageLimit,
    };
};
/**
 * @description PrepareProvider is a utility class to output the prepared format of an operation
 */
class PrepareProvider extends provider_1.Provider {
    constructor(context) {
        super(context);
        this.context = context;
        _counters.set(this, void 0);
        __classPrivateFieldSet(this, _counters, {});
    }
    getBlockHash(block) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.context.readProvider.getBlockHash(block !== null && block !== void 0 ? block : 'head~2');
        });
    }
    getProtocolHash() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.context.readProvider.getNextProtocol('head');
        });
    }
    getHeadCounter(pkh) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return (_a = this.context.readProvider.getCounter(pkh, 'head')) !== null && _a !== void 0 ? _a : '0';
        });
    }
    adjustGasForBatchOperation(gasLimitBlock, gaslimitOp, numberOfOps) {
        return bignumber_js_1.default.min(gaslimitOp, gasLimitBlock.div(numberOfOps + 1));
    }
    getAccountLimits(pkh, constants, numberOfOps) {
        return __awaiter(this, void 0, void 0, function* () {
            const balance = yield this.context.readProvider.getBalance(pkh, 'head');
            const { hard_gas_limit_per_operation, hard_gas_limit_per_block, hard_storage_limit_per_operation, cost_per_byte, } = constants;
            return {
                fee: 0,
                gasLimit: numberOfOps
                    ? Math.floor(this.adjustGasForBatchOperation(hard_gas_limit_per_block, hard_gas_limit_per_operation, numberOfOps).toNumber())
                    : hard_gas_limit_per_operation.toNumber(),
                storageLimit: Math.floor(bignumber_js_1.default.min(balance.dividedBy(cost_per_byte), hard_storage_limit_per_operation).toNumber()),
            };
        });
    }
    getFee(op, pkh, headCounter) {
        if (!__classPrivateFieldGet(this, _counters)[pkh] || __classPrivateFieldGet(this, _counters)[pkh] < headCounter) {
            __classPrivateFieldGet(this, _counters)[pkh] = headCounter;
        }
        const opCounter = ++__classPrivateFieldGet(this, _counters)[pkh];
        return {
            counter: `${opCounter}`,
            fee: typeof op.fee === 'undefined' ? '0' : `${op.fee}`,
            gas_limit: typeof op.gas_limit === 'undefined' ? '0' : `${op.gas_limit}`,
            storage_limit: typeof op.storage_limit === 'undefined' ? '0' : `${op.storage_limit}`,
        };
    }
    getSource(op, pkh, source) {
        return { source: typeof op.source === 'undefined' ? source || pkh : op.source };
    }
    addRevealOperationIfNeeded(operation, publicKeyHash) {
        return __awaiter(this, void 0, void 0, function* () {
            if (types_1.isOpRequireReveal(operation)) {
                const ops = [operation];
                const { publicKey, pkh } = yield this.getKeys();
                if (yield this.isAccountRevealRequired(publicKeyHash)) {
                    if (!publicKey) {
                        throw new core_1.PublicKeyNotFoundError(pkh);
                    }
                    ops.unshift(yield contract_1.createRevealOperation({
                        fee: constants_1.DEFAULT_FEE.REVEAL,
                        storageLimit: constants_1.DEFAULT_STORAGE_LIMIT.REVEAL,
                        gasLimit: constants_1.getRevealGasLimit(pkh),
                    }, publicKeyHash, publicKey));
                    return ops;
                }
            }
            return operation;
        });
    }
    getKeys() {
        return __awaiter(this, void 0, void 0, function* () {
            const isSignerConfigured = this.context.isAnySignerConfigured();
            return {
                pkh: isSignerConfigured
                    ? yield this.signer.publicKeyHash()
                    : yield this.context.walletProvider.getPKH(),
                publicKey: isSignerConfigured ? yield this.signer.publicKey() : undefined,
            };
        });
    }
    convertIntoArray(op) {
        if (Array.isArray(op)) {
            return [...op];
        }
        else {
            return [op];
        }
    }
    constructOpContents(ops, headCounter, pkh, source, currentVotingPeriod) {
        return ops.map((op) => {
            switch (op.kind) {
                case rpc_1.OpKind.ACTIVATION:
                case rpc_1.OpKind.DRAIN_DELEGATE:
                    return Object.assign({}, op);
                case rpc_1.OpKind.ORIGINATION:
                    return Object.assign(Object.assign(Object.assign(Object.assign({}, op), { balance: typeof op.balance !== 'undefined' ? `${op.balance}` : '0' }), this.getSource(op, pkh, source)), this.getFee(op, pkh, headCounter));
                case rpc_1.OpKind.TRANSACTION: {
                    const cops = Object.assign(Object.assign(Object.assign(Object.assign({}, op), { amount: typeof op.amount !== 'undefined' ? `${op.amount}` : '0' }), this.getSource(op, pkh, source)), this.getFee(op, pkh, headCounter));
                    if (cops.source.toLowerCase().startsWith('kt1')) {
                        throw new core_1.DeprecationError(`KT1 addresses are not supported as source since ${constants_1.Protocols.PsBabyM1}`);
                    }
                    return cops;
                }
                case rpc_1.OpKind.REVEAL:
                case rpc_1.OpKind.DELEGATION:
                case rpc_1.OpKind.REGISTER_GLOBAL_CONSTANT:
                case rpc_1.OpKind.UPDATE_CONSENSUS_KEY:
                case rpc_1.OpKind.SMART_ROLLUP_ADD_MESSAGES:
                case rpc_1.OpKind.SMART_ROLLUP_ORIGINATE:
                    return Object.assign(Object.assign(Object.assign({}, op), this.getSource(op, pkh, source)), this.getFee(op, pkh, headCounter));
                case rpc_1.OpKind.TRANSFER_TICKET:
                    return Object.assign(Object.assign(Object.assign(Object.assign({}, op), { ticket_amount: `${op.ticket_amount}` }), this.getSource(op, pkh, source)), this.getFee(op, pkh, headCounter));
                case rpc_1.OpKind.INCREASE_PAID_STORAGE:
                    return Object.assign(Object.assign(Object.assign(Object.assign({}, op), { amount: `${op.amount}` }), this.getSource(op, pkh, source)), this.getFee(op, pkh, headCounter));
                case rpc_1.OpKind.BALLOT:
                    if (currentVotingPeriod === undefined) {
                        throw new errors_1.RPCResponseError(`Failed to get the current voting period index`);
                    }
                    return Object.assign(Object.assign({}, op), { period: currentVotingPeriod === null || currentVotingPeriod === void 0 ? void 0 : currentVotingPeriod.voting_period.index });
                case rpc_1.OpKind.PROPOSALS:
                    if (currentVotingPeriod === undefined) {
                        throw new errors_1.RPCResponseError(`Failed to get the current voting period index`);
                    }
                    return Object.assign(Object.assign({}, op), { period: currentVotingPeriod === null || currentVotingPeriod === void 0 ? void 0 : currentVotingPeriod.voting_period.index });
                default:
                    throw new core_1.InvalidOperationKindError(op.kind);
            }
        });
    }
    /**
     *
     * @description Method to prepare an activation operation
     * @param operation RPCOperation object or RPCOperation array
     * @param source string or undefined source pkh
     * @returns a PreparedOperation object
     */
    activate({ pkh, secret }) {
        return __awaiter(this, void 0, void 0, function* () {
            const op = yield contract_1.createActivationOperation({
                pkh,
                secret,
            });
            const ops = this.convertIntoArray(op);
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            __classPrivateFieldSet(this, _counters, {});
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            const contents = this.constructOpContents(ops, headCounter, pkh);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare a reveal operation
     * @param operation RPCOperation object or RPCOperation array
     * @param source string or undefined source pkh
     * @returns a PreparedOperation object
     */
    reveal({ fee, gasLimit, storageLimit }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { pkh, publicKey } = yield this.getKeys();
            if (!publicKey) {
                throw new core_1.PublicKeyNotFoundError(pkh);
            }
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
            const mergedEstimates = mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS);
            const op = yield contract_1.createRevealOperation({
                fee: mergedEstimates.fee,
                gasLimit: mergedEstimates.gasLimit,
                storageLimit: mergedEstimates.storageLimit,
            }, pkh, publicKey);
            const ops = this.convertIntoArray(op);
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            __classPrivateFieldSet(this, _counters, {});
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            const contents = this.constructOpContents(ops, headCounter, pkh);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare an origination operation
     * @param operation RPCOperation object or RPCOperation array
     * @param source string or undefined source pkh
     * @returns a PreparedOperation object
     */
    originate(_a, source) {
        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, ["fee", "storageLimit", "gasLimit"]);
        return __awaiter(this, void 0, void 0, function* () {
            const { pkh } = yield this.getKeys();
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
            const op = yield contract_1.createOriginationOperation(yield this.context.parser.prepareCodeOrigination(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS))));
            const operation = yield this.addRevealOperationIfNeeded(op, pkh);
            const ops = this.convertIntoArray(operation);
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            __classPrivateFieldSet(this, _counters, {});
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            const contents = this.constructOpContents(ops, headCounter, pkh, source);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare a transaction operation
     * @param operation RPCOperation object or RPCOperation array
     * @param source string or undefined source pkh
     * @returns a PreparedOperation object
     */
    transaction(_a) {
        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, ["fee", "storageLimit", "gasLimit"]);
        return __awaiter(this, void 0, void 0, function* () {
            const { pkh } = yield this.getKeys();
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
            const op = yield contract_1.createTransferOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
            const operation = yield this.addRevealOperationIfNeeded(op, pkh);
            const ops = this.convertIntoArray(operation);
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            __classPrivateFieldSet(this, _counters, {});
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            const contents = this.constructOpContents(ops, headCounter, pkh, rest.source);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare a delegation operation
     * @param operation RPCOperation object or RPCOperation array
     * @param source string or undefined source pkh
     * @returns a PreparedOperation object
     */
    delegation(_a) {
        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, ["fee", "storageLimit", "gasLimit"]);
        return __awaiter(this, void 0, void 0, function* () {
            const { pkh } = yield this.getKeys();
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
            const op = yield contract_1.createSetDelegateOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
            const operation = yield this.addRevealOperationIfNeeded(op, pkh);
            const ops = this.convertIntoArray(operation);
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            __classPrivateFieldSet(this, _counters, {});
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            const contents = this.constructOpContents(ops, headCounter, pkh, rest.source);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare a register delegate operation
     * @param operation RPCOperation object or RPCOperation array
     * @param source string or undefined source pkh
     * @returns a PreparedOperation object
     */
    registerDelegate({ fee, storageLimit, gasLimit }, source) {
        return __awaiter(this, void 0, void 0, function* () {
            const { pkh } = yield this.getKeys();
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
            const mergedEstimates = mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS);
            const op = yield contract_1.createRegisterDelegateOperation({
                fee: mergedEstimates.fee,
                storageLimit: mergedEstimates.storageLimit,
                gasLimit: mergedEstimates.gasLimit,
            }, pkh);
            const operation = yield this.addRevealOperationIfNeeded(op, pkh);
            const ops = this.convertIntoArray(operation);
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            __classPrivateFieldSet(this, _counters, {});
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            const contents = this.constructOpContents(ops, headCounter, pkh, source);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare a register_global_constant operation
     * @param operation RPCOperation object or RPCOperation array
     * @param source string or undefined source pkh
     * @returns a PreparedOperation object
     */
    registerGlobalConstant(_a) {
        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, ["fee", "storageLimit", "gasLimit"]);
        return __awaiter(this, void 0, void 0, function* () {
            const { pkh } = yield this.getKeys();
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
            const op = yield contract_1.createRegisterGlobalConstantOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
            const operation = yield this.addRevealOperationIfNeeded(op, pkh);
            const ops = this.convertIntoArray(operation);
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            __classPrivateFieldSet(this, _counters, {});
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            const contents = this.constructOpContents(ops, headCounter, pkh, rest.source);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare an update_consensus_key operation
     * @param operation RPCOperation object or RPCOperation array
     * @param source string or undefined source pkh
     * @returns a PreparedOperation object
     */
    updateConsensusKey(_a, source) {
        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, ["fee", "storageLimit", "gasLimit"]);
        return __awaiter(this, void 0, void 0, function* () {
            const { pkh } = yield this.getKeys();
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
            const op = yield contract_1.createUpdateConsensusKeyOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
            const operation = yield this.addRevealOperationIfNeeded(op, pkh);
            const ops = this.convertIntoArray(operation);
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            __classPrivateFieldSet(this, _counters, {});
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            const contents = this.constructOpContents(ops, headCounter, pkh, source);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare an increase_paid_storage operation
     * @param operation RPCOperation object or RPCOperation array
     * @param source string or undefined source pkh
     * @returns a PreparedOperation object
     */
    increasePaidStorage(_a) {
        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, ["fee", "storageLimit", "gasLimit"]);
        return __awaiter(this, void 0, void 0, function* () {
            const { pkh } = yield this.getKeys();
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
            const op = yield contract_1.createIncreasePaidStorageOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
            const operation = yield this.addRevealOperationIfNeeded(op, pkh);
            const ops = this.convertIntoArray(operation);
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            __classPrivateFieldSet(this, _counters, {});
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            const contents = this.constructOpContents(ops, headCounter, pkh, rest.source);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare a ballot operation
     * @param operation RPCOperation object or RPCOperation array
     * @returns a PreparedOperation object
     */
    ballot(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const { pkh } = yield this.getKeys();
            const op = yield contract_1.createBallotOperation(Object.assign({}, params));
            const ops = this.convertIntoArray(op);
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            __classPrivateFieldSet(this, _counters, {});
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            let currentVotingPeriod;
            try {
                currentVotingPeriod = yield this.rpc.getCurrentPeriod();
            }
            catch (e) {
                throw new errors_1.RPCResponseError('Failed to get the current voting period index');
            }
            const contents = this.constructOpContents(ops, headCounter, pkh, undefined, currentVotingPeriod);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare a proposals operation
     * @param operation RPCOperation object or RPCOperation array
     * @returns a PreparedOperation object
     */
    proposals(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const { pkh } = yield this.getKeys();
            const op = yield contract_1.createProposalsOperation(Object.assign({}, params));
            const ops = this.convertIntoArray(op);
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            __classPrivateFieldSet(this, _counters, {});
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            let currentVotingPeriod;
            try {
                currentVotingPeriod = yield this.rpc.getCurrentPeriod();
            }
            catch (e) {
                throw new errors_1.RPCResponseError('Failed to get the current voting period index');
            }
            const contents = this.constructOpContents(ops, headCounter, pkh, undefined, currentVotingPeriod);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare a drain_delegate operation
     * @param operation RPCOperation object or RPCOperation array
     * @returns a PreparedOperation object
     */
    drainDelegate(params, source) {
        return __awaiter(this, void 0, void 0, function* () {
            const { pkh } = yield this.getKeys();
            const op = yield contract_1.createDrainDelegateOperation(Object.assign({}, params));
            const ops = this.convertIntoArray(op);
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            __classPrivateFieldSet(this, _counters, {});
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            const contents = this.constructOpContents(ops, headCounter, pkh, source);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare a transfer_ticket operation
     * @param operation RPCOperation object or RPCOperation array
     * @param source string or undefined source pkh
     * @returns a PreparedOperation object
     */
    transferTicket(_a) {
        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, ["fee", "storageLimit", "gasLimit"]);
        return __awaiter(this, void 0, void 0, function* () {
            const { pkh } = yield this.getKeys();
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
            const op = yield contract_1.createTransferTicketOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
            const operation = yield this.addRevealOperationIfNeeded(op, pkh);
            const ops = this.convertIntoArray(operation);
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            __classPrivateFieldSet(this, _counters, {});
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            const contents = this.constructOpContents(ops, headCounter, pkh, rest.source);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare a smart_rollup_add_messages operation
     * @param operation RPCOperation object or RPCOperation array
     * @param source string or undefined source pkh
     * @returns a PreparedOperation object
     */
    smartRollupAddMessages(_a) {
        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, ["fee", "storageLimit", "gasLimit"]);
        return __awaiter(this, void 0, void 0, function* () {
            const { pkh } = yield this.getKeys();
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
            const op = yield contract_1.createSmartRollupAddMessagesOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
            const operation = yield this.addRevealOperationIfNeeded(op, pkh);
            const ops = this.convertIntoArray(operation);
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            __classPrivateFieldSet(this, _counters, {});
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            const contents = this.constructOpContents(ops, headCounter, pkh, rest.source);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare a smart_rollup_originate operation
     * @param operation RPCOperation object or RPCOperation array
     * @returns a PreparedOperation object
     */
    smartRollupOriginate(_a) {
        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, ["fee", "storageLimit", "gasLimit"]);
        return __awaiter(this, void 0, void 0, function* () {
            const { pkh } = yield this.getKeys();
            const originationProof = yield this.rpc.getOriginationProof({
                kind: rest.pvmKind,
                kernel: rest.kernel,
            });
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
            const op = yield contract_1.createSmartRollupOriginateOperation(Object.assign(Object.assign(Object.assign({}, mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)), rest), { originationProof }));
            const operation = yield this.addRevealOperationIfNeeded(op, pkh);
            const ops = this.convertIntoArray(operation);
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            __classPrivateFieldSet(this, _counters, {});
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            const contents = this.constructOpContents(ops, headCounter, pkh, rest.source);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare a batch operation
     * @param operation RPCOperation object or RPCOperation array
     * @returns a PreparedOperation object
     */
    batch(batchParams, estimates) {
        return __awaiter(this, void 0, void 0, function* () {
            const { pkh, publicKey } = yield this.getKeys();
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants, batchParams.length);
            const revealNeeded = yield this.isRevealOpNeeded(batchParams, pkh);
            const ops = [];
            if (!estimates) {
                for (const op of batchParams) {
                    if (types_1.isOpWithFee(op)) {
                        const limits = mergeLimits(op, DEFAULT_PARAMS);
                        ops.push(yield this.getRPCOp(Object.assign(Object.assign({}, op), limits)));
                    }
                    else {
                        ops.push(Object.assign({}, op));
                    }
                }
            }
            else {
                for (const op of batchParams) {
                    if (types_1.isOpWithFee(op)) {
                        const e = estimates.shift();
                        const limits = mergeLimits(op, {
                            fee: e.suggestedFeeMutez,
                            storageLimit: e.storageLimit,
                            gasLimit: e.gasLimit,
                        });
                        ops.push(yield this.getRPCOp(Object.assign(Object.assign({}, op), limits)));
                    }
                    else {
                        ops.push(Object.assign({}, op));
                    }
                }
            }
            if (revealNeeded) {
                if (!publicKey) {
                    throw new core_1.PublicKeyNotFoundError(pkh);
                }
                ops.unshift(yield contract_1.createRevealOperation({
                    fee: constants_1.DEFAULT_FEE.REVEAL,
                    storageLimit: constants_1.DEFAULT_STORAGE_LIMIT.REVEAL,
                    gasLimit: constants_1.getRevealGasLimit(pkh),
                }, pkh, publicKey));
            }
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            __classPrivateFieldSet(this, _counters, {});
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            const contents = this.constructOpContents(ops, headCounter, pkh);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to prepare a batch operation
     * @param operation RPCOperation object or RPCOperation array
     * @returns a PreparedOperation object
     */
    contractCall(contractMethod) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const hash = yield this.getBlockHash();
            const protocol = yield this.getProtocolHash();
            const { pkh } = yield this.getKeys();
            __classPrivateFieldSet(this, _counters, {});
            const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
            const params = contractMethod.toTransferParams();
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
            const estimateLimits = mergeLimits({
                fee: params.fee,
                storageLimit: params.storageLimit,
                gasLimit: params.gasLimit,
            }, DEFAULT_PARAMS);
            const op = {
                kind: rpc_1.OpKind.TRANSACTION,
                fee: (_a = params.fee) !== null && _a !== void 0 ? _a : estimateLimits.fee,
                gas_limit: (_b = params.gasLimit) !== null && _b !== void 0 ? _b : estimateLimits.gasLimit,
                storage_limit: (_c = params.storageLimit) !== null && _c !== void 0 ? _c : estimateLimits.storageLimit,
                amount: String(params.amount),
                destination: params.to,
                parameters: params.parameter,
            };
            const operation = yield this.addRevealOperationIfNeeded(op, pkh);
            const ops = this.convertIntoArray(operation);
            const contents = this.constructOpContents(ops, headCounter, pkh);
            return {
                opOb: {
                    branch: hash,
                    contents,
                    protocol,
                },
                counter: headCounter,
            };
        });
    }
    /**
     *
     * @description Method to convert a PreparedOperation to the params needed for the preapplyOperation method
     * @param prepared a Prepared Operation
     * @returns a PreapplyParams object
     */
    toPreapply(prepared) {
        return __awaiter(this, void 0, void 0, function* () {
            const { opOb: { contents, branch, protocol }, } = prepared;
            const forgeParams = this.toForge(prepared);
            const forged = yield this.context.forger.forge(forgeParams);
            const sig = yield this.context.signer.sign(forged, new Uint8Array([3]));
            return [{ contents, branch, protocol, signature: sig.prefixSig }];
        });
    }
    /**
     *
     * @description Method to convert a PreparedOperation to the params needed for forging
     * @param param a Prepared Operation
     * @returns a ForgeParams object
     */
    toForge({ opOb: { contents, branch } }) {
        return {
            branch,
            contents,
        };
    }
}
exports.PrepareProvider = PrepareProvider;
_counters = new WeakMap();
//# sourceMappingURL=prepare-provider.js.map