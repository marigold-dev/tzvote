"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RPCEstimateProvider = void 0;
const errors_1 = require("../operations/errors");
const types_1 = require("../operations/types");
const estimate_1 = require("./estimate");
const utils_1 = require("@taquito/utils");
const errors_2 = require("./errors");
const provider_1 = require("../provider");
const prepare_provider_1 = require("../prepare/prepare-provider");
const core_1 = require("@taquito/core");
class RPCEstimateProvider extends provider_1.Provider {
    constructor() {
        super(...arguments);
        this.ALLOCATION_STORAGE = 257;
        this.ORIGINATION_STORAGE = 257;
        this.OP_SIZE_REVEAL = 128;
        this.prepare = new prepare_provider_1.PrepareProvider(this.context);
    }
    getKeys() {
        return __awaiter(this, void 0, void 0, function* () {
            const isSignerConfigured = this.context.isAnySignerConfigured();
            return {
                publicKeyHash: isSignerConfigured
                    ? yield this.signer.publicKeyHash()
                    : yield this.context.walletProvider.getPKH(),
                publicKey: isSignerConfigured ? yield this.signer.publicKey() : undefined,
            };
        });
    }
    getEstimationPropertiesFromOperationContent(content, size, costPerByte) {
        const operationResults = errors_1.flattenOperationResult({ contents: [content] });
        let totalMilligas = 0;
        let totalStorage = 0;
        operationResults.forEach((result) => {
            totalStorage +=
                'originated_contracts' in result && typeof result.originated_contracts !== 'undefined'
                    ? result.originated_contracts.length * this.ORIGINATION_STORAGE
                    : 0;
            totalStorage += 'allocated_destination_contract' in result ? this.ALLOCATION_STORAGE : 0;
            totalMilligas += Number(result.consumed_milligas) || 0;
            totalStorage +=
                'paid_storage_size_diff' in result ? Number(result.paid_storage_size_diff) || 0 : 0;
            totalStorage +=
                'storage_size' in result && 'global_address' in result
                    ? Number(result.storage_size) || 0
                    : 0;
            totalStorage += 'genesis_commitment_hash' in result ? Number(result.size) : 0;
        });
        if (types_1.isOpWithFee(content)) {
            return {
                milligasLimit: totalMilligas || 0,
                storageLimit: Number(totalStorage || 0),
                opSize: size,
                minimalFeePerStorageByteMutez: costPerByte.toNumber(),
            };
        }
        else {
            return {
                milligasLimit: 0,
                storageLimit: 0,
                opSize: size,
                minimalFeePerStorageByteMutez: costPerByte.toNumber(),
                baseFeeMutez: 0,
            };
        }
    }
    calculateEstimates(op, constants) {
        return __awaiter(this, void 0, void 0, function* () {
            const { opbytes, opOb: { branch, contents }, } = yield this.forge(op);
            const operation = {
                operation: { branch, contents },
                chain_id: yield this.context.readProvider.getChainId(),
            };
            const { opResponse } = yield this.simulate(operation);
            const { cost_per_byte } = constants;
            const errors = [...errors_1.flattenErrors(opResponse, 'backtracked'), ...errors_1.flattenErrors(opResponse)];
            // Fail early in case of errors
            if (errors.length) {
                throw new errors_1.TezosOperationError(errors, 'Error occurred during estimation');
            }
            let numberOfOps = 1;
            if (Array.isArray(op.opOb.contents) && op.opOb.contents.length > 1) {
                numberOfOps =
                    opResponse.contents[0].kind === 'reveal'
                        ? op.opOb.contents.length - 1
                        : op.opOb.contents.length;
            }
            return opResponse.contents.map((x) => {
                return this.getEstimationPropertiesFromOperationContent(x, 
                // TODO: Calculate a specific opSize for each operation.
                x.kind === 'reveal' ? this.OP_SIZE_REVEAL / 2 : opbytes.length / 2 / numberOfOps, cost_per_byte);
            });
        });
    }
    /**
     *
     * @description Estimate gasLimit, storageLimit and fees for an origination operation
     *
     * @returns An estimation of gasLimit, storageLimit and fees for the operation
     *
     * @param OriginationOperation Originate operation parameter
     */
    originate(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const preparedOperation = yield this.prepare.originate(params);
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);
            if (preparedOperation.opOb.contents[0].kind === 'reveal') {
                estimateProperties.shift();
            }
            return estimate_1.Estimate.createEstimateInstanceFromProperties(estimateProperties);
        });
    }
    /**
     *
     * @description Estimate gasLimit, storageLimit and fees for an transfer operation
     *
     * @returns An estimation of gasLimit, storageLimit and fees for the operation
     *
     * @param TransferOperation Originate operation parameter
     */
    transfer(_a) {
        var _b;
        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, ["fee", "storageLimit", "gasLimit"]);
        return __awaiter(this, void 0, void 0, function* () {
            const toValidation = utils_1.validateAddress(rest.to);
            if (toValidation !== utils_1.ValidationResult.VALID) {
                throw new core_1.InvalidAddressError(rest.to, utils_1.invalidDetail(toValidation));
            }
            const srouceValidation = utils_1.validateAddress((_b = rest.source) !== null && _b !== void 0 ? _b : '');
            if (rest.source && srouceValidation !== utils_1.ValidationResult.VALID) {
                throw new core_1.InvalidAddressError(rest.source, utils_1.invalidDetail(srouceValidation));
            }
            if (rest.amount < 0) {
                throw new core_1.InvalidAmountError(rest.amount.toString());
            }
            const preparedOperation = yield this.prepare.transaction(Object.assign({ fee,
                storageLimit,
                gasLimit }, rest));
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);
            if (preparedOperation.opOb.contents[0].kind === 'reveal') {
                estimateProperties.shift();
            }
            return estimate_1.Estimate.createEstimateInstanceFromProperties(estimateProperties);
        });
    }
    /**
     *
     * @description Estimate gasLimit, storageLimit and fees for a transferTicket operation
     *
     * @returns An estimation of gasLimit, storageLimit and fees for the operation
     *
     * @param TransferTicketParams operation parameter
     */
    transferTicket(_a) {
        var _b;
        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, ["fee", "storageLimit", "gasLimit"]);
        return __awaiter(this, void 0, void 0, function* () {
            const destinationValidation = utils_1.validateAddress(rest.destination);
            if (destinationValidation !== utils_1.ValidationResult.VALID) {
                throw new core_1.InvalidAddressError(rest.destination, utils_1.invalidDetail(destinationValidation));
            }
            const sourceValidation = utils_1.validateAddress((_b = rest.source) !== null && _b !== void 0 ? _b : '');
            if (rest.source && sourceValidation !== utils_1.ValidationResult.VALID) {
                throw new core_1.InvalidAddressError(rest.source, utils_1.invalidDetail(sourceValidation));
            }
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const preparedOperation = yield this.prepare.transferTicket(Object.assign({ fee,
                storageLimit,
                gasLimit }, rest));
            const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);
            if (preparedOperation.opOb.contents[0].kind === 'reveal') {
                estimateProperties.shift();
            }
            return estimate_1.Estimate.createEstimateInstanceFromProperties(estimateProperties);
        });
    }
    /**
     *
     * @description Estimate gasLimit, storageLimit and fees for a delegate operation
     *
     * @returns An estimation of gasLimit, storageLimit and fees for the operation
     *
     * @param Estimate
     */
    setDelegate(_a) {
        var _b;
        var { fee, gasLimit, storageLimit } = _a, rest = __rest(_a, ["fee", "gasLimit", "storageLimit"]);
        return __awaiter(this, void 0, void 0, function* () {
            const sourceValidation = utils_1.validateAddress(rest.source);
            if (rest.source && sourceValidation !== utils_1.ValidationResult.VALID) {
                throw new core_1.InvalidAddressError(rest.source, utils_1.invalidDetail(sourceValidation));
            }
            const delegateValidation = utils_1.validateAddress((_b = rest.delegate) !== null && _b !== void 0 ? _b : '');
            if (rest.delegate && delegateValidation !== utils_1.ValidationResult.VALID) {
                throw new core_1.InvalidAddressError(rest.delegate, utils_1.invalidDetail(delegateValidation));
            }
            const preparedOperation = yield this.prepare.delegation(Object.assign({ fee,
                storageLimit,
                gasLimit }, rest));
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);
            if (preparedOperation.opOb.contents[0].kind === 'reveal') {
                estimateProperties.shift();
            }
            return estimate_1.Estimate.createEstimateInstanceFromProperties(estimateProperties);
        });
    }
    /**
     *
     * @description Estimate gasLimit, storageLimit and fees for a each operation in the batch
     *
     * @returns An array of Estimate objects. If a reveal operation is needed, the first element of the array is the Estimate for the reveal operation.
     */
    batch(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const preparedOperations = yield this.prepare.batch(params);
            const estimateProperties = yield this.calculateEstimates(preparedOperations, protocolConstants);
            return estimate_1.Estimate.createArrayEstimateInstancesFromProperties(estimateProperties);
        });
    }
    /**
     *
     * @description Estimate gasLimit, storageLimit and fees for a delegate operation
     *
     * @returns An estimation of gasLimit, storageLimit and fees for the operation
     *
     * @param Estimate
     */
    registerDelegate(_a, source) {
        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, ["fee", "storageLimit", "gasLimit"]);
        return __awaiter(this, void 0, void 0, function* () {
            const pkh = (yield this.getKeys()).publicKeyHash;
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const checkSource = source || pkh;
            const preparedOperation = yield this.prepare.registerDelegate(Object.assign({ fee, storageLimit, gasLimit }, rest), checkSource);
            const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);
            if (preparedOperation.opOb.contents[0].kind === 'reveal') {
                estimateProperties.shift();
            }
            return estimate_1.Estimate.createEstimateInstanceFromProperties(estimateProperties);
        });
    }
    /**
     *
     * @description Estimate gasLimit, storageLimit and fees to reveal the current account
     *
     * @returns An estimation of gasLimit, storageLimit and fees for the operation or undefined if the account is already revealed
     *
     * @param Estimate
     */
    reveal(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const { publicKeyHash, publicKey } = yield this.getKeys();
            if (!publicKey) {
                throw new errors_2.RevealEstimateError();
            }
            if (yield this.isAccountRevealRequired(publicKeyHash)) {
                const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
                const preparedOperation = params
                    ? yield this.prepare.reveal(params)
                    : yield this.prepare.reveal({});
                const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);
                return estimate_1.Estimate.createEstimateInstanceFromProperties(estimateProperties);
            }
        });
    }
    /**
     *
     * @description Estimate gasLimit, storageLimit and fees for an registerGlobalConstant operation
     *
     * @returns An estimation of gasLimit, storageLimit and fees for the operation
     *
     * @param params registerGlobalConstant operation parameter
     */
    registerGlobalConstant(_a) {
        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, ["fee", "storageLimit", "gasLimit"]);
        return __awaiter(this, void 0, void 0, function* () {
            const preparedOperation = yield this.prepare.registerGlobalConstant(Object.assign({ fee,
                storageLimit,
                gasLimit }, rest));
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);
            if (preparedOperation.opOb.contents[0].kind === 'reveal') {
                estimateProperties.shift();
            }
            return estimate_1.Estimate.createEstimateInstanceFromProperties(estimateProperties);
        });
    }
    /**
     *
     * @description Estimate gasLimit, storageLimit, and fees for an increasePaidStorage operation
     *
     * @returns An estimation of gasLimit, storageLimit, and fees for the operation
     *
     * @param params increasePaidStorage operation parameters
     */
    increasePaidStorage(_a) {
        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, ["fee", "storageLimit", "gasLimit"]);
        return __awaiter(this, void 0, void 0, function* () {
            if (rest.amount < 0) {
                throw new core_1.InvalidAmountError(rest.amount.toString());
            }
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const preparedOperation = yield this.prepare.increasePaidStorage(Object.assign({ fee,
                storageLimit,
                gasLimit }, rest));
            const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);
            if (preparedOperation.opOb.contents[0].kind === 'reveal') {
                estimateProperties.shift();
            }
            return estimate_1.Estimate.createEstimateInstanceFromProperties(estimateProperties);
        });
    }
    /**
     *
     * @description Estimate gasLimit, storageLimit and fees for an Update Consensus Key operation
     *
     * @returns An estimation of gasLimit, storageLimit and fees for the operation
     *
     * @param Estimate
     */
    updateConsensusKey(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const preparedOperation = yield this.prepare.updateConsensusKey(params);
            const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);
            if (preparedOperation.opOb.contents[0].kind === 'reveal') {
                estimateProperties.shift();
            }
            return estimate_1.Estimate.createEstimateInstanceFromProperties(estimateProperties);
        });
    }
    /**
     *
     * @description Estimate gasLimit, storageLimit and fees for a smart_rollup_add_messages operation
     *
     * @returns An estimation of gasLimit, storageLimit and fees for the operation
     *
     * @param Estimate
     */
    smartRollupAddMessages(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const preparedOperation = yield this.prepare.smartRollupAddMessages(params);
            const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);
            if (preparedOperation.opOb.contents[0].kind === 'reveal') {
                estimateProperties.shift();
            }
            return estimate_1.Estimate.createEstimateInstanceFromProperties(estimateProperties);
        });
    }
    /**
     *
     * @description Estimate gasLimit, storageLimit and fees for an Smart Rollup Originate operation
     *
     * @returns An estimation of gasLimit, storageLimit and fees for the operation
     *
     * @param SmartRollupOriginateParams
     */
    smartRollupOriginate(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const preparedOperation = yield this.prepare.smartRollupOriginate(params);
            const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);
            if (preparedOperation.opOb.contents[0].kind === 'reveal') {
                estimateProperties.shift();
            }
            return estimate_1.Estimate.createEstimateInstanceFromProperties(estimateProperties);
        });
    }
    /**
     *
     * @description Estimate gasLimit, storageLimit and fees for contract call
     *
     * @returns An estimation of gasLimit, storageLimit and fees for the contract call
     *
     * @param Estimate
     */
    contractCall(contractMethod) {
        return __awaiter(this, void 0, void 0, function* () {
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const preparedOperation = yield this.prepare.contractCall(contractMethod);
            const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);
            if (preparedOperation.opOb.contents[0].kind === 'reveal') {
                estimateProperties.shift();
            }
            return estimate_1.Estimate.createEstimateInstanceFromProperties(estimateProperties);
        });
    }
}
exports.RPCEstimateProvider = RPCEstimateProvider;
//# sourceMappingURL=rpc-estimate-provider.js.map