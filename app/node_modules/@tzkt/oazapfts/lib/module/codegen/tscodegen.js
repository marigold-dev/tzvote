import fs from "fs";
import ts, { factory } from "typescript";
export const questionToken = factory.createToken(ts.SyntaxKind.QuestionToken);
export function createQuestionToken(token) {
    if (!token)
        return undefined;
    if (token === true)
        return questionToken;
    return token;
}
export const keywordType = {
    any: factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword),
    number: factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),
    object: factory.createTypeReferenceNode(factory.createIdentifier("Record"), [
        factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),
        factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword),
    ]),
    string: factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),
    boolean: factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword),
    undefined: factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword),
    unknown: factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword),
    void: factory.createKeywordTypeNode(ts.SyntaxKind.VoidKeyword),
    null: factory.createLiteralTypeNode(factory.createNull()),
};
export function createKeywordType(type) {
    return keywordType[type];
}
export const modifier = {
    async: factory.createModifier(ts.SyntaxKind.AsyncKeyword),
    export: factory.createModifier(ts.SyntaxKind.ExportKeyword),
};
export function createLiteral(v) {
    switch (typeof v) {
        case "string":
            return factory.createStringLiteral(v);
        case "boolean":
            return v ? factory.createTrue() : factory.createFalse();
        case "number":
            return factory.createNumericLiteral(String(v));
    }
}
export function createEnumTypeNode(values) {
    const types = values.map((v) => v === null
        ? keywordType.null
        : factory.createLiteralTypeNode(createLiteral(v)));
    return types.length > 1 ? factory.createUnionTypeNode(types) : types[0];
}
export function createTypeAliasDeclaration({ modifiers, name, typeParameters, type, }) {
    return factory.createTypeAliasDeclaration(modifiers, name, typeParameters, type);
}
export function toExpression(ex) {
    if (typeof ex === "string")
        return factory.createIdentifier(ex);
    return ex;
}
export function createCall(expression, { typeArgs, args, } = {}) {
    return factory.createCallExpression(toExpression(expression), typeArgs, args);
}
export function createMethodCall(method, opts) {
    return createCall(factory.createPropertyAccessExpression(factory.createThis(), method), opts);
}
export function createObjectLiteral(props) {
    return factory.createObjectLiteralExpression(props.map(([name, identifier]) => createPropertyAssignment(name, toExpression(identifier))), true);
}
export function createPropertyAssignment(name, expression) {
    if (ts.isIdentifier(expression)) {
        if (expression.text === name) {
            return factory.createShorthandPropertyAssignment(name);
        }
    }
    return factory.createPropertyAssignment(propertyName(name), expression);
}
export function block(...statements) {
    return factory.createBlock(statements, true);
}
export function createArrowFunction(parameters, body, { modifiers, typeParameters, type, equalsGreaterThanToken, } = {}) {
    return factory.createArrowFunction(modifiers, typeParameters, parameters, type, equalsGreaterThanToken, body);
}
export function createFunctionDeclaration(name, { modifiers, asteriskToken, typeParameters, type, }, parameters, body) {
    return factory.createFunctionDeclaration(modifiers, asteriskToken, name, typeParameters, parameters, type, body);
}
export function createClassDeclaration({ decorators, modifiers, name, typeParameters, heritageClauses, members, }) {
    return factory.createClassDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members);
}
export function createConstructor({ decorators, modifiers, parameters, body, }) {
    return factory.createConstructorDeclaration(decorators, modifiers, parameters, body);
}
export function createMethod(name, { modifiers, asteriskToken, questionToken, typeParameters, type, } = {}, parameters = [], body) {
    return factory.createMethodDeclaration(modifiers, asteriskToken, name, createQuestionToken(questionToken), typeParameters, parameters, type, body);
}
export function createParameter(name, { modifiers, dotDotDotToken, questionToken, type, initializer, }) {
    return factory.createParameterDeclaration(modifiers, dotDotDotToken, name, createQuestionToken(questionToken), type, initializer);
}
function propertyName(name) {
    if (typeof name === "string") {
        return isValidIdentifier(name)
            ? factory.createIdentifier(name)
            : factory.createStringLiteral(name);
    }
    return name;
}
export function createPropertySignature({ modifiers, name, questionToken, type, }) {
    return factory.createPropertySignature(modifiers, propertyName(name), createQuestionToken(questionToken), type);
}
export function createIndexSignature(type, { modifiers, indexName = "key", indexType = keywordType.string, } = {}) {
    return factory.createIndexSignature(modifiers, [createParameter(indexName, { type: indexType })], type);
}
export function createObjectBinding(elements) {
    return factory.createObjectBindingPattern(elements.map(({ dotDotDotToken, propertyName, name, initializer }) => factory.createBindingElement(dotDotDotToken, propertyName, name, initializer)));
}
export function createTemplateString(head, spans) {
    if (!spans.length)
        return factory.createStringLiteral(head);
    return factory.createTemplateExpression(factory.createTemplateHead(head), spans.map(({ expression, literal }, i) => factory.createTemplateSpan(expression, i === spans.length - 1
        ? factory.createTemplateTail(literal)
        : factory.createTemplateMiddle(literal))));
}
export function findNode(nodes, kind, test) {
    const node = nodes.find((s) => s.kind === kind && (!test || test(s)));
    if (!node)
        throw new Error(`Node not found: ${kind}`);
    return node;
}
export function getName(name) {
    if (ts.isIdentifier(name)) {
        return name.escapedText;
    }
    if (ts.isLiteralExpression(name)) {
        return name.text;
    }
    return "";
}
export function getFirstDeclarationName(n) {
    const name = ts.getNameOfDeclaration(n.declarationList.declarations[0]);
    return name ? getName(name) : "";
}
export function findFirstVariableDeclaration(nodes, name) {
    const statement = findNode(nodes, ts.SyntaxKind.VariableStatement, (n) => getFirstDeclarationName(n) === name);
    const [first] = statement.declarationList.declarations;
    if (!first)
        throw new Error("Missing declaration");
    return first;
}
export function changePropertyValue(o, property, value) {
    const p = o.properties.find((p) => ts.isPropertyAssignment(p) && getName(p.name) === property);
    if (p && ts.isPropertyAssignment(p)) {
        // p.initializer is readonly, this might break in a future TS version, but works fine for now.
        Object.assign(p, { initializer: value });
    }
    else {
        throw new Error(`No such property: ${property}`);
    }
}
export function appendNodes(array, ...nodes) {
    return factory.createNodeArray([...array, ...nodes]);
}
export function addComment(node, comment) {
    if (!comment)
        return node;
    return ts.addSyntheticLeadingComment(node, ts.SyntaxKind.MultiLineCommentTrivia, `*\n * ${comment.replace(/\n/g, "\n * ")}\n `, true);
}
export function parseFile(file) {
    return ts.createSourceFile(file, fs.readFileSync(file, "utf8"), ts.ScriptTarget.Latest, 
    /*setParentNodes*/ false, ts.ScriptKind.TS);
}
const printer = ts.createPrinter({
    newLine: ts.NewLineKind.LineFeed,
});
export function printNode(node) {
    const file = ts.createSourceFile("someFileName.ts", "", ts.ScriptTarget.Latest, 
    /*setParentNodes*/ false, ts.ScriptKind.TS);
    return printer.printNode(ts.EmitHint.Unspecified, node, file);
}
export function printNodes(nodes) {
    const file = ts.createSourceFile("someFileName.ts", "", ts.ScriptTarget.Latest, 
    /*setParentNodes*/ false, ts.ScriptKind.TS);
    return nodes
        .map((node) => printer.printNode(ts.EmitHint.Unspecified, node, file))
        .join("\n");
}
export function printFile(sourceFile) {
    return printer.printFile(sourceFile);
}
export function isValidIdentifier(str) {
    if (!str.length || str.trim() !== str)
        return false;
    const node = ts.parseIsolatedEntityName(str, ts.ScriptTarget.Latest);
    return (!!node &&
        node.kind === ts.SyntaxKind.Identifier &&
        node.originalKeywordKind === undefined);
}
//# sourceMappingURL=tscodegen.js.map