"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.supportDeepObjects = exports.callOazapftsFunction = exports.callQueryParamParser = exports.callQsFunction = exports.defaultHelpers = exports.createUrlExpression = exports.toIdentifier = exports.getReferenceName = exports.refPathToPropertyPath = exports.isReference = exports.isNullable = exports.getOperationName = exports.getOperationIdentifier = exports.getFormatter = exports.getBodyFormatter = exports.isJsonMimeType = exports.isMimeType = exports.verbs = void 0;
const lodash_1 = __importDefault(require("lodash"));
const typescript_1 = __importStar(require("typescript"));
const path_1 = __importDefault(require("path"));
const cg = __importStar(require("./tscodegen"));
const generateServers_1 = __importStar(require("./generateServers"));
exports.verbs = [
    "GET",
    "PUT",
    "POST",
    "DELETE",
    "OPTIONS",
    "HEAD",
    "PATCH",
    "TRACE",
];
const contentTypes = {
    "*/*": "json",
    "application/json": "json",
    "application/x-www-form-urlencoded": "form",
    "multipart/form-data": "multipart",
};
function isMimeType(s) {
    return typeof s === "string" && /^[^/]+\/[^/]+$/.test(s);
}
exports.isMimeType = isMimeType;
function isJsonMimeType(mime) {
    return contentTypes[mime] === "json" || /\bjson\b/i.test(mime);
}
exports.isJsonMimeType = isJsonMimeType;
function getBodyFormatter(body) {
    if (body?.content) {
        for (const contentType of Object.keys(body.content)) {
            const formatter = contentTypes[contentType];
            if (formatter)
                return formatter;
            if (isJsonMimeType(contentType))
                return "json";
        }
    }
}
exports.getBodyFormatter = getBodyFormatter;
/**
 * Get the name of a formatter function for a given parameter.
 */
function getFormatter({ style = "form", explode = true, content, }) {
    if (content) {
        const medias = Object.keys(content);
        if (medias.length !== 1) {
            throw new Error("Parameters with content property must specify one media type");
        }
        if (!isJsonMimeType(medias[0])) {
            throw new Error("Parameters with content property must specify a JSON compatible media type");
        }
        return "json";
    }
    if (explode && style === "deepObject")
        return "deep";
    if (explode)
        return "explode";
    if (style === "spaceDelimited")
        return "space";
    if (style === "pipeDelimited")
        return "pipe";
    return "form";
}
exports.getFormatter = getFormatter;
function getOperationIdentifier(id) {
    if (!id)
        return;
    if (id.match(/[^\w\s]/))
        return;
    id = lodash_1.default.camelCase(id);
    if (cg.isValidIdentifier(id))
        return id;
}
exports.getOperationIdentifier = getOperationIdentifier;
/**
 * Create a method name for a given operation, either from its operationId or
 * the HTTP verb and path.
 */
function getOperationName(verb, path, operationId) {
    const id = getOperationIdentifier(operationId);
    if (id)
        return id;
    path = path.replace(/\{(.+?)\}/, "by $1").replace(/\{(.+?)\}/, "and $1");
    return toIdentifier(`${verb} ${path}`);
}
exports.getOperationName = getOperationName;
function isNullable(schema) {
    return schema && !isReference(schema) && schema.nullable;
}
exports.isNullable = isNullable;
function isReference(obj) {
    return typeof obj === "object" && obj !== null && "$ref" in obj;
}
exports.isReference = isReference;
/**
 * Converts a local reference path into an array of property names.
 */
function refPathToPropertyPath(ref) {
    if (!ref.startsWith("#/")) {
        throw new Error(`External refs are not supported (${ref}). Make sure to call SwaggerParser.bundle() first.`);
    }
    return ref
        .slice(2)
        .split("/")
        .map((s) => decodeURI(s.replace(/~1/g, "/").replace(/~0/g, "~")));
}
exports.refPathToPropertyPath = refPathToPropertyPath;
/**
 * Get the last path component of the given ref.
 */
function getRefBasename(ref) {
    return ref.replace(/.+\//, "");
}
/**
 * Returns a name for the given ref that can be used as basis for a type
 * alias. This usually is the baseName, unless the ref ends with a number,
 * in which case the whole ref is returned, with slashes turned into
 * underscores.
 */
function getRefName(ref) {
    const base = getRefBasename(ref);
    if (/^\d+/.test(base)) {
        return refPathToPropertyPath(ref).join("_");
    }
    return base;
}
/**
 * If the given object is a ReferenceObject, return the last part of its path.
 */
function getReferenceName(obj) {
    if (isReference(obj)) {
        return getRefBasename(obj.$ref);
    }
}
exports.getReferenceName = getReferenceName;
function toIdentifier(s, upperFirst = false) {
    let cc = lodash_1.default.camelCase(s);
    if (upperFirst)
        cc = lodash_1.default.upperFirst(cc);
    if (cg.isValidIdentifier(cc))
        return cc;
    return "$" + cc;
}
exports.toIdentifier = toIdentifier;
/**
 * Create a template string literal from the given OpenAPI urlTemplate.
 * Curly braces in the path are turned into identifier expressions,
 * which are read from the local scope during runtime.
 */
function createUrlExpression(path, qs) {
    const spans = [];
    // Use a replacer function to collect spans as a side effect:
    const head = path.replace(/(.*?)\{(.+?)\}(.*?)(?=\{|$)/g, (_substr, head, name, literal) => {
        const expression = toIdentifier(name);
        spans.push({
            expression: cg.createCall(typescript_1.factory.createIdentifier("encodeURIComponent"), { args: [typescript_1.factory.createIdentifier(expression)] }),
            literal,
        });
        return head;
    });
    if (qs) {
        // add the query string as last span
        spans.push({ expression: qs, literal: "" });
    }
    return cg.createTemplateString(head, spans);
}
exports.createUrlExpression = createUrlExpression;
/**
 * Default helpers used in extensions.
 */
exports.defaultHelpers = {
    isReference,
    isNullable,
    ...cg,
};
/**
 * Create a call expression for one of the QS runtime functions.
 */
function callQsFunction(name, args) {
    return callExternalFunction("QS", name, args);
}
exports.callQsFunction = callQsFunction;
/**
 * Create a call expression for one of the query parameter parsers
 * provided in queryParamParsers.ts.
 * @param name query parameter parser callback name
 * @param args to invoke callback with
 */
function callQueryParamParser(name, args) {
    return callExternalFunction("QueryParamsParsers", name, args);
}
exports.callQueryParamParser = callQueryParamParser;
function callExternalFunction(namespace, name, args) {
    return cg.createCall(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier(namespace), name), { args });
}
/**
 * Create a call expression for one of the oazapfts runtime functions.
 */
function callOazapftsFunction(name, args, typeArgs) {
    return cg.createCall(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("oazapfts"), name), { args, typeArgs });
}
exports.callOazapftsFunction = callOazapftsFunction;
/**
 * Despite its name, OpenApi's `deepObject` serialization does not support
 * deeply nested objects. As a workaround we detect parameters that contain
 * square brackets and merge them into a single object.
 */
function supportDeepObjects(params) {
    const res = [];
    const merged = {};
    params.forEach((p) => {
        const m = /^(.+?)\[(.*?)\]/.exec(p.name);
        if (!m) {
            res.push(p);
            return;
        }
        const [, name, prop] = m;
        let obj = merged[name];
        if (!obj) {
            obj = merged[name] = {
                name,
                in: p.in,
                style: "deepObject",
                schema: {
                    type: "object",
                    properties: {},
                },
            };
            res.push(obj);
        }
        obj.schema.properties[prop] = p.schema;
    });
    return res;
}
exports.supportDeepObjects = supportDeepObjects;
/**
 * Main entry point that generates TypeScript code from a given API spec.
 */
class ApiGenerator {
    spec;
    opts;
    isConverted;
    extensions;
    constructor(spec, opts = {}, 
    /** Indicates if the document was converted from an older version of the OpenAPI specification. */
    isConverted = false, extensions = {}) {
        this.spec = spec;
        this.opts = opts;
        this.isConverted = isConverted;
        this.extensions = extensions;
    }
    aliases = [];
    enumAliases = [];
    enumRefs = {};
    // Collect the types of all referenced schemas so we can export them later
    refs = {};
    // Keep track of already used type aliases
    typeAliases = {};
    reset() {
        this.aliases = [];
        this.enumAliases = [];
        this.refs = {};
        this.typeAliases = {};
    }
    resolve(obj) {
        if (!isReference(obj))
            return obj;
        const ref = obj.$ref;
        const path = refPathToPropertyPath(ref);
        const resolved = lodash_1.default.get(this.spec, path);
        if (typeof resolved === "undefined") {
            throw new Error(`Can't find ${path}`);
        }
        return resolved;
    }
    resolveArray(array) {
        return array ? array.map((el) => this.resolve(el)) : [];
    }
    skip(tags) {
        const excluded = tags && tags.some((t) => this.opts?.exclude?.includes(t));
        if (excluded) {
            return true;
        }
        if (this.opts?.include) {
            const included = tags && tags.some((t) => this.opts.include?.includes(t));
            return !included;
        }
        return false;
    }
    getUniqueAlias(name) {
        let used = this.typeAliases[name] || 0;
        if (used) {
            this.typeAliases[name] = ++used;
            name += used;
        }
        this.typeAliases[name] = 1;
        return name;
    }
    getEnumUniqueAlias(name, values) {
        // If enum name already exists and have the same values
        if (this.enumRefs[name] && this.enumRefs[name].values == values) {
            return name;
        }
        return this.getUniqueAlias(name);
    }
    /**
     * Create a type alias for the schema referenced by the given ReferenceObject
     */
    getRefAlias(obj) {
        const { $ref } = obj;
        let ref = this.refs[$ref];
        if (!ref) {
            const schema = this.resolve(obj);
            const name = schema.title || getRefName($ref);
            const identifier = toIdentifier(name, true);
            const alias = this.getUniqueAlias(identifier);
            ref = this.refs[$ref] = typescript_1.factory.createTypeReferenceNode(alias, undefined);
            const type = this.getTypeFromSchema(schema);
            this.aliases.push(cg.createTypeAliasDeclaration({
                modifiers: [cg.modifier.export],
                name: alias,
                type,
            }));
        }
        return ref;
    }
    getUnionType(variants, discriminator) {
        if (discriminator) {
            // oneOf + discriminator -> tagged union (polymorphism)
            if (discriminator.propertyName === undefined) {
                throw new Error("Discriminators require a propertyName");
            }
            // By default, the last component of the ref name (i.e., after the last trailing slash) is
            // used as the discriminator value for each variant. This can be overridden using the
            // discriminator.mapping property.
            const mappedValues = new Set(Object.values(discriminator.mapping || {}).map(getRefBasename));
            return typescript_1.factory.createUnionTypeNode([
                ...Object.entries(discriminator.mapping || {}).map(([discriminatorValue, variantRef]) => [
                    discriminatorValue,
                    { $ref: variantRef },
                ]),
                ...variants
                    .filter((variant) => {
                    if (!isReference(variant)) {
                        // From the Swagger spec: "When using the discriminator, inline schemas will not be
                        // considered."
                        throw new Error("Discriminators require references, not inline schemas");
                    }
                    return !mappedValues.has(getRefBasename(variant.$ref));
                })
                    .map((schema) => [
                    getRefBasename(schema.$ref),
                    schema,
                ]),
            ].map(([discriminatorValue, variant]) => 
            // Yields: { [discriminator.propertyName]: discriminatorValue } & variant
            typescript_1.factory.createIntersectionTypeNode([
                typescript_1.factory.createTypeLiteralNode([
                    cg.createPropertySignature({
                        name: discriminator.propertyName,
                        type: typescript_1.factory.createLiteralTypeNode(typescript_1.factory.createStringLiteral(discriminatorValue)),
                    }),
                ]),
                this.getTypeFromSchema(variant),
            ])));
        }
        else {
            // oneOf -> untagged union
            return typescript_1.factory.createUnionTypeNode(variants.map((schema) => this.getTypeFromSchema(schema)));
        }
    }
    /**
     * Creates a type node from a given schema.
     * Delegates to getBaseTypeFromSchema internally and
     * optionally adds a union with null.
     */
    getTypeFromSchema(schema, name) {
        let type;
        // try to apply custom extensions
        const extensions = this.extensions.schemaParserExtensions;
        if (extensions && extensions.length > 0) {
            const extensionHelpers = {
                defaultSchemaTypeParser: this.getBaseTypeFromSchema.bind(this),
                ...exports.defaultHelpers,
            };
            for (let extension of extensions) {
                type = extension(schema, name, extensionHelpers, this);
                if (type)
                    break;
            }
        }
        // if custom extensions returned no type - use default parser
        type ??= this.getBaseTypeFromSchema(schema, name);
        return isNullable(schema)
            ? typescript_1.factory.createUnionTypeNode([type, cg.keywordType.null])
            : type;
    }
    /**
     * This is the very core of the OpenAPI to TS conversion - it takes a
     * schema and returns the appropriate type.
     */
    getBaseTypeFromSchema(schema, name) {
        if (!schema)
            return cg.keywordType.any;
        if (isReference(schema)) {
            return this.getRefAlias(schema);
        }
        if (schema.oneOf) {
            // oneOf -> union
            return this.getUnionType(schema.oneOf, schema.discriminator);
        }
        if (schema.anyOf) {
            // anyOf -> union
            return typescript_1.factory.createUnionTypeNode(schema.anyOf.map((schema) => this.getTypeFromSchema(schema)));
        }
        if (schema.allOf) {
            // allOf -> intersection
            const types = schema.allOf.map((schema) => this.getTypeFromSchema(schema));
            if (schema.properties || schema.additionalProperties) {
                // properties -> literal type
                types.push(this.getTypeFromProperties(schema.properties || {}, schema.required, schema.additionalProperties));
            }
            return typescript_1.factory.createIntersectionTypeNode(types);
        }
        if ("items" in schema) {
            // items -> array
            return typescript_1.factory.createArrayTypeNode(this.getTypeFromSchema(schema.items));
        }
        if (schema.properties || schema.additionalProperties) {
            // properties -> literal type
            return this.getTypeFromProperties(schema.properties || {}, schema.required, schema.additionalProperties);
        }
        if (schema.enum) {
            // enum -> enum or union
            return this.opts.useEnumType && name && schema.type !== "boolean"
                ? this.getTrueEnum(schema, name)
                : cg.createEnumTypeNode(schema.enum);
        }
        if (schema.format == "binary") {
            return typescript_1.factory.createTypeReferenceNode("Blob", []);
        }
        if (schema.const) {
            return this.getTypeFromEnum([schema.const]);
        }
        if (schema.type) {
            // string, boolean, null, number
            if (schema.type === "integer")
                return cg.keywordType.number;
            if (schema.type in cg.keywordType)
                return cg.keywordType[schema.type];
        }
        return cg.keywordType.any;
    }
    /**
     * Creates literal type (or union) from an array of values
     */
    getTypeFromEnum(values) {
        const types = values.map((s) => {
            if (s === null)
                return cg.keywordType.null;
            if (typeof s === "boolean")
                return s
                    ? typescript_1.factory.createLiteralTypeNode(typescript_1.default.factory.createToken(typescript_1.default.SyntaxKind.TrueKeyword))
                    : typescript_1.factory.createLiteralTypeNode(typescript_1.default.factory.createToken(typescript_1.default.SyntaxKind.FalseKeyword));
            if (typeof s === "number")
                return typescript_1.factory.createLiteralTypeNode(typescript_1.factory.createNumericLiteral(s));
            if (typeof s === "string")
                return typescript_1.factory.createLiteralTypeNode(typescript_1.factory.createStringLiteral(s));
            throw new Error(`Unexpected ${String(s)} of type ${typeof s} in enum`);
        });
        return types.length > 1 ? typescript_1.factory.createUnionTypeNode(types) : types[0];
    }
    getEnumValuesString(values) {
        return values.join("_");
    }
    /*
      Creates a enum "ref" if not used, reuse existing if values and name matches or creates a new one
      with a new name adding a number
    */
    getTrueEnum(schema, propName) {
        const proposedName = schema.title || lodash_1.default.upperFirst(propName);
        const stringEnumValue = this.getEnumValuesString(schema.enum ? schema.enum : []);
        const name = this.getEnumUniqueAlias(proposedName, stringEnumValue);
        if (this.enumRefs[proposedName] && proposedName === name) {
            return this.enumRefs[proposedName].type;
        }
        const values = schema.enum ? schema.enum : [];
        const members = values.map((s, index) => {
            if (schema.type === "boolean") {
                s = Boolean(s) ? "true" : "false";
            }
            else if (schema.type === "string") {
                s = lodash_1.default.upperFirst(s);
            }
            return typescript_1.factory.createEnumMember(typescript_1.factory.createIdentifier(s), schema.type === "number"
                ? typescript_1.factory.createNumericLiteral(index)
                : typescript_1.factory.createStringLiteral(s));
        });
        this.enumAliases.push(typescript_1.factory.createEnumDeclaration([cg.modifier.export], name, members));
        const type = typescript_1.factory.createTypeReferenceNode(name, undefined);
        this.enumRefs[proposedName] = {
            values: stringEnumValue,
            type: typescript_1.factory.createTypeReferenceNode(name, undefined),
        };
        return type;
    }
    /**
     * Recursively creates a type literal with the given props.
     */
    getTypeFromProperties(props, required, additionalProperties) {
        const members = Object.keys(props).map((name) => {
            const schema = props[name];
            const isRequired = required && required.includes(name);
            let type = this.getTypeFromSchema(schema, name);
            if (!isRequired && this.opts.unionUndefined) {
                type = typescript_1.factory.createUnionTypeNode([type, cg.keywordType.undefined]);
            }
            return cg.createPropertySignature({
                questionToken: !isRequired,
                name,
                type,
            });
        });
        if (additionalProperties) {
            const type = additionalProperties === true
                ? cg.keywordType.any
                : this.getTypeFromSchema(additionalProperties);
            members.push(cg.createIndexSignature(type));
        }
        return typescript_1.factory.createTypeLiteralNode(members);
    }
    getTypeFromResponses(responses) {
        return typescript_1.factory.createUnionTypeNode(Object.entries(responses).map(([code, res]) => {
            const statusType = code === "default"
                ? cg.keywordType.number
                : typescript_1.factory.createLiteralTypeNode(typescript_1.factory.createNumericLiteral(code));
            const props = [
                cg.createPropertySignature({
                    name: "status",
                    type: statusType,
                }),
            ];
            const dataType = this.getTypeFromResponse(res);
            if (dataType !== cg.keywordType.void) {
                props.push(cg.createPropertySignature({
                    name: "data",
                    type: dataType,
                }));
            }
            return typescript_1.factory.createTypeLiteralNode(props);
        }));
    }
    getTypeFromResponse(resOrRef) {
        const res = this.resolve(resOrRef);
        if (!res || !res.content)
            return cg.keywordType.void;
        return this.getTypeFromSchema(this.getSchemaFromContent(res.content));
    }
    getResponseType(responses) {
        // backwards-compatibility
        if (!responses)
            return "text";
        const extensions = this.extensions.reponseTypeExtensions;
        if (extensions && extensions.length > 0) {
            for (let extension of extensions) {
                const responseType = extension(responses, {
                    ...exports.defaultHelpers,
                    defaultSchemaResolver: this.resolve.bind(this),
                }, this);
                if (responseType)
                    return responseType;
            }
        }
        const resolvedResponses = Object.values(responses).map((response) => this.resolve(response));
        // if no content is specified, assume `text` (backwards-compatibility)
        if (!resolvedResponses.some((res) => Object.keys(res.content ?? {}).length > 0)) {
            return "text";
        }
        const isJson = resolvedResponses.some((response) => {
            const responseMimeTypes = Object.keys(response.content ?? {});
            return responseMimeTypes.some(isJsonMimeType);
        });
        // if there’s `application/json` or `*/*`, assume `json`
        if (isJson) {
            return "json";
        }
        // if there’s `text/*`, assume `text`
        if (resolvedResponses.some((res) => Object.keys(res.content ?? []).some((type) => type.startsWith("text/")))) {
            return "text";
        }
        // for the rest, assume `blob`
        return "blob";
    }
    getSchemaFromContent(content) {
        const contentType = Object.keys(content).find(isMimeType);
        if (contentType) {
            const { schema } = content[contentType];
            if (schema) {
                return schema;
            }
        }
        // if no content is specified -> string
        // `text/*` -> string
        if (Object.keys(content).length === 0 ||
            Object.keys(content).some((type) => type.startsWith("text/"))) {
            return { type: "string" };
        }
        // rest (e.g. `application/octet-stream`, `application/gzip`, …) -> binary
        return { type: "string", format: "binary" };
    }
    /**
     * Default way to create a node from provided method parameter.
     * @param p method parameter to generate node from
     */
    getTypeFromDefaultParameter(p) {
        return this.getTypeFromSchema(isReference(p) ? p : p.schema);
    }
    getTypeFromParameter(p) {
        const extensions = this.extensions.parameterParserExtensions;
        if (extensions && extensions.length > 0) {
            const extensionHelpers = {
                ...exports.defaultHelpers,
                defaultParameterTypeParser: this.getTypeFromDefaultParameter.bind(this),
            };
            for (let extension of extensions) {
                const type = extension(p, extensionHelpers, this);
                if (type)
                    return type;
            }
        }
        if (p.content) {
            const schema = this.getSchemaFromContent(p.content);
            return this.getTypeFromSchema(schema);
        }
        return this.getTypeFromDefaultParameter(p);
    }
    /**
     * Adds import of query string parsers extension to a source file.
     * @param src Source file to add import statement to.
     */
    addQueryStringParserExtensionsImport = (src) => {
        const { statements } = src;
        let lastImportIndex = 0;
        for (let i = statements.length - 1; i >= 0; i--) {
            const isImportDeclaration = typescript_1.default.isImportDeclaration(statements[i]);
            if (isImportDeclaration) {
                lastImportIndex = i;
                break;
            }
        }
        const extensionsImport = typescript_1.factory.createImportDeclaration(undefined, typescript_1.factory.createImportClause(false, typescript_1.factory.createIdentifier("QueryParamsParsers"), undefined), typescript_1.factory.createStringLiteral("./queryParamParsers"));
        const existingImports = typescript_1.factory.createNodeArray(statements.slice(0, lastImportIndex + 1));
        const restStatements = statements.slice(lastImportIndex + 1);
        const updatedStatements = cg.appendNodes(existingImports, extensionsImport, ...restStatements);
        Object.assign(src, { statements: updatedStatements });
    };
    wrapResult(ex) {
        return this.opts?.optimistic ? callOazapftsFunction("ok", [ex]) : ex;
    }
    generateApi() {
        this.reset();
        // Parse ApiStub.ts so that we don't have to generate everything manually
        const stub = cg.parseFile(path_1.default.resolve(__dirname, "../../src/codegen/ApiStub.ts"));
        // ApiStub contains `const servers = {}`, find it ...
        const servers = cg.findFirstVariableDeclaration(stub.statements, "servers");
        // servers.initializer is readonly, this might break in a future TS version, but works fine for now.
        Object.assign(servers, {
            initializer: (0, generateServers_1.default)(this.spec.servers || []),
        });
        const { initializer } = cg.findFirstVariableDeclaration(stub.statements, "defaults");
        if (!initializer || !typescript_1.default.isObjectLiteralExpression(initializer)) {
            throw new Error("No object literal: defaults");
        }
        cg.changePropertyValue(initializer, "baseUrl", (0, generateServers_1.defaultBaseUrl)(this.spec.servers || []));
        const extensions = this.extensions.queryStringParserExtensions;
        const hasExtensions = extensions && extensions.length > 0;
        hasExtensions && this.addQueryStringParserExtensionsImport(stub);
        // Collect class functions to be added...
        const functions = [];
        // Keep track of names to detect duplicates
        const names = {};
        Object.keys(this.spec.paths).forEach((path) => {
            const item = this.spec.paths[path];
            if (!item) {
                return;
            }
            Object.keys(this.resolve(item)).forEach((verb) => {
                const method = verb.toUpperCase();
                // skip summary/description/parameters etc...
                if (!exports.verbs.includes(method))
                    return;
                const op = item[verb];
                const { operationId, requestBody, responses, summary, description, tags, } = op;
                if (this.skip(tags)) {
                    return;
                }
                let name = getOperationName(verb, path, operationId);
                const count = (names[name] = (names[name] || 0) + 1);
                if (count > 1) {
                    // The name is already taken, which means that the spec is probably
                    // invalid as operationIds must be unique. Since this is quite common
                    // nevertheless we append a counter:
                    name += count;
                }
                // merge item and op parameters
                const resolvedParameters = this.resolveArray(item.parameters);
                for (const p of this.resolveArray(op.parameters)) {
                    const existing = resolvedParameters.find((r) => r.name === p.name && r.in === p.in);
                    if (!existing) {
                        resolvedParameters.push(p);
                    }
                }
                // expand older OpenAPI parameters into deepObject style where needed
                const parameters = this.isConverted
                    ? supportDeepObjects(resolvedParameters)
                    : resolvedParameters;
                // split into required/optional
                const [required, optional] = lodash_1.default.partition(parameters, "required");
                // convert parameter names to argument names ...
                const argNames = new Map();
                lodash_1.default.sortBy(parameters, "name.length").forEach((p) => {
                    const identifier = toIdentifier(p.name);
                    const existing = [...argNames.values()];
                    const suffix = existing.includes(identifier)
                        ? lodash_1.default.upperFirst(p.in)
                        : "";
                    argNames.set(p, identifier + suffix);
                });
                const getArgName = (param) => {
                    const name = argNames.get(param);
                    if (!name)
                        throw new Error(`Can't find parameter: ${param.name}`);
                    return name;
                };
                // build the method signature - first all the required parameters
                const methodParams = required.map((p) => cg.createParameter(getArgName(this.resolve(p)), {
                    type: this.getTypeFromParameter(p),
                }));
                let body;
                let bodyVar;
                // add body if present
                if (requestBody) {
                    body = this.resolve(requestBody);
                    const schema = this.getSchemaFromContent(body.content);
                    const type = this.getTypeFromSchema(schema);
                    bodyVar = toIdentifier(type.name || getReferenceName(schema) || "body");
                    methodParams.push(cg.createParameter(bodyVar, {
                        type,
                        questionToken: !body.required,
                    }));
                }
                // add an object with all optional parameters
                if (optional.length) {
                    methodParams.push(cg.createParameter(cg.createObjectBinding(optional
                        .map((param) => this.resolve(param))
                        .map((param) => ({ name: getArgName(param) }))), {
                        initializer: typescript_1.factory.createObjectLiteralExpression(),
                        type: typescript_1.factory.createTypeLiteralNode(optional.map((p) => cg.createPropertySignature({
                            name: getArgName(this.resolve(p)),
                            questionToken: true,
                            type: this.getTypeFromParameter(p),
                        }))),
                    }));
                }
                methodParams.push(cg.createParameter("opts", {
                    type: typescript_1.factory.createTypeReferenceNode("Oazapfts.RequestOpts", undefined),
                    questionToken: true,
                }));
                // Next, build the method body...
                const returnType = this.getResponseType(responses);
                const query = parameters.filter((p) => p.in === "query");
                const header = parameters.filter((p) => p.in === "header");
                let qs;
                if (query.length) {
                    const paramsByFormatter = lodash_1.default.groupBy(query, getFormatter);
                    qs = callQsFunction("query", Object.entries(paramsByFormatter).map(([format, params]) => {
                        //const [allowReserved, encodeReserved] = _.partition(params, "allowReserved");
                        const basicParams = [];
                        const extendedParams = [];
                        const getExtendedCallbackName = (p) => {
                            const extensions = this.extensions.queryStringParserExtensions;
                            if (!extensions || extensions.length === 0)
                                return;
                            const helpers = {
                                defaultSchemaResolver: this.resolve.bind(this),
                                ...exports.defaultHelpers,
                            };
                            for (let extension of extensions) {
                                const name = extension(p, helpers, this);
                                if (name)
                                    return name;
                            }
                        };
                        params.forEach((parameter) => {
                            const callbackName = getExtendedCallbackName(parameter);
                            callbackName
                                ? extendedParams.push({ parameter, callbackName })
                                : basicParams.push(parameter);
                        });
                        const createParam = (p) => {
                            return [p.name, getArgName(p)];
                        };
                        const basicParamsMap = basicParams.map(createParam);
                        const basicParamsObjLiteral = cg.createObjectLiteral(basicParamsMap);
                        const extendedParamsFnCalls = extendedParams.map((o) => {
                            const name = o.parameter.name;
                            const argName = getArgName(o.parameter);
                            const args = [
                                typescript_1.factory.createStringLiteral(name),
                                typescript_1.factory.createIdentifier(argName),
                            ];
                            const fnCall = callQueryParamParser(o.callbackName, args);
                            return fnCall;
                        });
                        const qsCallParamsObjectLiteral = typescript_1.factory.updateObjectLiteralExpression(basicParamsObjLiteral, [
                            ...basicParamsObjLiteral.properties,
                            ...extendedParamsFnCalls.map((c) => typescript_1.factory.createSpreadAssignment(c)),
                        ]);
                        return callQsFunction(format, [qsCallParamsObjectLiteral]);
                    }));
                }
                const url = createUrlExpression(path, qs);
                const init = [
                    typescript_1.factory.createSpreadAssignment(typescript_1.factory.createIdentifier("opts")),
                ];
                if (method !== "GET") {
                    init.push(typescript_1.factory.createPropertyAssignment("method", typescript_1.factory.createStringLiteral(method)));
                }
                if (bodyVar) {
                    init.push(cg.createPropertyAssignment("body", typescript_1.factory.createIdentifier(bodyVar)));
                }
                if (header.length) {
                    init.push(typescript_1.factory.createPropertyAssignment("headers", typescript_1.factory.createObjectLiteralExpression([
                        typescript_1.factory.createSpreadAssignment(typescript_1.factory.createLogicalAnd(typescript_1.factory.createIdentifier("opts"), typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier("opts"), "headers"))),
                        ...header.map((param) => cg.createPropertyAssignment(param.name, typescript_1.factory.createIdentifier(getArgName(param)))),
                    ], true)));
                }
                const args = [url];
                if (init.length) {
                    const formatter = getBodyFormatter(body); // json, form, multipart
                    const initObj = typescript_1.factory.createObjectLiteralExpression(init, true);
                    args.push(formatter ? callOazapftsFunction(formatter, [initObj]) : initObj);
                }
                functions.push(cg.addComment(cg.createFunctionDeclaration(name, {
                    modifiers: [cg.modifier.export],
                }, methodParams, cg.block(typescript_1.factory.createReturnStatement(this.wrapResult(callOazapftsFunction({
                    json: "fetchJson",
                    text: "fetchText",
                    blob: "fetchBlob",
                }[returnType], args, returnType === "json" || returnType === "blob"
                    ? [
                        this.getTypeFromResponses(responses) ||
                            typescript_1.default.SyntaxKind.AnyKeyword,
                    ]
                    : undefined))))), summary || description));
            });
        });
        Object.assign(stub, {
            statements: cg.appendNodes(stub.statements, ...[...this.aliases, ...functions], ...this.enumAliases),
        });
        return stub;
    }
}
exports.default = ApiGenerator;
//# sourceMappingURL=generate.js.map