import ts from "typescript";
import { OpenAPIV3 } from "openapi-types";
import { Opts } from ".";
import { OazapftsExtensions } from "./extensions";
export declare const verbs: string[];
type ContentType = "json" | "form" | "multipart";
export declare function isMimeType(s: unknown): boolean;
export declare function isJsonMimeType(mime: string): boolean;
export declare function getBodyFormatter(body?: OpenAPIV3.RequestBodyObject): ContentType | undefined;
type SchemaObject = OpenAPIV3.SchemaObject & {
    const?: unknown;
};
/**
 * Get the name of a formatter function for a given parameter.
 */
export declare function getFormatter({ style, explode, content, }: OpenAPIV3.ParameterObject): "json" | "form" | "deep" | "explode" | "space" | "pipe";
export declare function getOperationIdentifier(id?: string): string | undefined;
/**
 * Create a method name for a given operation, either from its operationId or
 * the HTTP verb and path.
 */
export declare function getOperationName(verb: string, path: string, operationId?: string): string;
export declare function isNullable(schema?: SchemaObject | OpenAPIV3.ReferenceObject): boolean | undefined;
export declare function isReference(obj: unknown): obj is OpenAPIV3.ReferenceObject;
/**
 * Converts a local reference path into an array of property names.
 */
export declare function refPathToPropertyPath(ref: string): string[];
/**
 * If the given object is a ReferenceObject, return the last part of its path.
 */
export declare function getReferenceName(obj: unknown): string | undefined;
export declare function toIdentifier(s: string, upperFirst?: boolean): string;
/**
 * Create a template string literal from the given OpenAPI urlTemplate.
 * Curly braces in the path are turned into identifier expressions,
 * which are read from the local scope during runtime.
 */
export declare function createUrlExpression(path: string, qs?: ts.Expression): ts.StringLiteral | ts.TemplateExpression;
/**
 * Default helpers used in extensions.
 */
export declare const defaultHelpers: {
    createQuestionToken(token?: boolean | ts.QuestionToken | undefined): ts.PunctuationToken<ts.SyntaxKind.QuestionToken> | undefined;
    createKeywordType(type: "string" | "number" | "boolean" | "undefined" | "object" | "any" | "unknown" | "void" | "null"): ts.KeywordTypeNode<ts.SyntaxKind.AnyKeyword> | ts.KeywordTypeNode<ts.SyntaxKind.NumberKeyword> | ts.KeywordTypeNode<ts.SyntaxKind.StringKeyword> | ts.KeywordTypeNode<ts.SyntaxKind.UnknownKeyword> | ts.TypeReferenceNode | ts.KeywordTypeNode<ts.SyntaxKind.BooleanKeyword> | ts.KeywordTypeNode<ts.SyntaxKind.UndefinedKeyword> | ts.KeywordTypeNode<ts.SyntaxKind.VoidKeyword> | ts.LiteralTypeNode;
    createLiteral(v: string | number | boolean): ts.TrueLiteral | ts.FalseLiteral | ts.StringLiteral | ts.NumericLiteral;
    createEnumTypeNode(values: (string | number | boolean)[]): ts.LiteralTypeNode | ts.UnionTypeNode;
    createTypeAliasDeclaration({ modifiers, name, typeParameters, type, }: {
        modifiers?: ts.Modifier[] | undefined;
        name: string | ts.Identifier;
        typeParameters?: ts.TypeParameterDeclaration[] | undefined;
        type: ts.TypeNode;
    }): ts.TypeAliasDeclaration;
    toExpression(ex: string | ts.Expression): ts.Expression;
    createCall(expression: string | ts.Expression, { typeArgs, args, }?: {
        typeArgs?: ts.TypeNode[] | undefined;
        args?: ts.Expression[] | undefined;
    }): ts.CallExpression;
    createMethodCall(method: string, opts: {
        typeArgs?: ts.TypeNode[] | undefined;
        args?: ts.Expression[] | undefined;
    }): ts.CallExpression;
    createObjectLiteral(props: [string, string | ts.Expression][]): ts.ObjectLiteralExpression;
    createPropertyAssignment(name: string, expression: ts.Expression): ts.PropertyAssignment | ts.ShorthandPropertyAssignment;
    block(...statements: ts.Statement[]): ts.Block;
    createArrowFunction(parameters: ts.ParameterDeclaration[], body: ts.ConciseBody, { modifiers, typeParameters, type, equalsGreaterThanToken, }?: {
        modifiers?: ts.Modifier[] | undefined;
        typeParameters?: ts.TypeParameterDeclaration[] | undefined;
        type?: ts.TypeNode | undefined;
        equalsGreaterThanToken?: ts.EqualsGreaterThanToken | undefined;
    }): ts.ArrowFunction;
    createFunctionDeclaration(name: string | ts.Identifier | undefined, { modifiers, asteriskToken, typeParameters, type, }: {
        modifiers?: ts.Modifier[] | undefined;
        asteriskToken?: ts.AsteriskToken | undefined;
        typeParameters?: ts.TypeParameterDeclaration[] | undefined;
        type?: ts.TypeNode | undefined;
    }, parameters: ts.ParameterDeclaration[], body?: ts.Block | undefined): ts.FunctionDeclaration;
    createClassDeclaration({ decorators, modifiers, name, typeParameters, heritageClauses, members, }: {
        decorators?: ts.Decorator[] | undefined;
        modifiers?: ts.Modifier[] | undefined;
        name?: string | ts.Identifier | undefined;
        typeParameters?: ts.TypeParameterDeclaration[] | undefined;
        heritageClauses?: ts.HeritageClause[] | undefined;
        members: ts.ClassElement[];
    }): ts.ClassDeclaration;
    createConstructor({ decorators, modifiers, parameters, body, }: {
        decorators?: ts.Decorator[] | undefined;
        modifiers?: ts.Modifier[] | undefined;
        parameters: ts.ParameterDeclaration[];
        body?: ts.Block | undefined;
    }): ts.ConstructorDeclaration;
    createMethod(name: string | ts.Identifier | ts.StringLiteral | ts.NumericLiteral | ts.ComputedPropertyName, { modifiers, asteriskToken, questionToken, typeParameters, type, }?: {
        modifiers?: ts.Modifier[] | undefined;
        asteriskToken?: ts.AsteriskToken | undefined;
        questionToken?: boolean | ts.QuestionToken | undefined;
        typeParameters?: ts.TypeParameterDeclaration[] | undefined;
        type?: ts.TypeNode | undefined;
    }, parameters?: ts.ParameterDeclaration[], body?: ts.Block | undefined): ts.MethodDeclaration;
    createParameter(name: string | ts.BindingName, { modifiers, dotDotDotToken, questionToken, type, initializer, }: {
        modifiers?: ts.Modifier[] | undefined;
        dotDotDotToken?: ts.DotDotDotToken | undefined;
        questionToken?: boolean | ts.QuestionToken | undefined;
        type?: ts.TypeNode | undefined;
        initializer?: ts.Expression | undefined;
    }): ts.ParameterDeclaration;
    createPropertySignature({ modifiers, name, questionToken, type, }: {
        modifiers?: ts.Modifier[] | undefined;
        name: string | ts.PropertyName;
        questionToken?: boolean | ts.QuestionToken | undefined;
        type?: ts.TypeNode | undefined;
    }): ts.PropertySignature;
    createIndexSignature(type: ts.TypeNode, { modifiers, indexName, indexType, }?: {
        indexName?: string | undefined;
        indexType?: ts.TypeNode | undefined;
        modifiers?: ts.Modifier[] | undefined;
    }): ts.IndexSignatureDeclaration;
    createObjectBinding(elements: {
        name: string | ts.BindingName;
        dotDotDotToken?: ts.DotDotDotToken | undefined;
        propertyName?: string | ts.PropertyName | undefined;
        initializer?: ts.Expression | undefined;
    }[]): ts.ObjectBindingPattern;
    createTemplateString(head: string, spans: {
        literal: string;
        expression: ts.Expression;
    }[]): ts.StringLiteral | ts.TemplateExpression;
    findNode<T extends ts.Node>(nodes: ts.NodeArray<ts.Node>, kind: T extends {
        kind: infer K;
    } ? K : never, test?: ((node: T) => boolean | undefined) | undefined): T;
    getName(name: ts.Node): string | (void & {
        __escapedIdentifier: void;
    });
    getFirstDeclarationName(n: ts.VariableStatement): string | (void & {
        __escapedIdentifier: void;
    });
    findFirstVariableDeclaration(nodes: ts.NodeArray<ts.Node>, name: string): ts.VariableDeclaration;
    changePropertyValue(o: ts.ObjectLiteralExpression, property: string, value: ts.Expression): void;
    appendNodes<T_1 extends ts.Node>(array: ts.NodeArray<T_1>, ...nodes: T_1[]): ts.NodeArray<T_1>;
    addComment<T_2 extends ts.Node>(node: T_2, comment?: string | undefined): T_2;
    parseFile(file: string): ts.SourceFile;
    printNode(node: ts.Node): string;
    printNodes(nodes: ts.Node[]): string;
    printFile(sourceFile: ts.SourceFile): string;
    isValidIdentifier(str: string): boolean;
    questionToken: ts.PunctuationToken<ts.SyntaxKind.QuestionToken>;
    keywordType: {
        readonly any: ts.KeywordTypeNode<ts.SyntaxKind.AnyKeyword>;
        readonly number: ts.KeywordTypeNode<ts.SyntaxKind.NumberKeyword>;
        readonly object: ts.TypeReferenceNode;
        readonly string: ts.KeywordTypeNode<ts.SyntaxKind.StringKeyword>;
        readonly boolean: ts.KeywordTypeNode<ts.SyntaxKind.BooleanKeyword>;
        readonly undefined: ts.KeywordTypeNode<ts.SyntaxKind.UndefinedKeyword>;
        readonly unknown: ts.KeywordTypeNode<ts.SyntaxKind.UnknownKeyword>;
        readonly void: ts.KeywordTypeNode<ts.SyntaxKind.VoidKeyword>;
        readonly null: ts.LiteralTypeNode;
    };
    modifier: {
        async: ts.ModifierToken<ts.SyntaxKind.AsyncKeyword>;
        export: ts.ModifierToken<ts.SyntaxKind.ExportKeyword>;
    };
    isReference: typeof isReference;
    isNullable: typeof isNullable;
};
/**
 * Create a call expression for one of the QS runtime functions.
 */
export declare function callQsFunction(name: string, args: ts.Expression[]): ts.CallExpression;
/**
 * Create a call expression for one of the query parameter parsers
 * provided in queryParamParsers.ts.
 * @param name query parameter parser callback name
 * @param args to invoke callback with
 */
export declare function callQueryParamParser(name: string, args: ts.Expression[]): ts.CallExpression;
/**
 * Create a call expression for one of the oazapfts runtime functions.
 */
export declare function callOazapftsFunction(name: string, args: ts.Expression[], typeArgs?: ts.TypeNode[]): ts.CallExpression;
/**
 * Despite its name, OpenApi's `deepObject` serialization does not support
 * deeply nested objects. As a workaround we detect parameters that contain
 * square brackets and merge them into a single object.
 */
export declare function supportDeepObjects(params: OpenAPIV3.ParameterObject[]): OpenAPIV3.ParameterObject[];
/**
 * Main entry point that generates TypeScript code from a given API spec.
 */
export default class ApiGenerator {
    readonly spec: OpenAPIV3.Document;
    readonly opts: Opts;
    /** Indicates if the document was converted from an older version of the OpenAPI specification. */
    readonly isConverted: boolean;
    private readonly extensions;
    constructor(spec: OpenAPIV3.Document, opts?: Opts, 
    /** Indicates if the document was converted from an older version of the OpenAPI specification. */
    isConverted?: boolean, extensions?: OazapftsExtensions);
    aliases: ts.TypeAliasDeclaration[];
    enumAliases: ts.Statement[];
    enumRefs: Record<string, {
        values: string;
        type: ts.TypeReferenceNode;
    }>;
    refs: Record<string, ts.TypeReferenceNode>;
    typeAliases: Record<string, number>;
    reset(): void;
    resolve<T>(obj: T | OpenAPIV3.ReferenceObject): T;
    resolveArray<T>(array?: Array<T | OpenAPIV3.ReferenceObject>): T[];
    skip(tags?: string[]): boolean;
    getUniqueAlias(name: string): string;
    getEnumUniqueAlias(name: string, values: string): string;
    /**
     * Create a type alias for the schema referenced by the given ReferenceObject
     */
    getRefAlias(obj: OpenAPIV3.ReferenceObject): ts.TypeReferenceNode;
    getUnionType(variants: (OpenAPIV3.ReferenceObject | SchemaObject)[], discriminator?: OpenAPIV3.DiscriminatorObject): ts.UnionTypeNode;
    /**
     * Creates a type node from a given schema.
     * Delegates to getBaseTypeFromSchema internally and
     * optionally adds a union with null.
     */
    getTypeFromSchema(schema?: SchemaObject | OpenAPIV3.ReferenceObject, name?: string): ts.TypeNode;
    /**
     * This is the very core of the OpenAPI to TS conversion - it takes a
     * schema and returns the appropriate type.
     */
    getBaseTypeFromSchema(schema?: SchemaObject | OpenAPIV3.ReferenceObject, name?: string): ts.TypeNode;
    /**
     * Creates literal type (or union) from an array of values
     */
    getTypeFromEnum(values: unknown[]): ts.LiteralTypeNode | ts.UnionTypeNode;
    getEnumValuesString(values: string[]): string;
    getTrueEnum(schema: OpenAPIV3.NonArraySchemaObject, propName: string): ts.TypeReferenceNode;
    /**
     * Recursively creates a type literal with the given props.
     */
    getTypeFromProperties(props: {
        [prop: string]: SchemaObject | OpenAPIV3.ReferenceObject;
    }, required?: string[], additionalProperties?: boolean | OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject): ts.TypeLiteralNode;
    getTypeFromResponses(responses: OpenAPIV3.ResponsesObject): ts.UnionTypeNode;
    getTypeFromResponse(resOrRef: OpenAPIV3.ResponseObject | OpenAPIV3.ReferenceObject): ts.TypeNode;
    getResponseType(responses?: OpenAPIV3.ResponsesObject): "json" | "text" | "blob";
    getSchemaFromContent(content: Record<string, OpenAPIV3.MediaTypeObject>): OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject;
    /**
     * Default way to create a node from provided method parameter.
     * @param p method parameter to generate node from
     */
    private getTypeFromDefaultParameter;
    getTypeFromParameter(p: OpenAPIV3.ParameterObject): ts.TypeNode;
    /**
     * Adds import of query string parsers extension to a source file.
     * @param src Source file to add import statement to.
     */
    private addQueryStringParserExtensionsImport;
    wrapResult(ex: ts.Expression): ts.Expression;
    generateApi(): ts.SourceFile;
}
export {};
