import {
  BigNumber,
  bignumber_default
} from "./chunk-CJ47JOF3.js";
import {
  DeprecationError,
  InvalidAddressError,
  InvalidAmountError,
  InvalidBlockHashError,
  InvalidChainIdError,
  InvalidContractAddressError,
  InvalidHexStringError,
  InvalidKeyHashError,
  InvalidOperationHashError,
  InvalidOperationKindError,
  InvalidPublicKeyError,
  InvalidViewParameterError,
  NetworkError,
  ParameterValidationError,
  Parser,
  PublicKeyNotFoundError,
  RpcError,
  TaquitoError,
  TezosToolkitConfigError,
  UnsupportedActionError,
  packDataBytes
} from "./chunk-VKRPOTFK.js";
import {
  require_blake2b,
  require_bs58check,
  require_ed25519,
  require_elliptic
} from "./chunk-B4LNAEGG.js";
import {
  require_buffer
} from "./chunk-TMQFY2KS.js";
import {
  __commonJS,
  __toESM
} from "./chunk-FOWDQQBS.js";

// node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/bind.js"(exports, module) {
    "use strict";
    module.exports = function bind2(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/utils.js
var require_utils = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/utils.js"(exports, module) {
    "use strict";
    var bind2 = require_bind();
    var toString = Object.prototype.toString;
    function isArray4(val) {
      return Array.isArray(val);
    }
    function isUndefined2(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined2(val) && val.constructor !== null && !isUndefined2(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString.call(val) === "[object ArrayBuffer]";
    }
    function isFormData2(val) {
      return toString.call(val) === "[object FormData]";
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    function isString2(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (toString.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate(val) {
      return toString.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString.call(val) === "[object File]";
    }
    function isBlob(val) {
      return toString.call(val) === "[object Blob]";
    }
    function isFunction2(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction2(val.pipe);
    }
    function isURLSearchParams(val) {
      return toString.call(val) === "[object URLSearchParams]";
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv2() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray4(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge3() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge3(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge3({}, val);
        } else if (isArray4(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind2(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    module.exports = {
      isArray: isArray4,
      isArrayBuffer,
      isBuffer,
      isFormData: isFormData2,
      isArrayBufferView,
      isString: isString2,
      isNumber,
      isObject,
      isPlainObject,
      isUndefined: isUndefined2,
      isDate,
      isFile,
      isBlob,
      isFunction: isFunction2,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv: isStandardBrowserEnv2,
      forEach,
      merge: merge3,
      extend,
      trim,
      stripBOM
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/buildURL.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module.exports = function buildURL2(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/core/InterceptorManager.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module.exports = InterceptorManager;
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/core/enhanceError.js"(exports, module) {
    "use strict";
    module.exports = function enhanceError2(error, config2, code2, request, response) {
      error.config = config2;
      if (code2) {
        error.code = code2;
      }
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      };
      return error;
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/core/createError.js"(exports, module) {
    "use strict";
    var enhanceError2 = require_enhanceError();
    module.exports = function createError2(message, config2, code2, request, response) {
      var error = new Error(message);
      return enhanceError2(error, config2, code2, request, response);
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/core/settle.js"(exports, module) {
    "use strict";
    var createError2 = require_createError();
    module.exports = function settle2(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError2(
          "Request failed with status code " + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/cookies.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs support document.cookie
      function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }()
    );
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module) {
    "use strict";
    module.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/combineURLs.js"(exports, module) {
    "use strict";
    module.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/core/buildFullPath.js"(exports, module) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module.exports = function buildFullPath2(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/parseHeaders.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }()
    );
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/cancel/Cancel.js"(exports, module) {
    "use strict";
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module.exports = Cancel;
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/adapters/xhr.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var settle2 = require_settle();
    var cookies = require_cookies();
    var buildURL2 = require_buildURL();
    var buildFullPath2 = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError2 = require_createError();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    module.exports = function xhrAdapter(config2) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config2.data;
        var requestHeaders = config2.headers;
        var responseType = config2.responseType;
        var onCanceled;
        function done() {
          if (config2.cancelToken) {
            config2.cancelToken.unsubscribe(onCanceled);
          }
          if (config2.signal) {
            config2.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config2.auth) {
          var username = config2.auth.username || "";
          var password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath2(config2.baseURL, config2.url);
        request.open(config2.method.toUpperCase(), buildURL2(fullPath, config2.params, config2.paramsSerializer), true);
        request.timeout = config2.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config2,
            request
          };
          settle2(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(createError2("Request aborted", config2, "ECONNABORTED", request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(createError2("Network Error", config2, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
          var transitional = config2.transitional || defaults.transitional;
          if (config2.timeoutErrorMessage) {
            timeoutErrorMessage = config2.timeoutErrorMessage;
          }
          reject(createError2(
            timeoutErrorMessage,
            config2,
            transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
            request
          ));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config2.withCredentials || isURLSameOrigin(fullPath)) && config2.xsrfCookieName ? cookies.read(config2.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config2.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config2.withCredentials)) {
          request.withCredentials = !!config2.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config2.responseType;
        }
        if (typeof config2.onDownloadProgress === "function") {
          request.addEventListener("progress", config2.onDownloadProgress);
        }
        if (typeof config2.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config2.onUploadProgress);
        }
        if (config2.cancelToken || config2.signal) {
          onCanceled = function(cancel) {
            if (!request) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
            request.abort();
            request = null;
          };
          config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
          if (config2.signal) {
            config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/defaults.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var normalizeHeaderName = require_normalizeHeaderName();
    var enhanceError2 = require_enhanceError();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter2;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter2 = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter2 = require_xhr();
      }
      return adapter2;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw enhanceError2(e, this, "E_JSON_PARSE");
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module.exports = defaults;
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/core/transformData.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var defaults = require_defaults();
    module.exports = function transformData(data, headers, fns) {
      var context2 = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context2, data, headers);
      });
      return data;
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/cancel/isCancel.js"(exports, module) {
    "use strict";
    module.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/core/dispatchRequest.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    function throwIfCancellationRequested(config2) {
      if (config2.cancelToken) {
        config2.cancelToken.throwIfRequested();
      }
      if (config2.signal && config2.signal.aborted) {
        throw new Cancel("canceled");
      }
    }
    module.exports = function dispatchRequest(config2) {
      throwIfCancellationRequested(config2);
      config2.headers = config2.headers || {};
      config2.data = transformData.call(
        config2,
        config2.data,
        config2.headers,
        config2.transformRequest
      );
      config2.headers = utils.merge(
        config2.headers.common || {},
        config2.headers[config2.method] || {},
        config2.headers
      );
      utils.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config2.headers[method];
        }
      );
      var adapter2 = config2.adapter || defaults.adapter;
      return adapter2(config2).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config2);
        response.data = transformData.call(
          config2,
          response.data,
          response.headers,
          config2.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config2);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config2,
              reason.response.data,
              reason.response.headers,
              config2.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/core/mergeConfig.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config3 = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap2 = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge3 = mergeMap2[prop] || mergeDeepProperties;
        var configValue = merge3(prop);
        utils.isUndefined(configValue) && merge3 !== mergeDirectKeys || (config3[prop] = configValue);
      });
      return config3;
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/env/data.js
var require_data = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/env/data.js"(exports, module) {
    module.exports = {
      "version": "0.26.0"
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/validator.js"(exports, module) {
    "use strict";
    var VERSION2 = require_data().version;
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION2 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, " has been removed" + (version ? " in " + version : "")));
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError("option " + opt + " must be " + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    module.exports = {
      assertOptions,
      validators
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/core/Axios.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var buildURL2 = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(configOrUrl, config2) {
      if (typeof configOrUrl === "string") {
        config2 = config2 || {};
        config2.url = configOrUrl;
      } else {
        config2 = configOrUrl || {};
      }
      config2 = mergeConfig(this.defaults, config2);
      if (config2.method) {
        config2.method = config2.method.toLowerCase();
      } else if (this.defaults.method) {
        config2.method = this.defaults.method.toLowerCase();
      } else {
        config2.method = "get";
      }
      var transitional = config2.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config2);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config2;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config2) {
      config2 = mergeConfig(this.defaults, config2);
      return buildURL2(config2.url, config2.params, config2.paramsSerializer).replace(/^\?/, "");
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config2) {
        return this.request(mergeConfig(config2 || {}, {
          method,
          url,
          data: (config2 || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios.prototype[method] = function(url, data, config2) {
        return this.request(mergeConfig(config2 || {}, {
          method,
          url,
          data
        }));
      };
    });
    module.exports = Axios;
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/cancel/CancelToken.js"(exports, module) {
    "use strict";
    var Cancel = require_Cancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      this.promise.then(function(cancel) {
        if (!token._listeners)
          return;
        var i;
        var l = token._listeners.length;
        for (i = 0; i < l; i++) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve) {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module.exports = CancelToken;
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/spread.js"(exports, module) {
    "use strict";
    module.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/helpers/isAxiosError.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    };
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/lib/axios.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var bind2 = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context2 = new Axios(defaultConfig);
      var instance = bind2(Axios.prototype.request, context2);
      utils.extend(instance, Axios.prototype, context2);
      utils.extend(instance, context2);
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios2 = createInstance(defaults);
    axios2.Axios = Axios;
    axios2.Cancel = require_Cancel();
    axios2.CancelToken = require_CancelToken();
    axios2.isCancel = require_isCancel();
    axios2.VERSION = require_data().version;
    axios2.all = function all(promises) {
      return Promise.all(promises);
    };
    axios2.spread = require_spread();
    axios2.isAxiosError = require_isAxiosError();
    module.exports = axios2;
    module.exports.default = axios2;
  }
});

// node_modules/@taquito/http-utils/node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/@taquito/http-utils/node_modules/axios/index.js"(exports, module) {
    module.exports = require_axios();
  }
});

// node_modules/blakejs/util.js
var require_util = __commonJS({
  "node_modules/blakejs/util.js"(exports, module) {
    var ERROR_MSG_INPUT = "Input must be an string, Buffer or Uint8Array";
    function normalizeInput(input) {
      let ret;
      if (input instanceof Uint8Array) {
        ret = input;
      } else if (typeof input === "string") {
        const encoder = new TextEncoder();
        ret = encoder.encode(input);
      } else {
        throw new Error(ERROR_MSG_INPUT);
      }
      return ret;
    }
    function toHex(bytes) {
      return Array.prototype.map.call(bytes, function(n) {
        return (n < 16 ? "0" : "") + n.toString(16);
      }).join("");
    }
    function uint32ToHex(val) {
      return (4294967296 + val).toString(16).substring(1);
    }
    function debugPrint(label, arr, size) {
      let msg = "\n" + label + " = ";
      for (let i = 0; i < arr.length; i += 2) {
        if (size === 32) {
          msg += uint32ToHex(arr[i]).toUpperCase();
          msg += " ";
          msg += uint32ToHex(arr[i + 1]).toUpperCase();
        } else if (size === 64) {
          msg += uint32ToHex(arr[i + 1]).toUpperCase();
          msg += uint32ToHex(arr[i]).toUpperCase();
        } else
          throw new Error("Invalid size " + size);
        if (i % 6 === 4) {
          msg += "\n" + new Array(label.length + 4).join(" ");
        } else if (i < arr.length - 2) {
          msg += " ";
        }
      }
      console.log(msg);
    }
    function testSpeed(hashFn, N, M) {
      let startMs = (/* @__PURE__ */ new Date()).getTime();
      const input = new Uint8Array(N);
      for (let i = 0; i < N; i++) {
        input[i] = i % 256;
      }
      const genMs = (/* @__PURE__ */ new Date()).getTime();
      console.log("Generated random input in " + (genMs - startMs) + "ms");
      startMs = genMs;
      for (let i = 0; i < M; i++) {
        const hashHex = hashFn(input);
        const hashMs = (/* @__PURE__ */ new Date()).getTime();
        const ms = hashMs - startMs;
        startMs = hashMs;
        console.log("Hashed in " + ms + "ms: " + hashHex.substring(0, 20) + "...");
        console.log(
          Math.round(N / (1 << 20) / (ms / 1e3) * 100) / 100 + " MB PER SECOND"
        );
      }
    }
    module.exports = {
      normalizeInput,
      toHex,
      debugPrint,
      testSpeed
    };
  }
});

// node_modules/blakejs/blake2b.js
var require_blake2b2 = __commonJS({
  "node_modules/blakejs/blake2b.js"(exports, module) {
    var util = require_util();
    function ADD64AA(v2, a, b) {
      const o0 = v2[a] + v2[b];
      let o1 = v2[a + 1] + v2[b + 1];
      if (o0 >= 4294967296) {
        o1++;
      }
      v2[a] = o0;
      v2[a + 1] = o1;
    }
    function ADD64AC(v2, a, b0, b1) {
      let o0 = v2[a] + b0;
      if (b0 < 0) {
        o0 += 4294967296;
      }
      let o1 = v2[a + 1] + b1;
      if (o0 >= 4294967296) {
        o1++;
      }
      v2[a] = o0;
      v2[a + 1] = o1;
    }
    function B2B_GET32(arr, i) {
      return arr[i] ^ arr[i + 1] << 8 ^ arr[i + 2] << 16 ^ arr[i + 3] << 24;
    }
    function B2B_G(a, b, c, d, ix, iy) {
      const x0 = m[ix];
      const x1 = m[ix + 1];
      const y0 = m[iy];
      const y1 = m[iy + 1];
      ADD64AA(v, a, b);
      ADD64AC(v, a, x0, x1);
      let xor0 = v[d] ^ v[a];
      let xor1 = v[d + 1] ^ v[a + 1];
      v[d] = xor1;
      v[d + 1] = xor0;
      ADD64AA(v, c, d);
      xor0 = v[b] ^ v[c];
      xor1 = v[b + 1] ^ v[c + 1];
      v[b] = xor0 >>> 24 ^ xor1 << 8;
      v[b + 1] = xor1 >>> 24 ^ xor0 << 8;
      ADD64AA(v, a, b);
      ADD64AC(v, a, y0, y1);
      xor0 = v[d] ^ v[a];
      xor1 = v[d + 1] ^ v[a + 1];
      v[d] = xor0 >>> 16 ^ xor1 << 16;
      v[d + 1] = xor1 >>> 16 ^ xor0 << 16;
      ADD64AA(v, c, d);
      xor0 = v[b] ^ v[c];
      xor1 = v[b + 1] ^ v[c + 1];
      v[b] = xor1 >>> 31 ^ xor0 << 1;
      v[b + 1] = xor0 >>> 31 ^ xor1 << 1;
    }
    var BLAKE2B_IV32 = new Uint32Array([
      4089235720,
      1779033703,
      2227873595,
      3144134277,
      4271175723,
      1013904242,
      1595750129,
      2773480762,
      2917565137,
      1359893119,
      725511199,
      2600822924,
      4215389547,
      528734635,
      327033209,
      1541459225
    ]);
    var SIGMA8 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3
    ];
    var SIGMA82 = new Uint8Array(
      SIGMA8.map(function(x) {
        return x * 2;
      })
    );
    var v = new Uint32Array(32);
    var m = new Uint32Array(32);
    function blake2bCompress(ctx, last3) {
      let i = 0;
      for (i = 0; i < 16; i++) {
        v[i] = ctx.h[i];
        v[i + 16] = BLAKE2B_IV32[i];
      }
      v[24] = v[24] ^ ctx.t;
      v[25] = v[25] ^ ctx.t / 4294967296;
      if (last3) {
        v[28] = ~v[28];
        v[29] = ~v[29];
      }
      for (i = 0; i < 32; i++) {
        m[i] = B2B_GET32(ctx.b, 4 * i);
      }
      for (i = 0; i < 12; i++) {
        B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);
        B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);
        B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);
        B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);
        B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);
        B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);
        B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);
        B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);
      }
      for (i = 0; i < 16; i++) {
        ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16];
      }
    }
    var parameterBlock = new Uint8Array([
      0,
      0,
      0,
      0,
      //  0: outlen, keylen, fanout, depth
      0,
      0,
      0,
      0,
      //  4: leaf length, sequential mode
      0,
      0,
      0,
      0,
      //  8: node offset
      0,
      0,
      0,
      0,
      // 12: node offset
      0,
      0,
      0,
      0,
      // 16: node depth, inner length, rfu
      0,
      0,
      0,
      0,
      // 20: rfu
      0,
      0,
      0,
      0,
      // 24: rfu
      0,
      0,
      0,
      0,
      // 28: rfu
      0,
      0,
      0,
      0,
      // 32: salt
      0,
      0,
      0,
      0,
      // 36: salt
      0,
      0,
      0,
      0,
      // 40: salt
      0,
      0,
      0,
      0,
      // 44: salt
      0,
      0,
      0,
      0,
      // 48: personal
      0,
      0,
      0,
      0,
      // 52: personal
      0,
      0,
      0,
      0,
      // 56: personal
      0,
      0,
      0,
      0
      // 60: personal
    ]);
    function blake2bInit(outlen, key, salt, personal) {
      if (outlen === 0 || outlen > 64) {
        throw new Error("Illegal output length, expected 0 < length <= 64");
      }
      if (key && key.length > 64) {
        throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
      }
      if (salt && salt.length !== 16) {
        throw new Error("Illegal salt, expected Uint8Array with length is 16");
      }
      if (personal && personal.length !== 16) {
        throw new Error("Illegal personal, expected Uint8Array with length is 16");
      }
      const ctx = {
        b: new Uint8Array(128),
        h: new Uint32Array(16),
        t: 0,
        // input count
        c: 0,
        // pointer within buffer
        outlen
        // output length in bytes
      };
      parameterBlock.fill(0);
      parameterBlock[0] = outlen;
      if (key)
        parameterBlock[1] = key.length;
      parameterBlock[2] = 1;
      parameterBlock[3] = 1;
      if (salt)
        parameterBlock.set(salt, 32);
      if (personal)
        parameterBlock.set(personal, 48);
      for (let i = 0; i < 16; i++) {
        ctx.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameterBlock, i * 4);
      }
      if (key) {
        blake2bUpdate(ctx, key);
        ctx.c = 128;
      }
      return ctx;
    }
    function blake2bUpdate(ctx, input) {
      for (let i = 0; i < input.length; i++) {
        if (ctx.c === 128) {
          ctx.t += ctx.c;
          blake2bCompress(ctx, false);
          ctx.c = 0;
        }
        ctx.b[ctx.c++] = input[i];
      }
    }
    function blake2bFinal(ctx) {
      ctx.t += ctx.c;
      while (ctx.c < 128) {
        ctx.b[ctx.c++] = 0;
      }
      blake2bCompress(ctx, true);
      const out = new Uint8Array(ctx.outlen);
      for (let i = 0; i < ctx.outlen; i++) {
        out[i] = ctx.h[i >> 2] >> 8 * (i & 3);
      }
      return out;
    }
    function blake2b(input, key, outlen, salt, personal) {
      outlen = outlen || 64;
      input = util.normalizeInput(input);
      if (salt) {
        salt = util.normalizeInput(salt);
      }
      if (personal) {
        personal = util.normalizeInput(personal);
      }
      const ctx = blake2bInit(outlen, key, salt, personal);
      blake2bUpdate(ctx, input);
      return blake2bFinal(ctx);
    }
    function blake2bHex(input, key, outlen, salt, personal) {
      const output = blake2b(input, key, outlen, salt, personal);
      return util.toHex(output);
    }
    module.exports = {
      blake2b,
      blake2bHex,
      blake2bInit,
      blake2bUpdate,
      blake2bFinal
    };
  }
});

// node_modules/blakejs/blake2s.js
var require_blake2s = __commonJS({
  "node_modules/blakejs/blake2s.js"(exports, module) {
    var util = require_util();
    function B2S_GET32(v2, i) {
      return v2[i] ^ v2[i + 1] << 8 ^ v2[i + 2] << 16 ^ v2[i + 3] << 24;
    }
    function B2S_G(a, b, c, d, x, y) {
      v[a] = v[a] + v[b] + x;
      v[d] = ROTR32(v[d] ^ v[a], 16);
      v[c] = v[c] + v[d];
      v[b] = ROTR32(v[b] ^ v[c], 12);
      v[a] = v[a] + v[b] + y;
      v[d] = ROTR32(v[d] ^ v[a], 8);
      v[c] = v[c] + v[d];
      v[b] = ROTR32(v[b] ^ v[c], 7);
    }
    function ROTR32(x, y) {
      return x >>> y ^ x << 32 - y;
    }
    var BLAKE2S_IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SIGMA = new Uint8Array([
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0
    ]);
    var v = new Uint32Array(16);
    var m = new Uint32Array(16);
    function blake2sCompress(ctx, last3) {
      let i = 0;
      for (i = 0; i < 8; i++) {
        v[i] = ctx.h[i];
        v[i + 8] = BLAKE2S_IV[i];
      }
      v[12] ^= ctx.t;
      v[13] ^= ctx.t / 4294967296;
      if (last3) {
        v[14] = ~v[14];
      }
      for (i = 0; i < 16; i++) {
        m[i] = B2S_GET32(ctx.b, 4 * i);
      }
      for (i = 0; i < 10; i++) {
        B2S_G(0, 4, 8, 12, m[SIGMA[i * 16 + 0]], m[SIGMA[i * 16 + 1]]);
        B2S_G(1, 5, 9, 13, m[SIGMA[i * 16 + 2]], m[SIGMA[i * 16 + 3]]);
        B2S_G(2, 6, 10, 14, m[SIGMA[i * 16 + 4]], m[SIGMA[i * 16 + 5]]);
        B2S_G(3, 7, 11, 15, m[SIGMA[i * 16 + 6]], m[SIGMA[i * 16 + 7]]);
        B2S_G(0, 5, 10, 15, m[SIGMA[i * 16 + 8]], m[SIGMA[i * 16 + 9]]);
        B2S_G(1, 6, 11, 12, m[SIGMA[i * 16 + 10]], m[SIGMA[i * 16 + 11]]);
        B2S_G(2, 7, 8, 13, m[SIGMA[i * 16 + 12]], m[SIGMA[i * 16 + 13]]);
        B2S_G(3, 4, 9, 14, m[SIGMA[i * 16 + 14]], m[SIGMA[i * 16 + 15]]);
      }
      for (i = 0; i < 8; i++) {
        ctx.h[i] ^= v[i] ^ v[i + 8];
      }
    }
    function blake2sInit(outlen, key) {
      if (!(outlen > 0 && outlen <= 32)) {
        throw new Error("Incorrect output length, should be in [1, 32]");
      }
      const keylen = key ? key.length : 0;
      if (key && !(keylen > 0 && keylen <= 32)) {
        throw new Error("Incorrect key length, should be in [1, 32]");
      }
      const ctx = {
        h: new Uint32Array(BLAKE2S_IV),
        // hash state
        b: new Uint8Array(64),
        // input block
        c: 0,
        // pointer within block
        t: 0,
        // input count
        outlen
        // output length in bytes
      };
      ctx.h[0] ^= 16842752 ^ keylen << 8 ^ outlen;
      if (keylen > 0) {
        blake2sUpdate(ctx, key);
        ctx.c = 64;
      }
      return ctx;
    }
    function blake2sUpdate(ctx, input) {
      for (let i = 0; i < input.length; i++) {
        if (ctx.c === 64) {
          ctx.t += ctx.c;
          blake2sCompress(ctx, false);
          ctx.c = 0;
        }
        ctx.b[ctx.c++] = input[i];
      }
    }
    function blake2sFinal(ctx) {
      ctx.t += ctx.c;
      while (ctx.c < 64) {
        ctx.b[ctx.c++] = 0;
      }
      blake2sCompress(ctx, true);
      const out = new Uint8Array(ctx.outlen);
      for (let i = 0; i < ctx.outlen; i++) {
        out[i] = ctx.h[i >> 2] >> 8 * (i & 3) & 255;
      }
      return out;
    }
    function blake2s(input, key, outlen) {
      outlen = outlen || 32;
      input = util.normalizeInput(input);
      const ctx = blake2sInit(outlen, key);
      blake2sUpdate(ctx, input);
      return blake2sFinal(ctx);
    }
    function blake2sHex(input, key, outlen) {
      const output = blake2s(input, key, outlen);
      return util.toHex(output);
    }
    module.exports = {
      blake2s,
      blake2sHex,
      blake2sInit,
      blake2sUpdate,
      blake2sFinal
    };
  }
});

// node_modules/blakejs/index.js
var require_blakejs = __commonJS({
  "node_modules/blakejs/index.js"(exports, module) {
    var b2b = require_blake2b2();
    var b2s = require_blake2s();
    module.exports = {
      blake2b: b2b.blake2b,
      blake2bHex: b2b.blake2bHex,
      blake2bInit: b2b.blake2bInit,
      blake2bUpdate: b2b.blake2bUpdate,
      blake2bFinal: b2b.blake2bFinal,
      blake2s: b2s.blake2s,
      blake2sHex: b2s.blake2sHex,
      blake2sInit: b2s.blake2sInit,
      blake2sUpdate: b2s.blake2sUpdate,
      blake2sFinal: b2s.blake2sFinal
    };
  }
});

// node_modules/typedarray-to-buffer/index.js
var require_typedarray_to_buffer = __commonJS({
  "node_modules/typedarray-to-buffer/index.js"(exports, module) {
    module.exports = function typedarrayToBuffer(arr) {
      return ArrayBuffer.isView(arr) ? Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength) : Buffer.from(arr);
    };
  }
});

// node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS({
  "node_modules/fast-json-stable-stringify/index.js"(exports, module) {
    "use strict";
    module.exports = function(data, opts) {
      if (!opts)
        opts = {};
      if (typeof opts === "function")
        opts = { cmp: opts };
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var cmp = opts.cmp && function(f) {
        return function(node) {
          return function(a, b) {
            var aobj = { key: a, value: node[a] };
            var bobj = { key: b, value: node[b] };
            return f(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return function stringify2(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        if (node === void 0)
          return;
        if (typeof node == "number")
          return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object")
          return JSON.stringify(node);
        var i, out;
        if (Array.isArray(node)) {
          out = "[";
          for (i = 0; i < node.length; i++) {
            if (i)
              out += ",";
            out += stringify2(node[i]) || "null";
          }
          return out + "]";
        }
        if (node === null)
          return "null";
        if (seen.indexOf(node) !== -1) {
          if (cycles)
            return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          var value = stringify2(node[key]);
          if (!value)
            continue;
          if (out)
            out += ",";
          out += JSON.stringify(key) + ":" + value;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
      }(data);
    };
  }
});

// node_modules/@taquito/http-utils/dist/taquito-http-utils.es6.js
var import_axios = __toESM(require_axios2());
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var settle = require_settle();
var buildURL = require_buildURL();
var buildFullPath = require_buildFullPath();
var { isUndefined, isStandardBrowserEnv, isFormData } = require_utils();
function fetchAdapter(config2) {
  return __awaiter(this, void 0, void 0, function* () {
    const request = createRequest(config2);
    const promiseChain = [getResponse(request, config2)];
    if (config2.timeout && config2.timeout > 0) {
      promiseChain.push(new Promise((res) => {
        setTimeout(() => {
          const message = config2.timeoutErrorMessage ? config2.timeoutErrorMessage : "timeout of " + config2.timeout + "ms exceeded";
          res(createError(message, config2, "ECONNABORTED", request));
        }, config2.timeout);
      }));
    }
    const data = yield Promise.race(promiseChain);
    return new Promise((resolve, reject) => {
      if (data instanceof Error) {
        reject(data);
      } else {
        const c = config2;
        "settle" in c && Object.prototype.toString.call(c.settle) === "[object Function]" ? c.settle(resolve, reject, data) : settle(resolve, reject, data);
      }
    });
  });
}
function getResponse(request, config2) {
  return __awaiter(this, void 0, void 0, function* () {
    try {
      const stageOne = yield fetch(request);
      let response = {
        ok: stageOne.ok,
        status: stageOne.status,
        statusText: stageOne.statusText,
        headers: new Headers(stageOne.headers),
        config: config2,
        request
      };
      if (stageOne.status >= 400) {
        return createError("Response Error", config2, "ERR_NETWORK", request, response);
      }
      response = {
        ok: stageOne.ok,
        status: stageOne.status,
        statusText: stageOne.statusText,
        headers: new Headers(stageOne.headers),
        config: config2,
        request
      };
      if (stageOne.status >= 200 && stageOne.status !== 204) {
        switch (config2.responseType) {
          case "arraybuffer":
            response.data = yield stageOne.arrayBuffer();
            break;
          case "blob":
            response.data = yield stageOne.blob();
            break;
          case "json":
            response.data = yield stageOne.json();
            break;
          default:
            response.data = yield stageOne.text();
            break;
        }
      }
      return response;
    } catch (e) {
      return createError("Network Error", config2, "ERR_NETWORK", request);
    }
  });
}
function createRequest(config2) {
  var _a3;
  const headers = new Headers(config2.headers);
  if (config2.auth) {
    const username = config2.auth.username || "";
    const password = config2.auth.password ? decodeURI(encodeURIComponent(config2.auth.password)) : "";
    headers.set("Authorization", `Basic ${btoa(username + ":" + password)}`);
  }
  const method = (_a3 = config2.method) === null || _a3 === void 0 ? void 0 : _a3.toUpperCase();
  const options = {
    headers,
    method
  };
  if (method !== "GET" && method !== "HEAD") {
    options.body = config2.data;
    if (isFormData(options.body) && isStandardBrowserEnv()) {
      headers.delete("Content-Type");
    }
  }
  const c = config2;
  if ("mode" in c) {
    options.mode = c.mode;
  }
  if ("cache" in c) {
    options.cache = c.cache;
  }
  if ("integrity" in c) {
    options.integrity = c.integrity;
  }
  if ("redirect" in c) {
    options.redirect = c.redirect;
  }
  if ("referrer" in c) {
    options.referrer = c.referrer;
  }
  if (!isUndefined(c.withCredentials)) {
    options.credentials = c.withCredentials ? "include" : "omit";
  }
  const fullPath = buildFullPath(c.baseURL, c.url);
  const url = buildURL(fullPath, c.params, c.paramsSerializer);
  return new Request(url, options);
}
function createError(message, config2, code2, request, response) {
  const error = new Error(message);
  return enhanceError(error, config2, code2, request, response);
}
function enhanceError(error, config2, code2, request, response) {
  error.config = config2;
  if (code2) {
    error.code = code2;
  }
  error.request = request;
  error.response = response;
  error.isAxiosError = true;
  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: "description" in this ? this.description : void 0,
      number: "number" in this ? this.number : void 0,
      // Mozilla
      fileName: "fileName" in this ? this.fileName : void 0,
      lineNumber: "lineNumber" in this ? this.lineNumber : void 0,
      columnNumber: "columnNumber" in this ? this.columnNumber : void 0,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  };
  return error;
}
var HttpRequestFailed = class extends NetworkError {
  constructor(method, url, cause) {
    super();
    this.method = method;
    this.url = url;
    this.cause = cause;
    this.name = "HttpRequestFailed";
    this.message = `${method} ${url} ${String(cause)}`;
  }
};
var HttpResponseError = class extends NetworkError {
  constructor(message, status, statusText, body, url) {
    super();
    this.message = message;
    this.status = status;
    this.statusText = statusText;
    this.body = body;
    this.url = url;
    this.name = "HttpResponse";
  }
};
var STATUS_CODE;
(function(STATUS_CODE2) {
  STATUS_CODE2[STATUS_CODE2["CONTINUE"] = 100] = "CONTINUE";
  STATUS_CODE2[STATUS_CODE2["SWITCHING_PROTOCOLS"] = 101] = "SWITCHING_PROTOCOLS";
  STATUS_CODE2[STATUS_CODE2["PROCESSING"] = 102] = "PROCESSING";
  STATUS_CODE2[STATUS_CODE2["OK"] = 200] = "OK";
  STATUS_CODE2[STATUS_CODE2["CREATED"] = 201] = "CREATED";
  STATUS_CODE2[STATUS_CODE2["ACCEPTED"] = 202] = "ACCEPTED";
  STATUS_CODE2[STATUS_CODE2["NON_AUTHORITATIVE_INFORMATION"] = 203] = "NON_AUTHORITATIVE_INFORMATION";
  STATUS_CODE2[STATUS_CODE2["NO_CONTENT"] = 204] = "NO_CONTENT";
  STATUS_CODE2[STATUS_CODE2["RESET_CONTENT"] = 205] = "RESET_CONTENT";
  STATUS_CODE2[STATUS_CODE2["PARTIAL_CONTENT"] = 206] = "PARTIAL_CONTENT";
  STATUS_CODE2[STATUS_CODE2["MULTI_STATUS"] = 207] = "MULTI_STATUS";
  STATUS_CODE2[STATUS_CODE2["ALREADY_REPORTED"] = 208] = "ALREADY_REPORTED";
  STATUS_CODE2[STATUS_CODE2["IM_USED"] = 226] = "IM_USED";
  STATUS_CODE2[STATUS_CODE2["MULTIPLE_CHOICES"] = 300] = "MULTIPLE_CHOICES";
  STATUS_CODE2[STATUS_CODE2["MOVED_PERMANENTLY"] = 301] = "MOVED_PERMANENTLY";
  STATUS_CODE2[STATUS_CODE2["FOUND"] = 302] = "FOUND";
  STATUS_CODE2[STATUS_CODE2["SEE_OTHER"] = 303] = "SEE_OTHER";
  STATUS_CODE2[STATUS_CODE2["NOT_MODIFIED"] = 304] = "NOT_MODIFIED";
  STATUS_CODE2[STATUS_CODE2["USE_PROXY"] = 305] = "USE_PROXY";
  STATUS_CODE2[STATUS_CODE2["SWITCH_PROXY"] = 306] = "SWITCH_PROXY";
  STATUS_CODE2[STATUS_CODE2["TEMPORARY_REDIRECT"] = 307] = "TEMPORARY_REDIRECT";
  STATUS_CODE2[STATUS_CODE2["PERMANENT_REDIRECT"] = 308] = "PERMANENT_REDIRECT";
  STATUS_CODE2[STATUS_CODE2["BAD_REQUEST"] = 400] = "BAD_REQUEST";
  STATUS_CODE2[STATUS_CODE2["UNAUTHORIZED"] = 401] = "UNAUTHORIZED";
  STATUS_CODE2[STATUS_CODE2["PAYMENT_REQUIRED"] = 402] = "PAYMENT_REQUIRED";
  STATUS_CODE2[STATUS_CODE2["FORBIDDEN"] = 403] = "FORBIDDEN";
  STATUS_CODE2[STATUS_CODE2["NOT_FOUND"] = 404] = "NOT_FOUND";
  STATUS_CODE2[STATUS_CODE2["METHOD_NOT_ALLOWED"] = 405] = "METHOD_NOT_ALLOWED";
  STATUS_CODE2[STATUS_CODE2["NOT_ACCEPTABLE"] = 406] = "NOT_ACCEPTABLE";
  STATUS_CODE2[STATUS_CODE2["PROXY_AUTHENTICATION_REQUIRED"] = 407] = "PROXY_AUTHENTICATION_REQUIRED";
  STATUS_CODE2[STATUS_CODE2["REQUEST_TIMEOUT"] = 408] = "REQUEST_TIMEOUT";
  STATUS_CODE2[STATUS_CODE2["CONFLICT"] = 409] = "CONFLICT";
  STATUS_CODE2[STATUS_CODE2["GONE"] = 410] = "GONE";
  STATUS_CODE2[STATUS_CODE2["LENGTH_REQUIRED"] = 411] = "LENGTH_REQUIRED";
  STATUS_CODE2[STATUS_CODE2["PRECONDITION_FAILED"] = 412] = "PRECONDITION_FAILED";
  STATUS_CODE2[STATUS_CODE2["PAYLOAD_TOO_LARGE"] = 413] = "PAYLOAD_TOO_LARGE";
  STATUS_CODE2[STATUS_CODE2["URI_TOO_LONG"] = 414] = "URI_TOO_LONG";
  STATUS_CODE2[STATUS_CODE2["UNSUPPORTED_MEDIA_TYPE"] = 415] = "UNSUPPORTED_MEDIA_TYPE";
  STATUS_CODE2[STATUS_CODE2["RANGE_NOT_SATISFIABLE"] = 416] = "RANGE_NOT_SATISFIABLE";
  STATUS_CODE2[STATUS_CODE2["EXPECTATION_FAILED"] = 417] = "EXPECTATION_FAILED";
  STATUS_CODE2[STATUS_CODE2["I_AM_A_TEAPOT"] = 418] = "I_AM_A_TEAPOT";
  STATUS_CODE2[STATUS_CODE2["MISDIRECTED_REQUEST"] = 421] = "MISDIRECTED_REQUEST";
  STATUS_CODE2[STATUS_CODE2["UNPROCESSABLE_ENTITY"] = 422] = "UNPROCESSABLE_ENTITY";
  STATUS_CODE2[STATUS_CODE2["LOCKED"] = 423] = "LOCKED";
  STATUS_CODE2[STATUS_CODE2["FAILED_DEPENDENCY"] = 424] = "FAILED_DEPENDENCY";
  STATUS_CODE2[STATUS_CODE2["UPGRADE_REQUIRED"] = 426] = "UPGRADE_REQUIRED";
  STATUS_CODE2[STATUS_CODE2["PRECONDITION_REQUIRED"] = 428] = "PRECONDITION_REQUIRED";
  STATUS_CODE2[STATUS_CODE2["TOO_MANY_REQUESTS"] = 429] = "TOO_MANY_REQUESTS";
  STATUS_CODE2[STATUS_CODE2["REQUEST_HEADER_FIELDS_TOO_LARGE"] = 431] = "REQUEST_HEADER_FIELDS_TOO_LARGE";
  STATUS_CODE2[STATUS_CODE2["UNAVAILABLE_FOR_LEGAL_REASONS"] = 451] = "UNAVAILABLE_FOR_LEGAL_REASONS";
  STATUS_CODE2[STATUS_CODE2["INTERNAL_SERVER_ERROR"] = 500] = "INTERNAL_SERVER_ERROR";
  STATUS_CODE2[STATUS_CODE2["NOT_IMPLEMENTED"] = 501] = "NOT_IMPLEMENTED";
  STATUS_CODE2[STATUS_CODE2["BAD_GATEWAY"] = 502] = "BAD_GATEWAY";
  STATUS_CODE2[STATUS_CODE2["SERVICE_UNAVAILABLE"] = 503] = "SERVICE_UNAVAILABLE";
  STATUS_CODE2[STATUS_CODE2["GATEWAY_TIMEOUT"] = 504] = "GATEWAY_TIMEOUT";
  STATUS_CODE2[STATUS_CODE2["HTTP_VERSION_NOT_SUPPORTED"] = 505] = "HTTP_VERSION_NOT_SUPPORTED";
  STATUS_CODE2[STATUS_CODE2["VARIANT_ALSO_NEGOTIATES"] = 506] = "VARIANT_ALSO_NEGOTIATES";
  STATUS_CODE2[STATUS_CODE2["INSUFFICIENT_STORAGE"] = 507] = "INSUFFICIENT_STORAGE";
  STATUS_CODE2[STATUS_CODE2["LOOP_DETECTED"] = 508] = "LOOP_DETECTED";
  STATUS_CODE2[STATUS_CODE2["NOT_EXTENDED"] = 510] = "NOT_EXTENDED";
  STATUS_CODE2[STATUS_CODE2["NETWORK_AUTHENTICATION_REQUIRED"] = 511] = "NETWORK_AUTHENTICATION_REQUIRED";
})(STATUS_CODE || (STATUS_CODE = {}));
var _a;
var isNode = typeof process !== "undefined" && !!((_a = process === null || process === void 0 ? void 0 : process.versions) === null || _a === void 0 ? void 0 : _a.node);
var adapter = isNode ? void 0 : fetchAdapter;
var ResponseType;
(function(ResponseType2) {
  ResponseType2["TEXT"] = "text";
  ResponseType2["JSON"] = "json";
})(ResponseType || (ResponseType = {}));
var HttpBackend = class {
  constructor(timeout2 = 3e4) {
    this.timeout = timeout2;
  }
  serialize(obj) {
    if (!obj) {
      return "";
    }
    const str = [];
    for (const p in obj) {
      if (obj.hasOwnProperty(p) && typeof obj[p] !== "undefined") {
        const prop = typeof obj[p].toJSON === "function" ? obj[p].toJSON() : obj[p];
        if (prop === null) {
          str.push(encodeURIComponent(p));
          continue;
        }
        if (Array.isArray(prop)) {
          prop.forEach((item) => {
            str.push(encodeURIComponent(p) + "=" + encodeURIComponent(item));
          });
          continue;
        }
        str.push(encodeURIComponent(p) + "=" + encodeURIComponent(prop));
      }
    }
    const serialized = str.join("&");
    if (serialized) {
      return `?${serialized}`;
    } else {
      return "";
    }
  }
  /**
   *
   * @param options contains options to be passed for the HTTP request (url, method and timeout)
   * @throws {@link HttpRequestFailed} | {@link HttpResponseError}
   */
  createRequest({ url, method, timeout: timeout2 = this.timeout, query, headers = {}, json = true }, data) {
    return __awaiter(this, void 0, void 0, function* () {
      const urlWithQuery = url + this.serialize(query);
      let resType;
      let transformResponse = void 0;
      if (!headers["Content-Type"]) {
        headers["Content-Type"] = "application/json";
      }
      if (!json) {
        resType = ResponseType.TEXT;
        transformResponse = [(v) => v];
      } else {
        resType = ResponseType.JSON;
      }
      try {
        const response = yield import_axios.default.request({
          url: urlWithQuery,
          method: method !== null && method !== void 0 ? method : "GET",
          headers,
          responseType: resType,
          transformResponse,
          timeout: timeout2,
          data,
          adapter
        });
        return response.data;
      } catch (err) {
        if (import_axios.default.isAxiosError(err) && err.response || !isNode && err.response) {
          let errorData;
          if (typeof err.response.data === "object") {
            errorData = JSON.stringify(err.response.data);
          } else {
            errorData = err.response.data;
          }
          throw new HttpResponseError(`Http error response: (${err.response.status}) ${errorData}`, err.response.status, err.response.statusText, errorData, urlWithQuery);
        } else {
          throw new HttpRequestFailed(String(method), urlWithQuery, err);
        }
      }
    });
  }
};

// node_modules/@taquito/utils/dist/taquito-utils.es6.js
var import_buffer = __toESM(require_buffer());
var import_ed25519 = __toESM(require_ed25519());
var import_blake2b = __toESM(require_blake2b());
var import_blakejs = __toESM(require_blakejs());
var import_bs58check = __toESM(require_bs58check());
var import_elliptic = __toESM(require_elliptic());
var import_typedarray_to_buffer = __toESM(require_typedarray_to_buffer());
var Prefix;
(function(Prefix2) {
  Prefix2["TZ1"] = "tz1";
  Prefix2["TZ2"] = "tz2";
  Prefix2["TZ3"] = "tz3";
  Prefix2["TZ4"] = "tz4";
  Prefix2["KT"] = "KT";
  Prefix2["KT1"] = "KT1";
  Prefix2["EDSK2"] = "edsk2";
  Prefix2["SPSK"] = "spsk";
  Prefix2["P2SK"] = "p2sk";
  Prefix2["EDPK"] = "edpk";
  Prefix2["SPPK"] = "sppk";
  Prefix2["P2PK"] = "p2pk";
  Prefix2["BLPK"] = "BLpk";
  Prefix2["EDESK"] = "edesk";
  Prefix2["SPESK"] = "spesk";
  Prefix2["P2ESK"] = "p2esk";
  Prefix2["EDSK"] = "edsk";
  Prefix2["EDSIG"] = "edsig";
  Prefix2["SPSIG"] = "spsig";
  Prefix2["P2SIG"] = "p2sig";
  Prefix2["SIG"] = "sig";
  Prefix2["NET"] = "Net";
  Prefix2["NCE"] = "nce";
  Prefix2["B"] = "B";
  Prefix2["O"] = "o";
  Prefix2["LO"] = "Lo";
  Prefix2["LLO"] = "LLo";
  Prefix2["P"] = "P";
  Prefix2["CO"] = "Co";
  Prefix2["ID"] = "id";
  Prefix2["EXPR"] = "expr";
  Prefix2["TZ"] = "TZ";
  Prefix2["VH"] = "vh";
  Prefix2["SASK"] = "sask";
  Prefix2["ZET1"] = "zet1";
  Prefix2["TXR1"] = "txr1";
  Prefix2["TXI"] = "txi";
  Prefix2["TXM"] = "txm";
  Prefix2["TXC"] = "txc";
  Prefix2["TXMR"] = "txmr";
  Prefix2["TXRL"] = "txM";
  Prefix2["TXW"] = "txw";
  Prefix2["SR1"] = "sr1";
  Prefix2["SRC1"] = "src1";
})(Prefix || (Prefix = {}));
var prefix = {
  [Prefix.TZ1]: new Uint8Array([6, 161, 159]),
  [Prefix.TZ2]: new Uint8Array([6, 161, 161]),
  [Prefix.TZ3]: new Uint8Array([6, 161, 164]),
  [Prefix.TZ4]: new Uint8Array([6, 161, 166]),
  [Prefix.KT]: new Uint8Array([2, 90, 121]),
  [Prefix.KT1]: new Uint8Array([2, 90, 121]),
  [Prefix.EDSK]: new Uint8Array([43, 246, 78, 7]),
  [Prefix.EDSK2]: new Uint8Array([13, 15, 58, 7]),
  [Prefix.SPSK]: new Uint8Array([17, 162, 224, 201]),
  [Prefix.P2SK]: new Uint8Array([16, 81, 238, 189]),
  [Prefix.EDPK]: new Uint8Array([13, 15, 37, 217]),
  [Prefix.SPPK]: new Uint8Array([3, 254, 226, 86]),
  [Prefix.P2PK]: new Uint8Array([3, 178, 139, 127]),
  [Prefix.BLPK]: new Uint8Array([6, 149, 135, 204]),
  [Prefix.EDESK]: new Uint8Array([7, 90, 60, 179, 41]),
  [Prefix.SPESK]: new Uint8Array([9, 237, 241, 174, 150]),
  [Prefix.P2ESK]: new Uint8Array([9, 48, 57, 115, 171]),
  [Prefix.EDSIG]: new Uint8Array([9, 245, 205, 134, 18]),
  [Prefix.SPSIG]: new Uint8Array([13, 115, 101, 19, 63]),
  [Prefix.P2SIG]: new Uint8Array([54, 240, 44, 52]),
  [Prefix.SIG]: new Uint8Array([4, 130, 43]),
  [Prefix.NET]: new Uint8Array([87, 82, 0]),
  [Prefix.NCE]: new Uint8Array([69, 220, 169]),
  [Prefix.B]: new Uint8Array([1, 52]),
  [Prefix.O]: new Uint8Array([5, 116]),
  [Prefix.LO]: new Uint8Array([133, 233]),
  [Prefix.LLO]: new Uint8Array([29, 159, 109]),
  [Prefix.P]: new Uint8Array([2, 170]),
  [Prefix.CO]: new Uint8Array([79, 179]),
  [Prefix.ID]: new Uint8Array([153, 103]),
  [Prefix.EXPR]: new Uint8Array([13, 44, 64, 27]),
  // Legacy prefix
  [Prefix.TZ]: new Uint8Array([2, 90, 121]),
  [Prefix.VH]: new Uint8Array([1, 106, 242]),
  [Prefix.SASK]: new Uint8Array([11, 237, 20, 92]),
  [Prefix.ZET1]: new Uint8Array([18, 71, 40, 223]),
  [Prefix.TXR1]: new Uint8Array([1, 128, 120, 31]),
  [Prefix.TXI]: new Uint8Array([79, 148, 196]),
  [Prefix.TXM]: new Uint8Array([79, 149, 30]),
  [Prefix.TXC]: new Uint8Array([79, 148, 17]),
  [Prefix.TXMR]: new Uint8Array([18, 7, 206, 87]),
  [Prefix.TXRL]: new Uint8Array([79, 146, 82]),
  [Prefix.TXW]: new Uint8Array([79, 150, 72]),
  [Prefix.SR1]: new Uint8Array([6, 124, 117]),
  [Prefix.SRC1]: new Uint8Array([17, 165, 134, 138])
};
var prefixLength = {
  [Prefix.TZ1]: 20,
  [Prefix.TZ2]: 20,
  [Prefix.TZ3]: 20,
  [Prefix.TZ4]: 20,
  [Prefix.KT]: 20,
  [Prefix.KT1]: 20,
  [Prefix.EDPK]: 32,
  [Prefix.SPPK]: 33,
  [Prefix.P2PK]: 33,
  //working with value in comment for base58.ml line 445 but not consistent with the three above
  [Prefix.BLPK]: 48,
  [Prefix.EDSIG]: 64,
  [Prefix.SPSIG]: 64,
  [Prefix.P2SIG]: 64,
  [Prefix.SIG]: 64,
  [Prefix.NET]: 4,
  [Prefix.B]: 32,
  [Prefix.P]: 32,
  [Prefix.O]: 32,
  [Prefix.VH]: 32,
  [Prefix.SASK]: 169,
  [Prefix.ZET1]: 43,
  [Prefix.TXR1]: 20,
  [Prefix.TXI]: 32,
  [Prefix.TXM]: 32,
  [Prefix.TXC]: 32,
  [Prefix.TXMR]: 32,
  [Prefix.TXRL]: 32,
  [Prefix.TXW]: 32,
  [Prefix.SR1]: 20,
  [Prefix.SRC1]: 32
};
var ValueConversionError = class extends UnsupportedActionError {
  constructor(value, desiredType) {
    super();
    this.value = value;
    this.desiredType = desiredType;
    this.name = "ValueConversionError";
    this.message = `Unable to convert ${value} to a ${desiredType}`;
  }
};
var ValidationResult;
(function(ValidationResult2) {
  ValidationResult2[ValidationResult2["NO_PREFIX_MATCHED"] = 0] = "NO_PREFIX_MATCHED";
  ValidationResult2[ValidationResult2["INVALID_CHECKSUM"] = 1] = "INVALID_CHECKSUM";
  ValidationResult2[ValidationResult2["INVALID_LENGTH"] = 2] = "INVALID_LENGTH";
  ValidationResult2[ValidationResult2["VALID"] = 3] = "VALID";
})(ValidationResult || (ValidationResult = {}));
function isValidPrefix(value) {
  if (typeof value !== "string") {
    return false;
  }
  return value in prefix;
}
function validatePrefixedValue(value, prefixes) {
  const match = new RegExp(`^(${prefixes.join("|")})`).exec(value);
  if (!match || match.length === 0) {
    return ValidationResult.NO_PREFIX_MATCHED;
  }
  const prefixKey = match[0];
  if (!isValidPrefix(prefixKey)) {
    return ValidationResult.NO_PREFIX_MATCHED;
  }
  if (value.includes("%")) {
    value = value.split("%")[0];
  }
  const kt1Regex = /^(KT1\w{33})$/;
  if (!kt1Regex.test(value) && prefixKey === "KT1") {
    return ValidationResult.INVALID_CHECKSUM;
  }
  let decoded = import_bs58check.default.decodeUnsafe(value);
  if (!decoded) {
    return ValidationResult.INVALID_CHECKSUM;
  }
  decoded = decoded.slice(prefix[prefixKey].length);
  if (decoded.length !== prefixLength[prefixKey]) {
    return ValidationResult.INVALID_LENGTH;
  }
  return ValidationResult.VALID;
}
var implicitPrefix = [Prefix.TZ1, Prefix.TZ2, Prefix.TZ3, Prefix.TZ4];
var contractPrefix = [Prefix.KT1, Prefix.TXR1];
var signaturePrefix = [Prefix.EDSIG, Prefix.P2SIG, Prefix.SPSIG, Prefix.SIG];
var pkPrefix = [Prefix.EDPK, Prefix.SPPK, Prefix.P2PK, Prefix.BLPK];
var operationPrefix = [Prefix.O];
var protocolPrefix = [Prefix.P];
var blockPrefix = [Prefix.B];
var smartRollupPrefix = [Prefix.SR1];
function validateAddress(value) {
  return validatePrefixedValue(value, [...implicitPrefix, ...contractPrefix, ...smartRollupPrefix]);
}
function validateChain(value) {
  return validatePrefixedValue(value, [Prefix.NET]);
}
function validateContractAddress(value) {
  return validatePrefixedValue(value, contractPrefix);
}
function validateKeyHash(value) {
  return validatePrefixedValue(value, implicitPrefix);
}
function validateSignature(value) {
  return validatePrefixedValue(value, signaturePrefix);
}
function validatePublicKey(value) {
  return validatePrefixedValue(value, pkPrefix);
}
function validateOperation(value) {
  return validatePrefixedValue(value, operationPrefix);
}
function validateBlock(value) {
  return validatePrefixedValue(value, blockPrefix);
}
function invalidDetail(validation) {
  switch (validation) {
    case ValidationResult.NO_PREFIX_MATCHED:
      return "with unsupported prefix";
    case ValidationResult.INVALID_CHECKSUM:
      return "failed checksum";
    case ValidationResult.INVALID_LENGTH:
      return "with incorrect length";
    default:
      return "";
  }
}
var TZ_DECIMALS = 6;
var MTZ_DECIMALS = 3;
function getDecimal(format2) {
  switch (format2) {
    case "tz":
      return TZ_DECIMALS;
    case "mtz":
      return MTZ_DECIMALS;
    case "mutez":
    default:
      return 0;
  }
}
function format(from2 = "mutez", to = "mutez", amount) {
  const bigNum = new bignumber_default(amount);
  if (bigNum.isNaN()) {
    return amount;
  }
  return bigNum.multipliedBy(Math.pow(10, getDecimal(from2))).dividedBy(Math.pow(10, getDecimal(to)));
}
function encodeExpr(value) {
  const blakeHash = import_blakejs.default.blake2b(hex2buf(value), void 0, 32);
  return b58cencode(blakeHash, prefix["expr"]);
}
function b58cencode(value, prefix2) {
  const payloadAr = typeof value === "string" ? Uint8Array.from(import_buffer.Buffer.from(value, "hex")) : value;
  const n = new Uint8Array(prefix2.length + payloadAr.length);
  n.set(prefix2);
  n.set(payloadAr, prefix2.length);
  return import_bs58check.default.encode(import_buffer.Buffer.from(n.buffer));
}
var b58cdecode = (enc, prefixArg) => import_bs58check.default.decode(enc).slice(prefixArg.length);
function b58decode(payload) {
  const buf = import_bs58check.default.decode(payload);
  const prefixMap = {
    [prefix.tz1.toString()]: "0000",
    [prefix.tz2.toString()]: "0001",
    [prefix.tz3.toString()]: "0002"
  };
  const rollupPrefMap = {
    [prefix.txr1.toString()]: "02"
  };
  const pref = prefixMap[new Uint8Array(buf.slice(0, 3)).toString()];
  const rollupPref = rollupPrefMap[new Uint8Array(buf.slice(0, 4)).toString()];
  if (pref) {
    const hex = buf2hex(buf.slice(3));
    return pref + hex;
  } else if (rollupPref) {
    const hex = buf2hex(buf.slice(4));
    return rollupPref + hex + "00";
  } else {
    return "01" + buf2hex(buf.slice(3, 42)) + "00";
  }
}
function b58decodeL2Address(payload) {
  const buf = import_bs58check.default.decode(payload);
  return buf2hex(buf.slice(3, 42));
}
function encodePubKey(value) {
  if (value.substring(0, 2) === "00") {
    const pref = {
      "0000": prefix.tz1,
      "0001": prefix.tz2,
      "0002": prefix.tz3
    };
    return b58cencode(value.substring(4), pref[value.substring(0, 4)]);
  } else if (value.substring(0, 2) === "02") {
    return b58cencode(value.substring(2, value.length - 2), prefix.txr1);
  }
  return b58cencode(value.substring(2, 42), prefix.KT);
}
function encodeL2Address(value) {
  return b58cencode(value, prefix.tz4);
}
function encodeKey(value) {
  if (value[0] === "0") {
    const pref = {
      "00": new Uint8Array([13, 15, 37, 217]),
      "01": new Uint8Array([3, 254, 226, 86]),
      "02": new Uint8Array([3, 178, 139, 127])
    };
    return b58cencode(value.substring(2), pref[value.substring(0, 2)]);
  }
}
function encodeKeyHash(value) {
  if (value[0] === "0") {
    const pref = {
      "00": new Uint8Array([6, 161, 159]),
      "01": new Uint8Array([6, 161, 161]),
      "02": new Uint8Array([6, 161, 164])
    };
    return b58cencode(value.substring(2), pref[value.substring(0, 2)]);
  }
}
var hex2buf = (hex) => {
  if (hex.length % 2 !== 0) {
    throw new InvalidHexStringError(hex, `: Expecting even number of characters`);
  }
  const hexDigits = stripHexPrefix(hex);
  if (!hexDigits.match(/^([\da-f]{2})*$/gi)) {
    throw new InvalidHexStringError(hex, `: Only characters 0-9, a-f and A-F are expected. Optionally, it can be prefixed with '0x'`);
  }
  const out = new Uint8Array(hexDigits.length / 2);
  let j = 0;
  for (let i = 0; i < hexDigits.length; i += 2) {
    const v = parseInt(hexDigits.slice(i, i + 2), 16);
    if (Number.isNaN(v)) {
      throw new ValueConversionError(hex, "Uint8Array");
    }
    out[j++] = v;
  }
  return out;
};
var mergebuf = (b1, b2) => {
  const r = new Uint8Array(b1.length + b2.length);
  r.set(b1);
  r.set(b2, b1.length);
  return r;
};
var buf2hex = (buffer2) => {
  const byteArray = new Uint8Array(buffer2);
  const hexParts = [];
  byteArray.forEach((byte) => {
    const hex = byte.toString(16);
    const paddedHex = `00${hex}`.slice(-2);
    hexParts.push(paddedHex);
  });
  return hexParts.join("");
};
function char2Bytes(str) {
  return import_buffer.Buffer.from(str, "utf8").toString("hex");
}
function bytes2Char(hex) {
  return import_buffer.Buffer.from(hex2buf(hex)).toString("utf8");
}
function stripHexPrefix(hex) {
  return hex.startsWith("0x") ? hex.slice(2) : hex;
}

// node_modules/@taquito/rpc/dist/taquito-rpc.es6.js
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter2(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var defaultChain = "main";
var defaultRPCOptions = { block: "head" };
var RPCMethodName;
(function(RPCMethodName2) {
  RPCMethodName2["GET_BAKING_RIGHTS"] = "getBakingRights";
  RPCMethodName2["GET_BALLOTS"] = "getBallots";
  RPCMethodName2["GET_BALLOT_LIST"] = "getBallotList";
  RPCMethodName2["GET_BIG_MAP_KEY"] = "getBigMapKey";
  RPCMethodName2["GET_BIG_MAP_EXPR"] = "getBigMapExpr";
  RPCMethodName2["GET_BLOCK_HASH"] = "getBlockHash";
  RPCMethodName2["GET_BLOCK"] = "getBlock";
  RPCMethodName2["GET_BLOCK_HEADER"] = "getBlockHeader";
  RPCMethodName2["GET_BLOCK_METADATA"] = "getBlockMetadata";
  RPCMethodName2["GET_BALANCE"] = "getBalance";
  RPCMethodName2["GET_CHAIN_ID"] = "getChainId";
  RPCMethodName2["GET_CONSTANTS"] = "getConstants";
  RPCMethodName2["GET_CONTRACT"] = "getContract";
  RPCMethodName2["GET_CURRENT_PERIOD"] = "getCurrentPeriod";
  RPCMethodName2["GET_CURRENT_PROPOSAL"] = "getCurrentProposal";
  RPCMethodName2["GET_CURRENT_QUORUM"] = "getCurrentQuorum";
  RPCMethodName2["GET_DELEGATE"] = "getDelegate";
  RPCMethodName2["GET_DELEGATES"] = "getDelegates";
  RPCMethodName2["GET_VOTING_INFO"] = "getVotingInfo";
  RPCMethodName2["GET_ENDORSING_RIGHTS"] = "getEndorsingRights";
  RPCMethodName2["GET_ENTRYPOINTS"] = "getEntrypoints";
  RPCMethodName2["GET_LIVE_BLOCKS"] = "getLiveBlocks";
  RPCMethodName2["GET_MANAGER_KEY"] = "getManagerKey";
  RPCMethodName2["GET_NORMALIZED_SCRIPT"] = "getNormalizedScript";
  RPCMethodName2["GET_PROPOSALS"] = "getProposals";
  RPCMethodName2["GET_PROTOCOLS"] = "getProtocols";
  RPCMethodName2["GET_SAPLING_DIFF_BY_CONTRACT"] = "getSaplingDiffByContract";
  RPCMethodName2["GET_SAPLING_DIFF_BY_ID"] = "getSaplingDiffById";
  RPCMethodName2["GET_SCRIPT"] = "getScript";
  RPCMethodName2["GET_STORAGE"] = "getStorage";
  RPCMethodName2["GET_SUCCESSOR_PERIOD"] = "getSuccessorPeriod";
  RPCMethodName2["GET_TX_ROLLUP_INBOX"] = "getTxRollupInbox";
  RPCMethodName2["GET_TX_ROLLUP_STATE"] = "getTxRollupState";
  RPCMethodName2["GET_VOTES_LISTINGS"] = "getVotesListings";
  RPCMethodName2["PACK_DATA"] = "packData";
  RPCMethodName2["GET_STORAGE_USED_SPACE"] = "getStorageUsedSpace";
  RPCMethodName2["GET_STORAGE_PAID_SPACE"] = "getStoragePaidSpace";
  RPCMethodName2["GET_TICKET_BALANCE"] = "getTicketBalance";
  RPCMethodName2["GET_ALL_TICKET_BALANCES"] = "getAllTicketBalances";
  RPCMethodName2["GET_PENDING_OPERATIONS"] = "getPendingOperations";
  RPCMethodName2["GET_ORIGINATION_PROOF"] = "getOriginationProof";
})(RPCMethodName || (RPCMethodName = {}));
function castToBigNumber(data, keys) {
  const returnArray = Array.isArray(data);
  if (typeof keys === "undefined") {
    keys = Object.keys(data);
  }
  const response = returnArray ? [] : {};
  keys.forEach((key) => {
    const item = data[key];
    let res;
    if (typeof item === "undefined") {
      return;
    }
    if (Array.isArray(item)) {
      res = castToBigNumber(item);
      response[key] = res;
      return;
    }
    res = new bignumber_default(item);
    response[key] = res;
  });
  return response;
}
var OPERATION_METADATA;
(function(OPERATION_METADATA2) {
  OPERATION_METADATA2["TOO_LARGE"] = "too large";
})(OPERATION_METADATA || (OPERATION_METADATA = {}));
var METADATA_BALANCE_UPDATES_CATEGORY;
(function(METADATA_BALANCE_UPDATES_CATEGORY2) {
  METADATA_BALANCE_UPDATES_CATEGORY2["BAKING_REWARDS"] = "baking rewards";
  METADATA_BALANCE_UPDATES_CATEGORY2["REWARDS"] = "rewards";
  METADATA_BALANCE_UPDATES_CATEGORY2["FEES"] = "fees";
  METADATA_BALANCE_UPDATES_CATEGORY2["DEPOSITS"] = "deposits";
  METADATA_BALANCE_UPDATES_CATEGORY2["LEGACY_REWARDS"] = "legacy_rewards";
  METADATA_BALANCE_UPDATES_CATEGORY2["LEGACY_FEES"] = "legacy_fees";
  METADATA_BALANCE_UPDATES_CATEGORY2["LEGACY_DEPOSITS"] = "legacy_deposits";
  METADATA_BALANCE_UPDATES_CATEGORY2["BLOCK_FEES"] = "block fees";
  METADATA_BALANCE_UPDATES_CATEGORY2["NONCE_REVELATION_REWARDS"] = "nonce revelation rewards";
  METADATA_BALANCE_UPDATES_CATEGORY2["DOUBLE_SIGNING_EVIDENCE_REWARDS"] = "double signing evidence rewards";
  METADATA_BALANCE_UPDATES_CATEGORY2["ENDORSING_REWARDS"] = "endorsing rewards";
  METADATA_BALANCE_UPDATES_CATEGORY2["BAKING_BONUSES"] = "baking bonuses";
  METADATA_BALANCE_UPDATES_CATEGORY2["STORAGE_FEES"] = "storage fees";
  METADATA_BALANCE_UPDATES_CATEGORY2["PUNISHMENTS"] = "punishments";
  METADATA_BALANCE_UPDATES_CATEGORY2["LOST_ENDORSING_REWARDS"] = "lost endorsing rewards";
  METADATA_BALANCE_UPDATES_CATEGORY2["SUBSIDY"] = "subsidy";
  METADATA_BALANCE_UPDATES_CATEGORY2["BURNED"] = "burned";
  METADATA_BALANCE_UPDATES_CATEGORY2["COMMITMENT"] = "commitment";
  METADATA_BALANCE_UPDATES_CATEGORY2["BOOTSTRAP"] = "bootstrap";
  METADATA_BALANCE_UPDATES_CATEGORY2["INVOICE"] = "invoice";
  METADATA_BALANCE_UPDATES_CATEGORY2["MINTED"] = "minted";
  METADATA_BALANCE_UPDATES_CATEGORY2["TX_ROLLUP_REJECTION_REWARDS"] = "tx_rollup_rejection_rewards";
  METADATA_BALANCE_UPDATES_CATEGORY2["TX_ROLLUP_REJECTION_PUNISHMENTS"] = "tx_rollup_rejection_punishments";
  METADATA_BALANCE_UPDATES_CATEGORY2["BONDS"] = "bonds";
})(METADATA_BALANCE_UPDATES_CATEGORY || (METADATA_BALANCE_UPDATES_CATEGORY = {}));
var PvmKind;
(function(PvmKind2) {
  PvmKind2["WASM2"] = "wasm_2_0_0";
  PvmKind2["ARITH"] = "arith";
})(PvmKind || (PvmKind = {}));
var SmartRollupRefutationOptions;
(function(SmartRollupRefutationOptions2) {
  SmartRollupRefutationOptions2["START"] = "start";
  SmartRollupRefutationOptions2["MOVE"] = "move";
})(SmartRollupRefutationOptions || (SmartRollupRefutationOptions = {}));
var SmartRollupInputProofKind;
(function(SmartRollupInputProofKind2) {
  SmartRollupInputProofKind2["INBOX_PROOF"] = "inbox_proof";
  SmartRollupInputProofKind2["REVEAL_PROOF"] = "reveal_proof";
  SmartRollupInputProofKind2["FIRST_INPUT"] = "first_input";
})(SmartRollupInputProofKind || (SmartRollupInputProofKind = {}));
var SmartRollupRefuteRevealProofKind;
(function(SmartRollupRefuteRevealProofKind2) {
  SmartRollupRefuteRevealProofKind2["RAW_DATA_PROOF"] = "raw_data_proof";
  SmartRollupRefuteRevealProofKind2["METADATA_PROOF"] = "metadata_proof";
  SmartRollupRefuteRevealProofKind2["DAL_PAGE_PROOF"] = "dal_page_proof";
})(SmartRollupRefuteRevealProofKind || (SmartRollupRefuteRevealProofKind = {}));
var SmartRollupRefuteGameStatusOptions;
(function(SmartRollupRefuteGameStatusOptions2) {
  SmartRollupRefuteGameStatusOptions2["ONGOING"] = "ongoing";
  SmartRollupRefuteGameStatusOptions2["ENDED"] = "ended";
})(SmartRollupRefuteGameStatusOptions || (SmartRollupRefuteGameStatusOptions = {}));
var SmartRollupRefuteGameEndedPlayerOutcomes;
(function(SmartRollupRefuteGameEndedPlayerOutcomes2) {
  SmartRollupRefuteGameEndedPlayerOutcomes2["LOSER"] = "loser";
  SmartRollupRefuteGameEndedPlayerOutcomes2["DRAW"] = "draw";
})(SmartRollupRefuteGameEndedPlayerOutcomes || (SmartRollupRefuteGameEndedPlayerOutcomes = {}));
var SmartRollupRefuteGameEndedReason;
(function(SmartRollupRefuteGameEndedReason2) {
  SmartRollupRefuteGameEndedReason2["CONFLICT_RESOLVED"] = "conflict_resolved";
  SmartRollupRefuteGameEndedReason2["TIMEOUT"] = "timeout";
})(SmartRollupRefuteGameEndedReason || (SmartRollupRefuteGameEndedReason = {}));
var OpKind;
(function(OpKind2) {
  OpKind2["ORIGINATION"] = "origination";
  OpKind2["DELEGATION"] = "delegation";
  OpKind2["REVEAL"] = "reveal";
  OpKind2["TRANSACTION"] = "transaction";
  OpKind2["ACTIVATION"] = "activate_account";
  OpKind2["ENDORSEMENT"] = "endorsement";
  OpKind2["PREENDORSEMENT"] = "preendorsement";
  OpKind2["SET_DEPOSITS_LIMIT"] = "set_deposits_limit";
  OpKind2["DOUBLE_PREENDORSEMENT_EVIDENCE"] = "double_preendorsement_evidence";
  OpKind2["ENDORSEMENT_WITH_SLOT"] = "endorsement_with_slot";
  OpKind2["SEED_NONCE_REVELATION"] = "seed_nonce_revelation";
  OpKind2["DOUBLE_ENDORSEMENT_EVIDENCE"] = "double_endorsement_evidence";
  OpKind2["DOUBLE_BAKING_EVIDENCE"] = "double_baking_evidence";
  OpKind2["PROPOSALS"] = "proposals";
  OpKind2["BALLOT"] = "ballot";
  OpKind2["FAILING_NOOP"] = "failing_noop";
  OpKind2["REGISTER_GLOBAL_CONSTANT"] = "register_global_constant";
  OpKind2["TX_ROLLUP_ORIGINATION"] = "tx_rollup_origination";
  OpKind2["TX_ROLLUP_SUBMIT_BATCH"] = "tx_rollup_submit_batch";
  OpKind2["TX_ROLLUP_COMMIT"] = "tx_rollup_commit";
  OpKind2["TX_ROLLUP_RETURN_BOND"] = "tx_rollup_return_bond";
  OpKind2["TX_ROLLUP_FINALIZE_COMMITMENT"] = "tx_rollup_finalize_commitment";
  OpKind2["TX_ROLLUP_REMOVE_COMMITMENT"] = "tx_rollup_remove_commitment";
  OpKind2["TX_ROLLUP_REJECTION"] = "tx_rollup_rejection";
  OpKind2["TX_ROLLUP_DISPATCH_TICKETS"] = "tx_rollup_dispatch_tickets";
  OpKind2["TRANSFER_TICKET"] = "transfer_ticket";
  OpKind2["INCREASE_PAID_STORAGE"] = "increase_paid_storage";
  OpKind2["UPDATE_CONSENSUS_KEY"] = "update_consensus_key";
  OpKind2["DRAIN_DELEGATE"] = "drain_delegate";
  OpKind2["VDF_REVELATION"] = "vdf_revelation";
  OpKind2["EVENT"] = "event";
  OpKind2["TICKET_UPDATES"] = "ticket_updates";
  OpKind2["SMART_ROLLUP_ORIGINATE"] = "smart_rollup_originate";
  OpKind2["SMART_ROLLUP_ADD_MESSAGES"] = "smart_rollup_add_messages";
  OpKind2["SMART_ROLLUP_EXECUTE_OUTBOX_MESSAGE"] = "smart_rollup_execute_outbox_message";
  OpKind2["SMART_ROLLUP_PUBLISH"] = "smart_rollup_publish";
  OpKind2["SMART_ROLLUP_CEMENT"] = "smart_rollup_cement";
  OpKind2["SMART_ROLLUP_RECOVER_BOND"] = "smart_rollup_recover_bond";
  OpKind2["SMART_ROLLUP_REFUTE"] = "smart_rollup_refute";
  OpKind2["SMART_ROLLUP_TIMEOUT"] = "smart_rollup_timeout";
})(OpKind || (OpKind = {}));
var RpcClient = class {
  /**
   *
   * @param url rpc root url
   * @param chain chain (default main)
   * @param httpBackend Http backend that issue http request.
   * You can override it by providing your own if you which to hook in the request/response
   *
   * @example new RpcClient('https://mainnet.api.tez.ie/', 'main') this will use https://mainnet.api.tez.ie//chains/main
   */
  constructor(url, chain = defaultChain, httpBackend = new HttpBackend()) {
    this.url = url;
    this.chain = chain;
    this.httpBackend = httpBackend;
  }
  createURL(path) {
    return `${this.url.replace(/\/+$/g, "")}${path}`;
  }
  validateAddress(address) {
    const addressValidation = validateAddress(address);
    if (addressValidation !== ValidationResult.VALID) {
      throw new InvalidAddressError(address, invalidDetail(addressValidation));
    }
  }
  validateContract(address) {
    const addressValidation = validateContractAddress(address);
    if (addressValidation !== ValidationResult.VALID) {
      throw new InvalidContractAddressError(address, invalidDetail(addressValidation));
    }
  }
  /**
   *
   * @param options contains generic configuration for rpc calls
   *
   * @description Get the block's hash, its unique identifier.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-hash
   */
  getBlockHash({ block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      const hash2 = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/hash`),
        method: "GET"
      });
      return hash2;
    });
  }
  /**
   *
   * @param options contains generic configuration for rpc calls
   *
   * @description List the ancestors of the given block which, if referred to as the branch in an operation header, are recent enough for that operation to be included in the current block.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-live-blocks
   */
  getLiveBlocks({ block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      const blocks = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/live_blocks`),
        method: "GET"
      });
      return blocks;
    });
  }
  /**
   *
   * @param address address from which we want to retrieve the balance
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the balance of a contract.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-balance
   */
  getBalance(address, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      this.validateAddress(address);
      const balance = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/balance`),
        method: "GET"
      });
      return new bignumber_default(balance);
    });
  }
  /**
   *
   * @param address contract address from which we want to retrieve the storage
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the data of the contract.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-storage
   */
  getStorage(address, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      this.validateContract(address);
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/storage`),
        method: "GET"
      });
    });
  }
  /**
   *
   * @param address contract address from which we want to retrieve the script
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the code and data of the contract.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script
   */
  getScript(address, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      this.validateContract(address);
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/script`),
        method: "GET"
      });
    });
  }
  /**
   *
   * @param address contract address from which we want to retrieve the script
   * @param unparsingMode default is { unparsing_mode: "Readable" }
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the script of the contract and normalize it using the requested unparsing mode.
   *
   */
  getNormalizedScript(address, unparsingMode = { unparsing_mode: "Readable" }, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      this.validateContract(address);
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/script/normalized`),
        method: "POST"
      }, unparsingMode);
    });
  }
  /**
   *
   * @param address contract address from which we want to retrieve
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the complete status of a contract.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id
   */
  getContract(address, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      this.validateAddress(address);
      const contractResponse = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}`),
        method: "GET"
      });
      return Object.assign(Object.assign({}, contractResponse), { balance: new bignumber_default(contractResponse.balance) });
    });
  }
  /**
   *
   * @param address contract address from which we want to retrieve the manager
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the manager key of a contract.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-manager-key
   */
  getManagerKey(address, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      this.validateAddress(address);
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/manager_key`),
        method: "GET"
      });
    });
  }
  /**
   *
   * @param address contract address from which we want to retrieve the delegate (baker)
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the delegate of a contract, if any.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-delegate
   */
  getDelegate(address, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      this.validateAddress(address);
      let delegate;
      try {
        delegate = yield this.httpBackend.createRequest({
          url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/delegate`),
          method: "GET"
        });
      } catch (ex) {
        if (ex instanceof HttpResponseError && ex.status === STATUS_CODE.NOT_FOUND) {
          delegate = null;
        } else {
          throw ex;
        }
      }
      return delegate;
    });
  }
  /**
   *
   * @param address contract address from which we want to retrieve the big map key
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the value associated with a key in the big map storage of the contract.
   *
   * @deprecated Deprecated in favor of getBigMapKeyByID
   *
   * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get
   */
  getBigMapKey(address, key, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      this.validateAddress(address);
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/big_map_get`),
        method: "POST"
      }, key);
    });
  }
  /**
   *
   * @param id Big Map ID
   * @param expr Expression hash to query (A b58check encoded Blake2b hash of the expression (The expression can be packed using the pack_data method))
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the value associated with a key in a big map.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr
   */
  getBigMapExpr(id, expr, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/big_maps/${id}/${expr}`),
        method: "GET"
      });
    });
  }
  /**
   *
   * @param address delegate address which we want to retrieve
   * @param options contains generic configuration for rpc calls
   *
   * @description Fetches information about a delegate from RPC.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-delegates-pkh
   */
  getDelegates(address, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      this.validateAddress(address);
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/delegates/${address}`),
        method: "GET"
      });
      const castedResponse = castToBigNumber(response, [
        "balance",
        "full_balance",
        "current_frozen_deposits",
        "frozen_deposits",
        "frozen_balance",
        "frozen_deposits_limit",
        "staking_balance",
        "delegated_balance",
        "voting_power"
      ]);
      return Object.assign(Object.assign(Object.assign({}, response), castedResponse), { frozen_balance_by_cycle: response.frozen_balance_by_cycle ? response.frozen_balance_by_cycle.map((_a3) => {
        var { deposit, deposits, fees, rewards } = _a3, rest = __rest(_a3, ["deposit", "deposits", "fees", "rewards"]);
        const castedToBigNumber = castToBigNumber({ deposit, deposits, fees, rewards }, [
          "deposit",
          "deposits",
          "fees",
          "rewards"
        ]);
        return Object.assign(Object.assign({}, rest), { deposit: castedToBigNumber.deposit, deposits: castedToBigNumber.deposits, fees: castedToBigNumber.fees, rewards: castedToBigNumber.rewards });
      }) : void 0 });
    });
  }
  /**
   *
   * @param address delegate address which we want to retrieve
   * @param options contains generic configuration for rpc calls
   *
   * @description Returns the delegate info (e.g. voting power) found in the listings of the current voting period.
   *
   * @see https://tezos.gitlab.io/kathmandu/rpc.html#get-block-id-context-delegates-pkh-voting-info
   */
  getVotingInfo(address, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      this.validateAddress(address);
      return yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/delegates/${address}/voting_info`),
        method: "GET"
      });
    });
  }
  /**
   *
   * @param options contains generic configuration for rpc calls
   *
   * @description All constants
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-constants
   */
  getConstants({ block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/constants`),
        method: "GET"
      });
      const castedResponse = castToBigNumber(response, [
        "time_between_blocks",
        "hard_gas_limit_per_operation",
        "hard_gas_limit_per_block",
        "proof_of_work_threshold",
        "tokens_per_roll",
        "seed_nonce_revelation_tip",
        "block_security_deposit",
        "endorsement_security_deposit",
        "block_reward",
        "endorsement_reward",
        "cost_per_byte",
        "hard_storage_limit_per_operation",
        "test_chain_duration",
        "baking_reward_per_endorsement",
        "delay_per_missing_endorsement",
        "minimal_block_delay",
        "liquidity_baking_subsidy",
        "cache_layout",
        "baking_reward_fixed_portion",
        "baking_reward_bonus_per_slot",
        "endorsing_reward_per_slot",
        "double_baking_punishment",
        "delay_increment_per_round",
        "tx_rollup_commitment_bond",
        "vdf_difficulty",
        "sc_rollup_stake_amount",
        "minimal_stake"
      ]);
      return Object.assign(Object.assign({}, response), castedResponse);
    });
  }
  /**
   *
   * @param options contains generic configuration for rpc calls. See examples for various available sytaxes.
   *
   * @description All the information about a block
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id
   * @example getBlock() will default to /main/chains/block/head.
   * @example getBlock({ block: head~2 }) will return an offset of 2 blocks.
   * @example getBlock({ block: BL8fTiWcSxWCjiMVnDkbh6EuhqVPZzgWheJ2dqwrxYRm9AephXh~2 }) will return an offset of 2 blocks from given block hash..
   */
  getBlock({ block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}`),
        method: "GET"
      });
      return response;
    });
  }
  /**
   *
   * @param options contains generic configuration for rpc calls
   *
   * @description The whole block header
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-header
   */
  getBlockHeader({ block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/header`),
        method: "GET"
      });
      return response;
    });
  }
  /**
   *
   * @param options contains generic configuration for rpc calls
   *
   * @description All the metadata associated to the block
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-metadata
   */
  getBlockMetadata({ block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/metadata`),
        method: "GET"
      });
      return response;
    });
  }
  /**
   *
   * @param args contains optional query arguments
   * @param options contains generic configuration for rpc calls
   *
   * @description Retrieves the list of delegates allowed to bake a block.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-helpers-baking-rights
   */
  getBakingRights(args = {}, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/baking_rights`),
        method: "GET",
        query: args
      });
      return response;
    });
  }
  /**
   *
   * @param args contains optional query arguments
   * @param options contains generic configuration for rpc calls
   *
   * @description Retrieves the list of delegates allowed to bake a block.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-helpers-endorsing-rights
   */
  getEndorsingRights(args = {}, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/endorsing_rights`),
        method: "GET",
        query: args
      });
      return response;
    });
  }
  /**
   * @param options contains generic configuration for rpc calls
   *
   * @description Ballots casted so far during a voting period
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-ballot-list
   */
  getBallotList({ block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/ballot_list`),
        method: "GET"
      });
      return response;
    });
  }
  /**
   *
   * @param options contains generic configuration for rpc calls
   *
   * @description Sum of ballots casted so far during a voting period.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-ballots
   */
  getBallots({ block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/ballots`),
        method: "GET"
      });
      const casted = castToBigNumber(response, ["yay", "nay", "pass"]);
      return casted;
    });
  }
  /**
   *
   * @param options contains generic configuration for rpc calls
   *
   * @description Current proposal under evaluation.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-proposal
   */
  getCurrentProposal({ block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/current_proposal`),
        method: "GET"
      });
      return response;
    });
  }
  /**
   *
   * @param options contains generic configuration for rpc calls
   *
   * @description Current expected quorum.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-quorum
   */
  getCurrentQuorum({ block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/current_quorum`),
        method: "GET"
      });
      return response;
    });
  }
  /**
   *
   * @param options contains generic configuration for rpc calls
   *
   * @description List of delegates with their voting weight, in number of rolls.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-listings
   */
  getVotesListings({ block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/listings`),
        method: "GET"
      });
      response.map((item) => {
        if (item.voting_power) {
          item.voting_power = new bignumber_default(item.voting_power);
        }
        return item;
      });
      return response;
    });
  }
  /**
   *
   * @param options contains generic configuration for rpc calls
   *
   * @description List of proposals with number of supporters.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-proposals
   */
  getProposals({ block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/proposals`),
        method: "GET"
      });
      response.map((item) => {
        return item[1] = new bignumber_default(item[1]);
      });
      return response;
    });
  }
  /**
   *
   * @param data operation contents to forge
   * @param options contains generic configuration for rpc calls
   *
   * @description Forge an operation returning the unsigned bytes
   *
   * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-forge-operations
   */
  forgeOperations(data, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/forge/operations`),
        method: "POST"
      }, data);
    });
  }
  /**
   *
   * @param signedOpBytes signed bytes to inject
   *
   * @description Inject an operation in node and broadcast it. Returns the ID of the operation. The `signedOperationContents` should be constructed using a contextual RPCs from the latest block and signed by the client. By default, the RPC will wait for the operation to be (pre-)validated before answering. See RPCs under /blocks/prevalidation for more details on the prevalidation context.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#post-injection-operation
   */
  injectOperation(signedOpBytes) {
    return __awaiter2(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/injection/operation`),
        method: "POST"
      }, signedOpBytes);
    });
  }
  /**
   *
   * @param ops Operations to apply
   * @param options contains generic configuration for rpc calls
   *
   * @description Simulate the validation of an operation
   *
   * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-preapply-operations
   */
  preapplyOperations(ops, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/preapply/operations`),
        method: "POST"
      }, ops);
      return response;
    });
  }
  /**
   *
   * @param contract address of the contract we want to get the entrypoints of
   *
   * @description Return the list of entrypoints of the contract
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-entrypoints
   *
   * @version 005_PsBABY5H
   */
  getEntrypoints(contract, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      this.validateContract(contract);
      const contractResponse = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${contract}/entrypoints`),
        method: "GET"
      });
      return contractResponse;
    });
  }
  /**
   * @param op Operation to run
   * @param options contains generic configuration for rpc calls
   *
   * @description Run an operation without signature checks
   *
   * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-run-operation
   */
  runOperation(op, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/scripts/run_operation`),
        method: "POST"
      }, op);
      return response;
    });
  }
  /**
   * @param op Operation to simulate
   * @param options contains generic configuration for rpc calls
   *
   * @description Simulate an operation on the blockchain
   *
   * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/nairobi-openapi.json
   */
  simulateOperation(op, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/scripts/simulate_operation`),
        method: "POST"
      }, op);
      return response;
    });
  }
  /**
   * @param code Code to run
   * @param options contains generic configuration for rpc calls
   *
   * @description Run a piece of code in the current context
   *
   * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-run-code
   */
  runCode(code2, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/scripts/run_code`),
        method: "POST"
      }, code2);
      return response;
    });
  }
  /**
   * @param viewScriptParams Parameters of the script view to run
   * @param options contains generic configuration for rpc calls
   *
   * @description Simulate a call to a michelson view
   *
   */
  runScriptView(_a3, { block } = defaultRPCOptions) {
    var { unparsing_mode = "Readable" } = _a3, rest = __rest(_a3, ["unparsing_mode"]);
    return __awaiter2(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/scripts/run_script_view`),
        method: "POST"
      }, Object.assign({ unparsing_mode }, rest));
    });
  }
  /**
   * @param viewParams Parameters of the view to run
   * @param options contains generic configuration for rpc calls
   *
   * @description Simulate a call to a view following the TZIP-4 standard. See https://gitlab.com/tzip/tzip/-/blob/master/proposals/tzip-4/tzip-4.md#view-entrypoints.
   *
   */
  runView(_a3, { block } = defaultRPCOptions) {
    var { unparsing_mode = "Readable" } = _a3, rest = __rest(_a3, ["unparsing_mode"]);
    return __awaiter2(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/scripts/run_view`),
        method: "POST"
      }, Object.assign({ unparsing_mode }, rest));
    });
  }
  getChainId() {
    return __awaiter2(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/chain_id`),
        method: "GET"
      });
    });
  }
  /**
   *
   * @param data Data to pack
   * @param options contains generic configuration for rpc calls
   *
   * @description Computes the serialized version of a data expression using the same algorithm as script instruction PACK
   * Note: You should always verify the packed bytes before signing or requesting that they be signed when using the the RPC to pack.
   * This precaution helps protect you and your applications users from RPC nodes that have been compromised.
   * A node that is operated by a bad actor, or compromised by a bad actor could return a fully formed operation that does not correspond to the input provided to the RPC endpoint.
   * A safer solution to pack and sign data would be to use the `packDataBytes` function available in the `@taquito/michel-codec` package.
   *
   * @example packData({ data: { string: "test" }, type: { prim: "string" } })
   *
   *
   * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-pack-data
   */
  packData(data, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      const _a3 = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/scripts/pack_data`),
        method: "POST"
      }, data), { gas } = _a3, rest = __rest(_a3, ["gas"]);
      let formattedGas = gas;
      const tryBigNumber = new bignumber_default(gas || "");
      if (!tryBigNumber.isNaN()) {
        formattedGas = tryBigNumber;
      }
      return Object.assign({ gas: formattedGas }, rest);
    });
  }
  /**
   *
   * @description Return rpc root url
   */
  getRpcUrl() {
    return this.url;
  }
  /**
   *
   * @param options contains generic configuration for rpc calls
   *
   * @description Voting period of current block.
   *
   * @example getCurrentPeriod() will default to current voting period for /main/chains/block/head.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-period
   */
  getCurrentPeriod({ block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/current_period`),
        method: "GET"
      });
      return response;
    });
  }
  /**
   *
   * @param options contains generic configuration for rpc calls
   *
   * @description Voting period of next block.
   *
   * @example getSuccessorPeriod() will default to successor voting period for /main/chains/block/head.
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-successor-period
   */
  getSuccessorPeriod({ block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/successor_period`),
        method: "GET"
      });
      return response;
    });
  }
  /**
   *
   * @param id Sapling state ID
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the value associated with a sapling state ID.
   *
   * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-sapling-sapling-state-id-get-diff
   */
  getSaplingDiffById(id, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/sapling/${id}/get_diff`),
        method: "GET"
      });
    });
  }
  /**
   *
   * @param contract address of the contract we want to get the sapling diff
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the value associated with a sapling state.
   *
   * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-single-sapling-get-diff
   */
  getSaplingDiffByContract(contract, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${contract}/single_sapling_get_diff`),
        method: "GET"
      });
    });
  }
  getProtocols({ block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/protocols`),
        method: "GET"
      });
    });
  }
  /**
   *
   * @param tx_rollup_id the transaction rollup ID
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the state of a rollup
   *
   * @see https://tezos.gitlab.io/jakarta/rpc.html#get-block-id-context-tx-rollup-tx-rollup-id-state
   */
  getTxRollupState(txRollupId, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/tx_rollup/${txRollupId}/state`),
        method: "GET"
      });
    });
  }
  /**
   *
   * @param tx_rollup_id the transaction rollup ID
   * @param block_level the block level
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the inbox of a transaction rollup
   *
   * @see https://tezos.gitlab.io/jakarta/rpc.html#get-block-id-context-tx-rollup-tx-rollup-id-inbox-block-level
   */
  getTxRollupInbox(txRollupId, blockLevel, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/tx_rollup/${txRollupId}/inbox/${blockLevel}`),
        method: "GET"
      });
    });
  }
  /**
   *
   * @param contract address of the contract we want to retrieve storage information of
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the amount of used space in a contract's storage
   *
   * @see https://tezos.gitlab.io/lima/rpc.html#get-block-id-context-contracts-contract-id-storage
   */
  getStorageUsedSpace(contract, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${contract}/storage/used_space`),
        method: "GET"
      });
    });
  }
  /**
   *
   * @param contract address of the contract we want to retrieve storage information of
   * @param options contains generic configuration for rpc calls
   *
   * @description Access the amount of paid space in a contract's storage
   *
   * @see https://tezos.gitlab.io/lima/rpc.html#get-block-id-context-contracts-contract-id-storage
   */
  getStoragePaidSpace(contract, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${contract}/storage/paid_space`),
        method: "GET"
      });
    });
  }
  /**
   *
   * @param contract implicit or originated address we want to retrieve ticket balance of
   * @param ticket object to specify a ticket by ticketer, content type and content
   * @param options contains generic configuration for rpc calls
   * @description Access the contract's balance of ticket with specified ticketer, content type, and content.
   * @example ticket { ticketer: 'address', content_type: { prim: "string" }, content: { string: 'ticket1' } }
   * @see https://tezos.gitlab.io/protocols/016_mumbai.html#rpc-changes
   */
  getTicketBalance(contract, ticket, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${contract}/ticket_balance`),
        method: "POST"
      }, ticket);
    });
  }
  /**
   *
   * @param contract originated address we want to retrieve ticket balances of
   * @param options contains generic configuration for rpc calls
   * @description Access the complete list of tickets owned by the given contract by scanning the contract's storage.
   * @see https://tezos.gitlab.io/protocols/016_mumbai.html#rpc-changes
   */
  getAllTicketBalances(contract, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${contract}/all_ticket_balances`),
        method: "GET"
      });
    });
  }
  /**
   * @description List the prevalidated operations in mempool (accessibility of mempool depends on each rpc endpoint)
   * @param args has 5 optional properties. We support version 1 with new encoding as version 0 will be deprecated soon. The rest of the properties is to filter pending operations response
   * @default args { version: '1', applied: true, refused: true, outdated, true, branchRefused: true, branchDelayed: true, validationPass: undefined }
   * @see https://tezos.gitlab.io/CHANGES.html?highlight=pending_operations#id4
   */
  getPendingOperations(args = {}) {
    return __awaiter2(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/mempool/pending_operations`),
        method: "GET",
        query: args
      });
    });
  }
  /**
   *
   * @param params contains the PVM kind and kernel to generate the origination proof from
   * @description rpc call to generate the origination proof needed for a smart rollup originate operation
   * @see https://tezos.gitlab.io/protocols/016_mumbai.html#rpc-changes
   */
  getOriginationProof(params, { block } = defaultRPCOptions) {
    return __awaiter2(this, void 0, void 0, function* () {
      return this.httpBackend.createRequest({
        url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/smart_rollups/all/origination_proof`),
        method: "POST"
      }, params);
    });
  }
};

// node_modules/rxjs/node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __awaiter3(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from2.length, ar; i < l; i++) {
      if (ar || !(i in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle2(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle2(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle2(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle2(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle2(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}

// node_modules/rxjs/dist/esm5/internal/util/isFunction.js
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a3, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a3 = _parentage_1.return))
                _a3.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
              _b.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a3;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a3 = this._finalizers) !== null && _a3 !== void 0 ? _a3 : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// node_modules/rxjs/dist/esm5/internal/config.js
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/util/noop.js
function noop() {
}

// node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
var COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}

// node_modules/rxjs/dist/esm5/internal/util/errorContext.js
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a3 = context, errorThrown = _a3.errorThrown, error = _a3.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};

// node_modules/rxjs/dist/esm5/internal/symbol/observable.js
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();

// node_modules/rxjs/dist/esm5/internal/util/identity.js
function identity(x) {
  return x;
}

// node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}

// node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a3 = _this, operator = _a3.operator, source = _a3.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a3;
    return (_a3 = this.source) === null || _a3 === void 0 ? void 0 : _a3.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a3;
  return (_a3 = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a3 !== void 0 ? _a3 : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}

// node_modules/rxjs/dist/esm5/internal/util/lift.js
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a3;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a3 = this.onFinalize) === null || _a3 === void 0 ? void 0 : _a3.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);

// node_modules/rxjs/dist/esm5/internal/operators/refCount.js
function refCount() {
  return operate(function(source, subscriber) {
    var connection = null;
    source._refCount++;
    var refCounter = createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      var sharedConnection = source._connection;
      var conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable = function(_super) {
  __extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._subject = null;
    _this._refCount = 0;
    _this._connection = null;
    if (hasLift(source)) {
      _this.lift = source.lift;
    }
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype._teardown = function() {
    this._refCount = 0;
    var _connection = this._connection;
    this._subject = this._connection = null;
    _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
  };
  ConnectableObservable2.prototype.connect = function() {
    var _this = this;
    var connection = this._connection;
    if (!connection) {
      connection = this._connection = new Subscription();
      var subject_1 = this.getSubject();
      connection.add(this.source.subscribe(createOperatorSubscriber(subject_1, void 0, function() {
        _this._teardown();
        subject_1.complete();
      }, function(err) {
        _this._teardown();
        subject_1.error(err);
      }, function() {
        return _this._teardown();
      })));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  };
  return ConnectableObservable2;
}(Observable);

// node_modules/rxjs/dist/esm5/internal/scheduler/performanceTimestampProvider.js
var performanceTimestampProvider = {
  now: function() {
    return (performanceTimestampProvider.delegate || performance).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrameProvider.js
var animationFrameProvider = {
  schedule: function(callback) {
    var request = requestAnimationFrame;
    var cancel = cancelAnimationFrame;
    var delegate = animationFrameProvider.delegate;
    if (delegate) {
      request = delegate.requestAnimationFrame;
      cancel = delegate.cancelAnimationFrame;
    }
    var handle = request(function(timestamp2) {
      cancel = void 0;
      callback(timestamp2);
    });
    return new Subscription(function() {
      return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
    });
  },
  requestAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  cancelAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/observable/dom/animationFrames.js
function animationFramesFactory(timestampProvider) {
  return new Observable(function(subscriber) {
    var provider = timestampProvider || performanceTimestampProvider;
    var start = provider.now();
    var id = 0;
    var run = function() {
      if (!subscriber.closed) {
        id = animationFrameProvider.requestAnimationFrame(function(timestamp2) {
          id = 0;
          var now = provider.now();
          subscriber.next({
            timestamp: timestampProvider ? now : timestamp2,
            elapsed: now - start
          });
          run();
        });
      }
    };
    run();
    return function() {
      if (id) {
        animationFrameProvider.cancelAnimationFrame(id);
      }
    };
  });
}
var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();

// node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});

// node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a3;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a3 = _b.return))
              _a3.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a3;
      return ((_a3 = this.observers) === null || _a3 === void 0 ? void 0 : _a3.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a3 = this, hasError = _a3.hasError, isStopped = _a3.isStopped, observers = _a3.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a3 = this, hasError = _a3.hasError, thrownError = _a3.thrownError, isStopped = _a3.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a3, _b;
    (_b = (_a3 = this.destination) === null || _a3 === void 0 ? void 0 : _a3.next) === null || _b === void 0 ? void 0 : _b.call(_a3, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a3, _b;
    (_b = (_a3 = this.destination) === null || _a3 === void 0 ? void 0 : _a3.error) === null || _b === void 0 ? void 0 : _b.call(_a3, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a3, _b;
    (_b = (_a3 = this.destination) === null || _a3 === void 0 ? void 0 : _a3.complete) === null || _b === void 0 ? void 0 : _b.call(_a3);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a3, _b;
    return (_b = (_a3 = this.source) === null || _a3 === void 0 ? void 0 : _a3.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
var BehaviorSubject = function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a3 = this, hasError = _a3.hasError, thrownError = _a3.thrownError, _value = _a3._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
var ReplaySubject = function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a3 = this, isStopped = _a3.isStopped, _buffer = _a3._buffer, _infiniteTimeWindow = _a3._infiniteTimeWindow, _timestampProvider = _a3._timestampProvider, _windowTime = _a3._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a3 = this, _infiniteTimeWindow = _a3._infiniteTimeWindow, _buffer = _a3._buffer;
    var copy = _buffer.slice();
    for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy[i]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a3 = this, _bufferSize = _a3._bufferSize, _timestampProvider = _a3._timestampProvider, _buffer = _a3._buffer, _infiniteTimeWindow = _a3._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now = _timestampProvider.now();
      var last3 = 0;
      for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
        last3 = i;
      }
      last3 && _buffer.splice(0, last3 + 1);
    }
  };
  return ReplaySubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/AsyncSubject.js
var AsyncSubject = function(_super) {
  __extends(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._value = null;
    _this._hasValue = false;
    _this._isComplete = false;
    return _this;
  }
  AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a3 = this, hasError = _a3.hasError, _hasValue = _a3._hasValue, _value = _a3._value, thrownError = _a3.thrownError, isStopped = _a3.isStopped, _isComplete = _a3._isComplete;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped || _isComplete) {
      _hasValue && subscriber.next(_value);
      subscriber.complete();
    }
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._value = value;
      this._hasValue = true;
    }
  };
  AsyncSubject2.prototype.complete = function() {
    var _a3 = this, _hasValue = _a3._hasValue, _value = _a3._value, _isComplete = _a3._isComplete;
    if (!_isComplete) {
      this._isComplete = true;
      _hasValue && _super.prototype.next.call(this, _value);
      _super.prototype.complete.call(this);
    }
  };
  return AsyncSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
var Action = function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return this;
  };
  return Action2;
}(Subscription);

// node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
var intervalProvider = {
  setInterval: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearInterval: function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
var AsyncAction = function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay2) {
    var _a3;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay2);
    }
    this.pending = true;
    this.delay = delay2;
    this.id = (_a3 = this.id) !== null && _a3 !== void 0 ? _a3 : this.requestAsyncId(scheduler, this.id, delay2);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && this.delay === delay2 && this.pending === false) {
      return id;
    }
    if (id != null) {
      intervalProvider.clearInterval(id);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay2) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay2);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = e ? e : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a3 = this, id = _a3.id, scheduler = _a3.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action);

// node_modules/rxjs/dist/esm5/internal/util/Immediate.js
var nextHandle = 1;
var resolved;
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var Immediate = {
  setImmediate: function(cb) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    if (!resolved) {
      resolved = Promise.resolve();
    }
    resolved.then(function() {
      return findAndClearHandle(handle) && cb();
    });
    return handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
};

// node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js
var setImmediate = Immediate.setImmediate;
var clearImmediate = Immediate.clearImmediate;
var immediateProvider = {
  setImmediate: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray([], __read(args)));
  },
  clearImmediate: function(handle) {
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js
var AsapAction = function(_super) {
  __extends(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    var _a3;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    }
    var actions = scheduler.actions;
    if (id != null && ((_a3 = actions[actions.length - 1]) === null || _a3 === void 0 ? void 0 : _a3.id) !== id) {
      immediateProvider.clearImmediate(id);
      if (scheduler._scheduled === id) {
        scheduler._scheduled = void 0;
      }
    }
    return void 0;
  };
  return AsapAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/Scheduler.js
var Scheduler = function() {
  function Scheduler2(schedulerActionCtor, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now;
  }
  Scheduler2.prototype.schedule = function(work, delay2, state) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay2);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
}();

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler = function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js
var AsapScheduler = function(_super) {
  __extends(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsapScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/asap.js
var asapScheduler = new AsapScheduler(AsapAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/async.js
var asyncScheduler = new AsyncScheduler(AsyncAction);
var async = asyncScheduler;

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueAction.js
var QueueAction = function(_super) {
  __extends(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 > 0) {
      return _super.prototype.schedule.call(this, state, delay2);
    }
    this.delay = delay2;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state, delay2) {
    return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay2) : this._execute(state, delay2);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.flush(this);
    return 0;
  };
  return QueueAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueScheduler.js
var QueueScheduler = function(_super) {
  __extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/queue.js
var queueScheduler = new QueueScheduler(QueueAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction = function(_super) {
  __extends(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(function() {
      return scheduler.flush(void 0);
    }));
  };
  AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    var _a3;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    }
    var actions = scheduler.actions;
    if (id != null && ((_a3 = actions[actions.length - 1]) === null || _a3 === void 0 ? void 0 : _a3.id) !== id) {
      animationFrameProvider.cancelAnimationFrame(id);
      scheduler._scheduled = void 0;
    }
    return void 0;
  };
  return AnimationFrameAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler = function(_super) {
  __extends(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationFrameScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AnimationFrameScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js
var animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/VirtualTimeScheduler.js
var VirtualTimeScheduler = function(_super) {
  __extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
    if (schedulerActionCtor === void 0) {
      schedulerActionCtor = VirtualAction;
    }
    if (maxFrames === void 0) {
      maxFrames = Infinity;
    }
    var _this = _super.call(this, schedulerActionCtor, function() {
      return _this.frame;
    }) || this;
    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }
  VirtualTimeScheduler2.prototype.flush = function() {
    var _a3 = this, actions = _a3.actions, maxFrames = _a3.maxFrames;
    var error;
    var action;
    while ((action = actions[0]) && action.delay <= maxFrames) {
      actions.shift();
      this.frame = action.delay;
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    }
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  VirtualTimeScheduler2.frameTimeFactor = 10;
  return VirtualTimeScheduler2;
}(AsyncScheduler);
var VirtualAction = function(_super) {
  __extends(VirtualAction2, _super);
  function VirtualAction2(scheduler, work, index) {
    if (index === void 0) {
      index = scheduler.index += 1;
    }
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.index = index;
    _this.active = true;
    _this.index = scheduler.index = index;
    return _this;
  }
  VirtualAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (Number.isFinite(delay2)) {
      if (!this.id) {
        return _super.prototype.schedule.call(this, state, delay2);
      }
      this.active = false;
      var action = new VirtualAction2(this.scheduler, this.work);
      this.add(action);
      return action.schedule(state, delay2);
    } else {
      return Subscription.EMPTY;
    }
  };
  VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    this.delay = scheduler.frame + delay2;
    var actions = scheduler.actions;
    actions.push(this);
    actions.sort(VirtualAction2.sortActions);
    return 1;
  };
  VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return void 0;
  };
  VirtualAction2.prototype._execute = function(state, delay2) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state, delay2);
    }
  };
  VirtualAction2.sortActions = function(a, b) {
    if (a.delay === b.delay) {
      if (a.index === b.index) {
        return 0;
      } else if (a.index > b.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a.delay > b.delay) {
      return 1;
    } else {
      return -1;
    }
  };
  return VirtualAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/observable/empty.js
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});

// node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
function isScheduler(value) {
  return value && isFunction(value.schedule);
}

// node_modules/rxjs/dist/esm5/internal/util/args.js
function last(arr) {
  return arr[arr.length - 1];
}
function popResultSelector(args) {
  return isFunction(last(args)) ? args.pop() : void 0;
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}

// node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
var isArrayLike = function(x) {
  return x && typeof x.length === "number" && typeof x !== "function";
};

// node_modules/rxjs/dist/esm5/internal/util/isPromise.js
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}

// node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return isFunction(input[observable]);
}

// node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

// node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// node_modules/rxjs/dist/esm5/internal/util/isIterable.js
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a3, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false)
            return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a3 = _b.sent(), value = _a3.value, done = _a3.done;
          if (!done)
            return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

// node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a3;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a3 = iterable_1.return))
          _a3.call(iterable_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process2(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process2(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a3;
  return __awaiter3(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
            return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a3 = asyncIterable_1.return)))
            return [3, 8];
          return [4, _a3.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2)
            throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
function executeSchedule(parentSubscription, scheduler, work, delay2, repeat2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  if (repeat2 === void 0) {
    repeat2 = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat2) {
      parentSubscription.add(this.schedule(null, delay2));
    } else {
      this.unsubscribe();
    }
  }, delay2);
  parentSubscription.add(scheduleSubscription);
  if (!repeat2) {
    return scheduleSubscription;
  }
}

// node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay2);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay2);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay2);
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay2));
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i = 0;
    return scheduler.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a3;
        var value;
        var done;
        try {
          _a3 = iterator2.next(), value = _a3.value, done = _a3.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}

// node_modules/rxjs/dist/esm5/internal/observable/from.js
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}

// node_modules/rxjs/dist/esm5/internal/observable/of.js
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  return from(args, scheduler);
}

// node_modules/rxjs/dist/esm5/internal/observable/throwError.js
function throwError(errorOrErrorFactory, scheduler) {
  var errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
    return errorOrErrorFactory;
  };
  var init = function(subscriber) {
    return subscriber.error(errorFactory());
  };
  return new Observable(scheduler ? function(subscriber) {
    return scheduler.schedule(init, 0, subscriber);
  } : init);
}

// node_modules/rxjs/dist/esm5/internal/Notification.js
var NotificationKind;
(function(NotificationKind2) {
  NotificationKind2["NEXT"] = "N";
  NotificationKind2["ERROR"] = "E";
  NotificationKind2["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = function() {
  function Notification2(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === "N";
  }
  Notification2.prototype.observe = function(observer) {
    return observeNotification(this, observer);
  };
  Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
    var _a3 = this, kind = _a3.kind, value = _a3.value, error = _a3.error;
    return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
  };
  Notification2.prototype.accept = function(nextOrObserver, error, complete) {
    var _a3;
    return isFunction((_a3 = nextOrObserver) === null || _a3 === void 0 ? void 0 : _a3.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
  };
  Notification2.prototype.toObservable = function() {
    var _a3 = this, kind = _a3.kind, value = _a3.value, error = _a3.error;
    var result = kind === "N" ? of(value) : kind === "E" ? throwError(function() {
      return error;
    }) : kind === "C" ? EMPTY : 0;
    if (!result) {
      throw new TypeError("Unexpected notification kind " + kind);
    }
    return result;
  };
  Notification2.createNext = function(value) {
    return new Notification2("N", value);
  };
  Notification2.createError = function(err) {
    return new Notification2("E", void 0, err);
  };
  Notification2.createComplete = function() {
    return Notification2.completeNotification;
  };
  Notification2.completeNotification = new Notification2("C");
  return Notification2;
}();
function observeNotification(notification, observer) {
  var _a3, _b, _c;
  var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
  if (typeof kind !== "string") {
    throw new TypeError('Invalid notification, missing "kind"');
  }
  kind === "N" ? (_a3 = observer.next) === null || _a3 === void 0 ? void 0 : _a3.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
}

// node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});

// node_modules/rxjs/dist/esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeError = createErrorClass(function(_super) {
  return function ArgumentOutOfRangeErrorImpl() {
    _super(this);
    this.name = "ArgumentOutOfRangeError";
    this.message = "argument out of range";
  };
});

// node_modules/rxjs/dist/esm5/internal/util/NotFoundError.js
var NotFoundError = createErrorClass(function(_super) {
  return function NotFoundErrorImpl(message) {
    _super(this);
    this.name = "NotFoundError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/SequenceError.js
var SequenceError = createErrorClass(function(_super) {
  return function SequenceErrorImpl(message) {
    _super(this);
    this.name = "SequenceError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/isDate.js
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}

// node_modules/rxjs/dist/esm5/internal/operators/timeout.js
var TimeoutError = createErrorClass(function(_super) {
  return function TimeoutErrorImpl(info) {
    if (info === void 0) {
      info = null;
    }
    _super(this);
    this.message = "Timeout has occurred";
    this.name = "TimeoutError";
    this.info = info;
  };
});
function timeout(config2, schedulerArg) {
  var _a3 = isValidDate(config2) ? { first: config2 } : typeof config2 === "number" ? { each: config2 } : config2, first2 = _a3.first, each = _a3.each, _b = _a3.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a3.scheduler, scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : asyncScheduler : _c, _d = _a3.meta, meta = _d === void 0 ? null : _d;
  if (first2 == null && each == null) {
    throw new TypeError("No timeout provided.");
  }
  return operate(function(source, subscriber) {
    var originalSourceSubscription;
    var timerSubscription;
    var lastValue = null;
    var seen = 0;
    var startTimer = function(delay2) {
      timerSubscription = executeSchedule(subscriber, scheduler, function() {
        try {
          originalSourceSubscription.unsubscribe();
          innerFrom(_with({
            meta,
            lastValue,
            seen
          })).subscribe(subscriber);
        } catch (err) {
          subscriber.error(err);
        }
      }, delay2);
    };
    originalSourceSubscription = source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
      seen++;
      subscriber.next(lastValue = value);
      each > 0 && startTimer(each);
    }, void 0, void 0, function() {
      if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
        timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
      }
      lastValue = null;
    }));
    !seen && startTimer(first2 != null ? typeof first2 === "number" ? first2 : +first2 - scheduler.now() : each);
  });
}
function timeoutErrorFactory(info) {
  throw new TimeoutError(info);
}

// node_modules/rxjs/dist/esm5/internal/operators/map.js
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
var isArray = Array.isArray;
function callOrApply(fn, args) {
  return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
}
function mapOneOrManyArgs(fn) {
  return map(function(args) {
    return callOrApply(fn, args);
  });
}

// node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
var isArray2 = Array.isArray;
var getPrototypeOf = Object.getPrototypeOf;
var objectProto = Object.prototype;
var getKeys = Object.keys;
function argsArgArrayOrObject(args) {
  if (args.length === 1) {
    var first_1 = args[0];
    if (isArray2(first_1)) {
      return { args: first_1, keys: null };
    }
    if (isPOJO(first_1)) {
      var keys = getKeys(first_1);
      return {
        args: keys.map(function(key) {
          return first_1[key];
        }),
        keys
      };
    }
  }
  return { args, keys: null };
}
function isPOJO(obj) {
  return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
}

// node_modules/rxjs/dist/esm5/internal/util/createObject.js
function createObject(keys, values) {
  return keys.reduce(function(result, key, i) {
    return result[key] = values[i], result;
  }, {});
}

// node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js
function combineLatest() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var resultSelector = popResultSelector(args);
  var _a3 = argsArgArrayOrObject(args), observables = _a3.args, keys = _a3.keys;
  if (observables.length === 0) {
    return from([], scheduler);
  }
  var result = new Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
    return createObject(keys, values);
  } : identity));
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
function combineLatestInit(observables, scheduler, valueTransform) {
  if (valueTransform === void 0) {
    valueTransform = identity;
  }
  return function(subscriber) {
    maybeSchedule(scheduler, function() {
      var length = observables.length;
      var values = new Array(length);
      var active = length;
      var remainingFirstValues = length;
      var _loop_1 = function(i2) {
        maybeSchedule(scheduler, function() {
          var source = from(observables[i2], scheduler);
          var hasFirstValue = false;
          source.subscribe(createOperatorSubscriber(subscriber, function(value) {
            values[i2] = value;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, function() {
            if (!--active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      };
      for (var i = 0; i < length; i++) {
        _loop_1(i);
      }
    }, subscriber);
  };
}
function maybeSchedule(scheduler, execute, subscription) {
  if (scheduler) {
    executeSchedule(subscription, scheduler, execute);
  } else {
    execute();
  }
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand2, innerSubScheduler, additionalFinalizer) {
  var buffer2 = [];
  var active = 0;
  var index = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer2.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer2.push(value);
  };
  var doInnerSub = function(value) {
    expand2 && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand2) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer2.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer2.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function(a, i) {
      return map(function(b, ii) {
        return resultSelector(a, b, i, ii);
      })(innerFrom(project(a, i)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap(identity, concurrent);
}

// node_modules/rxjs/dist/esm5/internal/operators/concatAll.js
function concatAll() {
  return mergeAll(1);
}

// node_modules/rxjs/dist/esm5/internal/observable/concat.js
function concat() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return concatAll()(from(args, popScheduler(args)));
}

// node_modules/rxjs/dist/esm5/internal/observable/defer.js
function defer(observableFactory) {
  return new Observable(function(subscriber) {
    innerFrom(observableFactory()).subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/timer.js
function timer(dueTime, intervalOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  var intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler(intervalOrScheduler)) {
      scheduler = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable(function(subscriber) {
    var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    var n = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/never.js
var NEVER = new Observable(noop);

// node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js
var isArray3 = Array.isArray;

// node_modules/rxjs/dist/esm5/internal/operators/filter.js
function filter(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index++) && subscriber.next(value);
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/range.js
function range(start, count2, scheduler) {
  if (count2 == null) {
    count2 = start;
    start = 0;
  }
  if (count2 <= 0) {
    return EMPTY;
  }
  var end = count2 + start;
  return new Observable(scheduler ? function(subscriber) {
    var n = start;
    return scheduler.schedule(function() {
      if (n < end) {
        subscriber.next(n++);
        this.schedule();
      } else {
        subscriber.complete();
      }
    });
  } : function(subscriber) {
    var n = start;
    while (n < end && !subscriber.closed) {
      subscriber.next(n++);
    }
    subscriber.complete();
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/catchError.js
function catchError(selector) {
  return operate(function(source, subscriber) {
    var innerSub = null;
    var syncUnsub = false;
    var handledResult;
    innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
      handledResult = innerFrom(selector(err, catchError(selector)(source)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/concatMap.js
function concatMap(project, resultSelector) {
  return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);
}

// node_modules/rxjs/dist/esm5/internal/observable/fromSubscribable.js
function fromSubscribable(subscribable) {
  return new Observable(function(subscriber) {
    return subscribable.subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/connect.js
var DEFAULT_CONFIG = {
  connector: function() {
    return new Subject();
  }
};
function connect(selector, config2) {
  if (config2 === void 0) {
    config2 = DEFAULT_CONFIG;
  }
  var connector = config2.connector;
  return operate(function(source, subscriber) {
    var subject = connector();
    innerFrom(selector(fromSubscribable(subject))).subscribe(subscriber);
    subscriber.add(source.subscribe(subject));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/defaultIfEmpty.js
function defaultIfEmpty(defaultValue) {
  return operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      if (!hasValue) {
        subscriber.next(defaultValue);
      }
      subscriber.complete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/take.js
function take(count2) {
  return count2 <= 0 ? function() {
    return EMPTY;
  } : operate(function(source, subscriber) {
    var seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (++seen <= count2) {
        subscriber.next(value);
        if (count2 <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js
function distinctUntilChanged(comparator, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity;
  }
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
  return operate(function(source, subscriber) {
    var previousKey;
    var first2 = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var currentKey = keySelector(value);
      if (first2 || !comparator(previousKey, currentKey)) {
        first2 = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
function defaultCompare(a, b) {
  return a === b;
}

// node_modules/rxjs/dist/esm5/internal/operators/distinctUntilKeyChanged.js
function distinctUntilKeyChanged(key, compare) {
  return distinctUntilChanged(function(x, y) {
    return compare ? compare(x[key], y[key]) : x[key] === y[key];
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/throwIfEmpty.js
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
    }));
  });
}
function defaultErrorFactory() {
  return new EmptyError();
}

// node_modules/rxjs/dist/esm5/internal/operators/endWith.js
function endWith() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  return function(source) {
    return concat(source, of.apply(void 0, __spreadArray([], __read(values))));
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/first.js
function first(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v, i) {
      return predicate(v, i, source);
    }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/multicast.js
function multicast(subjectOrSubjectFactory, selector) {
  var subjectFactory = isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
    return subjectOrSubjectFactory;
  };
  if (isFunction(selector)) {
    return connect(selector, {
      connector: subjectFactory
    });
  }
  return function(source) {
    return new ConnectableObservable(source, subjectFactory);
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/pluck.js
function pluck() {
  var properties = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    properties[_i] = arguments[_i];
  }
  var length = properties.length;
  if (length === 0) {
    throw new Error("list of properties cannot be empty.");
  }
  return map(function(x) {
    var currentProp = x;
    for (var i = 0; i < length; i++) {
      var p = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i]];
      if (typeof p !== "undefined") {
        currentProp = p;
      } else {
        return void 0;
      }
    }
    return currentProp;
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/publish.js
function publish(selector) {
  return selector ? function(source) {
    return connect(selector)(source);
  } : function(source) {
    return multicast(new Subject())(source);
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/retry.js
function retry(configOrCount) {
  if (configOrCount === void 0) {
    configOrCount = Infinity;
  }
  var config2;
  if (configOrCount && typeof configOrCount === "object") {
    config2 = configOrCount;
  } else {
    config2 = {
      count: configOrCount
    };
  }
  var _a3 = config2.count, count2 = _a3 === void 0 ? Infinity : _a3, delay2 = config2.delay, _b = config2.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
  return count2 <= 0 ? identity : operate(function(source, subscriber) {
    var soFar = 0;
    var innerSub;
    var subscribeForRetry = function() {
      var syncUnsub = false;
      innerSub = source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (resetOnSuccess) {
          soFar = 0;
        }
        subscriber.next(value);
      }, void 0, function(err) {
        if (soFar++ < count2) {
          var resub_1 = function() {
            if (innerSub) {
              innerSub.unsubscribe();
              innerSub = null;
              subscribeForRetry();
            } else {
              syncUnsub = true;
            }
          };
          if (delay2 != null) {
            var notifier = typeof delay2 === "number" ? timer(delay2) : innerFrom(delay2(err, soFar));
            var notifierSubscriber_1 = createOperatorSubscriber(subscriber, function() {
              notifierSubscriber_1.unsubscribe();
              resub_1();
            }, function() {
              subscriber.complete();
            });
            notifier.subscribe(notifierSubscriber_1);
          } else {
            resub_1();
          }
        } else {
          subscriber.error(err);
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        subscribeForRetry();
      }
    };
    subscribeForRetry();
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/share.js
function share(options) {
  if (options === void 0) {
    options = {};
  }
  var _a3 = options.connector, connector = _a3 === void 0 ? function() {
    return new Subject();
  } : _a3, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
  return function(wrapperSource) {
    var connection;
    var resetConnection;
    var subject;
    var refCount2 = 0;
    var hasCompleted = false;
    var hasErrored = false;
    var cancelReset = function() {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = void 0;
    };
    var reset = function() {
      cancelReset();
      connection = subject = void 0;
      hasCompleted = hasErrored = false;
    };
    var resetAndUnsubscribe = function() {
      var conn = connection;
      reset();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    };
    return operate(function(source, subscriber) {
      refCount2++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(function() {
        refCount2--;
        if (refCount2 === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection && refCount2 > 0) {
        connection = new SafeSubscriber({
          next: function(value) {
            return dest.next(value);
          },
          error: function(err) {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnError, err);
            dest.error(err);
          },
          complete: function() {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnComplete);
            dest.complete();
          }
        });
        innerFrom(source).subscribe(connection);
      }
    })(wrapperSource);
  };
}
function handleReset(reset, on) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  if (on === true) {
    reset();
    return;
  }
  if (on === false) {
    return;
  }
  var onSubscriber = new SafeSubscriber({
    next: function() {
      onSubscriber.unsubscribe();
      reset();
    }
  });
  return innerFrom(on.apply(void 0, __spreadArray([], __read(args)))).subscribe(onSubscriber);
}

// node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js
function shareReplay(configOrBufferSize, windowTime2, scheduler) {
  var _a3, _b, _c;
  var bufferSize;
  var refCount2 = false;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    _a3 = configOrBufferSize.bufferSize, bufferSize = _a3 === void 0 ? Infinity : _a3, _b = configOrBufferSize.windowTime, windowTime2 = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount2 = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
  } else {
    bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
  }
  return share({
    connector: function() {
      return new ReplaySubject(bufferSize, windowTime2, scheduler);
    },
    resetOnError: true,
    resetOnComplete: false,
    resetOnRefCountZero: refCount2
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/startWith.js
function startWith() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  var scheduler = popScheduler(values);
  return operate(function(source, subscriber) {
    (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/switchMap.js
function switchMap(project, resultSelector) {
  return operate(function(source, subscriber) {
    var innerSubscriber = null;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      return isComplete && !innerSubscriber && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function() {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function() {
      isComplete = true;
      checkComplete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js
function takeUntil(notifier) {
  return operate(function(source, subscriber) {
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
      return subscriber.complete();
    }, noop));
    !subscriber.closed && source.subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/takeWhile.js
function takeWhile(predicate, inclusive) {
  if (inclusive === void 0) {
    inclusive = false;
  }
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var result = predicate(value, index++);
      (result || inclusive) && subscriber.next(value);
      !result && subscriber.complete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/tap.js
function tap(observerOrNext, error, complete) {
  var tapObserver = isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
  return tapObserver ? operate(function(source, subscriber) {
    var _a3;
    (_a3 = tapObserver.subscribe) === null || _a3 === void 0 ? void 0 : _a3.call(tapObserver);
    var isUnsub = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var _a4;
      (_a4 = tapObserver.next) === null || _a4 === void 0 ? void 0 : _a4.call(tapObserver, value);
      subscriber.next(value);
    }, function() {
      var _a4;
      isUnsub = false;
      (_a4 = tapObserver.complete) === null || _a4 === void 0 ? void 0 : _a4.call(tapObserver);
      subscriber.complete();
    }, function(err) {
      var _a4;
      isUnsub = false;
      (_a4 = tapObserver.error) === null || _a4 === void 0 ? void 0 : _a4.call(tapObserver, err);
      subscriber.error(err);
    }, function() {
      var _a4, _b;
      if (isUnsub) {
        (_a4 = tapObserver.unsubscribe) === null || _a4 === void 0 ? void 0 : _a4.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity;
}

// node_modules/rxjs/dist/esm5/internal/operators/timeInterval.js
var TimeInterval = function() {
  function TimeInterval2(value, interval2) {
    this.value = value;
    this.interval = interval2;
  }
  return TimeInterval2;
}();

// node_modules/@taquito/michelson-encoder/dist/taquito-michelson-encoder.es6.js
var import_fast_json_stable_stringify = __toESM(require_fast_json_stable_stringify());
var _a$1;
var InvalidMapTypeError = class extends TaquitoError {
  constructor(mapType, reason) {
    super();
    this.mapType = mapType;
    this.reason = reason;
    this.message = `The map type '${JSON.stringify(mapType)}' is invalid. Reason: ${reason}.`;
    this.name = "InvalidMapTypeError";
  }
};
var michelsonMapTypeSymbol = Symbol.for("taquito-michelson-map-type-symbol");
function validateMapType(value) {
  if (!("prim" in value)) {
    throw new InvalidMapTypeError(value, `Missing 'prim' field`);
  }
  if (!["map", "big_map"].includes(value.prim)) {
    throw new InvalidMapTypeError(value, `The prim field should be 'map' or 'big_map'`);
  }
  if (!("args" in value)) {
    throw new InvalidMapTypeError(value, `Missing 'args' field`);
  }
  if (!Array.isArray(value.args)) {
    throw new InvalidMapTypeError(value, `The 'args' field should be an array`);
  }
  if (value.args.length !== 2) {
    throw new InvalidMapTypeError(value, `The 'args' field should have 2 elements`);
  }
}
var MapTypecheckError = class extends TaquitoError {
  constructor(value, type, objectType, reason) {
    super();
    this.value = value;
    this.type = type;
    this.reason = reason;
    this.name = "MapTypecheckError";
    this.message = `The ${objectType} provided: ${JSON.stringify(value)} is not compatible with the expected michelson type: ${JSON.stringify(type)}. Reason: ${JSON.stringify(reason)}.`;
    this.name = "MapTypecheckError";
  }
};
var MichelsonMap = class _MichelsonMap {
  /**
   * @param mapType If specified key and value will be type-checked before being added to the map
   *
   * @example new MichelsonMap({ prim: "map", args: [{prim: "string"}, {prim: "int"}]})
   */
  constructor(mapType) {
    this.valueMap = /* @__PURE__ */ new Map();
    this.keyMap = /* @__PURE__ */ new Map();
    this[_a$1] = true;
    if (mapType) {
      this.setType(mapType);
    }
  }
  // Used to check if an object is a michelson map.
  // Using instanceof was not working for project that had multiple instance of taquito dependencies
  // as the class constructor is different
  static isMichelsonMap(obj) {
    return obj && obj[michelsonMapTypeSymbol] === true;
  }
  setType(mapType) {
    validateMapType(mapType);
    this.keySchema = new Schema(mapType.args[0]);
    this.valueSchema = new Schema(mapType.args[1]);
  }
  removeType() {
    this.keySchema = void 0;
    this.valueSchema = void 0;
  }
  static fromLiteral(obj, mapType) {
    const map2 = new _MichelsonMap(mapType);
    Object.keys(obj).forEach((key) => {
      map2.set(key, obj[key]);
    });
    return map2;
  }
  typecheckKey(key) {
    if (!this.keySchema) {
      return;
    }
    this.keySchema.Typecheck(key);
  }
  typecheckValue(value) {
    if (!this.valueSchema) {
      return;
    }
    this.valueSchema.Typecheck(value);
  }
  /**
   * @throws {@link MapTypecheckError} when the argument passed does not match the expected schema for value
   */
  assertTypecheckValue(value) {
    try {
      this.typecheckValue(value);
    } catch (e) {
      throw new MapTypecheckError(value, this.valueSchema, "value", e);
    }
  }
  /**
   * @throws {@link MapTypecheckError} when the argument passed does not match the expected schema for key
   */
  assertTypecheckKey(key) {
    try {
      this.typecheckKey(key);
    } catch (e) {
      throw new MapTypecheckError(key, this.keySchema, "key", e);
    }
  }
  serializeDeterministically(key) {
    return (0, import_fast_json_stable_stringify.default)(key);
  }
  *keys() {
    for (const [key] of this.entries()) {
      yield key;
    }
  }
  *values() {
    for (const [, value] of this.entries()) {
      yield value;
    }
  }
  *entries() {
    for (const key of this.valueMap.keys()) {
      yield [this.keyMap.get(key), this.valueMap.get(key)];
    }
  }
  get(key) {
    this.assertTypecheckKey(key);
    const strKey = this.serializeDeterministically(key);
    return this.valueMap.get(strKey);
  }
  /**
   *
   * @description Set a key and a value in the MichelsonMap. If the key already exists, override the current value.
   *
   * @example map.set("myKey", "myValue") // Using a string as key
   *
   * @example map.set({0: "test", 1: "test1"}, "myValue") // Using a pair as key
   *
   * @warn The same key can be represented in multiple ways, depending on the type of the key. This duplicate key situation will cause a runtime error (duplicate key) when sending the map data to the Tezos RPC node.
   *
   * For example, consider a contract with a map whose key is of type boolean.  If you set the following values in MichelsonMap: map.set(false, "myValue") and map.set(null, "myValue").
   *
   * You will get two unique entries in the MichelsonMap. These values will both be evaluated as falsy by the MichelsonEncoder and ultimately rejected by the Tezos RPC.
   */
  set(key, value) {
    this.assertTypecheckKey(key);
    this.assertTypecheckValue(value);
    const strKey = this.serializeDeterministically(key);
    this.keyMap.set(strKey, key);
    this.valueMap.set(strKey, value);
  }
  delete(key) {
    this.assertTypecheckKey(key);
    this.keyMap.delete(this.serializeDeterministically(key));
    this.valueMap.delete(this.serializeDeterministically(key));
  }
  has(key) {
    this.assertTypecheckKey(key);
    const strKey = this.serializeDeterministically(key);
    return this.keyMap.has(strKey) && this.valueMap.has(strKey);
  }
  clear() {
    this.keyMap.clear();
    this.valueMap.clear();
  }
  get size() {
    return this.keyMap.size;
  }
  forEach(cb) {
    for (const [key, value] of this.entries()) {
      cb(value, key, this);
    }
  }
};
_a$1 = michelsonMapTypeSymbol;
var TokenValidationError = class extends TaquitoError {
  constructor(value, token, baseMessage) {
    super();
    this.value = value;
    this.token = token;
    this.name = "TokenValidationError";
    const annot = this.token.annot();
    const annotText = annot ? `[${annot}] ` : "";
    this.message = `${annotText}${baseMessage}`;
  }
};
var Token = class {
  constructor(val, idx, fac) {
    this.val = val;
    this.idx = idx;
    this.fac = fac;
    this.createToken = this.fac;
  }
  typeWithoutAnnotations() {
    const handleMichelsonExpression = (val) => {
      if (typeof val === "object") {
        if (Array.isArray(val)) {
          const array = val;
          return array.map((item) => handleMichelsonExpression(item));
        }
        const extended = val;
        if (extended.args) {
          return {
            prim: extended.prim,
            args: extended.args.map((x) => handleMichelsonExpression(x))
          };
        } else {
          return {
            prim: extended.prim
          };
        }
      }
      return val;
    };
    const handleMichelsonExtended = (val) => {
      if (val.args) {
        return {
          prim: val.prim,
          args: val.args.map((x) => handleMichelsonExpression(x))
        };
      } else {
        return {
          prim: val.prim
        };
      }
    };
    return handleMichelsonExtended(this.val);
  }
  annot() {
    return (Array.isArray(this.val.annots) && this.val.annots.length > 0 ? this.val.annots[0] : String(this.idx)).replace(/(%|:)(_Liq_entry_)?/, "");
  }
  hasAnnotations() {
    return Array.isArray(this.val.annots) && this.val.annots.length;
  }
  get tokenVal() {
    return this.val;
  }
  ExtractSignature() {
    return [[this.ExtractSchema()]];
  }
};
var ComparableToken = class extends Token {
  compare(o1, o2) {
    if (o1 === o2) {
      return 0;
    }
    return o1 < o2 ? -1 : 1;
  }
};
var BigMapValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "BigMapValidationError";
  }
};
var BigMapToken = class _BigMapToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  get ValueSchema() {
    return this.createToken(this.val.args[1], 0);
  }
  get KeySchema() {
    return this.createToken(this.val.args[0], 0);
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return {
      big_map: {
        key: this.KeySchema.ExtractSchema(),
        value: this.ValueSchema.ExtractSchema()
      }
    };
  }
  generateSchema() {
    return {
      __michelsonType: _BigMapToken.prim,
      schema: {
        key: this.KeySchema.generateSchema(),
        value: this.ValueSchema.generateSchema()
      }
    };
  }
  /**
   * @throws {@link BigMapValidationError}
   */
  validate(value) {
    if (!MichelsonMap.isMichelsonMap(value)) {
      throw new BigMapValidationError(value, this, `Value ${JSON.stringify(value)} is not a MichelsonMap`);
    }
  }
  objLitToMichelsonMap(val) {
    if (val instanceof MichelsonMap)
      return val;
    if (typeof val === "object") {
      if (Object.keys(val).length === 0) {
        return new MichelsonMap();
      } else {
        return MichelsonMap.fromLiteral(val);
      }
    }
    return val;
  }
  /**
   * @throws {@link BigMapValidationError}
   */
  Encode(args) {
    const val = this.objLitToMichelsonMap(args.pop());
    this.validate(val);
    return Array.from(val.keys()).sort((a, b) => this.KeySchema.compare(a, b)).map((key) => {
      return {
        prim: "Elt",
        args: [this.KeySchema.EncodeObject(key), this.ValueSchema.EncodeObject(val.get(key))]
      };
    });
  }
  /**
   * @throws {@link BigMapValidationError}
   */
  EncodeObject(args, semantic) {
    const val = this.objLitToMichelsonMap(args);
    this.validate(val);
    if (semantic && semantic[_BigMapToken.prim]) {
      return semantic[_BigMapToken.prim](val, this.val);
    }
    return Array.from(val.keys()).sort((a, b) => this.KeySchema.compare(a, b)).map((key) => {
      return {
        prim: "Elt",
        args: [this.KeySchema.EncodeObject(key), this.ValueSchema.EncodeObject(val.get(key))]
      };
    });
  }
  /**
   * @throws {@link InvalidMapTypeError} when the argument passed to val is an array but not a valid map type
   * @throws {@link BigMapValidationError} when the value is invalid
   */
  Execute(val, semantic) {
    if (semantic && semantic[_BigMapToken.prim]) {
      return semantic[_BigMapToken.prim](val, this.val);
    }
    if (Array.isArray(val)) {
      const map2 = new MichelsonMap(this.val);
      val.forEach((current) => {
        map2.set(this.KeySchema.ToKey(current.args[0]), this.ValueSchema.Execute(current.args[1]));
      });
      return map2;
    } else if ("int" in val) {
      return val.int;
    } else {
      throw new BigMapValidationError(val, this, `Big map is expecting either an array (Athens) or an object with an int property (Babylon). Got ${JSON.stringify(val)}`);
    }
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_BigMapToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.KeySchema.findAndReturnTokens(tokenToFind, tokens2);
    this.ValueSchema.findAndReturnTokens(tokenToFind, tokens2);
    return tokens2;
  }
};
BigMapToken.prim = "big_map";
var OrTokenDecodingError = class extends TaquitoError {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "OrTokenDecodingError";
  }
};
var OrToken = class _OrToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Encode(args) {
    const label = args[args.length - 1];
    const leftToken = this.createToken(this.val.args[0], this.idx);
    let keyCount = 1;
    if (leftToken instanceof _OrToken) {
      keyCount = Object.keys(leftToken.ExtractSchema()).length;
    }
    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);
    if (String(leftToken.annot()) === String(label) && !(leftToken instanceof _OrToken)) {
      args.pop();
      return { prim: "Left", args: [leftToken.Encode(args)] };
    } else if (String(rightToken.annot()) === String(label) && !(rightToken instanceof _OrToken)) {
      args.pop();
      return { prim: "Right", args: [rightToken.Encode(args)] };
    } else {
      if (leftToken instanceof _OrToken) {
        const val = leftToken.Encode(args);
        if (val) {
          return { prim: "Left", args: [val] };
        }
      }
      if (rightToken instanceof _OrToken) {
        const val = rightToken.Encode(args);
        if (val) {
          return { prim: "Right", args: [val] };
        }
      }
      return null;
    }
  }
  ExtractSignature() {
    const leftToken = this.createToken(this.val.args[0], this.idx);
    let keyCount = 1;
    if (leftToken instanceof _OrToken) {
      keyCount = Object.keys(leftToken.ExtractSchema()).length;
    }
    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);
    const newSig = [];
    if (leftToken instanceof _OrToken) {
      newSig.push(...leftToken.ExtractSignature());
    } else {
      for (const sig of leftToken.ExtractSignature()) {
        newSig.push([leftToken.annot(), ...sig]);
      }
    }
    if (rightToken instanceof _OrToken) {
      newSig.push(...rightToken.ExtractSignature());
    } else {
      for (const sig of rightToken.ExtractSignature()) {
        newSig.push([rightToken.annot(), ...sig]);
      }
    }
    return newSig;
  }
  EncodeObject(args, semantic) {
    const label = Object.keys(args)[0];
    const leftToken = this.createToken(this.val.args[0], this.idx);
    let keyCount = 1;
    if (leftToken instanceof _OrToken) {
      keyCount = Object.keys(leftToken.ExtractSchema()).length;
    }
    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);
    if (String(leftToken.annot()) === String(label) && !(leftToken instanceof _OrToken)) {
      return { prim: "Left", args: [leftToken.EncodeObject(args[label], semantic)] };
    } else if (String(rightToken.annot()) === String(label) && !(rightToken instanceof _OrToken)) {
      return { prim: "Right", args: [rightToken.EncodeObject(args[label], semantic)] };
    } else {
      if (leftToken instanceof _OrToken) {
        const val = leftToken.EncodeObject(args, semantic);
        if (val) {
          return { prim: "Left", args: [val] };
        }
      }
      if (rightToken instanceof _OrToken) {
        const val = rightToken.EncodeObject(args, semantic);
        if (val) {
          return { prim: "Right", args: [val] };
        }
      }
      return null;
    }
  }
  /**
   * @throws {@link OrTokenDecodingError}
   */
  Execute(val, semantics) {
    const leftToken = this.createToken(this.val.args[0], this.idx);
    let keyCount = 1;
    if (leftToken instanceof _OrToken) {
      keyCount = Object.keys(leftToken.ExtractSchema()).length;
    }
    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);
    if (val.prim === "Right") {
      if (rightToken instanceof _OrToken) {
        return rightToken.Execute(val.args[0], semantics);
      } else {
        return {
          [rightToken.annot()]: rightToken.Execute(val.args[0], semantics)
        };
      }
    } else if (val.prim === "Left") {
      if (leftToken instanceof _OrToken) {
        return leftToken.Execute(val.args[0], semantics);
      }
      return {
        [leftToken.annot()]: leftToken.Execute(val.args[0], semantics)
      };
    } else {
      throw new OrTokenDecodingError(`Was expecting Left or Right prim but got: ${JSON.stringify(val.prim)}`);
    }
  }
  traversal(getLeftValue, getRightValue, concat3) {
    const leftToken = this.createToken(this.val.args[0], this.idx);
    let keyCount = 1;
    let leftValue;
    if (leftToken instanceof _OrToken && !leftToken.hasAnnotations()) {
      leftValue = getLeftValue(leftToken);
      keyCount = Object.keys(leftToken.ExtractSchema()).length;
    } else {
      leftValue = { [leftToken.annot()]: getLeftValue(leftToken) };
    }
    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);
    let rightValue;
    if (rightToken instanceof _OrToken && !rightToken.hasAnnotations()) {
      rightValue = getRightValue(rightToken);
    } else {
      rightValue = { [rightToken.annot()]: getRightValue(rightToken) };
    }
    const res = concat3(leftValue, rightValue);
    return res;
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return this.traversal((leftToken) => leftToken.ExtractSchema(), (rightToken) => rightToken.ExtractSchema(), (leftValue, rightValue) => Object.assign(Object.assign({}, leftValue), rightValue));
  }
  generateSchema() {
    return {
      __michelsonType: _OrToken.prim,
      schema: this.traversal((leftToken) => {
        if (leftToken instanceof _OrToken && !leftToken.hasAnnotations()) {
          return leftToken.generateSchema().schema;
        } else {
          return leftToken.generateSchema();
        }
      }, (rightToken) => {
        if (rightToken instanceof _OrToken && !rightToken.hasAnnotations()) {
          return rightToken.generateSchema().schema;
        } else {
          return rightToken.generateSchema();
        }
      }, (leftValue, rightValue) => Object.assign(Object.assign({}, leftValue), rightValue))
    };
  }
  findToken(label) {
    const leftToken = this.createToken(this.val.args[0], this.idx);
    let keyCount = 1;
    if (leftToken instanceof _OrToken) {
      keyCount = Object.keys(leftToken.ExtractSchema()).length;
    }
    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);
    if (String(leftToken.annot()) === String(label) && !(leftToken instanceof _OrToken) && leftToken instanceof ComparableToken) {
      return leftToken;
    } else if (String(rightToken.annot()) === String(label) && !(rightToken instanceof _OrToken) && rightToken instanceof ComparableToken) {
      return rightToken;
    } else {
      if (leftToken instanceof _OrToken) {
        const tok = leftToken.findToken(label);
        if (tok) {
          return tok;
        }
      }
      if (rightToken instanceof _OrToken) {
        const tok = rightToken.findToken(label);
        if (tok) {
          return tok;
        }
      }
      return null;
    }
  }
  compare(val1, val2) {
    const labelVal1 = Object.keys(val1)[0];
    const labelVal2 = Object.keys(val2)[0];
    if (labelVal1 === labelVal2) {
      const token = this.findToken(labelVal1);
      if (token instanceof ComparableToken) {
        return token.compare(val1[labelVal1], val2[labelVal1]);
      }
    } else {
      const encoded1 = JSON.stringify(this.EncodeObject(val1));
      const encoded2 = JSON.stringify(this.EncodeObject(val2));
      return encoded1 < encoded2 ? -1 : 1;
    }
  }
  ToKey(val) {
    return this.Execute(val);
  }
  ToBigMapKey(val) {
    return {
      key: this.EncodeObject(val),
      type: this.typeWithoutAnnotations()
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_OrToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.traversal((leftToken) => leftToken.findAndReturnTokens(tokenToFind, tokens2), (rightToken) => rightToken.findAndReturnTokens(tokenToFind, tokens2), (leftValue, rightValue) => Object.assign(Object.assign({}, leftValue), rightValue));
    return tokens2;
  }
};
OrToken.prim = "or";
var TokenArgumentValidationError = class extends TaquitoError {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "TokenArgumentValidationError";
  }
};
var TokenComparisonError = class extends TaquitoError {
  constructor(val1, val2) {
    super();
    this.val1 = val1;
    this.val2 = val2;
    this.name = "TokenComparisonError";
    this.message = `Tokens ${JSON.stringify(val1)} and ${JSON.stringify(val2)} are not comparable`;
  }
};
function collapse$1(val, prim = PairToken.prim) {
  if (Array.isArray(val)) {
    return collapse$1({
      prim,
      args: val
    }, prim);
  }
  if (val.args === void 0) {
    throw new TokenArgumentValidationError(`The value ${JSON.stringify(val)} is an invalid PairToken with no arguments, a pair must have two or more arguments.`);
  }
  if (val.args.length > 2) {
    return [
      val.args[0],
      {
        prim,
        args: val.args.slice(1)
      }
    ];
  }
  return [val.args[0], val.args[1]];
}
var PairToken = class _PairToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(Array.isArray(val) ? {
      prim: _PairToken.prim,
      args: val
    } : val.prim ? val : {
      prim: _PairToken.prim,
      args: val
    }, idx, fac);
  }
  args() {
    return collapse$1(this.val);
  }
  tokens() {
    let cnt = 0;
    return this.args().map((a) => {
      const tok = this.createToken(a, this.idx + cnt);
      if (tok instanceof _PairToken) {
        cnt += Object.keys(tok.ExtractSchema()).length;
      } else {
        cnt++;
      }
      return tok;
    });
  }
  Encode(args) {
    return {
      prim: "Pair",
      args: this.tokens().map((t) => t.Encode(args))
    };
  }
  ExtractSignature() {
    const args = this.args();
    const leftToken = this.createToken(args[0], this.idx);
    let keyCount = 1;
    if (leftToken instanceof OrToken) {
      keyCount = Object.keys(leftToken.ExtractSchema()).length;
    }
    const rightToken = this.createToken(args[1], this.idx + keyCount);
    const newSig = [];
    for (const leftSig of leftToken.ExtractSignature()) {
      for (const rightSig of rightToken.ExtractSignature()) {
        newSig.push([...leftSig, ...rightSig]);
      }
    }
    return newSig;
  }
  ToBigMapKey(val) {
    return {
      key: this.EncodeObject(val),
      type: this.typeWithoutAnnotations()
    };
  }
  ToKey(val) {
    return this.Execute(val);
  }
  EncodeObject(args, semantic) {
    const [leftToken, rightToken] = this.tokens();
    let leftValue;
    if (leftToken instanceof _PairToken && !leftToken.hasAnnotations()) {
      leftValue = args;
    } else {
      leftValue = args[leftToken.annot()];
    }
    let rightValue;
    if (rightToken instanceof _PairToken && !rightToken.hasAnnotations()) {
      rightValue = args;
    } else {
      rightValue = args[rightToken.annot()];
    }
    return {
      prim: "Pair",
      args: [
        leftToken.EncodeObject(leftValue, semantic),
        rightToken.EncodeObject(rightValue, semantic)
      ]
    };
  }
  traversal(getLeftValue, getRightValue) {
    const args = this.args();
    const leftToken = this.createToken(args[0], this.idx);
    let keyCount = 1;
    let leftValue;
    if (leftToken instanceof _PairToken) {
      keyCount = Object.keys(leftToken.ExtractSchema()).length;
    }
    if (leftToken instanceof _PairToken && !leftToken.hasAnnotations()) {
      leftValue = getLeftValue(leftToken);
    } else {
      leftValue = { [leftToken.annot()]: getLeftValue(leftToken) };
    }
    const rightToken = this.createToken(args[1], this.idx + keyCount);
    let rightValue;
    if (rightToken instanceof _PairToken && !rightToken.hasAnnotations()) {
      rightValue = getRightValue(rightToken);
    } else {
      rightValue = { [rightToken.annot()]: getRightValue(rightToken) };
    }
    const res = Object.assign(Object.assign({}, leftValue), rightValue);
    return res;
  }
  Execute(val, semantics) {
    const args = collapse$1(val, "Pair");
    return this.traversal((leftToken) => leftToken.Execute(args[0], semantics), (rightToken) => rightToken.Execute(args[1], semantics));
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return this.traversal((leftToken) => leftToken.ExtractSchema(), (rightToken) => rightToken.ExtractSchema());
  }
  generateSchema() {
    return {
      __michelsonType: _PairToken.prim,
      schema: this.traversal((leftToken) => {
        if (leftToken instanceof _PairToken && !leftToken.hasAnnotations()) {
          return leftToken.generateSchema().schema;
        } else {
          return leftToken.generateSchema();
        }
      }, (rightToken) => {
        if (rightToken instanceof _PairToken && !rightToken.hasAnnotations()) {
          return rightToken.generateSchema().schema;
        } else {
          return rightToken.generateSchema();
        }
      })
    };
  }
  /**
   * @throws {@link TokenComparisonError}
   */
  compare(val1, val2) {
    const [leftToken, rightToken] = this.tokens();
    const getValue = (token, args) => {
      if (token instanceof _PairToken && !token.hasAnnotations()) {
        return args;
      } else {
        return args[token.annot()];
      }
    };
    if (leftToken instanceof ComparableToken && rightToken instanceof ComparableToken) {
      const result = leftToken.compare(getValue(leftToken, val1), getValue(leftToken, val2));
      if (result === 0) {
        return rightToken.compare(getValue(rightToken, val1), getValue(rightToken, val2));
      }
      return result;
    }
    throw new TokenComparisonError(val1, val2);
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_PairToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.tokens().map((t) => t.findAndReturnTokens(tokenToFind, tokens2));
    return tokens2;
  }
};
PairToken.prim = "pair";
var NatValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "NatValidationError";
  }
};
var NatToken = class _NatToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    return new bignumber_default(val[Object.keys(val)[0]]);
  }
  /**
   * @throws {@link NatValidationError}
   */
  Encode(args) {
    const val = args.pop();
    this.validate(val);
    return { int: new bignumber_default(val).toFixed() };
  }
  /**
   * @throws {@link NatValidationError}
   */
  validate(val) {
    const bigNumber = new bignumber_default(val);
    if (bigNumber.isNaN()) {
      throw new NatValidationError(val, this, `Value is not a number: ${JSON.stringify(val)}`);
    }
    if (bigNumber.isNegative()) {
      throw new NatValidationError(val, this, `Value cannot be negative: ${JSON.stringify(val)}`);
    }
  }
  /**
   * @throws {@link NatValidationError}
   */
  EncodeObject(val, semantic) {
    this.validate(val);
    if (semantic && semantic[_NatToken.prim]) {
      return semantic[_NatToken.prim](val);
    }
    return { int: new bignumber_default(val).toFixed() };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _NatToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _NatToken.prim,
      schema: _NatToken.prim
    };
  }
  ToBigMapKey(val) {
    return {
      key: { int: String(val) },
      type: { prim: _NatToken.prim }
    };
  }
  ToKey({ int }) {
    return new bignumber_default(int);
  }
  compare(nat1, nat2) {
    const o1 = Number(nat1);
    const o2 = Number(nat2);
    if (o1 === o2) {
      return 0;
    }
    return o1 < o2 ? -1 : 1;
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_NatToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
NatToken.prim = "nat";
var StringToken = class _StringToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    return val[Object.keys(val)[0]];
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _StringToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _StringToken.prim,
      schema: _StringToken.prim
    };
  }
  Encode(args) {
    const val = args.pop();
    return { string: val };
  }
  EncodeObject(val, semantic) {
    if (semantic && semantic[_StringToken.prim]) {
      return semantic[_StringToken.prim](val);
    }
    return { string: val };
  }
  ToKey({ string }) {
    return string;
  }
  ToBigMapKey(val) {
    return {
      key: { string: val },
      type: { prim: _StringToken.prim }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_StringToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
StringToken.prim = "string";
var AddressValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "AddressValidationError";
  }
};
var AddressToken = class _AddressToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  ToBigMapKey(val) {
    const decoded = b58decode(val);
    return {
      key: { bytes: decoded },
      type: { prim: "bytes" }
    };
  }
  /**
   * @throws {@link AddressValidationError}
   */
  validate(value) {
    if (validateAddress(value) !== ValidationResult.VALID) {
      throw new AddressValidationError(value, this, `Address is not valid: ${JSON.stringify(value)}`);
    }
  }
  /**
   * @throws {@link AddressValidationError}
   */
  Encode(args) {
    const val = args.pop();
    this.validate(val);
    return { string: val };
  }
  /**
   * @throws {@link AddressValidationError}
   */
  EncodeObject(val, semantic) {
    this.validate(val);
    if (semantic && semantic[_AddressToken.prim]) {
      return semantic[_AddressToken.prim](val);
    }
    return { string: val };
  }
  /**
   * @throws {@link AddressValidationError}
   */
  Execute(val) {
    if (val.string) {
      return val.string;
    }
    if (!val.bytes) {
      throw new AddressValidationError(val, this, `cannot be missing both string and bytes: ${JSON.stringify(val)}`);
    }
    return encodePubKey(val.bytes);
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _AddressToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _AddressToken.prim,
      schema: _AddressToken.prim
    };
  }
  /**
   * @throws {@link AddressValidationError}
   */
  ToKey({ bytes, string }) {
    if (string) {
      return string;
    }
    if (!bytes) {
      throw new AddressValidationError({ bytes, string }, this, `cannot be missing both string and bytes ${JSON.stringify({ string, bytes })}`);
    }
    return encodePubKey(bytes);
  }
  compare(address1, address2) {
    const isImplicit = (address) => {
      return address.startsWith("tz");
    };
    const implicit1 = isImplicit(address1);
    const implicit2 = isImplicit(address2);
    if (implicit1 && !implicit2) {
      return -1;
    } else if (implicit2 && !implicit1) {
      return 1;
    }
    return super.compare(address1, address2);
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_AddressToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
AddressToken.prim = "address";
var MapValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "MapValidationError";
  }
};
var MapToken = class _MapToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  get ValueSchema() {
    return this.createToken(this.val.args[1], 0);
  }
  get KeySchema() {
    return this.createToken(this.val.args[0], 0);
  }
  /**
   * @throws {@link MapValidationError}
   */
  validate(value) {
    if (!MichelsonMap.isMichelsonMap(value)) {
      throw new MapValidationError(value, this, `Value ${JSON.stringify(value)} is not a valid MichelsonMap`);
    }
  }
  Execute(val, semantics) {
    const map2 = new MichelsonMap(this.val);
    val.forEach((current) => {
      map2.set(this.KeySchema.ToKey(current.args[0]), this.ValueSchema.Execute(current.args[1], semantics));
    });
    return map2;
  }
  objLitToMichelsonMap(val) {
    if (val instanceof MichelsonMap)
      return val;
    if (typeof val === "object") {
      if (Object.keys(val).length === 0) {
        return new MichelsonMap();
      } else {
        return MichelsonMap.fromLiteral(val);
      }
    }
    return val;
  }
  /**
   * @throws {@link MapValidationError}
   */
  Encode(args) {
    const val = this.objLitToMichelsonMap(args.pop());
    this.validate(val);
    return Array.from(val.keys()).sort((a, b) => this.KeySchema.compare(a, b)).map((key) => {
      return {
        prim: "Elt",
        args: [this.KeySchema.EncodeObject(key), this.ValueSchema.EncodeObject(val.get(key))]
      };
    });
  }
  /**
   * @throws {@link MapValidationError}
   */
  EncodeObject(args, semantic) {
    const val = this.objLitToMichelsonMap(args);
    this.validate(val);
    if (semantic && semantic[_MapToken.prim]) {
      return semantic[_MapToken.prim](val);
    }
    return Array.from(val.keys()).sort((a, b) => this.KeySchema.compare(a, b)).map((key) => {
      return {
        prim: "Elt",
        args: [this.KeySchema.EncodeObject(key), this.ValueSchema.EncodeObject(val.get(key))]
      };
    });
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return {
      map: {
        key: this.KeySchema.ExtractSchema(),
        value: this.ValueSchema.ExtractSchema()
      }
    };
  }
  generateSchema() {
    return {
      __michelsonType: _MapToken.prim,
      schema: {
        key: this.KeySchema.generateSchema(),
        value: this.ValueSchema.generateSchema()
      }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_MapToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.KeySchema.findAndReturnTokens(tokenToFind, tokens2);
    this.ValueSchema.findAndReturnTokens(tokenToFind, tokens2);
    return tokens2;
  }
};
MapToken.prim = "map";
var BoolToken = class _BoolToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    return String(val.prim).toLowerCase() === "true" ? true : false;
  }
  Encode(args) {
    const val = args.pop();
    return { prim: val ? "True" : "False" };
  }
  EncodeObject(val, semantic) {
    if (semantic && semantic[_BoolToken.prim]) {
      return semantic[_BoolToken.prim](val);
    }
    return { prim: val ? "True" : "False" };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _BoolToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _BoolToken.prim,
      schema: _BoolToken.prim
    };
  }
  ToBigMapKey(val) {
    return {
      key: this.EncodeObject(val),
      type: { prim: _BoolToken.prim }
    };
  }
  ToKey(val) {
    return this.EncodeObject(val);
  }
  compare(val1, val2) {
    if (val1 && val2 || !val1 && !val2) {
      return 0;
    } else if (val1) {
      return 1;
    } else {
      return -1;
    }
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_BoolToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
BoolToken.prim = "bool";
var TxRollupL2AddressValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "TxRollupL2AddressValidationError";
  }
};
var TxRollupL2AddressToken = class _TxRollupL2AddressToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  ToBigMapKey(val) {
    const decoded = b58decodeL2Address(val);
    return {
      key: { bytes: decoded },
      type: { prim: "bytes" }
    };
  }
  /**
   * @throws {@link TxRollupL2AddressValidationError}
   */
  validate(value) {
    if (validateAddress(value) !== ValidationResult.VALID) {
      throw new TxRollupL2AddressValidationError(value, this, `tx_rollup_l2_address is not valid: ${JSON.stringify(value)}`);
    }
  }
  /**
   * @throws {@link TxRollupL2AddressValidationError}
   */
  Encode(args) {
    const val = args.pop();
    if (!val) {
      throw new TxRollupL2AddressValidationError(val, this, `arg missing to encode: this -> "${JSON.stringify(val)}"`);
    }
    this.validate(val);
    return { string: val };
  }
  /**
   * @throws {@link TxRollupL2AddressValidationError}
   */
  EncodeObject(val, semantic) {
    this.validate(val);
    if (semantic && semantic[_TxRollupL2AddressToken.prim]) {
      return semantic[_TxRollupL2AddressToken.prim](val);
    }
    return { string: val };
  }
  /**
   * @throws {@link TxRollupL2AddressValidationError}
   */
  Execute(val) {
    if (val.string) {
      return val.string;
    }
    if (!val.bytes) {
      throw new TxRollupL2AddressValidationError(val, this, `value cannot be missing string and byte value. must have one ${JSON.stringify(val)}`);
    }
    return encodeL2Address(val.bytes);
  }
  ExtractSchema() {
    return _TxRollupL2AddressToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _TxRollupL2AddressToken.prim,
      schema: _TxRollupL2AddressToken.prim
    };
  }
  /**
   * @throws {@link TxRollupL2AddressValidationError}
   */
  ToKey({ bytes, string }) {
    if (string) {
      return string;
    }
    if (!bytes) {
      throw new TxRollupL2AddressValidationError(bytes, this, `value cannot be missing string and byte value. must have one: bytes = ${JSON.stringify(bytes)}`);
    }
    return encodeL2Address(bytes);
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_TxRollupL2AddressToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
TxRollupL2AddressToken.prim = "tx_rollup_l2_address";
var ContractValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "ContractValidationError";
  }
};
var ContractToken = class _ContractToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  /**
   * @throws {@link ContractValidationError}
   */
  validate(value) {
    if (validateAddress(value) !== ValidationResult.VALID) {
      throw new ContractValidationError(value, this, `Value ${JSON.stringify(value)} is not a valid contract address.`);
    }
    return null;
  }
  /**
   * @throws {@link ContractValidationError}
   */
  Execute(val) {
    if (val.string) {
      return val.string;
    }
    if (!val.bytes) {
      throw new ContractValidationError(val, this, `Value ${JSON.stringify(val)} is not a valid contract address. must contain bytes or string.`);
    }
    return encodePubKey(val.bytes);
  }
  /**
   * @throws {@link ContractValidationError}
   */
  Encode(args) {
    const val = args.pop();
    this.validate(val);
    return { string: val };
  }
  /**
   * @throws {@link ContractValidationError}
   */
  EncodeObject(val, semantic) {
    this.validate(val);
    if (semantic && semantic[_ContractToken.prim]) {
      return semantic[_ContractToken.prim](val);
    }
    return { string: val };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _ContractToken.prim;
  }
  generateSchema() {
    const valueSchema = this.createToken(this.val.args[0], 0);
    return {
      __michelsonType: _ContractToken.prim,
      schema: {
        parameter: this.val.args[0] ? valueSchema.generateSchema() : {}
      }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_ContractToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
ContractToken.prim = "contract";
var ListValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "ListValidationError";
  }
};
var ListToken = class _ListToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  get valueSchema() {
    return this.createToken(this.val.args[0], this.idx);
  }
  /**
   * @throws {@link ListValidationError}
   */
  validate(value) {
    if (!Array.isArray(value)) {
      throw new ListValidationError(value, this, `Value ${JSON.stringify(value)} is not a valid array`);
    }
  }
  /**
   * @throws {@link ListValidationError}
   */
  Encode(args) {
    const val = args.pop();
    this.validate(val);
    const schema = this.createToken(this.val.args[0], 0);
    return val.reduce((prev, current) => {
      return [...prev, schema.EncodeObject(current)];
    }, []);
  }
  /**
   * @throws {@link ListValidationError}
   */
  Execute(val, semantics) {
    const schema = this.createToken(this.val.args[0], 0);
    this.validate(val);
    return val.reduce((prev, current) => {
      return [...prev, schema.Execute(current, semantics)];
    }, []);
  }
  /**
   * @throws {@link ListValidationError}
   */
  EncodeObject(args, semantic) {
    const schema = this.createToken(this.val.args[0], 0);
    this.validate(args);
    if (semantic && semantic[_ListToken.prim]) {
      return semantic[_ListToken.prim](args);
    }
    return args.reduce((prev, current) => {
      return [...prev, schema.EncodeObject(current)];
    }, []);
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return {
      [_ListToken.prim]: this.valueSchema.ExtractSchema()
    };
  }
  generateSchema() {
    return {
      __michelsonType: _ListToken.prim,
      schema: this.valueSchema.generateSchema()
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_ListToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.createToken(this.val.args[0], this.idx).findAndReturnTokens(tokenToFind, tokens2);
    return tokens2;
  }
};
ListToken.prim = "list";
var MutezValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "MutezValidationError";
  }
};
var MutezToken = class _MutezToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    return new bignumber_default(val[Object.keys(val)[0]]);
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _MutezToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _MutezToken.prim,
      schema: _MutezToken.prim
    };
  }
  /**
   * @throws {@link MutezValidationError}
   */
  validate(val) {
    const bigNumber = new bignumber_default(val);
    if (bigNumber.isNaN()) {
      throw new MutezValidationError(val, this, `Value is not a number: ${val}`);
    }
  }
  /**
   * @throws {@link MutezValidationError}
   */
  Encode(args) {
    const val = args.pop();
    this.validate(val);
    return { int: String(val).toString() };
  }
  /**
   * @throws {@link MutezValidationError}
   */
  EncodeObject(val, semantic) {
    this.validate(val);
    if (semantic && semantic[_MutezToken.prim]) {
      return semantic[_MutezToken.prim](val);
    }
    return { int: String(val).toString() };
  }
  ToBigMapKey(val) {
    return {
      key: { int: String(val) },
      type: { prim: _MutezToken.prim }
    };
  }
  ToKey({ int }) {
    return int;
  }
  compare(mutez1, mutez2) {
    const o1 = Number(mutez1);
    const o2 = Number(mutez2);
    if (o1 === o2) {
      return 0;
    }
    return o1 < o2 ? -1 : 1;
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_MutezToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
MutezToken.prim = "mutez";
var BytesValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "BytesValidationError";
  }
};
var BytesToken = class _BytesToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  ToBigMapKey(val) {
    return {
      key: { bytes: val },
      type: { prim: _BytesToken.prim }
    };
  }
  /**
   * @throws {@link BytesValidationError}
   */
  validate(val) {
    if (typeof val === "string" && /^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {
      return;
    }
    throw new BytesValidationError(val, this, `Invalid bytes: ${val}`);
  }
  convertUint8ArrayToHexString(val) {
    return val.constructor === Uint8Array ? Buffer.from(val).toString("hex") : val;
  }
  /**
   * @throws {@link BytesValidationError}
   */
  Encode(args) {
    let val = args.pop();
    val = stripHexPrefix(this.convertUint8ArrayToHexString(val));
    this.validate(val);
    return { bytes: String(val).toString() };
  }
  /**
   * @throws {@link BytesValidationError}
   */
  EncodeObject(val, semantic) {
    val = this.convertUint8ArrayToHexString(val);
    if (typeof val === "string") {
      val = stripHexPrefix(val);
    }
    this.validate(val);
    if (semantic && semantic[_BytesToken.prim]) {
      return semantic[_BytesToken.prim](val);
    }
    return { bytes: String(val).toString() };
  }
  Execute(val) {
    return val.bytes;
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _BytesToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _BytesToken.prim,
      schema: _BytesToken.prim
    };
  }
  ToKey({ bytes, string }) {
    if (string) {
      return string;
    }
    return bytes;
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_BytesToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
BytesToken.prim = "bytes";
var OptionToken = class _OptionToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  subToken() {
    return this.createToken(this.val.args[0], this.idx);
  }
  schema() {
    return this.createToken(this.val.args[0], 0);
  }
  annot() {
    return Array.isArray(this.val.annots) ? super.annot() : this.createToken(this.val.args[0], this.idx).annot();
  }
  Encode(args) {
    const value = args;
    if (value === void 0 || value === null) {
      return { prim: "None" };
    } else if (Array.isArray(value) && (value[value.length - 1] === void 0 || value[value.length - 1] === null)) {
      value.pop();
      return { prim: "None" };
    }
    return { prim: "Some", args: [this.schema().Encode(args)] };
  }
  EncodeObject(args, semantic) {
    let value = args;
    if (value === void 0 || value === null) {
      return { prim: "None" };
    }
    value = typeof value === "object" && "Some" in value ? value["Some"] : value;
    return { prim: "Some", args: [this.schema().EncodeObject(value, semantic)] };
  }
  Execute(val, semantics) {
    if (val.prim === "None") {
      return null;
    }
    return { Some: this.schema().Execute(val.args[0], semantics) };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return { Some: this.schema().ExtractSchema() };
  }
  generateSchema() {
    return {
      __michelsonType: _OptionToken.prim,
      schema: this.schema().generateSchema()
    };
  }
  ExtractSignature() {
    return [...this.schema().ExtractSignature()];
  }
  get KeySchema() {
    return this.schema();
  }
  compare(val1, val2) {
    if (!val1) {
      return -1;
    } else if (!val2) {
      return 1;
    }
    return this.KeySchema.compare(val1, val2);
  }
  ToKey(val) {
    return this.Execute(val);
  }
  ToBigMapKey(val) {
    return {
      key: this.EncodeObject(val),
      type: this.typeWithoutAnnotations()
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_OptionToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.subToken().findAndReturnTokens(tokenToFind, tokens2);
    return tokens2;
  }
};
OptionToken.prim = "option";
var TimestampToken = class _TimestampToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    if (val.string && /^\d+$/.test(val.string)) {
      return new Date(Number(val.string) * 1e3).toISOString();
    } else if (val.string) {
      return new Date(val.string).toISOString();
    } else if (val.int) {
      return new Date(Number(val.int) * 1e3).toISOString();
    }
  }
  Encode(args) {
    const val = args.pop();
    if (typeof val === "number") {
      return { int: String(val) };
    } else {
      return { string: val };
    }
  }
  EncodeObject(val, semantic) {
    if (semantic && semantic[_TimestampToken.prim]) {
      return semantic[_TimestampToken.prim](val);
    }
    if (typeof val === "number") {
      return { int: String(val) };
    } else {
      return { string: val };
    }
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _TimestampToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _TimestampToken.prim,
      schema: _TimestampToken.prim
    };
  }
  ToKey({ string }) {
    return string;
  }
  ToBigMapKey(val) {
    return {
      key: { string: val },
      type: { prim: _TimestampToken.prim }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_TimestampToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
TimestampToken.prim = "timestamp";
var IntValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "IntValidationError";
  }
};
var IntToken = class _IntToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    return new bignumber_default(val[Object.keys(val)[0]]);
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _IntToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _IntToken.prim,
      schema: _IntToken.prim
    };
  }
  /**
   * @throws {@link IntValidationError}
   */
  validate(val) {
    const bigNumber = new bignumber_default(val);
    if (bigNumber.isNaN()) {
      throw new IntValidationError(val, this, `Value is not a number: ${JSON.stringify(val)}`);
    }
  }
  /**
   * @throws {@link IntValidationError}
   */
  Encode(args) {
    const val = args.pop();
    this.validate(val);
    return { int: new bignumber_default(val).toFixed() };
  }
  /**
   * @throws {@link IntValidationError}
   */
  EncodeObject(val, semantic) {
    this.validate(val);
    if (semantic && semantic[_IntToken.prim]) {
      return semantic[_IntToken.prim](val);
    }
    return { int: new bignumber_default(val).toFixed() };
  }
  ToBigMapKey(val) {
    return {
      key: { int: String(val) },
      type: { prim: _IntToken.prim }
    };
  }
  ToKey({ int }) {
    return int;
  }
  compare(int1, int2) {
    const o1 = Number(int1);
    const o2 = Number(int2);
    if (o1 === o2) {
      return 0;
    }
    return o1 < o2 ? -1 : 1;
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_IntToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
IntToken.prim = "int";
var UnitToken = class _UnitToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Encode(args) {
    args.pop();
    return { prim: "Unit" };
  }
  EncodeObject(val, semantic) {
    if (semantic && semantic[_UnitToken.prim]) {
      return semantic[_UnitToken.prim](val);
    }
    return { prim: "Unit" };
  }
  Execute(_val) {
    return UnitValue;
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _UnitToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _UnitToken.prim,
      schema: _UnitToken.prim
    };
  }
  compare(_val1, _val2) {
    return 0;
  }
  ToKey(_val) {
    return UnitValue;
  }
  ToBigMapKey(_val) {
    return {
      key: { prim: "Unit" },
      type: { prim: _UnitToken.prim }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_UnitToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
UnitToken.prim = "unit";
var publicKeyPrefixLength = 4;
var KeyValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "KeyValidationError";
  }
};
var KeyToken = class _KeyToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    if (val.string) {
      return val.string;
    }
    return encodeKey(val.bytes);
  }
  /**
   * @throws {@link KeyValidationError}
   */
  validate(value) {
    if (validatePublicKey(value) !== ValidationResult.VALID) {
      throw new KeyValidationError(value, this, "Key is not valid");
    }
  }
  /**
   * @throws {@link KeyValidationError}
   */
  Encode(args) {
    const val = args.pop();
    this.validate(val);
    return { string: val };
  }
  /**
   * @throws {@link KeyValidationError}
   */
  EncodeObject(val, semantic) {
    this.validate(val);
    if (semantic && semantic[_KeyToken.prim]) {
      return semantic[_KeyToken.prim](val);
    }
    return { string: val };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _KeyToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _KeyToken.prim,
      schema: _KeyToken.prim
    };
  }
  ToKey(val) {
    return this.Execute(val);
  }
  ToBigMapKey(val) {
    return {
      key: { string: val },
      type: { prim: _KeyToken.prim }
    };
  }
  compare(key1, key2) {
    const keyPrefix1 = this.getPrefix(key1);
    const keyPrefix2 = this.getPrefix(key2);
    if (keyPrefix1 === Prefix.EDPK && keyPrefix2 !== Prefix.EDPK) {
      return -1;
    } else if (keyPrefix1 === Prefix.SPPK && keyPrefix2 !== Prefix.SPPK) {
      return keyPrefix2 === Prefix.EDPK ? 1 : -1;
    } else if (keyPrefix1 === Prefix.P2PK) {
      if (keyPrefix2 !== Prefix.P2PK) {
        return 1;
      }
      const keyBytes1 = this.getP256PublicKeyComparableBytes(key1);
      const keyBytes2 = this.getP256PublicKeyComparableBytes(key2);
      return Buffer.compare(keyBytes1, keyBytes2);
    }
    return super.compare(key1, key2);
  }
  getPrefix(val) {
    return val.substring(0, publicKeyPrefixLength);
  }
  getP256PublicKeyComparableBytes(p2pk) {
    return b58cdecode(p2pk, prefix[Prefix.P2PK]).slice(1);
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_KeyToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
KeyToken.prim = "key";
var KeyHashValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "KeyHashValidationError";
  }
};
var KeyHashToken = class _KeyHashToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    if (val.string) {
      return val.string;
    }
    return encodeKeyHash(val.bytes);
  }
  /**
   * @throws {@link KeyHashValidationError}
   */
  validate(value) {
    if (validateKeyHash(value) !== ValidationResult.VALID) {
      throw new KeyHashValidationError(value, this, `KeyHash is not valid: ${JSON.stringify(value)}`);
    }
  }
  /**
   * @throws {@link KeyHashValidationError}
   */
  Encode(args) {
    const val = args.pop();
    this.validate(val);
    return { string: val };
  }
  /**
   * @throws {@link KeyHashValidationError}
   */
  EncodeObject(val, semantic) {
    this.validate(val);
    if (semantic && semantic[_KeyHashToken.prim]) {
      return semantic[_KeyHashToken.prim](val);
    }
    return { string: val };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _KeyHashToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _KeyHashToken.prim,
      schema: _KeyHashToken.prim
    };
  }
  ToKey({ string, bytes }) {
    if (string) {
      return string;
    }
    return encodeKeyHash(bytes);
  }
  ToBigMapKey(val) {
    return {
      key: { string: val },
      type: { prim: _KeyHashToken.prim }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_KeyHashToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
KeyHashToken.prim = "key_hash";
var SignatureValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "SignatureValidationError";
  }
};
var SignatureToken = class _SignatureToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    if (val.string) {
      return val.string;
    }
    return val.bytes;
  }
  /**
   * @throws {@link SignatureValidationError}
   */
  validate(value) {
    if (validateSignature(value) !== ValidationResult.VALID) {
      throw new SignatureValidationError(value, this, "Signature is not valid");
    }
  }
  /**
   * @throws {@link SignatureValidationError}
   */
  Encode(args) {
    const val = args.pop();
    this.validate(val);
    return { string: val };
  }
  /**
   * @throws {@link SignatureValidationError}
   */
  EncodeObject(val, semantic) {
    this.validate(val);
    if (semantic && semantic[_SignatureToken.prim]) {
      return semantic[_SignatureToken.prim](val);
    }
    return { string: val };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _SignatureToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _SignatureToken.prim,
      schema: _SignatureToken.prim
    };
  }
  ToKey(val) {
    return this.Execute(val);
  }
  ToBigMapKey(val) {
    return {
      key: { string: val },
      type: { prim: _SignatureToken.prim }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_SignatureToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
SignatureToken.prim = "signature";
var LambdaToken = class _LambdaToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  get paramSchema() {
    return this.createToken(this.val.args[0], this.idx);
  }
  get returnSchema() {
    return this.createToken(this.val.args[1], this.idx + 1);
  }
  Execute(val) {
    if (val.string) {
      return val.string;
    } else {
      return val;
    }
  }
  Encode(args) {
    const val = args.pop();
    return val;
  }
  EncodeObject(val, semantic) {
    if (semantic && semantic[_LambdaToken.prim]) {
      return semantic[_LambdaToken.prim](val);
    }
    return val;
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return {
      [_LambdaToken.prim]: {
        parameters: this.paramSchema.ExtractSchema(),
        returns: this.returnSchema.ExtractSchema()
      }
    };
  }
  generateSchema() {
    return {
      __michelsonType: _LambdaToken.prim,
      schema: {
        parameters: this.paramSchema.generateSchema(),
        returns: this.returnSchema.generateSchema()
      }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_LambdaToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.createToken(this.val.args[0], this.idx).findAndReturnTokens(tokenToFind, tokens2);
    this.createToken(this.val.args[1], this.idx).findAndReturnTokens(tokenToFind, tokens2);
    return tokens2;
  }
};
LambdaToken.prim = "lambda";
var OperationToken = class _OperationToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  Execute(val) {
    return val.string;
  }
  Encode(...args) {
    const val = args.pop();
    return { string: val };
  }
  EncodeObject(val, semantic) {
    if (semantic && semantic[_OperationToken.prim]) {
      return semantic[_OperationToken.prim](val);
    }
    return { string: val };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _OperationToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _OperationToken.prim,
      schema: _OperationToken.prim
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_OperationToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
OperationToken.prim = "operation";
var SetValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "SetValidationError";
  }
};
var SetToken = class _SetToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  get KeySchema() {
    return this.createToken(this.val.args[0], 0);
  }
  /**
   * @throws {@link SetValidationError}
   */
  validate(value) {
    if (!Array.isArray(value)) {
      throw new SetValidationError(value, this, `Value ${JSON.stringify(value)} is not an array`);
    }
  }
  /**
   * @throws {@link SetValidationError}
   */
  Encode(args) {
    const val = args.pop();
    this.validate(val);
    return val.sort((a, b) => this.KeySchema.compare(a, b)).reduce((prev, current) => {
      return [...prev, this.KeySchema.EncodeObject(current)];
    }, []);
  }
  Execute(val, semantics) {
    return val.reduce((prev, current) => {
      return [...prev, this.KeySchema.Execute(current, semantics)];
    }, []);
  }
  /**
   * @throws {@link SetValidationError}
   */
  EncodeObject(args, semantic) {
    this.validate(args);
    if (semantic && semantic[_SetToken.prim]) {
      return semantic[_SetToken.prim](args);
    }
    return args.sort((a, b) => this.KeySchema.compare(a, b)).reduce((prev, current) => {
      return [...prev, this.KeySchema.EncodeObject(current)];
    }, []);
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _SetToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _SetToken.prim,
      schema: this.KeySchema.generateSchema()
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_SetToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.KeySchema.findAndReturnTokens(tokenToFind, tokens2);
    return tokens2;
  }
};
SetToken.prim = "set";
var ChainIDValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "ChainIDValidationError";
  }
};
var ChainIDToken = class _ChainIDToken extends ComparableToken {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  /**
   * @throws {@link ChainIDValidationError}
   */
  validate(value) {
    if (validateChain(value) !== ValidationResult.VALID) {
      throw new ChainIDValidationError(value, this, `Value ${JSON.stringify(value)} is not a valid ChainID`);
    }
  }
  Execute(val) {
    return val[Object.keys(val)[0]];
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _ChainIDToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _ChainIDToken.prim,
      schema: _ChainIDToken.prim
    };
  }
  /**
   * @throws {@link ChainIDValidationError}
   */
  Encode(args) {
    const val = args.pop();
    this.validate(val);
    return { string: val };
  }
  /**
   * @throws {@link ChainIDValidationError}
   */
  EncodeObject(val, semantic) {
    this.validate(val);
    if (semantic && semantic[_ChainIDToken.prim]) {
      return semantic[_ChainIDToken.prim](val);
    }
    return { string: val };
  }
  ToKey({ string }) {
    return string;
  }
  ToBigMapKey(val) {
    return {
      key: { string: val },
      type: { prim: _ChainIDToken.prim }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_ChainIDToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
ChainIDToken.prim = "chain_id";
var EncodeTicketError = class extends TaquitoError {
  constructor() {
    super();
    this.name = "TicketEncodeError";
    this.message = "Tickets cannot be sent to the blockchain; they are created on-chain";
  }
};
var ticketerType$1 = { prim: "contract" };
var amountType$1 = { prim: "int" };
var TicketToken = class _TicketToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  get valueToken() {
    return this.createToken(this.val.args[0], this.idx);
  }
  /**
   * @throws {@link EncodeTicketError}
   */
  Encode(_args) {
    throw new EncodeTicketError();
  }
  /**
   * @throws {@link EncodeTicketError}
   */
  EncodeObject(args, semantic) {
    if (semantic && semantic[_TicketToken.prim]) {
      return semantic[_TicketToken.prim](args, this.val);
    }
    throw new EncodeTicketError();
  }
  Execute(val, semantics) {
    if (semantics && semantics[_TicketToken.prim]) {
      return semantics[_TicketToken.prim](val, this.val);
    }
    const ticketer = this.createToken(ticketerType$1, this.idx);
    const value = this.valueToken;
    const amount = this.createToken(amountType$1, this.idx);
    if (void 0 === val.args[2] && void 0 !== val.args[1].args) {
      return {
        ticketer: ticketer.Execute(val.args[0], semantics),
        value: value.Execute(val.args[1].args[0], semantics),
        amount: amount.Execute(val.args[1].args[1], semantics)
      };
    }
    return {
      ticketer: ticketer.Execute(val.args[0], semantics),
      value: value.Execute(val.args[1], semantics),
      amount: amount.Execute(val.args[2], semantics)
    };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return {
      ticketer: ContractToken.prim,
      value: this.valueToken.ExtractSchema(),
      amount: IntToken.prim
    };
  }
  generateSchema() {
    return {
      __michelsonType: _TicketToken.prim,
      schema: {
        value: this.valueToken.generateSchema(),
        ticketer: {
          __michelsonType: ContractToken.prim,
          schema: ContractToken.prim
        },
        amount: {
          __michelsonType: IntToken.prim,
          schema: IntToken.prim
        }
      }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_TicketToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.valueToken.findAndReturnTokens(tokenToFind, tokens2);
    return tokens2;
  }
};
TicketToken.prim = "ticket";
var EncodeTicketDeprecatedError = class extends TaquitoError {
  constructor() {
    super();
    this.name = "TicketDeprecatedEncodeError";
    this.message = "Ticket_deprecated cannot be sent to the blockchain; they are created on-chain";
  }
};
var ticketerType = { prim: "contract" };
var amountType = { prim: "int" };
var TicketDeprecatedToken = class _TicketDeprecatedToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  get valueToken() {
    return this.createToken(this.val.args[0], this.idx);
  }
  /**
   * @throws {@link EncodeTicketDeprecatedError}
   */
  Encode(_args) {
    throw new EncodeTicketDeprecatedError();
  }
  /**
   * @throws {@link EncodeTicketDeprecatedError}
   */
  EncodeObject(args, semantic) {
    if (semantic && semantic[_TicketDeprecatedToken.prim]) {
      return semantic[_TicketDeprecatedToken.prim](args, this.val);
    }
    throw new EncodeTicketDeprecatedError();
  }
  Execute(val, semantics) {
    if (semantics && semantics[_TicketDeprecatedToken.prim]) {
      return semantics[_TicketDeprecatedToken.prim](val, this.val);
    }
    const ticketer = this.createToken(ticketerType, this.idx);
    const value = this.valueToken;
    const amount = this.createToken(amountType, this.idx);
    if (void 0 === val.args[2] && void 0 !== val.args[1].args) {
      return {
        ticketer: ticketer.Execute(val.args[0], semantics),
        value: value.Execute(val.args[1].args[0], semantics),
        amount: amount.Execute(val.args[1].args[1], semantics)
      };
    }
    return {
      ticketer: ticketer.Execute(val.args[0], semantics),
      value: value.Execute(val.args[1], semantics),
      amount: amount.Execute(val.args[2], semantics)
    };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return {
      ticketer: ContractToken.prim,
      value: this.valueToken.ExtractSchema(),
      amount: IntToken.prim
    };
  }
  generateSchema() {
    return {
      __michelsonType: _TicketDeprecatedToken.prim,
      schema: {
        value: this.valueToken.generateSchema(),
        ticketer: {
          __michelsonType: ContractToken.prim,
          schema: ContractToken.prim
        },
        amount: {
          __michelsonType: IntToken.prim,
          schema: IntToken.prim
        }
      }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_TicketDeprecatedToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    this.valueToken.findAndReturnTokens(tokenToFind, tokens2);
    return tokens2;
  }
};
TicketDeprecatedToken.prim = "ticket_deprecated";
var NeverTokenError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "NeverTokenError";
  }
};
var NeverToken = class _NeverToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  /**
   * @throws {@link NeverTokenError}
   */
  Encode(args) {
    const val = args.pop();
    throw new NeverTokenError(val, this, `Assigning a value to the type never is forbidden. Trying to assign ${JSON.stringify(val)}.`);
  }
  /**
   * @throws {@link NeverTokenError}
   */
  EncodeObject(val, semantic) {
    if (semantic && semantic[_NeverToken.prim]) {
      return semantic[_NeverToken.prim](val);
    }
    throw new NeverTokenError(val, this, `Assigning a value to the type never is forbidden. Trying to assign ${JSON.stringify(val)}.`);
  }
  /**
   * @throws {@link NeverTokenError}
   */
  Execute(val) {
    throw new NeverTokenError(val, this, `There is no literal value for the type never. Trying to execute ${JSON.stringify(val)}.`);
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _NeverToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _NeverToken.prim,
      schema: _NeverToken.prim
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_NeverToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
NeverToken.prim = "never";
var SaplingStateValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "SaplingStateValidationError";
  }
};
var SaplingStateToken = class _SaplingStateToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  isValid(val) {
    return typeof val === "object" && Object.keys(val).length === 0;
  }
  /**
   * @throws {@link SaplingStateValidationError}
   */
  Execute(val, semantic) {
    if (semantic && semantic[_SaplingStateToken.prim]) {
      return semantic[_SaplingStateToken.prim](val, this.val);
    }
    if ("int" in val) {
      return val.int;
    } else {
      throw new SaplingStateValidationError(val, this, `Sapling state is expecting an object with an int property. Got ${JSON.stringify(val)}`);
    }
  }
  /**
   * @throws {@link SaplingStateValidationError}
   */
  Encode(args) {
    const val = args.pop();
    if (this.isValid(val)) {
      return [];
    } else {
      throw new SaplingStateValidationError(val, this, `Invalid sapling_state. Received: ${JSON.stringify(val)} while expecting: {}`);
    }
  }
  /**
   * @throws {@link SaplingStateValidationError}
   */
  EncodeObject(val, semantic) {
    if (semantic && semantic[_SaplingStateToken.prim]) {
      return semantic[_SaplingStateToken.prim](val);
    }
    if (this.isValid(val)) {
      return [];
    } else {
      throw new SaplingStateValidationError(val, this, `Invalid sapling_state. Received: ${JSON.stringify(val)} while expecting: {}`);
    }
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return {
      [_SaplingStateToken.prim]: {
        "memo-size": Number(this.val.args[0]["int"])
      }
    };
  }
  generateSchema() {
    return {
      __michelsonType: _SaplingStateToken.prim,
      schema: {
        memoSize: this.val.args[0]["int"]
      }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_SaplingStateToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
SaplingStateToken.prim = "sapling_state";
var SaplingTransactionValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "SaplingTransactionValidationError";
  }
};
var SaplingTransactionToken = class _SaplingTransactionToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  /**
   * @throws {@link SaplingTransactionValidationError}
   */
  Execute(_val) {
    throw new SaplingTransactionValidationError(_val, this, `There is no literal value for the sapling_transaction type. Got: ${JSON.stringify(_val)}.`);
  }
  /**
   * @throws {@link SaplingTransactionValidationError}
   */
  validateBytes(val) {
    const bytes = /^(0x|0X)?([0-9a-fA-F]*$)/.exec(val);
    if (bytes && bytes[2].length % 2 === 0) {
      return bytes[2];
    } else {
      throw new SaplingTransactionValidationError(val, this, `Invalid bytes: ${JSON.stringify(val)}`);
    }
  }
  convertUint8ArrayToHexString(val) {
    return val.constructor === Uint8Array ? Buffer.from(val).toString("hex") : val;
  }
  Encode(args) {
    let val = args.pop();
    val = this.validateBytes(this.convertUint8ArrayToHexString(val));
    return { bytes: String(val).toString() };
  }
  EncodeObject(val, semantic) {
    val = this.validateBytes(this.convertUint8ArrayToHexString(val));
    if (semantic && semantic[_SaplingTransactionToken.prim]) {
      return semantic[_SaplingTransactionToken.prim](val);
    }
    return { bytes: String(val).toString() };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return {
      [_SaplingTransactionToken.prim]: {
        "memo-size": Number(this.val.args[0]["int"])
      }
    };
  }
  generateSchema() {
    return {
      __michelsonType: _SaplingTransactionToken.prim,
      schema: {
        memoSize: this.val.args[0]["int"]
      }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_SaplingTransactionToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
SaplingTransactionToken.prim = "sapling_transaction";
var SaplingTransactionDeprecatedValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "SaplingTransactionDeprecatedValidationError";
  }
};
var SaplingTransactionDeprecatedToken = class _SaplingTransactionDeprecatedToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  /**
   * @throws {@link SaplingTransactionDeprecatedValidationError}
   */
  Execute(_val) {
    throw new SaplingTransactionDeprecatedValidationError(_val, this, `There is no literal value for the sapling_transaction_deprecated type. Got: ${JSON.stringify(_val)}.`);
  }
  /**
   * @throws {@link SaplingTransactionDeprecatedValidationError}
   */
  validateBytes(val) {
    const bytes = /^(0x|0X)?([0-9a-fA-F]*$)/.exec(val);
    if (bytes && bytes[2].length % 2 === 0) {
      return bytes[2];
    } else {
      throw new SaplingTransactionDeprecatedValidationError(val, this, `Invalid bytes: ${JSON.stringify(val)}`);
    }
  }
  convertUint8ArrayToHexString(val) {
    return val.constructor === Uint8Array ? Buffer.from(val).toString("hex") : val;
  }
  Encode(args) {
    let val = args.pop();
    val = this.validateBytes(this.convertUint8ArrayToHexString(val));
    return { bytes: String(val).toString() };
  }
  EncodeObject(val, semantic) {
    val = this.validateBytes(this.convertUint8ArrayToHexString(val));
    if (semantic && semantic[_SaplingTransactionDeprecatedToken.prim]) {
      return semantic[_SaplingTransactionDeprecatedToken.prim](val);
    }
    return { bytes: String(val).toString() };
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return {
      [_SaplingTransactionDeprecatedToken.prim]: {
        "memo-size": Number(this.val.args[0]["int"])
      }
    };
  }
  generateSchema() {
    return {
      __michelsonType: _SaplingTransactionDeprecatedToken.prim,
      schema: {
        memoSize: this.val.args[0]["int"]
      }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_SaplingTransactionDeprecatedToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
SaplingTransactionDeprecatedToken.prim = "sapling_transaction_deprecated";
var Bls12381frValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "Bls12381frValidationError";
  }
};
var Bls12381frToken = class _Bls12381frToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  /**
   * @throws {@link Bls12381frValidationError}
   */
  validate(val) {
    if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {
      return;
    }
    throw new Bls12381frValidationError(val, this, `Invalid bytes: ${JSON.stringify(val)}`);
  }
  convertUint8ArrayToHexString(val) {
    return val.constructor === Uint8Array ? Buffer.from(val).toString("hex") : val;
  }
  /**
   * @throws {@link Bls12381frValidationError}
   */
  Encode(args) {
    let val = args.pop();
    if (typeof val === "number") {
      return { int: val.toString() };
    } else {
      val = this.convertUint8ArrayToHexString(val);
      this.validate(val);
      return { bytes: val };
    }
  }
  /**
   * @throws {@link Bls12381frValidationError}
   */
  EncodeObject(val, semantic) {
    if (semantic && semantic[_Bls12381frToken.prim]) {
      return semantic[_Bls12381frToken.prim](val);
    }
    if (typeof val === "number") {
      return { int: val.toString() };
    } else {
      val = this.convertUint8ArrayToHexString(val);
      this.validate(val);
      return { bytes: val };
    }
  }
  Execute(val) {
    return val.bytes;
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _Bls12381frToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _Bls12381frToken.prim,
      schema: _Bls12381frToken.prim
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_Bls12381frToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
Bls12381frToken.prim = "bls12_381_fr";
var Bls12381g1ValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "Bls12381g1ValidationError";
  }
};
var Bls12381g1Token = class _Bls12381g1Token extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  /**
   * @throws {@link Bls12381g1ValidationError}
   */
  validate(val) {
    if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {
      return;
    }
    throw new Bls12381g1ValidationError(val, this, `Invalid bytes: ${JSON.stringify(val)}`);
  }
  convertUint8ArrayToHexString(val) {
    return val.constructor === Uint8Array ? Buffer.from(val).toString("hex") : val;
  }
  /**
   * @throws {@link Bls12381g1ValidationError}
   */
  Encode(args) {
    let val = args.pop();
    val = this.convertUint8ArrayToHexString(val);
    this.validate(val);
    return { bytes: val };
  }
  /**
   * @throws {@link Bls12381g1ValidationError}
   */
  EncodeObject(val, semantic) {
    val = this.convertUint8ArrayToHexString(val);
    this.validate(val);
    if (semantic && semantic[_Bls12381g1Token.prim]) {
      return semantic[_Bls12381g1Token.prim](val);
    }
    return { bytes: val };
  }
  Execute(val) {
    return val.bytes;
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _Bls12381g1Token.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _Bls12381g1Token.prim,
      schema: _Bls12381g1Token.prim
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_Bls12381g1Token.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
Bls12381g1Token.prim = "bls12_381_g1";
var Bls12381g2ValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "Bls12381g2ValidationError";
  }
};
var Bls12381g2Token = class _Bls12381g2Token extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  /**
   * @throws {@link Bls12381g2ValidationError}
   */
  validate(val) {
    if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {
      return;
    }
    throw new Bls12381g2ValidationError(val, this, `Invalid bytes: ${JSON.stringify(val)}`);
  }
  convertUint8ArrayToHexString(val) {
    return val.constructor === Uint8Array ? Buffer.from(val).toString("hex") : val;
  }
  /**
   * @throws {@link Bls12381g2ValidationError}
   */
  Encode(args) {
    let val = args.pop();
    val = this.convertUint8ArrayToHexString(val);
    this.validate(val);
    return { bytes: val };
  }
  /**
   * @throws {@link Bls12381g2ValidationError}
   */
  EncodeObject(val, semantic) {
    val = this.convertUint8ArrayToHexString(val);
    this.validate(val);
    if (semantic && semantic[_Bls12381g2Token.prim]) {
      return semantic[_Bls12381g2Token.prim](val);
    }
    return { bytes: val };
  }
  Execute(val) {
    return val.bytes;
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _Bls12381g2Token.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _Bls12381g2Token.prim,
      schema: _Bls12381g2Token.prim
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_Bls12381g2Token.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
Bls12381g2Token.prim = "bls12_381_g2";
var ChestValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "ChestValidationError";
  }
};
var ChestToken = class _ChestToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  /**
   * @throws {@link ChestKeyValidationError}
   */
  validate(val) {
    if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 == 0) {
      return;
    }
    throw new ChestValidationError(val, this, `Invalid bytes: ${JSON.stringify(val)}`);
  }
  convertUint8ArrayToHexString(val) {
    return val.constructor === Uint8Array ? Buffer.from(val).toString("hex") : val;
  }
  /**
   * @throws {@link ChestKeyValidationError}
   */
  Encode(args) {
    let val = args.pop();
    val = this.convertUint8ArrayToHexString(val);
    this.validate(val);
    return { bytes: val };
  }
  /**
   * @throws {@link ChestKeyValidationError}
   */
  EncodeObject(val, semantic) {
    val = this.convertUint8ArrayToHexString(val);
    this.validate(val);
    if (semantic && semantic[_ChestToken.prim]) {
      return semantic[_ChestToken.prim](val);
    }
    return { bytes: val };
  }
  Execute(val) {
    return val.bytes;
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _ChestToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _ChestToken.prim,
      schema: _ChestToken.prim
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_ChestToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
ChestToken.prim = "chest";
var ChestKeyValidationError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "ChestKeyValidationError";
  }
};
var ChestKeyToken = class _ChestKeyToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  /**
   * @throws {@link ChestKeyValidationError}
   */
  validate(val) {
    if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {
      return;
    }
    throw new ChestKeyValidationError(val, this, `Invalid bytes: ${JSON.stringify(val)}`);
  }
  convertUint8ArrayToHexString(val) {
    return val.constructor === Uint8Array ? Buffer.from(val).toString("hex") : val;
  }
  /**
   * @throws {@link ChestKeyValidationError}
   */
  Encode(args) {
    let val = args.pop();
    val = this.convertUint8ArrayToHexString(val);
    this.validate(val);
    return { bytes: val };
  }
  /**
   * @throws {@link ChestKeyValidationError}
   */
  EncodeObject(val, semantic) {
    val = this.convertUint8ArrayToHexString(val);
    this.validate(val);
    if (semantic && semantic[_ChestKeyToken.prim]) {
      return semantic[_ChestKeyToken.prim](val);
    }
    return { bytes: val };
  }
  Execute(val) {
    return val.bytes;
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _ChestKeyToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _ChestKeyToken.prim,
      schema: _ChestKeyToken.prim
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_ChestKeyToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
ChestKeyToken.prim = "chest_key";
var GlobalConstantEncodingError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "GlobalConstantEncodingError";
  }
};
var GlobalConstantDecodingError = class extends TokenValidationError {
  constructor(value, token, message) {
    super(value, token, message);
    this.value = value;
    this.token = token;
    this.name = "GlobalConstantDecodingError";
  }
};
var GlobalConstantToken = class _GlobalConstantToken extends Token {
  constructor(val, idx, fac) {
    super(val, idx, fac);
    this.val = val;
    this.idx = idx;
    this.fac = fac;
  }
  /**
   * @throws {@link GlobalConstantDecodingError}
   */
  Execute(val, semantic) {
    if (semantic && semantic[_GlobalConstantToken.prim]) {
      return semantic[_GlobalConstantToken.prim](val, this.val);
    } else {
      throw new GlobalConstantDecodingError(val, this, `Unable to decode a value represented by a global constants. Please provide an expanded script to the Michelson-Encoder or semantics for the decoding. The following global constant hash was encountered: ${this.val.args[0]["string"]}.`);
    }
  }
  /**
   * @throws {@link GlobalConstantEncodingError}
   */
  Encode(args) {
    throw new GlobalConstantEncodingError(args, this, `Unable to encode a script containing global constants. Please provide an expanded script to the Michelson-Encoder. The following global constant hash was encountered: ${this.val.args[0]["string"]}.`);
  }
  /**
   * @throws {@link GlobalConstantEncodingError}
   */
  EncodeObject(val, semantic) {
    if (semantic && semantic[_GlobalConstantToken.prim]) {
      return semantic[_GlobalConstantToken.prim](val);
    }
    throw new GlobalConstantEncodingError(val, this, `Unable to encode a script containing global constants. Please provide an expanded script to the Michelson-Encoder. The following global constant hash was encountered: ${this.val.args[0]["string"]}.`);
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return _GlobalConstantToken.prim;
  }
  generateSchema() {
    return {
      __michelsonType: _GlobalConstantToken.prim,
      schema: {
        hash: this.val.args[0]["string"]
      }
    };
  }
  findAndReturnTokens(tokenToFind, tokens2) {
    if (_GlobalConstantToken.prim === tokenToFind) {
      tokens2.push(this);
    }
    return tokens2;
  }
};
GlobalConstantToken.prim = "constant";
var tokens = [
  PairToken,
  NatToken,
  StringToken,
  BigMapToken,
  AddressToken,
  TxRollupL2AddressToken,
  MapToken,
  BoolToken,
  OrToken,
  ContractToken,
  ListToken,
  MutezToken,
  BytesToken,
  OptionToken,
  TimestampToken,
  IntToken,
  UnitToken,
  KeyToken,
  KeyHashToken,
  SignatureToken,
  LambdaToken,
  OperationToken,
  SetToken,
  ChainIDToken,
  TicketToken,
  TicketDeprecatedToken,
  NeverToken,
  SaplingStateToken,
  SaplingTransactionToken,
  SaplingTransactionDeprecatedToken,
  Bls12381frToken,
  Bls12381g1Token,
  Bls12381g2Token,
  ChestToken,
  ChestKeyToken,
  GlobalConstantToken
];
var InvalidTokenError = class extends TaquitoError {
  constructor(message, data) {
    super(message);
    this.message = message;
    this.data = data;
    this.name = "Invalid token error";
  }
};
function createToken(val, idx) {
  if (Array.isArray(val)) {
    return new PairToken(val, idx, createToken);
  }
  const t = tokens.find((x) => x.prim === val.prim);
  if (!t) {
    throw new InvalidTokenError(`Malformed data: ${JSON.stringify(val)}. Expected a value with a valid prim property`, val);
  }
  return new t(val, idx, createToken);
}
var ParameterEncodingError = class extends InvalidViewParameterError {
  constructor(viewName, sigs, args, cause) {
    super(viewName, sigs, args, cause);
    this.viewName = viewName;
    this.sigs = sigs;
    this.args = args;
    this.cause = cause;
    this.name = "ParameterEncodingError";
    this.message = `Could not encode parameter ${JSON.stringify(args)} received for name "${viewName}" expecting one of the following signatures ${JSON.stringify(sigs)}`;
  }
};
var InvalidScriptError = class extends TaquitoError {
  constructor(script, reason) {
    super();
    this.script = script;
    this.reason = reason;
    this.name = "InvalidScriptError";
    let message = `Invalid on-chain view found in the following script.`;
    if (reason) {
      message += ` Reason: ${reason}.`;
    }
    message += `Script: ${JSON.stringify(script)}`;
    this.message = message;
  }
};
var InvalidRpcResponseError = class extends TaquitoError {
  constructor(script, reason) {
    super();
    this.script = script;
    this.reason = reason;
    this.name = "InvalidRpcResponseError";
    let message = `Invalid RPC response passed as argument(s).`;
    if (reason) {
      message += ` Reason: ${reason}.`;
    }
    message += ` Received: ${JSON.stringify(script)}`;
    this.message = message;
  }
};
var InvalidBigMapSchemaError = class extends TaquitoError {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "InvalidBigMapSchemaError";
  }
};
var InvalidBigMapDiffError = class extends TaquitoError {
  constructor(message, value) {
    super(message);
    this.message = message;
    this.value = value;
    this.name = "InvalidBigMapDiffError";
  }
};
var BigMapEncodingError = class extends TaquitoError {
  constructor(obj, details, schema, value) {
    super();
    this.details = details;
    this.schema = schema;
    this.value = value;
    this.name = "BigMapEncodingError";
    this.message = `Unable to encode the big map ${obj}. Schema is: ${JSON.stringify(schema)}. The ${obj} is: ${JSON.stringify(value)}. Error details: ${details}`;
  }
};
var StorageEncodingError = class extends TaquitoError {
  constructor(obj, details, schema, value, semantics) {
    super();
    this.details = details;
    this.schema = schema;
    this.value = value;
    this.semantics = semantics;
    this.name = "StorageEncodingError";
    this.message = `Unable to encode ${obj}. The schema is: ${JSON.stringify(schema)}, the value is: ${JSON.stringify(value)}.${semantics ? `And the semantic is: ${JSON.stringify(semantics)}` : ""}. Error details: ${details}`;
  }
};
var MissingArgumentError = class extends TaquitoError {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "MissingArgumentError";
  }
};
var _a2;
var schemaTypeSymbol = Symbol.for("taquito-schema-type-symbol");
function collapse(val, prim = PairToken.prim) {
  var _b, _c;
  if (Array.isArray(val)) {
    return collapse({
      prim,
      args: val
    }, prim);
  }
  const extended = val;
  if (extended.prim === prim && extended.args && extended.args.length > 2) {
    return Object.assign(Object.assign({}, extended), { args: [
      (_b = extended.args) === null || _b === void 0 ? void 0 : _b[0],
      {
        prim,
        args: (_c = extended.args) === null || _c === void 0 ? void 0 : _c.slice(1)
      }
    ] });
  }
  return extended;
}
function deepEqual(a, b) {
  if (a === void 0 || b === void 0) {
    return a === b;
  }
  const ac = collapse(a);
  const bc = collapse(b);
  return ac.prim === bc.prim && (ac.args === void 0 && bc.args === void 0 || ac.args !== void 0 && bc.args !== void 0 && ac.args.length === bc.args.length && ac.args.every((v, i) => {
    var _b, _c;
    return deepEqual(v, (_c = (_b = bc.args) === null || _b === void 0 ? void 0 : _b[i]) !== null && _c !== void 0 ? _c : {});
  })) && (ac.annots === void 0 && bc.annots === void 0 || ac.annots !== void 0 && bc.annots !== void 0 && ac.annots.length === bc.annots.length && ac.annots.every((v, i) => {
    var _b;
    return v === ((_b = bc.annots) === null || _b === void 0 ? void 0 : _b[i]);
  }));
}
var Schema = class _Schema {
  constructor(val) {
    this.val = val;
    this[_a2] = true;
    this.root = createToken(val, 0);
    if (this.root instanceof BigMapToken) {
      this.bigMap = this.root;
    } else if (this.isExpressionExtended(val) && val.prim === "pair") {
      const exp = val.args[0];
      if (this.isExpressionExtended(exp) && exp.prim === "big_map") {
        this.bigMap = new BigMapToken(exp, 0, createToken);
      }
    }
  }
  static isSchema(obj) {
    return obj && obj[schemaTypeSymbol] === true;
  }
  /**
   * @throws {@link InvalidRpcResponseError}
   */
  static fromRPCResponse(val) {
    if (!val) {
      throw new InvalidRpcResponseError(val, "the RPC response is empty");
    }
    if (!val.script) {
      throw new InvalidRpcResponseError(val, "the RPC response has no script");
    }
    if (!Array.isArray(val.script.code)) {
      throw new InvalidRpcResponseError(val, "The response.script.code should be an array");
    }
    let code2 = val.script.code;
    while (code2.length === 1 && Array.isArray(code2[0])) {
      code2 = code2[0];
    }
    const storage2 = code2.find((x) => "prim" in x && x.prim === "storage");
    if (!storage2 || !Array.isArray(storage2.args)) {
      throw new InvalidRpcResponseError(val, 'The response.script.code has an element of type {prim: "storage"}, but its args is not an array');
    }
    return new _Schema(storage2.args[0]);
  }
  isExpressionExtended(val) {
    return "prim" in val && Array.isArray(val.args);
  }
  removeTopLevelAnnotation(obj) {
    if (this.root instanceof PairToken || this.root instanceof OrToken) {
      if (this.root.hasAnnotations() && typeof obj === "object" && Object.keys(obj).length === 1) {
        return obj[Object.keys(obj)[0]];
      }
    }
    return obj;
  }
  Execute(val, semantics) {
    const storage2 = this.root.Execute(val, semantics);
    return this.removeTopLevelAnnotation(storage2);
  }
  Typecheck(val) {
    if (this.root instanceof BigMapToken && Number.isInteger(Number(val))) {
      return;
    }
    if (this.root instanceof TicketToken && val.ticketer && val.value && val.amount) {
      return;
    }
    if (this.root instanceof TicketDeprecatedToken && val.ticketer && val.value && val.amount) {
      return;
    }
    if (this.root instanceof MapToken && this.root.ValueSchema instanceof BigMapToken) {
      return;
    }
    this.root.EncodeObject(val);
  }
  /**
   * @throws {@link InvalidBigMapSchemaError}
   * @throws {@link InvalidBigMapDiffError}
   */
  ExecuteOnBigMapDiff(diff, semantics) {
    if (!this.bigMap) {
      throw new InvalidBigMapSchemaError("Big map schema is undefined");
    }
    if (!Array.isArray(diff)) {
      throw new InvalidBigMapDiffError(`Big map diff must be an array, got: ${JSON.stringify(diff)}`, diff);
    }
    const eltFormat = diff.map(({ key, value }) => ({ args: [key, value] }));
    return this.bigMap.Execute(eltFormat, semantics);
  }
  /**
   * @throws {@link InvalidBigMapSchemaError}
   */
  ExecuteOnBigMapValue(key, semantics) {
    if (!this.bigMap) {
      throw new InvalidBigMapSchemaError("Big map schema is undefined");
    }
    return this.bigMap.ValueSchema.Execute(key, semantics);
  }
  /**
   * @throws {@link InvalidBigMapSchemaError}
   * @throws {@link BigMapEncodingError}
   */
  EncodeBigMapKey(key) {
    if (!this.bigMap) {
      throw new InvalidBigMapSchemaError("Big map schema is undefined");
    }
    try {
      return this.bigMap.KeySchema.ToBigMapKey(key);
    } catch (ex) {
      throw new BigMapEncodingError("key", ex, this.bigMap.KeySchema, key);
    }
  }
  /**
   * @throws {@link TokenValidationError}
   * @throws {@link StorageEncodingError}
   */
  Encode(value, semantics) {
    try {
      return this.root.EncodeObject(value, semantics);
    } catch (ex) {
      if (ex instanceof TokenValidationError) {
        throw ex;
      }
      throw new StorageEncodingError("storage object", ex, this.root, value, semantics);
    }
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return this.removeTopLevelAnnotation(this.root.ExtractSchema());
  }
  /**
   * @description Produce a representation of the storage schema.
   * Note: Provide guidance on how to write the storage object for the origination operation with Taquito.
   */
  generateSchema() {
    return this.removeTopLevelAnnotation(this.root.generateSchema());
  }
  /**
   * @deprecated
   * @throws {@link InvalidBigMapSchemaError}
   */
  ComputeState(tx, state) {
    if (!this.bigMap) {
      throw new InvalidBigMapSchemaError("Big map schema is undefined");
    }
    const bigMap = tx.reduce((prev, current) => {
      return Object.assign(Object.assign({}, prev), this.ExecuteOnBigMapDiff(current.contents[0].metadata.operation_result.big_map_diff));
    }, {});
    return Object.assign(Object.assign({}, this.Execute(state)), { [this.bigMap.annot()]: bigMap });
  }
  /**
   * @description Look up in top-level pairs of the storage to find a value matching the specified type
   *
   * @returns The first value found that match the type or `undefined` if no value is found
   *
   * @param storage storage to parse to find the value
   * @param valueType type of value to look for
   *
   */
  FindFirstInTopLevelPair(storage2, valueType) {
    return this.findValue(this.root["val"], storage2, valueType);
  }
  // TODO check these type casts
  /**
   * @throws {@link MissingArgumentError}
   */
  findValue(schema, storage2, valueToFind) {
    if (deepEqual(valueToFind, schema)) {
      return storage2;
    }
    if (Array.isArray(schema) || schema.prim === "pair") {
      const sch = collapse(schema);
      const strg = collapse(storage2, "Pair");
      if (sch.args === void 0 || strg.args === void 0) {
        throw new MissingArgumentError("Tokens have no arguments");
      }
      if (sch.args[0])
        return (
          // unsafe
          this.findValue(sch.args[0], strg.args[0], valueToFind) || this.findValue(sch.args[1], strg.args[1], valueToFind)
        );
    }
  }
  /**
   * @description Look up the schema to find any occurrence of a particular token.
   *
   * @returns an array of tokens of the specified kind or an empty array if no token was found
   *
   * @param tokenToFind string representing the prim property of the token to find
   *
   * @example
   * ```
   * Useful to find all global constants in a script, an array of GlobalConstantToken is returned:
   *
   * const schema = new Schema(script);
   * const allGlobalConstantTokens = schema.findToken('constant');
   * ```
   *
   */
  findToken(tokenToFind) {
    const tokens2 = [];
    return this.root.findAndReturnTokens(tokenToFind, tokens2);
  }
};
_a2 = schemaTypeSymbol;
var ParameterSchema = class _ParameterSchema {
  /**
   * @description Return the schema of the parameter of a specific entry point
   * @throws {@link InvalidTokenError}
   */
  constructor(val) {
    this.root = createToken(val, 0);
  }
  /**
   *
   * @description Create an instance of ParameterSchema from a contract script
   *
   * @param val contract script obtained from the RPC
   * @returns ParameterSchema
   * @throws {InvalidRpcResponseError} If the RPC response is invalid
   */
  static fromRPCResponse(val) {
    if (!val) {
      throw new InvalidRpcResponseError(val, "the RPC response is empty");
    }
    if (!val.script) {
      throw new InvalidRpcResponseError(val, "the RPC response has no script");
    }
    if (!Array.isArray(val.script.code)) {
      throw new InvalidRpcResponseError(val, "The response.script.code should be an array");
    }
    const parameter = val.script.code.find((x) => "prim" in x && x.prim === "parameter");
    if (!parameter) {
      throw new InvalidRpcResponseError(val, `The response.script.code should have an element of type {prim: "parameter"}`);
    }
    if (!Array.isArray(parameter.args)) {
      throw new InvalidRpcResponseError(val, `The response.script.code has an element of type {prim: "parameter"}, but its args is not an array`);
    }
    return new _ParameterSchema(parameter.args[0]);
  }
  /**
   * @description Check if the Contract parameter is multiple entry point or not
   */
  get isMultipleEntryPoint() {
    return this.root instanceof OrToken || this.root instanceof OptionToken && this.root.subToken() instanceof OrToken;
  }
  /**
   * @description Check if the Contract parameter has an annotation or not
   */
  get hasAnnotation() {
    if (this.isMultipleEntryPoint) {
      return Object.keys(this.ExtractSchema())[0] !== "0";
    } else {
      return true;
    }
  }
  /**
   * @description Returns the javascript object equivalent of the Micheline value provided
   */
  Execute(val, semantics) {
    return this.root.Execute(val, semantics);
  }
  /**
   * @description Returns a micheline formatted object for the values provided
   * @throws {@link TokenValidationError}
   * @throws {@link ParameterEncodingError}
   */
  Encode(...args) {
    try {
      return this.root.Encode(args.reverse());
    } catch (ex) {
      if (ex instanceof TokenValidationError) {
        throw ex;
      }
      throw new ParameterEncodingError("Unable to encode parameter", this.root, args, ex);
    }
  }
  /**
   * @description Returns a micheline formatted object for the javascript object provided
   * @throws {@link TokenValidationError}
   * @throws {@link ParameterEncodingError}
   */
  EncodeObject(value, semantics) {
    try {
      return this.root.EncodeObject(value, semantics);
    } catch (ex) {
      if (ex instanceof TokenValidationError) {
        throw ex;
      }
      throw new ParameterEncodingError("Unable to encode parameter object", this.root, value, ex);
    }
  }
  /**
   * @deprecated ExtractSchema has been deprecated in favor of generateSchema
   *
   */
  ExtractSchema() {
    return this.root.ExtractSchema();
  }
  /**
   * @description Produce a schema grouping together all the entry points of a contract.
   */
  generateSchema() {
    return this.root.generateSchema();
  }
  ExtractSignatures() {
    return this.root.ExtractSignature();
  }
};
var ViewSchema = class _ViewSchema {
  /**
   * @throws {@link InvalidScriptError}
   */
  constructor(viewArgs) {
    if (!viewArgs) {
      throw new InvalidScriptError(viewArgs, "the args are not defined");
    }
    if (viewArgs.length !== 4) {
      throw new InvalidScriptError(viewArgs, `there should be exactly 4 arguments`);
    }
    if (!("string" in viewArgs[0]) || !viewArgs[0]["string"]) {
      throw new InvalidScriptError(viewArgs, `The first argument should be a string, representing the view name. It should be in the form: { string: 'viewName' }`);
    }
    this.viewName = viewArgs[0]["string"];
    this.viewArgsType = viewArgs[1];
    this.viewReturnType = viewArgs[2];
    this.instructions = viewArgs[3];
    this.rootArgsType = createToken(this.viewArgsType, 0);
    this.rootReturnType = createToken(this.viewReturnType, 0);
  }
  /**
   *
   * @description Create an instance of ViewSchema for each view in a script
   *
   * @param val contract script obtained from the RPC
   * @returns array of ViewSchema or empty array if there is no view in the contract
   * @throws {@link InvalidScriptError}
   */
  static fromRPCResponse(val) {
    const allViewSchema = [];
    const views = val && val.script && Array.isArray(val.script.code) && val.script.code.filter((x) => x.prim === "view");
    if (views) {
      views.forEach((view) => {
        allViewSchema.push(new _ViewSchema(view.args));
      });
    }
    return allViewSchema;
  }
  /**
   *
   * @description Transform the view parameter into Michelson
   *
   * @param args parameter of the view in js format
   * @returns parameter of the view in Michelson
   * @throws {@link ParameterEncodingError}
   */
  encodeViewArgs(args) {
    try {
      return this.rootArgsType.EncodeObject(args);
    } catch (ex) {
      throw new ParameterEncodingError(this.viewName, void 0, args, ex);
    }
  }
  /**
   *
   * @description Transform the view result from Michelson to readable data
   *
   * @param val result of the view in JSON Michelson
   * @param semantics optional semantics to override the default decoding behavior
   * @returns result of the view in a readable format
   */
  decodeViewResult(val, semantics) {
    return this.rootReturnType.Execute(val, semantics);
  }
  /**
   *
   * @description Return the signature of the view parameter
   */
  extractArgsSchema() {
    return this.rootArgsType.ExtractSchema();
  }
  /**
   *
   * @description Return the format of the view result
   */
  extractResultSchema() {
    return this.rootReturnType.ExtractSchema();
  }
};
var EventSchema = class _EventSchema {
  constructor(tag, type) {
    this.tag = tag;
    this.type = type;
  }
  static fromMichelineValue(val) {
    var _a3, _b;
    return new _EventSchema((_a3 = val.annots) === null || _a3 === void 0 ? void 0 : _a3[0], (_b = val.args) === null || _b === void 0 ? void 0 : _b[0]);
  }
  static fromRPCResponse(val) {
    const allEventSchema = [];
    val.script.code.forEach((code2) => {
      if (!("prim" in code2) || code2.prim !== "code" || !("args" in code2) || !code2.args) {
        return;
      }
      allEventSchema.push(..._EventSchema.extractEventsRecursively(code2.args));
    });
    return _EventSchema.removeDuplicates(allEventSchema);
  }
  static removeDuplicates(events) {
    const uniqueEvents = [];
    events.forEach((event) => {
      const idx = uniqueEvents.findIndex((e) => e.tag === event.tag && deepEqual(e.type, event.type));
      if (idx === -1) {
        uniqueEvents.push(event);
      }
    });
    return uniqueEvents;
  }
  static extractEventsRecursively(code2) {
    if (Array.isArray(code2)) {
      return code2.flatMap((c) => _EventSchema.extractEventsRecursively(c));
    }
    if (!("prim" in code2)) {
      return [];
    }
    if (code2.prim === "EMIT") {
      return [_EventSchema.fromMichelineValue(code2)];
    }
    if (!("args" in code2) || !code2.args) {
      return [];
    }
    return code2.args.flatMap((c) => _EventSchema.extractEventsRecursively(c));
  }
};
var UnitValue = Symbol();

// node_modules/@taquito/local-forging/dist/taquito-local-forging.es6.js
var toHexString = (bytes) => bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
var pad = (num, paddingLen = 8) => {
  return num.toString(16).padStart(paddingLen, "0");
};
var ENTRYPOINT_MAX_LENGTH = 31;
var CODEC;
(function(CODEC2) {
  CODEC2["SECRET"] = "secret";
  CODEC2["RAW"] = "raw";
  CODEC2["TZ1"] = "tz1";
  CODEC2["BRANCH"] = "branch";
  CODEC2["ZARITH"] = "zarith";
  CODEC2["PUBLIC_KEY"] = "public_key";
  CODEC2["PKH"] = "pkh";
  CODEC2["DELEGATE"] = "delegate";
  CODEC2["SCRIPT"] = "script";
  CODEC2["BALLOT_STATEMENT"] = "ballotStmt";
  CODEC2["PROPOSAL"] = "proposal";
  CODEC2["PROPOSAL_ARR"] = "proposalArr";
  CODEC2["INT32"] = "int32";
  CODEC2["INT16"] = "int16";
  CODEC2["PARAMETERS"] = "parameters";
  CODEC2["ADDRESS"] = "address";
  CODEC2["SMART_CONTRACT_ADDRESS"] = "smart_contract_address";
  CODEC2["SMART_ROLLUP_ADDRESS"] = "smart_rollup_address";
  CODEC2["SMART_ROLLUP_COMMITMENT_HASH"] = "smart_rollup_commitment_hash";
  CODEC2["VALUE"] = "value";
  CODEC2["PADDED_BYTES"] = "padded_bytes";
  CODEC2["SMART_ROLLUP_MESSAGE"] = "smart_rollup_message";
  CODEC2["MANAGER"] = "manager";
  CODEC2["BLOCK_PAYLOAD_HASH"] = "blockPayloadHash";
  CODEC2["ENTRYPOINT"] = "entrypoint";
  CODEC2["OPERATION"] = "operation";
  CODEC2["OP_ACTIVATE_ACCOUNT"] = "activate_account";
  CODEC2["OP_DELEGATION"] = "delegation";
  CODEC2["OP_TRANSACTION"] = "transaction";
  CODEC2["OP_ORIGINATION"] = "origination";
  CODEC2["OP_BALLOT"] = "ballot";
  CODEC2["OP_FAILING_NOOP"] = "failing_noop";
  CODEC2["OP_ENDORSEMENT"] = "endorsement";
  CODEC2["OP_SEED_NONCE_REVELATION"] = "seed_nonce_revelation";
  CODEC2["OP_REVEAL"] = "reveal";
  CODEC2["OP_PROPOSALS"] = "proposals";
  CODEC2["OP_REGISTER_GLOBAL_CONSTANT"] = "register_global_constant";
  CODEC2["OP_TRANSFER_TICKET"] = "transfer_ticket";
  CODEC2["OP_TX_ROLLUP_ORIGINATION"] = "tx_rollup_origination";
  CODEC2["OP_TX_ROLLUP_SUBMIT_BATCH"] = "tx_rollup_submit_batch";
  CODEC2["BURN_LIMIT"] = "burn_limit";
  CODEC2["TX_ROLLUP_ORIGINATION_PARAM"] = "tx_rollup_origination_param";
  CODEC2["TX_ROLLUP_ID"] = "tx_rollup_id";
  CODEC2["TX_ROLLUP_BATCH_CONTENT"] = "tx_rollup_batch_content";
  CODEC2["OP_INCREASE_PAID_STORAGE"] = "increase_paid_storage";
  CODEC2["OP_UPDATE_CONSENSUS_KEY"] = "update_consensus_key";
  CODEC2["OP_DRAIN_DELEGATE"] = "drain_delegate";
  CODEC2["DEPOSITS_LIMIT"] = "deposits_limit";
  CODEC2["OP_SET_DEPOSITS_LIMIT"] = "set_deposits_limit";
  CODEC2["OP_SMART_ROLLUP_ORIGINATE"] = "smart_rollup_originate";
  CODEC2["PVM_KIND"] = "pvm_kind";
  CODEC2["OP_SMART_ROLLUP_ADD_MESSAGES"] = "smart_rollup_add_messages";
  CODEC2["OP_SMART_ROLLUP_EXECUTE_OUTBOX_MESSAGE"] = "smart_rollup_execute_outbox_message";
})(CODEC || (CODEC = {}));
var opMapping = {
  "00": "parameter",
  "01": "storage",
  "02": "code",
  "03": "False",
  "04": "Elt",
  "05": "Left",
  "06": "None",
  "07": "Pair",
  "08": "Right",
  "09": "Some",
  "0a": "True",
  "0b": "Unit",
  "0c": "PACK",
  "0d": "UNPACK",
  "0e": "BLAKE2B",
  "0f": "SHA256",
  "10": "SHA512",
  "11": "ABS",
  "12": "ADD",
  "13": "AMOUNT",
  "14": "AND",
  "15": "BALANCE",
  "16": "CAR",
  "17": "CDR",
  "18": "CHECK_SIGNATURE",
  "19": "COMPARE",
  "1a": "CONCAT",
  "1b": "CONS",
  "1c": "CREATE_ACCOUNT",
  "1d": "CREATE_CONTRACT",
  "1e": "IMPLICIT_ACCOUNT",
  "1f": "DIP",
  "20": "DROP",
  "21": "DUP",
  "22": "EDIV",
  "23": "EMPTY_MAP",
  "24": "EMPTY_SET",
  "25": "EQ",
  "26": "EXEC",
  "27": "FAILWITH",
  "28": "GE",
  "29": "GET",
  "2a": "GT",
  "2b": "HASH_KEY",
  "2c": "IF",
  "2d": "IF_CONS",
  "2e": "IF_LEFT",
  "2f": "IF_NONE",
  "30": "INT",
  "31": "LAMBDA",
  "32": "LE",
  "33": "LEFT",
  "34": "LOOP",
  "35": "LSL",
  "36": "LSR",
  "37": "LT",
  "38": "MAP",
  "39": "MEM",
  "3a": "MUL",
  "3b": "NEG",
  "3c": "NEQ",
  "3d": "NIL",
  "3e": "NONE",
  "3f": "NOT",
  "40": "NOW",
  "41": "OR",
  "42": "PAIR",
  "43": "PUSH",
  "44": "RIGHT",
  "45": "SIZE",
  "46": "SOME",
  "47": "SOURCE",
  "48": "SENDER",
  "49": "SELF",
  "4a": "STEPS_TO_QUOTA",
  "4b": "SUB",
  "4c": "SWAP",
  "4d": "TRANSFER_TOKENS",
  "4e": "SET_DELEGATE",
  "4f": "UNIT",
  "50": "UPDATE",
  "51": "XOR",
  "52": "ITER",
  "53": "LOOP_LEFT",
  "54": "ADDRESS",
  "55": "CONTRACT",
  "56": "ISNAT",
  "57": "CAST",
  "58": "RENAME",
  "59": "bool",
  "5a": "contract",
  "5b": "int",
  "5c": "key",
  "5d": "key_hash",
  "5e": "lambda",
  "5f": "list",
  "60": "map",
  "61": "big_map",
  "62": "nat",
  "63": "option",
  "64": "or",
  "65": "pair",
  "66": "set",
  "67": "signature",
  "68": "string",
  "69": "bytes",
  "6a": "mutez",
  "6b": "timestamp",
  "6c": "unit",
  "6d": "operation",
  "6e": "address",
  "6f": "SLICE",
  "70": "DIG",
  "71": "DUG",
  "72": "EMPTY_BIG_MAP",
  "73": "APPLY",
  "74": "chain_id",
  "75": "CHAIN_ID",
  "76": "LEVEL",
  "77": "SELF_ADDRESS",
  "78": "never",
  "79": "NEVER",
  "7a": "UNPAIR",
  "7b": "VOTING_POWER",
  "7c": "TOTAL_VOTING_POWER",
  "7d": "KECCAK",
  "7e": "SHA3",
  "7f": "PAIRING_CHECK",
  "80": "bls12_381_g1",
  "81": "bls12_381_g2",
  "82": "bls12_381_fr",
  "83": "sapling_state",
  "84": "sapling_transaction_deprecated",
  "85": "SAPLING_EMPTY_STATE",
  "86": "SAPLING_VERIFY_UPDATE",
  "87": "ticket",
  "88": "TICKET_DEPRECATED",
  "89": "READ_TICKET",
  "8a": "SPLIT_TICKET",
  "8b": "JOIN_TICKETS",
  "8c": "GET_AND_UPDATE",
  "8d": "chest",
  "8e": "chest_key",
  "8f": "OPEN_CHEST",
  "90": "VIEW",
  "91": "view",
  "92": "constant",
  "93": "SUB_MUTEZ",
  "94": "tx_rollup_l2_address",
  "95": "MIN_BLOCK_TIME",
  "96": "sapling_transaction",
  "97": "EMIT",
  "98": "Lambda_rec",
  "99": "LAMBDA_REC",
  "9a": "TICKET",
  "9b": "BYTES",
  "9c": "NAT"
};
var opMappingReverse = (() => {
  const result = {};
  Object.keys(opMapping).forEach((key) => {
    result[opMapping[key]] = key;
  });
  return result;
})();
var kindMapping = {
  4: "activate_account",
  107: "reveal",
  110: "delegation",
  108: "transaction",
  109: "origination",
  6: "ballot",
  21: "endorsement",
  1: "seed_nonce_revelation",
  5: "proposals",
  111: "register_global_constant",
  150: "tx_rollup_origination",
  151: "tx_rollup_submit_batch",
  158: "transfer_ticket",
  112: "set_deposits_limit",
  113: "increase_paid_storage",
  114: "update_consensus_key",
  9: "drain_delegate",
  200: "smart_rollup_originate",
  201: "smart_rollup_add_messages",
  206: "smart_rollup_execute_outbox_message",
  17: "failing_noop"
};
var kindMappingReverse = (() => {
  const result = {};
  Object.keys(kindMapping).forEach((key) => {
    const keyNum = typeof key === "string" ? parseInt(key, 10) : key;
    result[kindMapping[keyNum]] = pad(keyNum, 2);
  });
  return result;
})();
var entrypointMapping = {
  "00": "default",
  "01": "root",
  "02": "do",
  "03": "set_delegate",
  "04": "remove_delegate",
  "05": "deposit"
};
var entrypointMappingReverse = (() => {
  const result = {};
  Object.keys(entrypointMapping).forEach((key) => {
    result[entrypointMapping[key]] = key;
  });
  return result;
})();
var InvalidOperationSchemaError = class extends ParameterValidationError {
  constructor(operation, errorDetail) {
    super();
    this.operation = operation;
    this.errorDetail = errorDetail;
    this.name = "InvalidOperationSchemaError";
    this.message = `Invalid operation content recevied`;
    errorDetail ? this.message += ` ${errorDetail}.` : "";
  }
};
var OversizedEntryPointError = class extends ParameterValidationError {
  constructor(entrypoint) {
    super();
    this.entrypoint = entrypoint;
    this.name = "OversizedEntryPointError";
    this.message = `Invalid entrypoint length "${entrypoint.length}", maximum length is "${ENTRYPOINT_MAX_LENGTH}".`;
  }
};
var InvalidBallotValueError = class extends ParameterValidationError {
  constructor(ballotValue) {
    super();
    this.ballotValue = ballotValue;
    this.name = "InvalidBallotValueError";
    this.message = `Invalid ballot value "${ballotValue}" expecting one of the following: "yay", "nay", "pass".`;
  }
};
var DecodeBallotValueError = class extends ParameterValidationError {
  constructor(ballotValue) {
    super();
    this.ballotValue = ballotValue;
    this.name = "DecodeBallotValueError";
    this.message = `Invalid ballot value "${ballotValue}", cannot be decoded.`;
  }
};
var UnexpectedMichelsonValueError = class extends ParameterValidationError {
  constructor(value) {
    super();
    this.value = value;
    this.name = "UnexpectedMichelsonValueError";
    this.message = `Invalid Michelson value "${value}", unalbe to encode.`;
  }
};
var OperationDecodingError = class extends ParameterValidationError {
  constructor(message) {
    super();
    this.message = message;
    this.name = "OperationDecodingError";
  }
};
var OperationEncodingError = class extends ParameterValidationError {
  constructor(message) {
    super();
    this.message = message;
    this.name = "OperationEncodingError";
  }
};
var UnsupportedOperationError = class extends ParameterValidationError {
  constructor(op) {
    super();
    this.op = op;
    this.name = "UnsupportedOperationError";
    this.message = `Unsupported operation "${op}", can submit an issue on our github for feature request.`;
  }
};
var UnsupportedPvmKindError = class extends ParameterValidationError {
  constructor(pvm) {
    super();
    this.pvm = pvm;
    this.name = "UnsupportedPvmKindError";
    this.message = `Invalid Pvm kind "${pvm}" expecting either "arith" or "wasm_2_0_0".`;
  }
};
var DecodePvmKindError = class extends ParameterValidationError {
  constructor(pvm) {
    super();
    this.pvm = pvm;
    this.name = "DecodePvmKindError";
    this.message = `Invalid Pvm kind "${pvm}", cannot be decoded.`;
  }
};
var InvalidSmartRollupAddressError = class extends ParameterValidationError {
  constructor(address, errorDetail) {
    super();
    this.address = address;
    this.errorDetail = errorDetail;
    this.name = "InvalidSmartRollupAddress";
    this.message = `Invalid smart rollup address "${address}"`;
    errorDetail ? this.message += ` ${errorDetail}.` : "";
  }
};
var InvalidSmartRollupCommitmentHashError = class extends ParameterValidationError {
  constructor(hash2, errorDetail) {
    super();
    this.hash = hash2;
    this.errorDetail = errorDetail;
    this.name = "InvalidSmartRollupCommitmentHashError";
    this.message = `Invalid smart rollup commitment hash "${hash2}"`;
    errorDetail ? this.message += ` ${errorDetail}.` : "";
  }
};
var Uint8ArrayConsumer = class _Uint8ArrayConsumer {
  constructor(arr, offset = 0) {
    this.arr = arr;
    this.offset = offset;
  }
  static fromHexString(hex) {
    const lowHex = hex.toLowerCase();
    if (/^(([a-f]|\d){2})*$/.test(lowHex)) {
      const arr = new Uint8Array((lowHex.match(/([a-z]|\d){2}/g) || []).map((byte) => parseInt(byte, 16)));
      return new _Uint8ArrayConsumer(arr);
    } else {
      throw new InvalidHexStringError(lowHex);
    }
  }
  consume(count2) {
    const subArr = this.arr.subarray(this.offset, this.offset + count2);
    this.offset += count2;
    return subArr;
  }
  get(idx) {
    return this.arr[this.offset + idx];
  }
  length() {
    return this.arr.length - this.offset;
  }
  slice(start, end) {
    return new _Uint8ArrayConsumer(this.arr.slice(start, end));
  }
};
var isPrim = (value) => {
  return "prim" in value;
};
var isBytes = (value) => {
  return "bytes" in value && typeof value.bytes === "string";
};
var isString = (value) => {
  return "string" in value && typeof value.string === "string";
};
var isInt = (value) => {
  return "int" in value && typeof value.int === "string";
};
var scriptEncoder = (script) => {
  const code2 = valueEncoder(script.code);
  const storage2 = valueEncoder(script.storage);
  return `${pad(code2.length / 2, 8)}${code2}${pad(storage2.length / 2, 8)}${storage2}`;
};
var scriptDecoder = (value) => {
  const code2 = extractRequiredLen(value);
  const storage2 = extractRequiredLen(value);
  return {
    code: valueDecoder(new Uint8ArrayConsumer(code2)),
    storage: valueDecoder(new Uint8ArrayConsumer(storage2))
  };
};
var valueEncoder = (value) => {
  if (Array.isArray(value)) {
    const encoded = value.map((x) => valueEncoder(x)).join("");
    const len = encoded.length / 2;
    return `02${pad(len)}${encoded}`;
  } else if (isPrim(value)) {
    return primEncoder(value);
  } else if (isBytes(value)) {
    return bytesEncoder(value);
  } else if (isString(value)) {
    return stringEncoder(value);
  } else if (isInt(value)) {
    return intEncoder(value);
  }
  throw new UnexpectedMichelsonValueError(JSON.stringify(value));
};
var valueDecoder = (value) => {
  const preamble = value.consume(1);
  switch (preamble[0]) {
    case 10:
      return bytesDecoder(value);
    case 1:
      return stringDecoder(value);
    case 0:
      return intDecoder(value);
    case 2: {
      const val = new Uint8ArrayConsumer(extractRequiredLen(value));
      const results = [];
      while (val.length() > 0) {
        results.push(valueDecoder(val));
      }
      return results;
    }
    default:
      return primDecoder(value, preamble);
  }
};
var extractRequiredLen = (value, bytesLength = 4) => {
  const len = value.consume(bytesLength);
  const valueLen = parseInt(Buffer.from(len).toString("hex"), 16);
  return value.consume(valueLen);
};
var stripLengthPrefixFromBytes = (value, bytesLength = 4) => {
  const ret = [];
  let values = value;
  while (values.length()) {
    const len = values.consume(bytesLength);
    const valueLen = parseInt(Buffer.from(len).toString("hex"), 16);
    ret.push(values.consume(valueLen));
    values = values.slice(valueLen + bytesLength);
  }
  return ret;
};
var bytesEncoder = (value) => {
  if (!/^([A-Fa-f0-9]{2})*$/.test(value.bytes)) {
    throw new InvalidHexStringError(value.bytes);
  }
  const len = value.bytes.length / 2;
  return `0a${pad(len)}${value.bytes}`;
};
var bytesDecoder = (value) => {
  const bytes = extractRequiredLen(value);
  return {
    bytes: Buffer.from(bytes).toString("hex")
  };
};
var stringEncoder = (value) => {
  const str = Buffer.from(value.string, "utf8").toString("hex");
  const hexLength = str.length / 2;
  return `01${pad(hexLength)}${str}`;
};
var stringDecoder = (value) => {
  const str = extractRequiredLen(value);
  return {
    string: Buffer.from(str).toString("utf8")
  };
};
var intEncoder = ({ int }) => {
  const num = new BigNumber(int, 10);
  const positiveMark = num.toString(2)[0] === "-" ? "1" : "0";
  const binary = num.toString(2).replace(/-/g, "");
  const pad2 = binary.length <= 6 ? 6 : (binary.length - 6) % 7 ? binary.length + 7 - (binary.length - 6) % 7 : binary.length;
  const splitted = binary.padStart(pad2, "0").match(/\d{6,7}/g);
  const reversed = splitted.reverse();
  reversed[0] = positiveMark + reversed[0];
  const numHex = reversed.map((x, i) => (
    // Add one to the last chunk
    parseInt((i === reversed.length - 1 ? "0" : "1") + x, 2).toString(16).padStart(2, "0")
  ));
  return `00${numHex.join("")}`;
};
var intDecoder = (value) => {
  let c = value.consume(1)[0];
  const hexNumber = [];
  const isNotLastChunkMask = 1 << 7;
  while (c & isNotLastChunkMask) {
    hexNumber.push(c);
    c = value.consume(1)[0];
  }
  hexNumber.push(c);
  const isNegative = !!(1 << 6 & hexNumber[0]);
  hexNumber[0] = hexNumber[0] & 127;
  const numBin = hexNumber.map((x, i) => x.toString(2).slice(i === 0 ? -6 : -7).padStart(i === 0 ? 6 : 7, "0")).reverse();
  let num = new BigNumber(numBin.join(""), 2);
  if (isNegative) {
    num = num.times(-1);
  }
  return {
    int: num.toFixed()
  };
};
var primEncoder = (value) => {
  const hasAnnot = +Array.isArray(value.annots);
  const argsCount = Array.isArray(value.args) ? value.args.length : 0;
  const preamble = pad(Math.min(2 * argsCount + hasAnnot + 3, 9), 2);
  const op = opMappingReverse[value.prim];
  let encodedArgs = (value.args || []).map((arg) => valueEncoder(arg)).join("");
  const encodedAnnots = Array.isArray(value.annots) ? encodeAnnots(value.annots) : "";
  if ((value.prim === "LAMBDA" || value.prim === "LAMBDA_REC") && argsCount) {
    encodedArgs = pad(encodedArgs.length / 2) + encodedArgs + pad(0);
  }
  if ((value.prim === "pair" || value.prim === "Pair") && argsCount > 2) {
    encodedArgs = encodedAnnots === "" ? pad(encodedArgs.length / 2) + encodedArgs + pad(0) : pad(encodedArgs.length / 2) + encodedArgs;
  }
  if (value.prim === "view" && value.args) {
    encodedArgs = pad(encodedArgs.length / 2) + encodedArgs + pad(0);
  }
  return `${preamble}${op}${encodedArgs}${encodedAnnots}`;
};
var primDecoder = (value, preamble) => {
  const hasAnnot = (preamble[0] - 3) % 2 === 1;
  let argsCount = Math.floor((preamble[0] - 3) / 2);
  const op = value.consume(1)[0].toString(16).padStart(2, "0");
  const result = {
    prim: opMapping[op]
  };
  if (opMapping[op] === "LAMBDA" || opMapping[op] === "LAMBDA_REC") {
    value.consume(4);
  }
  if (opMapping[op] === "view") {
    if (argsCount != 0) {
      return primViewDecoder(value, result);
    } else {
      return result;
    }
  }
  let combPairArgs;
  let combPairAnnots;
  if ((opMapping[op] === "pair" || opMapping[op] === "Pair") && argsCount > 2) {
    combPairArgs = decodeCombPair(value);
    argsCount = 0;
    combPairAnnots = decodeAnnots(value);
  }
  const args = new Array(argsCount).fill(0).map(() => valueDecoder(value));
  if (opMapping[op] === "LAMBDA" || opMapping[op] === "LAMBDA_REC") {
    value.consume(4);
  }
  if (combPairArgs) {
    result["args"] = combPairArgs;
  } else if (args.length) {
    result["args"] = args;
  }
  if (combPairAnnots && combPairAnnots[0] !== "") {
    result["annots"] = combPairAnnots;
  } else if (hasAnnot) {
    result["annots"] = decodeAnnots(value);
  }
  return result;
};
var primViewDecoder = (value, result) => {
  value.consume(4);
  result["args"] = new Array(4).fill(0).map(() => valueDecoder(value));
  value.consume(4);
  return result;
};
var decodeCombPair = (val) => {
  const array = new Uint8ArrayConsumer(extractRequiredLen(val));
  const args = [];
  while (array.length() > 0) {
    args.push(valueDecoder(array));
  }
  return args;
};
var encodeAnnots = (value) => {
  const mergedAnnot = value.map((x) => {
    return Buffer.from(x, "utf8").toString("hex");
  }).join("20");
  const len = mergedAnnot.length / 2;
  return `${pad(len)}${mergedAnnot}`;
};
var decodeAnnots = (val) => {
  const len = val.consume(4);
  const annotLen = parseInt(Buffer.from(len).toString("hex"), 16);
  const restOfAnnot = val.consume(annotLen);
  const restOfAnnotHex = Buffer.from(restOfAnnot).toString("hex");
  return restOfAnnotHex.split("20").map((x) => Buffer.from(x, "hex").toString("utf8"));
};
var prefixEncoder = (prefix$1) => (str) => {
  return buf2hex(Buffer.from(b58cdecode(str, prefix[prefix$1])));
};
var prefixDecoder = (pre) => (str) => {
  const val = str.consume(prefixLength[pre]);
  return b58cencode(val, prefix[pre]);
};
var tz1Decoder = prefixDecoder(Prefix.TZ1);
var branchDecoder = prefixDecoder(Prefix.B);
var pkhDecoder = (val) => {
  const prefix2 = val.consume(1);
  if (prefix2[0] === 0) {
    return prefixDecoder(Prefix.TZ1)(val);
  } else if (prefix2[0] === 1) {
    return prefixDecoder(Prefix.TZ2)(val);
  } else if (prefix2[0] === 2) {
    return prefixDecoder(Prefix.TZ3)(val);
  }
};
var branchEncoder = prefixEncoder(Prefix.B);
var tz1Encoder = prefixEncoder(Prefix.TZ1);
var boolEncoder = (bool) => bool ? "ff" : "00";
var proposalEncoder = (proposal) => {
  return prefixEncoder(Prefix.P)(proposal);
};
var proposalDecoder = (proposal) => {
  return prefixDecoder(Prefix.P)(proposal);
};
var proposalsDecoder = (proposal) => {
  const proposals = [];
  proposal.consume(4);
  while (proposal.length() > 0) {
    proposals.push(proposalDecoder(proposal));
  }
  return proposals;
};
var proposalsEncoder = (proposals) => {
  return pad(32 * proposals.length) + proposals.map((x) => proposalEncoder(x)).join("");
};
var ballotEncoder = (ballot) => {
  switch (ballot) {
    case "yay":
      return "00";
    case "nay":
      return "01";
    case "pass":
      return "02";
    default:
      throw new InvalidBallotValueError(ballot);
  }
};
var ballotDecoder = (ballot) => {
  const value = ballot.consume(1);
  switch (value[0]) {
    case 0:
      return "yay";
    case 1:
      return "nay";
    case 2:
      return "pass";
    default:
      throw new DecodeBallotValueError(value[0].toString());
  }
};
var pvmKindEncoder = (pvm) => {
  switch (pvm) {
    case "arith":
      return "00";
    case "wasm_2_0_0":
      return "01";
    default:
      throw new UnsupportedPvmKindError(pvm);
  }
};
var pvmKindDecoder = (pvm) => {
  const value = pvm.consume(1);
  switch (value[0]) {
    case 0:
      return "arith";
    case 1:
      return "wasm_2_0_0";
    default:
      throw new DecodePvmKindError(value[0].toString());
  }
};
var delegateEncoder = (val) => {
  if (val) {
    return boolEncoder(true) + pkhEncoder(val);
  } else {
    return boolEncoder(false);
  }
};
var int32Encoder = (val) => {
  const num = parseInt(String(val), 10);
  const byte = [];
  for (let i = 0; i < 4; i++) {
    const shiftBy = (4 - (i + 1)) * 8;
    byte.push((num & 255 << shiftBy) >> shiftBy);
  }
  return Buffer.from(byte).toString("hex");
};
var int32Decoder = (val) => {
  const num = val.consume(4);
  let finalNum = 0;
  for (let i = 0; i < num.length; i++) {
    finalNum = finalNum | num[i] << (num.length - (i + 1)) * 8;
  }
  return finalNum;
};
var int16Encoder = (val) => {
  const num = parseInt(String(val), 10);
  const byte = [];
  for (let i = 0; i < 2; i++) {
    const shiftBy = (2 - (i + 1)) * 8;
    byte.push((num & 255 << shiftBy) >> shiftBy);
  }
  return Buffer.from(byte).toString("hex");
};
var int16Decoder = (val) => {
  const num = val.consume(2);
  let finalNum = 0;
  for (let i = 0; i < num.length; i++) {
    finalNum = finalNum | num[i] << (num.length - (i + 1)) * 8;
  }
  return finalNum;
};
var boolDecoder = (val) => {
  const bool = val.consume(1);
  return bool[0] === 255;
};
var delegateDecoder = (val) => {
  const hasDelegate = boolDecoder(val);
  if (hasDelegate) {
    return pkhDecoder(val);
  }
};
var pkhEncoder = (val) => {
  const pubkeyPrefix = val.substring(0, 3);
  switch (pubkeyPrefix) {
    case Prefix.TZ1:
      return "00" + prefixEncoder(Prefix.TZ1)(val);
    case Prefix.TZ2:
      return "01" + prefixEncoder(Prefix.TZ2)(val);
    case Prefix.TZ3:
      return "02" + prefixEncoder(Prefix.TZ3)(val);
    case Prefix.TZ4:
      return "03" + prefixEncoder(Prefix.TZ4)(val);
    default:
      throw new InvalidKeyHashError(val, invalidDetail(ValidationResult.NO_PREFIX_MATCHED) + ` expecting one for the following "${Prefix.TZ1}", "${Prefix.TZ2}", "${Prefix.TZ3}" or "${Prefix.TZ4}".`);
  }
};
var publicKeyEncoder = (val) => {
  const pubkeyPrefix = val.substring(0, 4);
  switch (pubkeyPrefix) {
    case Prefix.EDPK:
      return "00" + prefixEncoder(Prefix.EDPK)(val);
    case Prefix.SPPK:
      return "01" + prefixEncoder(Prefix.SPPK)(val);
    case Prefix.P2PK:
      return "02" + prefixEncoder(Prefix.P2PK)(val);
    default:
      throw new InvalidPublicKeyError(val, invalidDetail(ValidationResult.NO_PREFIX_MATCHED) + ` expecting one of the following '${Prefix.EDPK}', '${Prefix.SPPK}', '${Prefix.P2PK}' or '${Prefix.BLPK}'.`);
  }
};
var addressEncoder = (val) => {
  const pubkeyPrefix = val.substring(0, 3);
  switch (pubkeyPrefix) {
    case Prefix.TZ1:
    case Prefix.TZ2:
    case Prefix.TZ3:
    case Prefix.TZ4:
      return "00" + pkhEncoder(val);
    case Prefix.KT1:
      return "01" + prefixEncoder(Prefix.KT1)(val) + "00";
    default:
      throw new InvalidAddressError(val, invalidDetail(ValidationResult.NO_PREFIX_MATCHED) + ` expecting one of the following prefix '${Prefix.TZ1}', ${Prefix.TZ2}', '${Prefix.TZ3}', '${Prefix.TZ4}' or '${Prefix.KT1}'.`);
  }
};
var smartRollupAddressEncoder = (val) => {
  if (val.substring(0, 3) !== Prefix.SR1) {
    throw new InvalidSmartRollupAddressError(val, invalidDetail(ValidationResult.NO_PREFIX_MATCHED) + ` expecting prefix '${Prefix.SR1}'.`);
  }
  return prefixEncoder(Prefix.SR1)(val);
};
var smartContractAddressEncoder = (val) => {
  const prefix2 = val.substring(0, 3);
  if (prefix2 === Prefix.KT1) {
    return "01" + prefixEncoder(Prefix.KT1)(val) + "00";
  }
  throw new InvalidContractAddressError(val, invalidDetail(ValidationResult.NO_PREFIX_MATCHED) + ` expecting prefix '${Prefix.KT1}'.`);
};
var publicKeyDecoder = (val) => {
  const preamble = val.consume(1);
  switch (preamble[0]) {
    case 0:
      return prefixDecoder(Prefix.EDPK)(val);
    case 1:
      return prefixDecoder(Prefix.SPPK)(val);
    case 2:
      return prefixDecoder(Prefix.P2PK)(val);
    default:
      throw new InvalidPublicKeyError(val.toString(), invalidDetail(ValidationResult.NO_PREFIX_MATCHED));
  }
};
var smartRollupCommitmentHashEncoder = (val) => {
  const prefix2 = val.substring(0, 4);
  if (prefix2 === Prefix.SRC1) {
    return prefixEncoder(Prefix.SRC1)(val);
  }
  throw new InvalidSmartRollupCommitmentHashError(val, invalidDetail(ValidationResult.NO_PREFIX_MATCHED) + ` expecting prefix '${Prefix.SRC1}'`);
};
var addressDecoder = (val) => {
  const preamble = val.consume(1);
  switch (preamble[0]) {
    case 0:
      return pkhDecoder(val);
    case 1: {
      const address = prefixDecoder(Prefix.KT1)(val);
      val.consume(1);
      return address;
    }
    default:
      throw new InvalidAddressError(val.toString(), ": Unable to decode.");
  }
};
var smartRollupAddressDecoder = (val) => {
  const address = prefixDecoder(Prefix.SR1)(val);
  if (address.substring(0, 3) !== Prefix.SR1) {
    throw new InvalidSmartRollupAddressError(address, invalidDetail(ValidationResult.NO_PREFIX_MATCHED) + ` expecting prefix '${Prefix.SR1}'.`);
  }
  return address;
};
var smartContractAddressDecoder = (val) => {
  const preamble = val.consume(1);
  if (preamble[0] === 1) {
    const scAddress = prefixDecoder(Prefix.KT1)(val);
    val.consume(1);
    return scAddress;
  }
  throw new InvalidContractAddressError(val.toString(), invalidDetail(ValidationResult.NO_PREFIX_MATCHED));
};
var smartRollupCommitmentHashDecoder = (val) => {
  const address = prefixDecoder(Prefix.SRC1)(val);
  if (address.substring(0, 4) !== Prefix.SRC1) {
    throw new InvalidSmartRollupCommitmentHashError(address, invalidDetail(ValidationResult.NO_PREFIX_MATCHED) + ` expecting prefix '${Prefix.SRC1}'`);
  }
  return address;
};
var zarithEncoder = (n) => {
  const fn = [];
  let nn = new bignumber_default(n, 10);
  if (nn.isNaN()) {
    throw new TypeError(`Invalid zarith number ${n}`);
  }
  while (true) {
    if (nn.lt(128)) {
      if (nn.lt(16))
        fn.push("0");
      fn.push(nn.toString(16));
      break;
    } else {
      let b = nn.mod(128);
      nn = nn.minus(b);
      nn = nn.dividedBy(128);
      b = b.plus(128);
      fn.push(b.toString(16));
    }
  }
  return fn.join("");
};
var zarithDecoder = (n) => {
  let mostSignificantByte = 0;
  while (mostSignificantByte < n.length() && (n.get(mostSignificantByte) & 128) !== 0) {
    mostSignificantByte += 1;
  }
  let num = new bignumber_default(0);
  for (let i = mostSignificantByte; i >= 0; i -= 1) {
    const tmp = n.get(i) & 127;
    num = num.multipliedBy(128);
    num = num.plus(tmp);
  }
  n.consume(mostSignificantByte + 1);
  return new bignumber_default(num).toString();
};
var entrypointDecoder = (value) => {
  const preamble = pad(value.consume(1)[0], 2);
  if (preamble in entrypointMapping) {
    return entrypointMapping[preamble];
  } else {
    const entry = extractRequiredLen(value, 1);
    const entrypoint = Buffer.from(entry).toString("utf8");
    if (entrypoint.length > ENTRYPOINT_MAX_LENGTH) {
      throw new OversizedEntryPointError(entrypoint);
    }
    return entrypoint;
  }
};
var parametersDecoder = (val) => {
  const preamble = val.consume(1);
  if (preamble[0] === 0) {
    return;
  } else {
    const encodedEntrypoint = entrypointDecoder(val);
    const params = extractRequiredLen(val);
    const parameters = valueDecoder(new Uint8ArrayConsumer(params));
    return {
      entrypoint: encodedEntrypoint,
      value: parameters
    };
  }
};
var entrypointEncoder = (entrypoint) => {
  if (entrypoint in entrypointMappingReverse) {
    return `${entrypointMappingReverse[entrypoint]}`;
  } else {
    if (entrypoint.length > ENTRYPOINT_MAX_LENGTH) {
      throw new OversizedEntryPointError(entrypoint);
    }
    const value = { string: entrypoint };
    return `ff${valueEncoder(value).slice(8)}`;
  }
};
var parametersEncoder = (val) => {
  if (!val || val.entrypoint === "default" && "prim" in val.value && val.value.prim === "Unit") {
    return "00";
  }
  const encodedEntrypoint = entrypointEncoder(val.entrypoint);
  const parameters = valueEncoder(val.value);
  const length = (parameters.length / 2).toString(16).padStart(8, "0");
  return `ff${encodedEntrypoint}${length}${parameters}`;
};
var valueParameterEncoder = (value) => {
  const valueEncoded = valueEncoder(value);
  return `${pad(valueEncoded.length / 2)}${valueEncoded}`;
};
var valueParameterDecoder = (val) => {
  const value = extractRequiredLen(val);
  return valueDecoder(new Uint8ArrayConsumer(value));
};
var blockPayloadHashEncoder = prefixEncoder(Prefix.VH);
var blockPayloadHashDecoder = prefixDecoder(Prefix.VH);
var entrypointNameEncoder = (entrypoint) => {
  const value = { string: entrypoint };
  return `${valueEncoder(value).slice(2)}`;
};
var entrypointNameDecoder = (val) => {
  const entry = extractRequiredLen(val);
  return Buffer.from(entry).toString("utf8");
};
var txRollupOriginationParamEncoder = (_value) => {
  return "";
};
var txRollupOriginationParamDecoder = (_val) => {
  return {};
};
var txRollupIdEncoder = prefixEncoder(Prefix.TXR1);
var txRollupIdDecoder = prefixDecoder(Prefix.TXR1);
var txRollupBatchContentEncoder = (value) => {
  return `${pad(value.length / 2)}${value}`;
};
var txRollupBatchContentDecoder = (val) => {
  const value = extractRequiredLen(val);
  return Buffer.from(value).toString("hex");
};
var burnLimitEncoder = (val) => {
  return !val ? "00" : `ff${zarithEncoder(val)}`;
};
var burnLimitDecoder = (value) => {
  const prefix2 = value.consume(1);
  if (Buffer.from(prefix2).toString("hex") !== "00") {
    return zarithDecoder(value);
  }
};
var depositsLimitEncoder = (val) => {
  return !val ? "00" : `ff${zarithEncoder(val)}`;
};
var depositsLimitDecoder = (value) => {
  const prefix2 = value.consume(1);
  if (Buffer.from(prefix2).toString("hex") !== "00") {
    return zarithDecoder(value);
  }
};
var paddedBytesEncoder = (val, paddingLength = 8) => {
  return `${pad(val.length / 2, paddingLength)}${val}`;
};
var paddedBytesDecoder = (val) => {
  const value = extractRequiredLen(val);
  return Buffer.from(value).toString("hex");
};
var smartRollupMessageEncoder = (val) => {
  const message = val.reduce((prev, curr) => {
    return prev + `${pad(curr.length / 2)}${curr}`;
  }, "");
  return `${pad(message.length / 2)}${message}`;
};
var smartRollupMessageDecoder = (val) => {
  const valueArray = extractRequiredLen(val);
  const ret = stripLengthPrefixFromBytes(new Uint8ArrayConsumer(valueArray));
  return ret.map((value) => Buffer.from(value).toString("hex"));
};
var ManagerOperationSchema = {
  branch: CODEC.BRANCH,
  contents: [CODEC.OPERATION]
};
var ActivationSchema = {
  pkh: CODEC.TZ1,
  secret: CODEC.SECRET
};
var RevealSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  public_key: CODEC.PUBLIC_KEY
};
var DelegationSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  delegate: CODEC.DELEGATE
};
var TransactionSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  amount: CODEC.ZARITH,
  destination: CODEC.ADDRESS,
  parameters: CODEC.PARAMETERS
};
var OriginationSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  balance: CODEC.ZARITH,
  delegate: CODEC.DELEGATE,
  script: CODEC.SCRIPT
};
var BallotSchema = {
  source: CODEC.PKH,
  period: CODEC.INT32,
  proposal: CODEC.PROPOSAL,
  ballot: CODEC.BALLOT_STATEMENT
};
var EndorsementSchema = {
  slot: CODEC.INT16,
  level: CODEC.INT32,
  round: CODEC.INT32,
  block_payload_hash: CODEC.BLOCK_PAYLOAD_HASH
};
var SeedNonceRevelationSchema = {
  level: CODEC.INT32,
  nonce: CODEC.RAW
};
var ProposalsSchema = {
  source: CODEC.PKH,
  period: CODEC.INT32,
  proposals: CODEC.PROPOSAL_ARR
};
var RegisterGlobalConstantSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  value: CODEC.VALUE
};
var TransferTicketSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  ticket_contents: CODEC.VALUE,
  ticket_ty: CODEC.VALUE,
  ticket_ticketer: CODEC.ADDRESS,
  ticket_amount: CODEC.ZARITH,
  destination: CODEC.ADDRESS,
  entrypoint: CODEC.ENTRYPOINT
};
var TxRollupOriginationSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  tx_rollup_origination: CODEC.TX_ROLLUP_ORIGINATION_PARAM
};
var TxRollupSubmitBatchSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  rollup: CODEC.TX_ROLLUP_ID,
  content: CODEC.TX_ROLLUP_BATCH_CONTENT,
  burn_limit: CODEC.BURN_LIMIT
};
var IncreasePaidStorageSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  amount: CODEC.ZARITH,
  destination: CODEC.SMART_CONTRACT_ADDRESS
};
var UpdateConsensusKeySchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  pk: CODEC.PUBLIC_KEY
};
var DrainDelegateSchema = {
  consensus_key: CODEC.PKH,
  delegate: CODEC.PKH,
  destination: CODEC.PKH
};
var SetDepositsLimitSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  limit: CODEC.DEPOSITS_LIMIT
};
var SmartRollupOriginateSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  pvm_kind: CODEC.PVM_KIND,
  kernel: CODEC.PADDED_BYTES,
  origination_proof: CODEC.PADDED_BYTES,
  parameters_ty: CODEC.VALUE
};
var SmartRollupAddMessagesSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  message: CODEC.SMART_ROLLUP_MESSAGE
};
var SmartRollupExecuteOutboxMessageSchema = {
  source: CODEC.PKH,
  fee: CODEC.ZARITH,
  counter: CODEC.ZARITH,
  gas_limit: CODEC.ZARITH,
  storage_limit: CODEC.ZARITH,
  rollup: CODEC.SMART_ROLLUP_ADDRESS,
  cemented_commitment: CODEC.SMART_ROLLUP_COMMITMENT_HASH,
  output_proof: CODEC.PADDED_BYTES
};
var FailingNoopSchema = {
  arbitrary: CODEC.PADDED_BYTES
};
var operationEncoder = (encoders2) => (operation) => {
  if (!(operation.kind in encoders2) || !(operation.kind in kindMappingReverse)) {
    throw new InvalidOperationKindError(operation.kind);
  }
  return kindMappingReverse[operation.kind] + encoders2[operation.kind](operation);
};
var operationDecoder = (decoders2) => (value) => {
  const op = value.consume(1);
  const operationName = kindMapping[op[0]];
  if (operationName === void 0) {
    throw new UnsupportedOperationError(op[0].toString());
  }
  const decodedObj = decoders2[operationName](value);
  if (typeof decodedObj !== "object") {
    throw new OperationDecodingError("Invalid operation, cannot be decoded.");
  }
  return Object.assign({ kind: operationName }, decodedObj);
};
var schemaEncoder = (encoders2) => (schema) => (value) => {
  const keys = Object.keys(schema);
  return keys.reduce((prev, key) => {
    const valueToEncode = schema[key];
    if (value && Array.isArray(valueToEncode)) {
      const encoder = encoders2[valueToEncode[0]];
      const values = value[key];
      if (!Array.isArray(values)) {
        throw new OperationEncodingError(`Invalid operation value "${JSON.stringify(values)}" of key "${key}, expected value to be Array.`);
      }
      return prev + values.reduce((prevBytes, current) => prevBytes + encoder(current), "");
    } else {
      const encoder = encoders2[valueToEncode];
      return prev + encoder(value[key]);
    }
  }, "");
};
var schemaDecoder = (decoders2) => (schema) => (value) => {
  const keys = Object.keys(schema);
  return keys.reduce((prev, key) => {
    const valueToEncode = schema[key];
    if (Array.isArray(valueToEncode)) {
      const decoder = decoders2[valueToEncode[0]];
      const decoded = [];
      const lastLength = value.length();
      while (value.length() > 0) {
        decoded.push(decoder(value));
        if (lastLength === value.length()) {
          throw new OperationDecodingError("Unable to decode value");
        }
      }
      return Object.assign(Object.assign({}, prev), { [key]: decoded });
    } else {
      const decoder = decoders2[valueToEncode];
      const result = decoder(value);
      if (typeof result !== "undefined") {
        return Object.assign(Object.assign({}, prev), { [key]: result });
      } else {
        return Object.assign({}, prev);
      }
    }
  }, {});
};
var decoders = {
  [CODEC.SECRET]: (val) => toHexString(val.consume(20)),
  [CODEC.RAW]: (val) => toHexString(val.consume(32)),
  [CODEC.TZ1]: tz1Decoder,
  [CODEC.BRANCH]: branchDecoder,
  [CODEC.ZARITH]: zarithDecoder,
  [CODEC.PUBLIC_KEY]: publicKeyDecoder,
  [CODEC.PKH]: pkhDecoder,
  [CODEC.DELEGATE]: delegateDecoder,
  [CODEC.INT32]: int32Decoder,
  [CODEC.SCRIPT]: scriptDecoder,
  [CODEC.BALLOT_STATEMENT]: ballotDecoder,
  [CODEC.PROPOSAL]: proposalDecoder,
  [CODEC.PROPOSAL_ARR]: proposalsDecoder,
  [CODEC.PARAMETERS]: parametersDecoder,
  [CODEC.ADDRESS]: addressDecoder,
  [CODEC.SMART_ROLLUP_ADDRESS]: smartRollupAddressDecoder,
  [CODEC.SMART_CONTRACT_ADDRESS]: smartContractAddressDecoder,
  [CODEC.SMART_ROLLUP_COMMITMENT_HASH]: smartRollupCommitmentHashDecoder,
  [CODEC.VALUE]: valueParameterDecoder,
  [CODEC.INT16]: int16Decoder,
  [CODEC.BLOCK_PAYLOAD_HASH]: blockPayloadHashDecoder,
  [CODEC.ENTRYPOINT]: entrypointNameDecoder,
  [CODEC.TX_ROLLUP_ORIGINATION_PARAM]: txRollupOriginationParamDecoder,
  [CODEC.TX_ROLLUP_ID]: txRollupIdDecoder,
  [CODEC.TX_ROLLUP_BATCH_CONTENT]: txRollupBatchContentDecoder,
  [CODEC.BURN_LIMIT]: burnLimitDecoder,
  [CODEC.DEPOSITS_LIMIT]: depositsLimitDecoder,
  [CODEC.PVM_KIND]: pvmKindDecoder,
  [CODEC.PADDED_BYTES]: paddedBytesDecoder,
  [CODEC.SMART_ROLLUP_MESSAGE]: smartRollupMessageDecoder
};
decoders[CODEC.OPERATION] = operationDecoder(decoders);
decoders[CODEC.OP_ACTIVATE_ACCOUNT] = (val) => schemaDecoder(decoders)(ActivationSchema)(val);
decoders[CODEC.OP_FAILING_NOOP] = (val) => schemaDecoder(decoders)(FailingNoopSchema)(val);
decoders[CODEC.OP_DELEGATION] = (val) => schemaDecoder(decoders)(DelegationSchema)(val);
decoders[CODEC.OP_TRANSACTION] = (val) => schemaDecoder(decoders)(TransactionSchema)(val);
decoders[CODEC.OP_ORIGINATION] = (val) => schemaDecoder(decoders)(OriginationSchema)(val);
decoders[CODEC.OP_BALLOT] = (val) => schemaDecoder(decoders)(BallotSchema)(val);
decoders[CODEC.OP_ENDORSEMENT] = (val) => schemaDecoder(decoders)(EndorsementSchema)(val);
decoders[CODEC.OP_SEED_NONCE_REVELATION] = (val) => schemaDecoder(decoders)(SeedNonceRevelationSchema)(val);
decoders[CODEC.OP_PROPOSALS] = (val) => schemaDecoder(decoders)(ProposalsSchema)(val);
decoders[CODEC.OP_REVEAL] = (val) => schemaDecoder(decoders)(RevealSchema)(val);
decoders[CODEC.OP_REGISTER_GLOBAL_CONSTANT] = (val) => schemaDecoder(decoders)(RegisterGlobalConstantSchema)(val);
decoders[CODEC.OP_TRANSFER_TICKET] = (val) => schemaDecoder(decoders)(TransferTicketSchema)(val);
decoders[CODEC.OP_TX_ROLLUP_ORIGINATION] = (val) => schemaDecoder(decoders)(TxRollupOriginationSchema)(val);
decoders[CODEC.OP_TX_ROLLUP_SUBMIT_BATCH] = (val) => schemaDecoder(decoders)(TxRollupSubmitBatchSchema)(val);
decoders[CODEC.OP_INCREASE_PAID_STORAGE] = (val) => schemaDecoder(decoders)(IncreasePaidStorageSchema)(val);
decoders[CODEC.OP_UPDATE_CONSENSUS_KEY] = (val) => schemaDecoder(decoders)(UpdateConsensusKeySchema)(val);
decoders[CODEC.OP_DRAIN_DELEGATE] = (val) => schemaDecoder(decoders)(DrainDelegateSchema)(val);
decoders[CODEC.OP_SMART_ROLLUP_ORIGINATE] = (val) => schemaDecoder(decoders)(SmartRollupOriginateSchema)(val);
decoders[CODEC.OP_SMART_ROLLUP_ADD_MESSAGES] = (val) => schemaDecoder(decoders)(SmartRollupAddMessagesSchema)(val);
decoders[CODEC.OP_SMART_ROLLUP_EXECUTE_OUTBOX_MESSAGE] = (val) => schemaDecoder(decoders)(SmartRollupExecuteOutboxMessageSchema)(val);
decoders[CODEC.MANAGER] = schemaDecoder(decoders)(ManagerOperationSchema);
decoders[CODEC.OP_SET_DEPOSITS_LIMIT] = (val) => schemaDecoder(decoders)(SetDepositsLimitSchema)(val);
var encoders = {
  [CODEC.SECRET]: (val) => val,
  [CODEC.RAW]: (val) => val,
  [CODEC.TZ1]: tz1Encoder,
  [CODEC.BRANCH]: branchEncoder,
  [CODEC.ZARITH]: zarithEncoder,
  [CODEC.PUBLIC_KEY]: publicKeyEncoder,
  [CODEC.PKH]: pkhEncoder,
  [CODEC.DELEGATE]: delegateEncoder,
  [CODEC.SCRIPT]: scriptEncoder,
  [CODEC.BALLOT_STATEMENT]: ballotEncoder,
  [CODEC.PROPOSAL]: proposalEncoder,
  [CODEC.PROPOSAL_ARR]: proposalsEncoder,
  [CODEC.INT32]: int32Encoder,
  [CODEC.PARAMETERS]: parametersEncoder,
  [CODEC.ADDRESS]: addressEncoder,
  [CODEC.SMART_ROLLUP_ADDRESS]: smartRollupAddressEncoder,
  [CODEC.SMART_CONTRACT_ADDRESS]: smartContractAddressEncoder,
  [CODEC.SMART_ROLLUP_COMMITMENT_HASH]: smartRollupCommitmentHashEncoder,
  [CODEC.VALUE]: valueParameterEncoder,
  [CODEC.INT16]: int16Encoder,
  [CODEC.BLOCK_PAYLOAD_HASH]: blockPayloadHashEncoder,
  [CODEC.ENTRYPOINT]: entrypointNameEncoder,
  [CODEC.TX_ROLLUP_ORIGINATION_PARAM]: txRollupOriginationParamEncoder,
  [CODEC.TX_ROLLUP_ID]: txRollupIdEncoder,
  [CODEC.TX_ROLLUP_BATCH_CONTENT]: txRollupBatchContentEncoder,
  [CODEC.BURN_LIMIT]: burnLimitEncoder,
  [CODEC.DEPOSITS_LIMIT]: depositsLimitEncoder,
  [CODEC.PVM_KIND]: pvmKindEncoder,
  [CODEC.PADDED_BYTES]: paddedBytesEncoder,
  [CODEC.SMART_ROLLUP_MESSAGE]: smartRollupMessageEncoder
};
encoders[CODEC.OPERATION] = operationEncoder(encoders);
encoders[CODEC.OP_ACTIVATE_ACCOUNT] = (val) => schemaEncoder(encoders)(ActivationSchema)(val);
encoders[CODEC.OP_DELEGATION] = (val) => schemaEncoder(encoders)(DelegationSchema)(val);
encoders[CODEC.OP_TRANSACTION] = (val) => schemaEncoder(encoders)(TransactionSchema)(val);
encoders[CODEC.OP_ORIGINATION] = (val) => schemaEncoder(encoders)(OriginationSchema)(val);
encoders[CODEC.OP_BALLOT] = (val) => schemaEncoder(encoders)(BallotSchema)(val);
encoders[CODEC.OP_ENDORSEMENT] = (val) => schemaEncoder(encoders)(EndorsementSchema)(val);
encoders[CODEC.OP_SEED_NONCE_REVELATION] = (val) => schemaEncoder(encoders)(SeedNonceRevelationSchema)(val);
encoders[CODEC.OP_PROPOSALS] = (val) => schemaEncoder(encoders)(ProposalsSchema)(val);
encoders[CODEC.OP_REVEAL] = (val) => schemaEncoder(encoders)(RevealSchema)(val);
encoders[CODEC.OP_REGISTER_GLOBAL_CONSTANT] = (val) => schemaEncoder(encoders)(RegisterGlobalConstantSchema)(val);
encoders[CODEC.OP_TRANSFER_TICKET] = (val) => schemaEncoder(encoders)(TransferTicketSchema)(val);
encoders[CODEC.OP_TX_ROLLUP_ORIGINATION] = (val) => schemaEncoder(encoders)(TxRollupOriginationSchema)(val);
encoders[CODEC.OP_TX_ROLLUP_SUBMIT_BATCH] = (val) => schemaEncoder(encoders)(TxRollupSubmitBatchSchema)(val);
encoders[CODEC.OP_INCREASE_PAID_STORAGE] = (val) => schemaEncoder(encoders)(IncreasePaidStorageSchema)(val);
encoders[CODEC.OP_UPDATE_CONSENSUS_KEY] = (val) => schemaEncoder(encoders)(UpdateConsensusKeySchema)(val);
encoders[CODEC.OP_DRAIN_DELEGATE] = (val) => schemaEncoder(encoders)(DrainDelegateSchema)(val);
encoders[CODEC.OP_SMART_ROLLUP_ORIGINATE] = (val) => schemaEncoder(encoders)(SmartRollupOriginateSchema)(val);
encoders[CODEC.OP_SMART_ROLLUP_ADD_MESSAGES] = (val) => schemaEncoder(encoders)(SmartRollupAddMessagesSchema)(val);
encoders[CODEC.OP_SMART_ROLLUP_EXECUTE_OUTBOX_MESSAGE] = (val) => schemaEncoder(encoders)(SmartRollupExecuteOutboxMessageSchema)(val);
encoders[CODEC.MANAGER] = schemaEncoder(encoders)(ManagerOperationSchema);
encoders[CODEC.OP_SET_DEPOSITS_LIMIT] = (val) => schemaEncoder(encoders)(SetDepositsLimitSchema)(val);
encoders[CODEC.OP_FAILING_NOOP] = (val) => schemaEncoder(encoders)(FailingNoopSchema)(val);
var OperationKindMapping = {
  activate_account: ActivationSchema,
  reveal: RevealSchema,
  delegation: DelegationSchema,
  transaction: TransactionSchema,
  origination: OriginationSchema,
  ballot: BallotSchema,
  endorsement: EndorsementSchema,
  seed_nonce_revelation: SeedNonceRevelationSchema,
  proposals: ProposalsSchema,
  register_global_constant: RegisterGlobalConstantSchema,
  transfer_ticket: TransferTicketSchema,
  tx_rollup_origination: TxRollupOriginationSchema,
  tx_rollup_submit_batch: TxRollupSubmitBatchSchema,
  increase_paid_storage: IncreasePaidStorageSchema,
  update_consensus_key: UpdateConsensusKeySchema,
  drain_delegate: DrainDelegateSchema,
  set_deposits_limit: SetDepositsLimitSchema,
  smart_rollup_originate: SmartRollupOriginateSchema,
  smart_rollup_add_messages: SmartRollupAddMessagesSchema,
  smart_rollup_execute_outbox_message: SmartRollupExecuteOutboxMessageSchema,
  failing_noop: FailingNoopSchema
};
var getArrayDifference = (arr1, arr2) => {
  return arr2.filter((x) => !arr1.includes(x));
};
var deleteArrayElementByValue = (array, item) => {
  return array.filter((e) => e !== item);
};
var validateOperationKind = (opKind) => {
  const opKindList = Object.keys(OperationKindMapping);
  return opKindList.includes(opKind);
};
var validateMissingProperty = (operationContent) => {
  const kind = operationContent.kind;
  const keys = Object.keys(operationContent);
  const cleanKeys = deleteArrayElementByValue(keys, "kind");
  const schemaKeys = Object.keys(OperationKindMapping[kind]);
  return getArrayDifference(cleanKeys, schemaKeys);
};
var ProtocolsHash;
(function(ProtocolsHash2) {
  ProtocolsHash2["Pt24m4xi"] = "Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd";
  ProtocolsHash2["PsBABY5H"] = "PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU";
  ProtocolsHash2["PsBabyM1"] = "PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS";
  ProtocolsHash2["PsCARTHA"] = "PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb";
  ProtocolsHash2["PsDELPH1"] = "PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo";
  ProtocolsHash2["PtEdo2Zk"] = "PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA";
  ProtocolsHash2["PsFLorena"] = "PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i";
  ProtocolsHash2["PtGRANADs"] = "PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV";
  ProtocolsHash2["PtHangz2"] = "PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx";
  ProtocolsHash2["Psithaca2"] = "Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A";
  ProtocolsHash2["PtJakart2"] = "PtJakart2xVj7pYXJBXrqHgd82rdkLey5ZeeGwDgPp9rhQUbSqY";
  ProtocolsHash2["PtKathman"] = "PtKathmankSpLLDALzWw7CGD2j2MtyveTwboEYokqUCP4a1LxMg";
  ProtocolsHash2["PtLimaPtL"] = "PtLimaPtLMwfNinJi9rCfDPWea8dFgTZ1MeJ9f1m2SRic6ayiwW";
  ProtocolsHash2["PtMumbaii"] = "PtMumbaiiFFEGbew1rRjzSPyzRbA51Tm3RVZL5suHPxSZYDhCEc";
  ProtocolsHash2["PtMumbai2"] = "PtMumbai2TmsJHNGRkD8v8YDbtao7BLUC3wjASn1inAKLFCjaH1";
  ProtocolsHash2["PtNairobi"] = "PtNairobiyssHuh87hEhfVBGCVrK3WnS8Z2FT4ymB5tAa4r1nQf";
  ProtocolsHash2["ProtoALpha"] = "ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK";
})(ProtocolsHash || (ProtocolsHash = {}));
var PROTOCOL_CURRENT = ProtocolsHash.PtMumbai2;
function getCodec(codec, _proto) {
  return {
    encoder: encoders[codec],
    decoder: (hex) => {
      const consumer = Uint8ArrayConsumer.fromHexString(hex);
      return decoders[codec](consumer);
    }
  };
}
var LocalForger = class {
  constructor(protocolHash = PROTOCOL_CURRENT) {
    this.protocolHash = protocolHash;
    this.codec = getCodec(CODEC.MANAGER, this.protocolHash);
  }
  forge(params) {
    const branchValidation = validateBlock(params.branch);
    if (branchValidation !== ValidationResult.VALID) {
      throw new InvalidBlockHashError(params.branch, invalidDetail(branchValidation));
    }
    for (const content of params.contents) {
      if (!validateOperationKind(content.kind)) {
        throw new InvalidOperationKindError(content.kind);
      }
      const diff = validateMissingProperty(content);
      if (diff.length === 1) {
        if (content.kind === "delegation" && diff[0] === "delegate") {
          continue;
        } else if (content.kind === "origination" && diff[0] === "delegate") {
          continue;
        } else if (content.kind === "transaction" && diff[0] === "parameters") {
          continue;
        } else if (content.kind === "set_deposits_limit" && diff[0] === "limit") {
          continue;
        } else if (content.kind === "tx_rollup_submit_batch" && diff[0] === "burn_limit") {
          continue;
        } else {
          throw new InvalidOperationSchemaError(content, `missing properties "${diff.join(", ")}"`);
        }
      } else if (diff.length > 1) {
        throw new InvalidOperationSchemaError(content, `missing properties "${diff.join(", ")}"`);
      }
    }
    const forged = this.codec.encoder(params).toLowerCase();
    return Promise.resolve(forged);
  }
  parse(hex) {
    return Promise.resolve(this.codec.decoder(hex));
  }
};
var localForger = new LocalForger();

// node_modules/@taquito/taquito/dist/taquito.es6.js
function __rest2(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter4(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function formatErrorMessage(error, stringToReplace) {
  const body = JSON.parse(error.body);
  if (body[0] && body[0].kind && body[0].msg) {
    const newBody = JSON.stringify({
      kind: body[0].kind,
      id: body[0].id,
      msg: body[0].msg.replace(stringToReplace, "")
    });
    return new HttpResponseError(`Http error response: (${error.status}) ${newBody}`, error.status, error.statusText, newBody, error.url);
  } else {
    return error;
  }
}
var RpcInjector = class {
  constructor(context2) {
    this.context = context2;
  }
  inject(signedOperationBytes) {
    return __awaiter4(this, void 0, void 0, function* () {
      let hash2;
      try {
        hash2 = yield this.context.rpc.injectOperation(signedOperationBytes);
      } catch (error) {
        const stringToStrip = ". You may want to use --replace to provide adequate fee and replace it";
        if (error instanceof HttpResponseError && error.message.includes(stringToStrip)) {
          throw formatErrorMessage(error, stringToStrip);
        } else {
          throw error;
        }
      }
      return hash2;
    });
  }
};
var UnconfiguredSignerError = class extends TezosToolkitConfigError {
  constructor() {
    super();
    this.name = "UnconfiguredSignerError";
    this.message = "No signer has been configured. Please configure one by calling setProvider({signer}) on your TezosToolkit instance.";
  }
};
var NoopSigner = class {
  publicKey() {
    return __awaiter4(this, void 0, void 0, function* () {
      throw new UnconfiguredSignerError();
    });
  }
  publicKeyHash() {
    return __awaiter4(this, void 0, void 0, function* () {
      throw new UnconfiguredSignerError();
    });
  }
  secretKey() {
    return __awaiter4(this, void 0, void 0, function* () {
      throw new UnconfiguredSignerError();
    });
  }
  sign(_bytes, _watermark) {
    return __awaiter4(this, void 0, void 0, function* () {
      throw new UnconfiguredSignerError();
    });
  }
};
function createObservableFromSubscription(sub) {
  return new Observable((subscriber) => {
    sub.on("data", (data) => {
      subscriber.next(data);
    });
    sub.on("error", (error) => {
      subscriber.error(error);
    });
    sub.on("close", () => {
      subscriber.complete();
    });
    return () => {
      sub.close();
    };
  });
}
var DEFAULT_GAS_LIMIT;
(function(DEFAULT_GAS_LIMIT2) {
  DEFAULT_GAS_LIMIT2[DEFAULT_GAS_LIMIT2["DELEGATION"] = 10600] = "DELEGATION";
  DEFAULT_GAS_LIMIT2[DEFAULT_GAS_LIMIT2["ORIGINATION"] = 10600] = "ORIGINATION";
  DEFAULT_GAS_LIMIT2[DEFAULT_GAS_LIMIT2["TRANSFER"] = 10600] = "TRANSFER";
  DEFAULT_GAS_LIMIT2[DEFAULT_GAS_LIMIT2["REVEAL_TZ1"] = 1e3] = "REVEAL_TZ1";
  DEFAULT_GAS_LIMIT2[DEFAULT_GAS_LIMIT2["REVEAL_TZ2"] = 1e3] = "REVEAL_TZ2";
  DEFAULT_GAS_LIMIT2[DEFAULT_GAS_LIMIT2["REVEAL_TZ3"] = 2e3] = "REVEAL_TZ3";
  DEFAULT_GAS_LIMIT2[DEFAULT_GAS_LIMIT2["REVEAL_TZ4"] = 2e3] = "REVEAL_TZ4";
})(DEFAULT_GAS_LIMIT || (DEFAULT_GAS_LIMIT = {}));
var DEFAULT_FEE;
(function(DEFAULT_FEE2) {
  DEFAULT_FEE2[DEFAULT_FEE2["DELEGATION"] = 1257] = "DELEGATION";
  DEFAULT_FEE2[DEFAULT_FEE2["ORIGINATION"] = 1e4] = "ORIGINATION";
  DEFAULT_FEE2[DEFAULT_FEE2["TRANSFER"] = 1e4] = "TRANSFER";
  DEFAULT_FEE2[DEFAULT_FEE2["REVEAL"] = 374] = "REVEAL";
})(DEFAULT_FEE || (DEFAULT_FEE = {}));
var DEFAULT_STORAGE_LIMIT;
(function(DEFAULT_STORAGE_LIMIT2) {
  DEFAULT_STORAGE_LIMIT2[DEFAULT_STORAGE_LIMIT2["DELEGATION"] = 0] = "DELEGATION";
  DEFAULT_STORAGE_LIMIT2[DEFAULT_STORAGE_LIMIT2["ORIGINATION"] = 257] = "ORIGINATION";
  DEFAULT_STORAGE_LIMIT2[DEFAULT_STORAGE_LIMIT2["TRANSFER"] = 257] = "TRANSFER";
  DEFAULT_STORAGE_LIMIT2[DEFAULT_STORAGE_LIMIT2["REVEAL"] = 0] = "REVEAL";
})(DEFAULT_STORAGE_LIMIT || (DEFAULT_STORAGE_LIMIT = {}));
var COST_PER_BYTE = 250;
var Protocols;
(function(Protocols2) {
  Protocols2["Pt24m4xi"] = "Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd";
  Protocols2["PsBABY5H"] = "PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU";
  Protocols2["PsBabyM1"] = "PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS";
  Protocols2["PsCARTHA"] = "PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb";
  Protocols2["PsDELPH1"] = "PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo";
  Protocols2["PtEdo2Zk"] = "PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA";
  Protocols2["PsFLorena"] = "PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i";
  Protocols2["PtGRANADs"] = "PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV";
  Protocols2["PtHangz2"] = "PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx";
  Protocols2["PsiThaCa"] = "PsiThaCaT47Zboaw71QWScM8sXeMM7bbQFncK9FLqYc6EKdpjVP";
  Protocols2["Psithaca2"] = "Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A";
  Protocols2["PtJakart2"] = "PtJakart2xVj7pYXJBXrqHgd82rdkLey5ZeeGwDgPp9rhQUbSqY";
  Protocols2["PtKathman"] = "PtKathmankSpLLDALzWw7CGD2j2MtyveTwboEYokqUCP4a1LxMg";
  Protocols2["PtLimaPtL"] = "PtLimaPtLMwfNinJi9rCfDPWea8dFgTZ1MeJ9f1m2SRic6ayiwW";
  Protocols2["PtMumbaii"] = "PtMumbaiiFFEGbew1rRjzSPyzRbA51Tm3RVZL5suHPxSZYDhCEc";
  Protocols2["PtMumbai2"] = "PtMumbai2TmsJHNGRkD8v8YDbtao7BLUC3wjASn1inAKLFCjaH1";
  Protocols2["PtNairobi"] = "PtNairobiyssHuh87hEhfVBGCVrK3WnS8Z2FT4ymB5tAa4r1nQf";
  Protocols2["ProtoALpha"] = "ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK";
})(Protocols || (Protocols = {}));
var protocols = {
  "004": [Protocols.Pt24m4xi],
  "005": [Protocols.PsBABY5H, Protocols.PsBabyM1],
  "006": [Protocols.PsCARTHA],
  "007": [Protocols.PsDELPH1],
  "008": [Protocols.PtEdo2Zk],
  "009": [Protocols.PsFLorena],
  "010": [Protocols.PtGRANADs],
  "011": [Protocols.PtHangz2],
  "012": [Protocols.PsiThaCa, Protocols.Psithaca2],
  "013": [Protocols.PtJakart2],
  "014": [Protocols.PtKathman],
  "015": [Protocols.PtLimaPtL],
  "016": [Protocols.PtMumbai2],
  "017": [Protocols.PtNairobi],
  "018": [Protocols.ProtoALpha]
};
var ChainIds;
(function(ChainIds2) {
  ChainIds2["MAINNET"] = "NetXdQprcVkpaWU";
  ChainIds2["CARTHAGENET"] = "NetXjD3HPJJjmcd";
  ChainIds2["DELPHINET"] = "NetXm8tYqnMWky1";
  ChainIds2["EDONET"] = "NetXSgo1ZT2DRUG";
  ChainIds2["FLORENCENET"] = "NetXxkAx4woPLyu";
  ChainIds2["GRANADANET"] = "NetXz969SFaFn8k";
  ChainIds2["HANGZHOUNET"] = "NetXZSsxBpMQeAT";
  ChainIds2["ITHACANET"] = "NetXbhmtAbMukLc";
  ChainIds2["ITHACANET2"] = "NetXnHfVqm9iesp";
  ChainIds2["JAKARTANET2"] = "NetXLH1uAxK7CCh";
  ChainIds2["KATHMANDUNET"] = "NetXazhm4yetmff";
  ChainIds2["LIMANET"] = "NetXizpkH94bocH";
  ChainIds2["MUMBAINET"] = "NetXQw6nWSnrJ5t";
  ChainIds2["MUMBAINET2"] = "NetXgbcrNtXD2yA";
  ChainIds2["NAIROBINET"] = "NetXyuzvDo2Ugzb";
})(ChainIds || (ChainIds = {}));
var getRevealGasLimit = (address) => Math.round(getRevealGasLimitInternal(address) * 11 / 10);
var getRevealGasLimitInternal = (address) => {
  switch (address.substring(0, 3)) {
    case "tz1":
      return DEFAULT_GAS_LIMIT.REVEAL_TZ1;
    case "tz2":
      return DEFAULT_GAS_LIMIT.REVEAL_TZ2;
    case "tz3":
      return DEFAULT_GAS_LIMIT.REVEAL_TZ3;
    case "tz4":
      return DEFAULT_GAS_LIMIT.REVEAL_TZ4;
    default:
      throw new Error(`Cannot estimate reveal gas limit for ${address}`);
  }
};
var InvalidParameterError = class extends ParameterValidationError {
  constructor(smartContractMethodName, sigs, invalidParams) {
    super();
    this.smartContractMethodName = smartContractMethodName;
    this.sigs = sigs;
    this.invalidParams = invalidParams;
    this.name = "InvalidParameterError";
    this.message = `${smartContractMethodName} Received ${invalidParams.length} arguments while expecting one of the following signatures (${JSON.stringify(sigs)})`;
  }
};
var InvalidDelegationSource = class extends ParameterValidationError {
  constructor(source) {
    super();
    this.source = source;
    this.name = `InvalidDelegationSource`;
    this.message = `Since Babylon delegation source can no longer be a contract address ${source}. Please use the smart contract abstraction to set your delegate.`;
  }
};
var InvalidCodeParameter = class extends ParameterValidationError {
  constructor(message, data) {
    super();
    this.message = message;
    this.data = data;
    this.name = "InvalidCodeParameter";
  }
};
var InvalidInitParameter = class extends ParameterValidationError {
  constructor(message, data) {
    super();
    this.message = message;
    this.data = data;
    this.name = "InvalidInitParameter";
  }
};
var ViewSimulationError = class extends RpcError {
  constructor(message, viewName, failWith, cause) {
    super();
    this.message = message;
    this.viewName = viewName;
    this.failWith = failWith;
    this.cause = cause;
    this.name = "ViewSimulationError";
  }
};
var validateAndExtractFailwith = (error) => {
  if (isJsonString(error.body)) {
    const parsedError = JSON.parse(error.body);
    if (Array.isArray(parsedError) && "with" in parsedError[parsedError.length - 1]) {
      return parsedError[parsedError.length - 1].with;
    }
  }
};
var isJsonString = (str) => {
  try {
    JSON.parse(str);
  } catch (e) {
    return false;
  }
  return true;
};
var InvalidViewSimulationContext = class extends ParameterValidationError {
  constructor(info) {
    super();
    this.info = info;
    this.name = "InvalidViewSimulationContext";
    this.message = `${info} Please configure the context of the view execution in the executeView method.`;
  }
};
var RevealOperationError = class extends RpcError {
  constructor(message) {
    super();
    this.message = message;
    this.name = "RevealOperationError";
  }
};
var OriginationParameterError = class extends ParameterValidationError {
  constructor(message) {
    super();
    this.message = message;
    this.name;
  }
};
var InvalidBalanceError = class extends ParameterValidationError {
  constructor(message) {
    super();
    this.message = message;
    this.name = "InvalidBalanceError";
  }
};
var createActivationOperation = ({ pkh, secret }) => __awaiter4(void 0, void 0, void 0, function* () {
  return {
    kind: OpKind.ACTIVATION,
    pkh,
    secret
  };
});
var createOriginationOperation = ({ code: code2, init, balance = "0", delegate, storage: storage2, fee = DEFAULT_FEE.ORIGINATION, gasLimit = DEFAULT_GAS_LIMIT.ORIGINATION, storageLimit = DEFAULT_STORAGE_LIMIT.ORIGINATION, mutez = false }) => __awaiter4(void 0, void 0, void 0, function* () {
  if (storage2 !== void 0 && init !== void 0) {
    throw new OriginationParameterError("Storage and Init cannot be set a the same time. Please either use storage or init but not both.");
  }
  if (!Array.isArray(code2)) {
    throw new InvalidCodeParameter("Wrong code parameter type, expected an array", code2);
  }
  let contractStorage;
  if (storage2 !== void 0) {
    const storageType = code2.find((p) => "prim" in p && p.prim === "storage");
    if ((storageType === null || storageType === void 0 ? void 0 : storageType.args) === void 0) {
      throw new InvalidCodeParameter("The storage section is missing from the script", code2);
    }
    const schema = new Schema(storageType.args[0]);
    contractStorage = schema.Encode(storage2);
  } else if (init !== void 0 && typeof init === "object") {
    contractStorage = init;
  } else {
    throw new InvalidInitParameter("Wrong init parameter type, expected JSON Michelson", init);
  }
  const script = {
    code: code2,
    storage: contractStorage
  };
  if (isNaN(Number(balance))) {
    throw new InvalidBalanceError(`Invalid Balance "${balance}", cannot be converted to a number`);
  }
  const operation = {
    kind: OpKind.ORIGINATION,
    fee,
    gas_limit: gasLimit,
    storage_limit: storageLimit,
    balance: mutez ? balance.toString() : format("tz", "mutez", balance).toString(),
    script
  };
  if (delegate) {
    operation.delegate = delegate;
  }
  return operation;
});
var createTransferOperation = ({ to, amount, parameter, fee = DEFAULT_FEE.TRANSFER, gasLimit = DEFAULT_GAS_LIMIT.TRANSFER, storageLimit = DEFAULT_STORAGE_LIMIT.TRANSFER, mutez = false }) => __awaiter4(void 0, void 0, void 0, function* () {
  const operation = {
    kind: OpKind.TRANSACTION,
    fee,
    gas_limit: gasLimit,
    storage_limit: storageLimit,
    amount: mutez ? amount.toString() : format("tz", "mutez", amount).toString(),
    destination: to,
    parameters: parameter
  };
  return operation;
});
var createSetDelegateOperation = ({ delegate, source, fee = DEFAULT_FEE.DELEGATION, gasLimit = DEFAULT_GAS_LIMIT.DELEGATION, storageLimit = DEFAULT_STORAGE_LIMIT.DELEGATION }) => __awaiter4(void 0, void 0, void 0, function* () {
  const operation = {
    kind: OpKind.DELEGATION,
    source,
    fee,
    gas_limit: gasLimit,
    storage_limit: storageLimit,
    delegate
  };
  return operation;
});
var createRegisterDelegateOperation = ({ fee = DEFAULT_FEE.DELEGATION, gasLimit = DEFAULT_GAS_LIMIT.DELEGATION, storageLimit = DEFAULT_STORAGE_LIMIT.DELEGATION }, source) => __awaiter4(void 0, void 0, void 0, function* () {
  return {
    kind: OpKind.DELEGATION,
    fee,
    gas_limit: gasLimit,
    storage_limit: storageLimit,
    delegate: source
  };
});
var createRevealOperation = ({ fee = DEFAULT_FEE.REVEAL, gasLimit = void 0, storageLimit = DEFAULT_STORAGE_LIMIT.REVEAL }, source, publicKey) => __awaiter4(void 0, void 0, void 0, function* () {
  return {
    kind: OpKind.REVEAL,
    fee,
    public_key: publicKey,
    source,
    gas_limit: gasLimit !== null && gasLimit !== void 0 ? gasLimit : getRevealGasLimit(source),
    storage_limit: storageLimit
  };
});
var createRegisterGlobalConstantOperation = ({ value, source, fee, gasLimit, storageLimit }) => __awaiter4(void 0, void 0, void 0, function* () {
  return {
    kind: OpKind.REGISTER_GLOBAL_CONSTANT,
    value,
    fee,
    gas_limit: gasLimit,
    storage_limit: storageLimit,
    source
  };
});
var createTransferTicketOperation = ({ ticketContents, ticketTy, ticketTicketer, ticketAmount, destination, entrypoint, source, fee, gasLimit, storageLimit }) => __awaiter4(void 0, void 0, void 0, function* () {
  return {
    kind: OpKind.TRANSFER_TICKET,
    fee,
    gas_limit: gasLimit,
    storage_limit: storageLimit,
    source,
    ticket_contents: ticketContents,
    ticket_ty: ticketTy,
    ticket_ticketer: ticketTicketer,
    ticket_amount: ticketAmount,
    destination,
    entrypoint
  };
});
var createIncreasePaidStorageOperation = ({ source, fee, gasLimit, storageLimit, amount, destination }) => __awaiter4(void 0, void 0, void 0, function* () {
  return {
    kind: OpKind.INCREASE_PAID_STORAGE,
    source,
    fee,
    gas_limit: gasLimit,
    storage_limit: storageLimit,
    amount,
    destination
  };
});
var createDrainDelegateOperation = ({ consensus_key, delegate, destination }) => __awaiter4(void 0, void 0, void 0, function* () {
  return {
    kind: OpKind.DRAIN_DELEGATE,
    consensus_key,
    delegate,
    destination
  };
});
var createBallotOperation = ({ source, proposal, ballot }) => __awaiter4(void 0, void 0, void 0, function* () {
  return {
    kind: OpKind.BALLOT,
    source,
    proposal,
    ballot
  };
});
var createProposalsOperation = ({ source, proposals }) => __awaiter4(void 0, void 0, void 0, function* () {
  return {
    kind: OpKind.PROPOSALS,
    source,
    proposals
  };
});
var createUpdateConsensusKeyOperation = ({ source, fee, gasLimit, storageLimit, pk }) => __awaiter4(void 0, void 0, void 0, function* () {
  return {
    kind: OpKind.UPDATE_CONSENSUS_KEY,
    source,
    fee,
    gas_limit: gasLimit,
    storage_limit: storageLimit,
    pk
  };
});
var createSmartRollupAddMessagesOperation = ({ source, fee, gasLimit, storageLimit, message }) => __awaiter4(void 0, void 0, void 0, function* () {
  return {
    kind: OpKind.SMART_ROLLUP_ADD_MESSAGES,
    source,
    fee,
    gas_limit: gasLimit,
    storage_limit: storageLimit,
    message
  };
});
var createSmartRollupOriginateOperation = ({ source, fee, gasLimit, storageLimit, pvmKind, kernel, originationProof, parametersType }) => __awaiter4(void 0, void 0, void 0, function* () {
  return {
    kind: OpKind.SMART_ROLLUP_ORIGINATE,
    source,
    fee,
    gas_limit: gasLimit,
    storage_limit: storageLimit,
    pvm_kind: pvmKind,
    kernel,
    origination_proof: originationProof,
    parameters_ty: parametersType
  };
});
var attachKind = (op, kind) => {
  return Object.assign(Object.assign({}, op), { kind });
};
var findWithKind = (arr, kind) => {
  if (Array.isArray(arr)) {
    const found = arr.find((op) => op.kind === kind);
    if (found && isKind(found, kind)) {
      return found;
    }
  }
};
var isKind = (op, kind) => {
  return op.kind === kind;
};
var isOpWithFee = (op) => {
  return [
    "transaction",
    "delegation",
    "origination",
    "reveal",
    "register_global_constant",
    "increase_paid_storage",
    "tx_rollup_origination",
    "tx_rollup_submit_batch",
    "transfer_ticket",
    "update_consensus_key",
    "smart_rollup_add_messages",
    "smart_rollup_originate"
  ].indexOf(op.kind) !== -1;
};
var isOpRequireReveal = (op) => {
  return [
    "transaction",
    "delegation",
    "origination",
    "register_global_constant",
    "increase_paid_storage",
    "tx_rollup_origination",
    "tx_rollup_submit_batch",
    "transfer_ticket",
    "update_consensus_key",
    "smart_rollup_add_messages",
    "smart_rollup_originate"
  ].indexOf(op.kind) !== -1;
};
var hasMetadata = (op) => {
  return "metadata" in op;
};
var hasMetadataWithResult = (op) => {
  return hasMetadata(op) && "operation_result" in op.metadata;
};
var hasMetadataWithInternalOperationResult = (op) => {
  return hasMetadata(op) && "internal_operation_results" in op.metadata;
};
var isErrorWithMessage = (error) => {
  return "with" in error;
};
var TezosOperationError = class extends RpcError {
  constructor(errors, errorDetails) {
    super();
    this.errors = errors;
    this.errorDetails = errorDetails;
    this.name = "TezosOperationError";
    const lastError = errors[errors.length - 1];
    this.id = lastError.id;
    this.kind = lastError.kind;
    this.message = `(${this.kind}) ${this.id}`;
    if (isErrorWithMessage(lastError)) {
      if (lastError.with.string) {
        this.message = lastError.with.string;
      } else if (lastError.with.int) {
        this.message = lastError.with.int;
      } else {
        this.message = JSON.stringify(lastError.with);
      }
    }
  }
};
var TezosPreapplyFailureError = class extends Error {
  constructor(result) {
    super();
    this.result = result;
    this.name = "TezosPreapplyFailureError";
    this.message = "Preapply returned an unexpected result";
  }
};
var flattenOperationResult = (response) => {
  const results = Array.isArray(response) ? response : [response];
  const returnedResults = [];
  for (let i = 0; i < results.length; i++) {
    for (let j = 0; j < results[i].contents.length; j++) {
      const content = results[i].contents[j];
      if (hasMetadataWithResult(content) && "fee" in content) {
        returnedResults.push(Object.assign({ fee: content.fee }, content.metadata.operation_result));
        if (Array.isArray(content.metadata.internal_operation_results)) {
          content.metadata.internal_operation_results.forEach((x) => returnedResults.push(x.result));
        }
      }
    }
  }
  return returnedResults;
};
var flattenErrors = (response, status = "failed") => {
  const results = Array.isArray(response) ? response : [response];
  let errors = [];
  for (let i = 0; i < results.length; i++) {
    for (let j = 0; j < results[i].contents.length; j++) {
      const content = results[i].contents[j];
      if (hasMetadata(content)) {
        if (hasMetadataWithResult(content) && content.metadata.operation_result.status === status) {
          errors = errors.concat(content.metadata.operation_result.errors || []);
        }
        if (hasMetadataWithInternalOperationResult(content) && Array.isArray(content.metadata.internal_operation_results)) {
          for (const internalResult of content.metadata.internal_operation_results) {
            if ("result" in internalResult && internalResult.result.status === status) {
              errors = errors.concat(internalResult.result.errors || []);
            }
          }
        }
      }
    }
  }
  return errors;
};
var OriginationOperationError = class extends TaquitoError {
  constructor(message) {
    super();
    this.message = message;
    this.name = "OriginationOperationError";
  }
};
var InvalidEstimateValueError = class extends ParameterValidationError {
  constructor(message) {
    super();
    this.message = message;
    this.name = "InvalidEstimateValueError";
  }
};
var InvalidConfirmationCountError = class extends ParameterValidationError {
  constructor(invalidConfirmations) {
    super();
    this.invalidConfirmations = invalidConfirmations;
    this.name = "InvalidConfirmationCountError";
    this.message = `Invalid confirmation count ${invalidConfirmations} expecting at least 1`;
  }
};
var ConfirmationTimeoutError = class extends NetworkError {
  constructor(message) {
    super();
    this.message = message;
    this.name = "ConfirmationTimeoutError";
  }
};
var RPCResponseError = class extends RpcError {
  constructor(message, cause) {
    super();
    this.message = message;
    this.cause = cause;
    this.name = "RPCResponseError";
  }
};
var Operation = class {
  /**
   *
   * @param hash Operation hash
   * @param raw Raw operation that was injected
   * @param context Taquito context allowing access to rpc and signer
   * @throws {@link InvalidOperationHashError}
   */
  constructor(hash2, raw, results, context2) {
    this.hash = hash2;
    this.raw = raw;
    this.results = results;
    this.context = context2;
    this._pollingConfig$ = new ReplaySubject(1);
    this.currentHead$ = this._pollingConfig$.pipe(switchMap((config2) => {
      return new BehaviorSubject(config2).pipe(timeout({
        each: config2.timeout * 1e3,
        with: () => throwError(() => new ConfirmationTimeoutError(`Confirmation polling timed out`))
      }));
    }), switchMap(() => {
      return defer(() => createObservableFromSubscription(this.context.stream.subscribeBlock("head"))).pipe(switchMap((newHead) => {
        var _a3, _b;
        const prevHead = (_b = (_a3 = this.lastHead) === null || _a3 === void 0 ? void 0 : _a3.header.level) !== null && _b !== void 0 ? _b : newHead.header.level - 1;
        return range(prevHead + 1, newHead.header.level - prevHead - 1).pipe(concatMap((level) => this.context.readProvider.getBlock(level)), endWith(newHead));
      }), tap((newHead) => this.lastHead = newHead));
    }), shareReplay({ refCount: true }));
    this.confirmed$ = this.currentHead$.pipe(map((head) => {
      for (let i = 3; i >= 0; i--) {
        head.operations[i].forEach((op) => {
          if (op.hash === this.hash) {
            this._foundAt = head.header.level;
          }
        });
      }
      if (head.header.level - this._foundAt >= 0) {
        return this._foundAt;
      }
    }), filter((x) => x !== void 0), first(), shareReplay());
    this._foundAt = Number.POSITIVE_INFINITY;
    if (validateOperation(this.hash) !== ValidationResult.VALID) {
      throw new InvalidOperationHashError(this.hash);
    }
    this.confirmed$.pipe(first(), catchError(() => {
      return of(EMPTY);
    })).subscribe();
  }
  get includedInBlock() {
    return this._foundAt;
  }
  get revealOperation() {
    return Array.isArray(this.results) && this.results.find((op) => op.kind === "reveal");
  }
  get revealStatus() {
    if (this.revealOperation) {
      return this.revealOperation.metadata.operation_result.status;
    } else {
      return "unknown";
    }
  }
  get status() {
    return this.results.map((result) => {
      if (hasMetadataWithResult(result)) {
        return result.metadata.operation_result.status;
      } else {
        return "unknown";
      }
    })[0] || "unknown";
  }
  /**
   *
   * @param confirmations [0] Number of confirmation to wait for
   * @param timeout [180] Timeout
   */
  confirmation(confirmations, timeout2) {
    return __awaiter4(this, void 0, void 0, function* () {
      if (typeof confirmations !== "undefined" && confirmations < 1) {
        throw new InvalidConfirmationCountError(confirmations);
      }
      const { defaultConfirmationCount, confirmationPollingTimeoutSecond } = this.context.config;
      this._pollingConfig$.next({
        timeout: timeout2 || confirmationPollingTimeoutSecond
      });
      const conf = confirmations !== void 0 ? confirmations : defaultConfirmationCount;
      return new Promise((resolve, reject) => {
        this.confirmed$.pipe(switchMap(() => this.currentHead$), filter((head) => head.header.level - this._foundAt >= conf - 1), first()).subscribe((_) => {
          resolve(this._foundAt + (conf - 1));
        }, reject);
      });
    });
  }
};
var BatchOperation = class extends Operation {
  constructor(hash2, params, source, raw, results, context2) {
    super(hash2, raw, results, context2);
    this.params = params;
    this.source = source;
  }
  sumProp(arr, prop) {
    return arr.reduce((prev, current) => {
      return prop in current ? Number(current[prop]) + prev : prev;
    }, 0);
  }
  getOriginatedContractAddresses() {
    const originationOpResults = this.results.filter((x) => x.kind === "origination");
    let addresses = [];
    for (const res of originationOpResults) {
      if (res.metadata.operation_result.originated_contracts) {
        addresses = [...addresses, ...res.metadata.operation_result.originated_contracts];
      }
    }
    return addresses;
  }
  get status() {
    return this.results.filter((result) => BATCH_KINDS.indexOf(result.kind) !== -1).map((result) => {
      if (hasMetadataWithResult(result)) {
        const opResult = result.metadata.operation_result;
        return opResult.status;
      } else {
        return "unknown";
      }
    })[0] || "unknown";
  }
  get fee() {
    return this.sumProp(this.params, "fee");
  }
  get gasLimit() {
    return this.sumProp(this.params, "gas_limit");
  }
  get storageLimit() {
    return this.sumProp(this.params, "storage_limit");
  }
  get consumedGas() {
    bignumber_default.config({ DECIMAL_PLACES: 0, ROUNDING_MODE: bignumber_default.ROUND_UP });
    return new bignumber_default(this.consumedMilliGas).dividedBy(1e3).toString();
  }
  get consumedMilliGas() {
    return String(this.sumProp(flattenOperationResult({ contents: this.results }), "consumed_milligas"));
  }
  get storageDiff() {
    return String(this.sumProp(flattenOperationResult({ contents: this.results }), "paid_storage_size_diff"));
  }
  get errors() {
    return flattenErrors({ contents: this.results });
  }
};
var Provider = class {
  constructor(context2) {
    this.context = context2;
  }
  get rpc() {
    return this.context.rpc;
  }
  get signer() {
    return this.context.signer;
  }
  forge({ opOb: { branch, contents, protocol }, counter }) {
    return __awaiter4(this, void 0, void 0, function* () {
      const forgedBytes = yield this.context.forger.forge({ branch, contents });
      return {
        opbytes: forgedBytes,
        opOb: {
          branch,
          contents,
          protocol
        },
        counter
      };
    });
  }
  estimate(_a3, estimator) {
    var { fee, gasLimit, storageLimit } = _a3, rest = __rest2(_a3, ["fee", "gasLimit", "storageLimit"]);
    return __awaiter4(this, void 0, void 0, function* () {
      let calculatedFee = fee;
      let calculatedGas = gasLimit;
      let calculatedStorage = storageLimit;
      if (calculatedFee && calculatedFee % 1 !== 0) {
        throw new InvalidEstimateValueError(`Fee value must not be a decimal: ${calculatedFee}`);
      }
      if (calculatedGas && calculatedGas % 1 !== 0) {
        throw new InvalidEstimateValueError(`Gas Limit value must not be a decimal: ${calculatedGas}`);
      }
      if (calculatedStorage && calculatedStorage % 1 !== 0) {
        throw new InvalidEstimateValueError(`Storage Limit value must not be a decimal: ${calculatedStorage}`);
      }
      if (fee === void 0 || gasLimit === void 0 || storageLimit === void 0) {
        const estimation = yield estimator(Object.assign({ fee, gasLimit, storageLimit }, rest));
        calculatedFee !== null && calculatedFee !== void 0 ? calculatedFee : calculatedFee = estimation.suggestedFeeMutez;
        calculatedGas !== null && calculatedGas !== void 0 ? calculatedGas : calculatedGas = estimation.gasLimit;
        calculatedStorage !== null && calculatedStorage !== void 0 ? calculatedStorage : calculatedStorage = estimation.storageLimit;
      }
      return {
        fee: calculatedFee,
        gasLimit: calculatedGas,
        storageLimit: calculatedStorage
      };
    });
  }
  getRPCOp(param) {
    return __awaiter4(this, void 0, void 0, function* () {
      switch (param.kind) {
        case OpKind.TRANSACTION:
          return createTransferOperation(Object.assign({}, param));
        case OpKind.ORIGINATION:
          return createOriginationOperation(yield this.context.parser.prepareCodeOrigination(Object.assign({}, param)));
        case OpKind.DELEGATION:
          return createSetDelegateOperation(Object.assign({}, param));
        case OpKind.REGISTER_GLOBAL_CONSTANT:
          return createRegisterGlobalConstantOperation(Object.assign({}, param));
        case OpKind.INCREASE_PAID_STORAGE:
          return createIncreasePaidStorageOperation(Object.assign({}, param));
        case OpKind.TRANSFER_TICKET:
          return createTransferTicketOperation(Object.assign({}, param));
        case OpKind.SMART_ROLLUP_ADD_MESSAGES:
          return createSmartRollupAddMessagesOperation(Object.assign({}, param));
        case OpKind.SMART_ROLLUP_ORIGINATE:
          return createSmartRollupOriginateOperation(Object.assign({}, param));
        default:
          throw new InvalidOperationKindError(param.kind);
      }
    });
  }
  runOperation(op) {
    return __awaiter4(this, void 0, void 0, function* () {
      return {
        opResponse: yield this.rpc.runOperation(op),
        op,
        context: this.context.clone()
      };
    });
  }
  simulate(op) {
    return __awaiter4(this, void 0, void 0, function* () {
      return {
        opResponse: yield this.rpc.simulateOperation(op),
        op,
        context: this.context.clone()
      };
    });
  }
  isRevealOpNeeded(op, pkh) {
    return __awaiter4(this, void 0, void 0, function* () {
      return !(yield this.isAccountRevealRequired(pkh)) || !this.isRevealRequiredForOpType(op) ? false : true;
    });
  }
  isAccountRevealRequired(publicKeyHash) {
    return __awaiter4(this, void 0, void 0, function* () {
      return !(yield this.context.readProvider.isAccountRevealed(publicKeyHash, "head"));
    });
  }
  isRevealRequiredForOpType(op) {
    let opRequireReveal = false;
    for (const operation of op) {
      if (isOpRequireReveal(operation)) {
        opRequireReveal = true;
      }
    }
    return opRequireReveal;
  }
  signAndInject(forgedBytes) {
    return __awaiter4(this, void 0, void 0, function* () {
      const signed = yield this.signer.sign(forgedBytes.opbytes, new Uint8Array([3]));
      forgedBytes.opbytes = signed.sbytes;
      forgedBytes.opOb.signature = signed.prefixSig;
      const opResponse = [];
      const results = yield this.rpc.preapplyOperations([forgedBytes.opOb]);
      if (!Array.isArray(results)) {
        throw new TezosPreapplyFailureError(results);
      }
      for (let i = 0; i < results.length; i++) {
        for (let j = 0; j < results[i].contents.length; j++) {
          opResponse.push(results[i].contents[j]);
        }
      }
      const errors = flattenErrors(results);
      if (errors.length) {
        throw new TezosOperationError(errors, "Error occurred during validation simulation of operation");
      }
      return {
        hash: yield this.context.injector.inject(forgedBytes.opbytes),
        forgedBytes,
        opResponse,
        context: this.context.clone()
      };
    });
  }
};
var WalletOperationBatch = class {
  constructor(walletProvider, context2) {
    this.walletProvider = walletProvider;
    this.context = context2;
    this.operations = [];
  }
  /**
   *
   * @description Add a transaction operation to the batch
   *
   * @param params Transfer operation parameter
   */
  withTransfer(params) {
    const toValidation = validateAddress(params.to);
    if (toValidation !== ValidationResult.VALID) {
      throw new InvalidAddressError(params.to, invalidDetail(toValidation));
    }
    this.operations.push(Object.assign({ kind: OpKind.TRANSACTION }, params));
    return this;
  }
  /**
   *
   * @description Add a contract call to the batch
   *
   * @param params Call a contract method
   * @param options Generic operation parameters
   */
  withContractCall(params, options = {}) {
    return this.withTransfer(params.toTransferParams(options));
  }
  /**
   *
   * @description Add a delegation operation to the batch
   *
   * @param params Delegation operation parameter
   */
  withDelegation(params) {
    var _a3;
    const delegateValidation = validateAddress((_a3 = params.delegate) !== null && _a3 !== void 0 ? _a3 : "");
    if (params.delegate && delegateValidation !== ValidationResult.VALID) {
      throw new InvalidAddressError(params.delegate, invalidDetail(delegateValidation));
    }
    this.operations.push(Object.assign({ kind: OpKind.DELEGATION }, params));
    return this;
  }
  /**
   *
   * @description Add an origination operation to the batch
   *
   * @param params Origination operation parameter
   */
  withOrigination(params) {
    this.operations.push(Object.assign({ kind: OpKind.ORIGINATION }, params));
    return this;
  }
  /**
   *
   * @description Add an IncreasePaidStorage operation to the batch
   *
   * @param param IncreasePaidStorage operation parameter
   */
  withIncreasePaidStorage(params) {
    const destinationValidation = validateAddress(params.destination);
    if (destinationValidation !== ValidationResult.VALID) {
      throw new InvalidAddressError(params.destination, invalidDetail(destinationValidation));
    }
    this.operations.push(Object.assign({ kind: OpKind.INCREASE_PAID_STORAGE }, params));
    return this;
  }
  mapOperation(param) {
    return __awaiter4(this, void 0, void 0, function* () {
      switch (param.kind) {
        case OpKind.TRANSACTION:
          return this.walletProvider.mapTransferParamsToWalletParams(() => __awaiter4(this, void 0, void 0, function* () {
            return param;
          }));
        case OpKind.ORIGINATION:
          return this.walletProvider.mapOriginateParamsToWalletParams(() => __awaiter4(this, void 0, void 0, function* () {
            return this.context.parser.prepareCodeOrigination(Object.assign({}, param));
          }));
        case OpKind.DELEGATION:
          return this.walletProvider.mapDelegateParamsToWalletParams(() => __awaiter4(this, void 0, void 0, function* () {
            return param;
          }));
        case OpKind.INCREASE_PAID_STORAGE:
          return this.walletProvider.mapIncreasePaidStorageWalletParams(() => __awaiter4(this, void 0, void 0, function* () {
            return param;
          }));
        default:
          throw new InvalidOperationKindError(JSON.stringify(param.kind));
      }
    });
  }
  /**
   *
   * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array
   *
   * @param params Operations parameter
   * @throws {@link InvalidOperationKindError}
   */
  with(params) {
    for (const param of params) {
      switch (param.kind) {
        case OpKind.TRANSACTION:
          this.withTransfer(param);
          break;
        case OpKind.ORIGINATION:
          this.withOrigination(param);
          break;
        case OpKind.DELEGATION:
          this.withDelegation(param);
          break;
        case OpKind.INCREASE_PAID_STORAGE:
          this.withIncreasePaidStorage(param);
          break;
        default:
          throw new InvalidOperationKindError(JSON.stringify(param.kind));
      }
    }
    return this;
  }
  /**
   *
   * @description Submit batch operation to wallet
   *
   */
  send() {
    return __awaiter4(this, void 0, void 0, function* () {
      const ops = [];
      for (const op of this.operations) {
        ops.push(yield this.mapOperation(op));
      }
      const opHash = yield this.walletProvider.sendOperations(ops);
      return this.context.operationFactory.createBatchOperation(opHash);
    });
  }
};
var Wallet = class {
  constructor(context2) {
    this.context = context2;
    this.walletCommand = (send) => {
      return {
        send
      };
    };
  }
  get walletProvider() {
    return this.context.walletProvider;
  }
  /**
   * @description Retrieve the PKH of the account that is currently in use by the wallet
   *
   * @param option Option to use while fetching the PKH.
   * If forceRefetch is specified the wallet provider implementation will refetch the PKH from the wallet
   */
  pkh({ forceRefetch } = {}) {
    return __awaiter4(this, void 0, void 0, function* () {
      if (!this._pkh || forceRefetch) {
        this._pkh = yield this.walletProvider.getPKH();
      }
      return this._pkh;
    });
  }
  /**
   *
   * @description Originate a new contract according to the script in parameters.
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @param originateParams Originate operation parameter
   */
  originate(params) {
    return this.walletCommand(() => __awaiter4(this, void 0, void 0, function* () {
      const mappedParams = yield this.walletProvider.mapOriginateParamsToWalletParams(() => this.context.parser.prepareCodeOrigination(Object.assign({}, params)));
      const opHash = yield this.walletProvider.sendOperations([mappedParams]);
      return this.context.operationFactory.createOriginationOperation(opHash);
    }));
  }
  /**
   *
   * @description Set the delegate for a contract.
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @param delegateParams operation parameter
   */
  setDelegate(params) {
    var _a3;
    const delegateValidation = validateAddress((_a3 = params.delegate) !== null && _a3 !== void 0 ? _a3 : "");
    if (params.delegate && delegateValidation !== ValidationResult.VALID) {
      throw new InvalidAddressError(params.delegate, invalidDetail(delegateValidation));
    }
    return this.walletCommand(() => __awaiter4(this, void 0, void 0, function* () {
      const mappedParams = yield this.walletProvider.mapDelegateParamsToWalletParams(() => __awaiter4(this, void 0, void 0, function* () {
        return params;
      }));
      const opHash = yield this.walletProvider.sendOperations([mappedParams]);
      return this.context.operationFactory.createDelegationOperation(opHash);
    }));
  }
  /**
   *
   * @description failing_noop operation that is guaranteed to fail. DISCLAIMER: Not all wallets support signing failing_noop operations.
   *
   * @returns Signature for a failing_noop
   *
   * @param params operation parameter
   */
  signFailingNoop(params) {
    return __awaiter4(this, void 0, void 0, function* () {
      const op = {
        kind: OpKind.FAILING_NOOP,
        arbitrary: params.arbitrary
      };
      const hash2 = yield this.context.readProvider.getBlockHash(params.basedOnBlock);
      const forgedBytes = yield this.context.forger.forge({
        branch: hash2,
        contents: [op]
      });
      const signature = yield this.walletProvider.sign(forgedBytes, Uint8Array.from([3]));
      return {
        signature,
        bytes: forgedBytes,
        signedContent: {
          branch: hash2,
          contents: [
            {
              kind: OpKind.FAILING_NOOP,
              arbitrary: params.arbitrary
            }
          ]
        }
      };
    });
  }
  /**
   *
   * @description Register the current address as delegate.
   *
   * @returns An operation handle with the result from the rpc node
   *
   */
  registerDelegate() {
    return this.walletCommand(() => __awaiter4(this, void 0, void 0, function* () {
      const mappedParams = yield this.walletProvider.mapDelegateParamsToWalletParams(() => __awaiter4(this, void 0, void 0, function* () {
        const delegate = yield this.pkh();
        return { delegate };
      }));
      const opHash = yield this.walletProvider.sendOperations([mappedParams]);
      return this.context.operationFactory.createDelegationOperation(opHash);
    }));
  }
  /**
   *
   * @description Transfer tezos tokens from current address to a specific address or call a smart contract.
   *
   * @returns A wallet command from which we can send the operation to the wallet
   *
   * @param params operation parameter
   */
  transfer(params) {
    const toValidation = validateAddress(params.to);
    if (toValidation !== ValidationResult.VALID) {
      throw new InvalidAddressError(params.to, invalidDetail(toValidation));
    }
    return this.walletCommand(() => __awaiter4(this, void 0, void 0, function* () {
      const mappedParams = yield this.walletProvider.mapTransferParamsToWalletParams(() => __awaiter4(this, void 0, void 0, function* () {
        return params;
      }));
      const opHash = yield this.walletProvider.sendOperations([mappedParams]);
      return this.context.operationFactory.createTransactionOperation(opHash);
    }));
  }
  /**
   *
   * @description
   *
   * @returns
   *
   * @param params
   */
  increasePaidStorage(params) {
    const destinationValidation = validateAddress(params.destination);
    if (destinationValidation !== ValidationResult.VALID) {
      throw new InvalidAddressError(params.destination, invalidDetail(destinationValidation));
    }
    return this.walletCommand(() => __awaiter4(this, void 0, void 0, function* () {
      const mappedParams = yield this.walletProvider.mapIncreasePaidStorageWalletParams(() => __awaiter4(this, void 0, void 0, function* () {
        return params;
      }));
      const opHash = yield this.walletProvider.sendOperations([mappedParams]);
      return this.context.operationFactory.createIncreasePaidStorageOperation(opHash);
    }));
  }
  /**
   *
   * @description Create a batch of operation
   *
   * @returns A batch object from which we can add more operation or send a command to the wallet to execute the batch
   *
   * @param params List of operation to initialize the batch with
   */
  batch(params) {
    const batch = new WalletOperationBatch(this.walletProvider, this.context);
    if (Array.isArray(params)) {
      batch.with(params);
    }
    return batch;
  }
  /**
   *
   * @description Create an smart contract abstraction for the address specified. Calling entrypoints with the returned
   * smart contract abstraction will leverage the wallet provider to make smart contract calls
   *
   * @param address Smart contract address
   * @throws {@link InvalidContractAddressError} If the contract address is not valid
   */
  at(address, contractAbstractionComposer = (x) => x) {
    return __awaiter4(this, void 0, void 0, function* () {
      const addressValidation = validateContractAddress(address);
      if (addressValidation !== ValidationResult.VALID) {
        throw new InvalidContractAddressError(address, invalidDetail(addressValidation));
      }
      const rpc = this.context.withExtensions().rpc;
      const readProvider = this.context.withExtensions().readProvider;
      const script = yield readProvider.getScript(address, "head");
      const entrypoints = yield readProvider.getEntrypoints(address);
      const abs = new ContractAbstraction(address, script, this, this.context.contract, entrypoints, rpc, readProvider);
      return contractAbstractionComposer(abs, this.context);
    });
  }
  getPK() {
    return this.walletProvider.getPK();
  }
};
var receiptFromOperation = (op, { ALLOCATION_BURN, ORIGINATION_BURN } = {
  ALLOCATION_BURN: 257,
  ORIGINATION_BURN: 257
}) => {
  bignumber_default.config({ DECIMAL_PLACES: 0, ROUNDING_MODE: bignumber_default.ROUND_UP });
  const operationResults = flattenOperationResult({ contents: op });
  let totalMilliGas = new bignumber_default(0);
  let totalStorage = new bignumber_default(0);
  let totalFee = new bignumber_default(0);
  let totalOriginationBurn = new bignumber_default(0);
  let totalAllocationBurn = new bignumber_default(0);
  let totalPaidStorageDiff = new bignumber_default(0);
  operationResults.forEach((result) => {
    totalFee = totalFee.plus(result.fee || 0);
    totalOriginationBurn = totalOriginationBurn.plus(Array.isArray(result.originated_contracts) ? result.originated_contracts.length * ORIGINATION_BURN : 0);
    totalAllocationBurn = totalAllocationBurn.plus("allocated_destination_contract" in result ? ALLOCATION_BURN : 0);
    totalMilliGas = totalMilliGas.plus(result.consumed_milligas || 0);
    totalPaidStorageDiff = totalPaidStorageDiff.plus("paid_storage_size_diff" in result ? Number(result.paid_storage_size_diff) || 0 : 0);
  });
  totalStorage = totalStorage.plus(totalAllocationBurn).plus(totalOriginationBurn).plus(totalPaidStorageDiff);
  return {
    totalFee,
    totalMilliGas,
    totalGas: totalMilliGas.dividedBy(1e3),
    totalStorage,
    totalAllocationBurn,
    totalOriginationBurn,
    totalPaidStorageDiff,
    totalStorageBurn: new bignumber_default(totalStorage.multipliedBy(COST_PER_BYTE))
  };
};
var ConfirmationUndefinedError = class extends TezosToolkitConfigError {
  constructor() {
    super();
    this.name = "ConfirmationUndefinedError";
    this.message = "Default confirmation count can not be undefined";
  }
};
var ObservableError = class extends NetworkError {
  constructor(message) {
    super();
    this.message = message;
    this.name = "ObservableError";
  }
};
var MAX_BRANCH_ANCESTORS = 60;
var WalletOperation = class {
  /**
   *
   * @param opHash Operation hash
   * @param raw Raw operation that was injected
   * @param context Taquito context allowing access to rpc and signer
   * @throws {InvalidOperationHashError}
   */
  constructor(opHash, context2, _newHead$) {
    this.opHash = opHash;
    this.context = context2;
    this._newHead$ = _newHead$;
    this._operationResult = new ReplaySubject(1);
    this._includedInBlock = new ReplaySubject(1);
    this._included = false;
    this.newHead$ = this._newHead$.pipe(switchMap((newHead) => {
      var _a3, _b;
      const prevHead = (_b = (_a3 = this.lastHead) === null || _a3 === void 0 ? void 0 : _a3.header.level) !== null && _b !== void 0 ? _b : newHead.header.level - 1;
      return range(prevHead + 1, newHead.header.level - prevHead - 1).pipe(concatMap((level) => this.context.readProvider.getBlock(level)), endWith(newHead));
    }), tap((newHead) => this.lastHead = newHead), share({
      connector: () => new ReplaySubject(1),
      resetOnError: false,
      resetOnComplete: false,
      resetOnRefCountZero: false
    }));
    this.confirmed$ = this.newHead$.pipe(map((head) => {
      for (const opGroup of head.operations) {
        for (const op of opGroup) {
          if (op.hash === this.opHash) {
            this._included = true;
            this._includedInBlock.next(head);
            this._operationResult.next(op.contents);
            return head;
          }
        }
      }
    }), filter((x) => {
      return typeof x !== "undefined";
    }), first(), share({
      connector: () => new ReplaySubject(1),
      resetOnError: false,
      resetOnComplete: false,
      resetOnRefCountZero: false
    }));
    if (validateOperation(this.opHash) !== ValidationResult.VALID) {
      throw new InvalidOperationHashError(this.opHash);
    }
    this.confirmed$.pipe(first(), catchError(() => of(void 0))).subscribe();
  }
  operationResults() {
    return __awaiter4(this, void 0, void 0, function* () {
      return this._operationResult.pipe(first()).toPromise();
    });
  }
  /**
   * @description Receipt expose the total amount of tezos token burn and spent on fees
   * The promise returned by receipt will resolve only once the transaction is included
   */
  receipt() {
    return __awaiter4(this, void 0, void 0, function* () {
      const results = yield this.operationResults();
      if (!results) {
        throw new ObservableError("Unable to get operation results");
      }
      return receiptFromOperation(results);
    });
  }
  getCurrentConfirmation() {
    return __awaiter4(this, void 0, void 0, function* () {
      if (!this._included) {
        return 0;
      }
      return combineLatest([this._includedInBlock, from(this.context.readProvider.getBlock("head"))]).pipe(map(([foundAtBlock, head]) => {
        return head.header.level - foundAtBlock.header.level + 1;
      }), first()).toPromise();
    });
  }
  isInCurrentBranch(tipBlockIdentifier = "head") {
    return __awaiter4(this, void 0, void 0, function* () {
      if (!this._included) {
        return true;
      }
      const tipBlockHeaderLevel = yield this.context.readProvider.getBlockLevel(tipBlockIdentifier);
      const inclusionBlock = yield this._includedInBlock.pipe(first()).toPromise();
      if (!inclusionBlock) {
        throw new ObservableError("Inclusion block is undefined");
      }
      const levelDiff = tipBlockHeaderLevel - inclusionBlock.header.level;
      if (levelDiff <= 0) {
        return true;
      }
      const tipBlockLevel = Math.min(inclusionBlock.header.level + levelDiff, inclusionBlock.header.level + MAX_BRANCH_ANCESTORS);
      const blocks = new Set(yield this.context.readProvider.getLiveBlocks(tipBlockLevel));
      return blocks.has(inclusionBlock.hash);
    });
  }
  confirmationObservable(confirmations) {
    if (typeof confirmations !== "undefined" && confirmations < 1) {
      throw new InvalidConfirmationCountError(confirmations);
    }
    const { defaultConfirmationCount } = this.context.config;
    const conf = confirmations !== void 0 ? confirmations : defaultConfirmationCount;
    if (conf === void 0) {
      throw new ConfirmationUndefinedError();
    }
    return combineLatest([this._includedInBlock, this.newHead$]).pipe(distinctUntilChanged(([, previousHead], [, newHead]) => {
      return previousHead.hash === newHead.hash;
    }), map(([foundAtBlock, head]) => {
      return {
        block: head,
        expectedConfirmation: conf,
        currentConfirmation: head.header.level - foundAtBlock.header.level + 1,
        completed: head.header.level - foundAtBlock.header.level >= conf - 1,
        isInCurrentBranch: () => this.isInCurrentBranch(head.hash)
      };
    }), takeWhile(({ completed }) => !completed, true));
  }
  /**
   *
   * @param confirmations [0] Number of confirmation to wait for
   */
  confirmation(confirmations) {
    return this.confirmationObservable(confirmations).toPromise();
  }
};
var TransactionWalletOperation = class extends WalletOperation {
  constructor(opHash, context2, newHead$) {
    super(opHash, context2, newHead$);
    this.opHash = opHash;
    this.context = context2;
  }
  revealOperation() {
    return __awaiter4(this, void 0, void 0, function* () {
      const operationResult = yield this.operationResults();
      if (!operationResult) {
        throw new ObservableError("operationResult returned undefined");
      }
      return operationResult.find((x) => x.kind === OpKind.REVEAL);
    });
  }
  transactionOperation() {
    return __awaiter4(this, void 0, void 0, function* () {
      const operationResult = yield this.operationResults();
      if (!operationResult) {
        throw new ObservableError("operationResult returned undefined");
      }
      return operationResult.find((x) => x.kind === OpKind.TRANSACTION);
    });
  }
  status() {
    return __awaiter4(this, void 0, void 0, function* () {
      if (!this._included) {
        return "pending";
      }
      const op = yield this.transactionOperation();
      if (!op) {
        return "unknown";
      }
      return op.metadata.operation_result.status;
    });
  }
};
var OriginationWalletOperation = class extends WalletOperation {
  constructor(opHash, context2, newHead$) {
    super(opHash, context2, newHead$);
    this.opHash = opHash;
    this.context = context2;
  }
  originationOperation() {
    return __awaiter4(this, void 0, void 0, function* () {
      const operationResult = yield this.operationResults();
      if (operationResult) {
        return findWithKind(operationResult, OpKind.ORIGINATION);
      } else {
        throw new ObservableError("Unable to fetch operation result");
      }
    });
  }
  revealOperation() {
    return __awaiter4(this, void 0, void 0, function* () {
      const operationResult = yield this.operationResults();
      if (operationResult) {
        return findWithKind(operationResult, OpKind.REVEAL);
      } else {
        throw new ObservableError("Unable to fetch operation result");
      }
    });
  }
  status() {
    return __awaiter4(this, void 0, void 0, function* () {
      if (!this._included) {
        return "pending";
      }
      const op = yield this.originationOperation();
      if (!op) {
        return "unknown";
      }
      return op.metadata.operation_result.status;
    });
  }
  contract() {
    return __awaiter4(this, void 0, void 0, function* () {
      const op = yield this.originationOperation();
      const address = ((op === null || op === void 0 ? void 0 : op.metadata.operation_result.originated_contracts) || [])[0];
      return this.context.wallet.at(address);
    });
  }
};
var DelegationWalletOperation = class extends WalletOperation {
  constructor(opHash, context2, newHead$) {
    super(opHash, context2, newHead$);
    this.opHash = opHash;
    this.context = context2;
  }
  revealOperation() {
    return __awaiter4(this, void 0, void 0, function* () {
      const operationResult = yield this.operationResults();
      if (operationResult) {
        return operationResult.find((x) => x.kind === OpKind.REVEAL);
      } else {
        throw new ObservableError("Unable to fetch operation result");
      }
    });
  }
  delegationOperation() {
    return __awaiter4(this, void 0, void 0, function* () {
      const operationResult = yield this.operationResults();
      if (operationResult) {
        return operationResult.find((x) => x.kind === OpKind.DELEGATION);
      } else {
        throw new ObservableError("Unable to fetch operation result");
      }
    });
  }
  status() {
    return __awaiter4(this, void 0, void 0, function* () {
      if (!this._included) {
        return "pending";
      }
      const op = yield this.delegationOperation();
      if (!op) {
        return "unknown";
      }
      return op.metadata.operation_result.status;
    });
  }
};
var LegacyWalletProvider = class {
  constructor(context2) {
    this.context = context2;
  }
  getPKH() {
    return __awaiter4(this, void 0, void 0, function* () {
      return this.context.signer.publicKeyHash();
    });
  }
  mapTransferParamsToWalletParams(params) {
    return __awaiter4(this, void 0, void 0, function* () {
      return attachKind(yield params(), OpKind.TRANSACTION);
    });
  }
  mapOriginateParamsToWalletParams(params) {
    return __awaiter4(this, void 0, void 0, function* () {
      return attachKind(yield params(), OpKind.ORIGINATION);
    });
  }
  mapDelegateParamsToWalletParams(params) {
    return __awaiter4(this, void 0, void 0, function* () {
      return attachKind(yield params(), OpKind.DELEGATION);
    });
  }
  mapIncreasePaidStorageWalletParams(params) {
    return __awaiter4(this, void 0, void 0, function* () {
      return attachKind(yield params(), OpKind.INCREASE_PAID_STORAGE);
    });
  }
  sendOperations(params) {
    return __awaiter4(this, void 0, void 0, function* () {
      const op = yield this.context.batch.batch(params).send();
      return op.hash;
    });
  }
  sign(bytes, watermark) {
    return __awaiter4(this, void 0, void 0, function* () {
      const { prefixSig } = yield this.context.signer.sign(bytes, watermark);
      return prefixSig;
    });
  }
  getPK() {
    return this.context.signer.publicKey();
  }
};
var ContractMethodObject = class {
  constructor(provider, address, parameterSchema, name, args = "unit", isMultipleEntrypoint = true, isAnonymous = false) {
    this.provider = provider;
    this.address = address;
    this.parameterSchema = parameterSchema;
    this.name = name;
    this.args = args;
    this.isMultipleEntrypoint = isMultipleEntrypoint;
    this.isAnonymous = isAnonymous;
  }
  /**
   * @description Get the signature of the smart contract method
   */
  getSignature() {
    return this.isAnonymous ? this.parameterSchema.ExtractSchema()[this.name] : this.parameterSchema.ExtractSchema();
  }
  /**
   *
   * @description Send the smart contract operation
   *
   * @param Options generic operation parameter
   */
  send(params = {}) {
    if (this.provider instanceof Wallet) {
      return this.provider.transfer(this.toTransferParams(params)).send();
    } else {
      return this.provider.transfer(this.toTransferParams(params));
    }
  }
  /**
   *
   * @description Create transfer params to be used with TezosToolkit.contract.transfer methods
   *
   * @param Options generic transfer operation parameters
   */
  toTransferParams({ fee, gasLimit, storageLimit, source, amount = 0, mutez = false } = {}) {
    const fullTransferParams = {
      to: this.address,
      amount,
      fee,
      mutez,
      source,
      gasLimit,
      storageLimit,
      parameter: {
        entrypoint: this.isMultipleEntrypoint ? this.name : DEFAULT_SMART_CONTRACT_METHOD_NAME,
        value: this.isAnonymous ? this.parameterSchema.EncodeObject({ [this.name]: this.args }) : this.parameterSchema.EncodeObject(this.args)
      }
    };
    return fullTransferParams;
  }
};
var ContractMethod = class {
  constructor(provider, address, parameterSchema, name, args, isMultipleEntrypoint = true, isAnonymous = false) {
    this.provider = provider;
    this.address = address;
    this.parameterSchema = parameterSchema;
    this.name = name;
    this.args = args;
    this.isMultipleEntrypoint = isMultipleEntrypoint;
    this.isAnonymous = isAnonymous;
  }
  validateArgs(args, schema, name) {
    const sigs = schema.ExtractSignatures();
    if (!sigs.find((x) => x.length === args.length)) {
      throw new InvalidParameterError(name, sigs, args);
    }
  }
  /**
   * @description Get the schema of the smart contract method
   */
  get schema() {
    return this.isAnonymous ? this.parameterSchema.ExtractSchema()[this.name] : this.parameterSchema.ExtractSchema();
  }
  /**
   * @description Get the signature of the smart contract method
   */
  getSignature() {
    if (this.isAnonymous) {
      const sig = this.parameterSchema.ExtractSignatures().find((x) => x[0] === this.name);
      if (sig) {
        sig.shift();
        return sig;
      }
    } else {
      const sig = this.parameterSchema.ExtractSignatures();
      return sig.length == 1 ? sig[0] : sig;
    }
  }
  /**
   *
   * @description Send the smart contract operation
   *
   * @param Options generic operation parameter
   */
  send(params = {}) {
    if (this.provider instanceof Wallet) {
      return this.provider.transfer(this.toTransferParams(params)).send();
    } else {
      return this.provider.transfer(this.toTransferParams(params));
    }
  }
  /**
   *
   * @description Create transfer params to be used with TezosToolkit.contract.transfer methods
   *
   * @param Options generic transfer operation parameters
   */
  toTransferParams({ fee, gasLimit, storageLimit, source, amount = 0, mutez = false } = {}) {
    const fullTransferParams = {
      to: this.address,
      amount,
      fee,
      mutez,
      source,
      gasLimit,
      storageLimit,
      parameter: {
        entrypoint: this.isMultipleEntrypoint ? this.name : DEFAULT_SMART_CONTRACT_METHOD_NAME,
        value: this.isAnonymous ? this.parameterSchema.Encode(this.name, ...this.args) : this.parameterSchema.Encode(...this.args)
      }
    };
    return fullTransferParams;
  }
};
var OnChainView = class {
  constructor(_rpc, _readProvider, _contractAddress, _smartContractViewSchema, _contractStorageType, _args = "Unit") {
    this._rpc = _rpc;
    this._readProvider = _readProvider;
    this._contractAddress = _contractAddress;
    this._smartContractViewSchema = _smartContractViewSchema;
    this._contractStorageType = _contractStorageType;
    this._args = _args;
  }
  /**
   * @description Get the signature of the smart contract view
   */
  getSignature() {
    return {
      parameter: this._smartContractViewSchema.extractArgsSchema(),
      result: this._smartContractViewSchema.extractResultSchema()
    };
  }
  /**
   * @description Get the result of the view simulation
   * @param executionContext.source the public key hash of the account who initialized this view execution.
   * @param executionContext.viewCaller the contract address which is the caller of view.
   */
  executeView(executionContext) {
    return __awaiter4(this, void 0, void 0, function* () {
      this.verifyContextExecution(executionContext);
      const chainId = yield this._readProvider.getChainId();
      const viewArgs = this.transformArgsToMichelson();
      const scriptView = {
        contract: this._contractAddress,
        view: this._smartContractViewSchema.viewName,
        input: viewArgs,
        chain_id: chainId,
        source: executionContext.viewCaller
      };
      if (executionContext.source) {
        scriptView.payer = executionContext.source;
      }
      return this.executeViewAndDecodeResult(scriptView);
    });
  }
  verifyContextExecution(executionContext) {
    if (executionContext.source && validateAddress(executionContext.source) !== ValidationResult.VALID) {
      throw new InvalidViewSimulationContext(`The source account who initialized the view execution is invalid: ${executionContext.source}.`);
    }
    if (!executionContext.viewCaller || validateAddress(executionContext.viewCaller) !== ValidationResult.VALID) {
      throw new InvalidViewSimulationContext(`The contract which is the caller of view is invalid: ${executionContext.viewCaller}.`);
    }
  }
  transformArgsToMichelson() {
    try {
      return this._smartContractViewSchema.encodeViewArgs(this._args);
    } catch (error) {
      throw new InvalidViewParameterError(this._smartContractViewSchema.viewName, this.getSignature(), this._args, error);
    }
  }
  /**
   * @description Loops through the view's instructions and replace BALANCE, SENDER, SELF_ADDRESS and AMOUNT with Michelson expressions that match the current context, if applicable.
   *
   * Certain specific instructions have different semantics in view:
   * BALANCE represents the current amount of mutez held by the contract where view is;
   * SENDER represents the contract which is the caller of view;
   * SELF_ADDRESS represents the contract where view is;
   * AMOUNT is always 0 mutez.
   *
   */
  adaptViewCodeToContext(instructions, viewCaller, contractBalance) {
    const instructionsToReplace = {
      BALANCE: [{ prim: "PUSH", args: [{ prim: "mutez" }, { int: contractBalance }] }],
      SENDER: [{ prim: "PUSH", args: [{ prim: "address" }, { string: viewCaller }] }],
      SELF_ADDRESS: [
        { prim: "PUSH", args: [{ prim: "address" }, { string: this._contractAddress }] }
      ],
      AMOUNT: [{ prim: "PUSH", args: [{ prim: "mutez" }, { int: "0" }] }]
    };
    instructions.forEach((inst, i) => {
      if (inst.prim in instructionsToReplace) {
        instructions[i] = Object(instructionsToReplace)[inst.prim];
      }
      if (inst.args && inst.args.length !== 0) {
        this.adaptViewCodeToContext(inst.args, viewCaller, contractBalance);
      } else if (Array.isArray(inst)) {
        this.adaptViewCodeToContext(inst, viewCaller, contractBalance);
      }
    });
    return instructions;
  }
  executeViewAndDecodeResult(viewScript) {
    return __awaiter4(this, void 0, void 0, function* () {
      let storage2;
      try {
        storage2 = (yield this._rpc.runScriptView(viewScript)).data;
      } catch (error) {
        const failWith = validateAndExtractFailwith(error);
        throw failWith ? new ViewSimulationError(`The simulation of the on-chain view named ${this._smartContractViewSchema.viewName} failed with: ${JSON.stringify(failWith)}`, this._smartContractViewSchema.viewName, failWith, error) : error;
      }
      return this._smartContractViewSchema.decodeViewResult(storage2);
    });
  }
};
var ContractMethodFactory = class {
  constructor(provider, contractAddress) {
    this.provider = provider;
    this.contractAddress = contractAddress;
  }
  createContractMethodFlatParams(smartContractMethodSchema, smartContractMethodName, args, isMultipleEntrypoint = true, isAnonymous = false) {
    return new ContractMethod(this.provider, this.contractAddress, smartContractMethodSchema, smartContractMethodName, args, isMultipleEntrypoint, isAnonymous);
  }
  createContractMethodObjectParam(smartContractMethodSchema, smartContractMethodName, args, isMultipleEntrypoint = true, isAnonymous = false) {
    return new ContractMethodObject(this.provider, this.contractAddress, smartContractMethodSchema, smartContractMethodName, args, isMultipleEntrypoint, isAnonymous);
  }
  createContractViewObjectParam(rpc, readProvider, smartContractViewSchema, contractStorageType, viewArgs) {
    return new OnChainView(rpc, readProvider, this.contractAddress, smartContractViewSchema, contractStorageType, viewArgs);
  }
};
var DEFAULT_SMART_CONTRACT_METHOD_NAME = "default";
var ContractView = class {
  constructor(currentContract, name, callbackParametersSchema, parameterSchema, args, rpc, readProvider) {
    this.currentContract = currentContract;
    this.name = name;
    this.callbackParametersSchema = callbackParametersSchema;
    this.parameterSchema = parameterSchema;
    this.args = args;
    this.rpc = rpc;
    this.readProvider = readProvider;
  }
  read(chainId) {
    return __awaiter4(this, void 0, void 0, function* () {
      const chainIdValidation = validateChain(chainId !== null && chainId !== void 0 ? chainId : "");
      if (validateContractAddress(chainId !== null && chainId !== void 0 ? chainId : "") == ValidationResult.VALID) {
        throw new DeprecationError(`Since version 12, the lambda view no longer depends on a lambda contract. The read method no longer accepts a contract address as a parameter.`);
      } else if (chainId && chainIdValidation !== ValidationResult.VALID) {
        throw new InvalidChainIdError(chainId, invalidDetail(chainIdValidation));
      }
      const arg = this.parameterSchema.Encode(...this.args);
      const result = yield this.rpc.runView({
        contract: this.currentContract.address,
        entrypoint: this.name,
        input: arg,
        chain_id: chainId ? chainId : yield this.readProvider.getChainId()
      });
      return this.callbackParametersSchema.Execute(result.data);
    });
  }
};
var validateArgs = (args, schema, name) => {
  const sigs = schema.ExtractSignatures();
  if (!sigs.find((x) => x.length === args.length)) {
    throw new InvalidParameterError(name, sigs, args);
  }
};
var isView = (entrypoint) => {
  let isView2 = false;
  if ("prim" in entrypoint && entrypoint.prim === "pair" && entrypoint.args) {
    const lastElement = entrypoint.args[entrypoint.args.length - 1];
    if ("prim" in lastElement && lastElement.prim === "contract") {
      isView2 = true;
    }
  }
  return isView2;
};
var ContractAbstraction = class {
  constructor(address, script, provider, storageProvider, entrypoints, rpc, readProvider) {
    this.address = address;
    this.script = script;
    this.storageProvider = storageProvider;
    this.entrypoints = entrypoints;
    this.rpc = rpc;
    this.readProvider = readProvider;
    this.methods = {};
    this.methodsObject = {};
    this.views = {};
    this.contractViews = {};
    this.contractMethodFactory = new ContractMethodFactory(provider, address);
    this.schema = Schema.fromRPCResponse({ script: this.script });
    this.parameterSchema = ParameterSchema.fromRPCResponse({ script: this.script });
    this.viewSchema = ViewSchema.fromRPCResponse({ script: this.script });
    if (this.viewSchema.length !== 0) {
      this._initializeOnChainViews(this, rpc, this.readProvider, this.viewSchema);
    }
    this.eventSchema = EventSchema.fromRPCResponse({ script: this.script });
    this._initializeMethods(this, this.entrypoints.entrypoints, this.rpc, this.readProvider);
  }
  _initializeMethods(currentContract, entrypoints, rpc, readProvider) {
    const parameterSchema = this.parameterSchema;
    const keys = Object.keys(entrypoints);
    if (parameterSchema.isMultipleEntryPoint) {
      keys.forEach((smartContractMethodName) => {
        const smartContractMethodSchema = new ParameterSchema(entrypoints[smartContractMethodName]);
        this.methods[smartContractMethodName] = function(...args) {
          return currentContract.contractMethodFactory.createContractMethodFlatParams(smartContractMethodSchema, smartContractMethodName, args);
        };
        this.methodsObject[smartContractMethodName] = function(args) {
          return currentContract.contractMethodFactory.createContractMethodObjectParam(smartContractMethodSchema, smartContractMethodName, args);
        };
        if (isView(entrypoints[smartContractMethodName])) {
          const view = function(...args) {
            const entrypointParamWithoutCallback = entrypoints[smartContractMethodName].args[0];
            const smartContractMethodSchemaWithoutCallback = new ParameterSchema(entrypointParamWithoutCallback);
            const parametersCallback = entrypoints[smartContractMethodName].args[1].args[0];
            const smartContractMethodCallbackSchema = new ParameterSchema(parametersCallback);
            validateArgs(args, smartContractMethodSchemaWithoutCallback, smartContractMethodName);
            return new ContractView(currentContract, smartContractMethodName, smartContractMethodCallbackSchema, smartContractMethodSchemaWithoutCallback, args, rpc, readProvider);
          };
          this.views[smartContractMethodName] = view;
        }
      });
      const anonymousMethods = Object.keys(parameterSchema.ExtractSchema()).filter((key) => Object.keys(entrypoints).indexOf(key) === -1);
      anonymousMethods.forEach((smartContractMethodName) => {
        this.methods[smartContractMethodName] = function(...args) {
          return currentContract.contractMethodFactory.createContractMethodFlatParams(parameterSchema, smartContractMethodName, args, false, true);
        };
        this.methodsObject[smartContractMethodName] = function(args) {
          return currentContract.contractMethodFactory.createContractMethodObjectParam(parameterSchema, smartContractMethodName, args, false, true);
        };
      });
    } else {
      const smartContractMethodSchema = this.parameterSchema;
      this.methods[DEFAULT_SMART_CONTRACT_METHOD_NAME] = function(...args) {
        return currentContract.contractMethodFactory.createContractMethodFlatParams(smartContractMethodSchema, DEFAULT_SMART_CONTRACT_METHOD_NAME, args, false);
      };
      this.methodsObject[DEFAULT_SMART_CONTRACT_METHOD_NAME] = function(args) {
        return currentContract.contractMethodFactory.createContractMethodObjectParam(smartContractMethodSchema, DEFAULT_SMART_CONTRACT_METHOD_NAME, args, false);
      };
    }
  }
  _initializeOnChainViews(currentContract, rpc, readProvider, allContractViews) {
    const storageType = this.schema.val;
    allContractViews.forEach((viewSchema) => {
      this.contractViews[viewSchema.viewName] = function(args) {
        return currentContract.contractMethodFactory.createContractViewObjectParam(rpc, readProvider, viewSchema, storageType, args);
      };
    });
  }
  /**
   * @description Return a friendly representation of the smart contract storage
   */
  storage() {
    return this.storageProvider.getStorage(this.address, this.schema);
  }
  /**
   *
   * @description Return a friendly representation of the smart contract big map value
   *
   * @param key BigMap key to fetch
   *
   * @deprecated getBigMapKey has been deprecated in favor of getBigMapKeyByID
   *
   * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get
   */
  bigMap(key) {
    return this.storageProvider.getBigMapKey(this.address, key, this.schema);
  }
};
var setDelegate = (key) => {
  return [
    { prim: "DROP" },
    { prim: "NIL", args: [{ prim: "operation" }] },
    {
      prim: "PUSH",
      args: [{ prim: "key_hash" }, { string: key }]
    },
    { prim: "SOME" },
    { prim: "SET_DELEGATE" },
    { prim: "CONS" }
  ];
};
var transferImplicit = (key, mutez) => {
  return [
    { prim: "DROP" },
    { prim: "NIL", args: [{ prim: "operation" }] },
    {
      prim: "PUSH",
      args: [{ prim: "key_hash" }, { string: key }]
    },
    { prim: "IMPLICIT_ACCOUNT" },
    {
      prim: "PUSH",
      args: [{ prim: "mutez" }, { int: `${mutez}` }]
    },
    { prim: "UNIT" },
    { prim: "TRANSFER_TOKENS" },
    { prim: "CONS" }
  ];
};
var removeDelegate = () => {
  return [
    { prim: "DROP" },
    { prim: "NIL", args: [{ prim: "operation" }] },
    { prim: "NONE", args: [{ prim: "key_hash" }] },
    { prim: "SET_DELEGATE" },
    { prim: "CONS" }
  ];
};
var transferToContract = (key, amount) => {
  return [
    { prim: "DROP" },
    { prim: "NIL", args: [{ prim: "operation" }] },
    {
      prim: "PUSH",
      args: [{ prim: "address" }, { string: key }]
    },
    { prim: "CONTRACT", args: [{ prim: "unit" }] },
    {
      prim: "IF_NONE",
      args: [[{ prim: "UNIT" }, { prim: "FAILWITH" }], []]
    },
    {
      prim: "PUSH",
      args: [{ prim: "mutez" }, { int: `${amount}` }]
    },
    { prim: "UNIT" },
    { prim: "TRANSFER_TOKENS" },
    { prim: "CONS" }
  ];
};
var MANAGER_LAMBDA = {
  setDelegate,
  removeDelegate,
  transferImplicit,
  transferToContract
};
var code = [
  {
    prim: "parameter",
    args: [
      {
        prim: "lambda",
        args: [
          { prim: "unit" },
          {
            prim: "pair",
            args: [{ prim: "list", args: [{ prim: "operation" }] }, { prim: "unit" }]
          }
        ]
      }
    ]
  },
  { prim: "storage", args: [{ prim: "unit" }] },
  { prim: "code", args: [[{ prim: "CAR" }, { prim: "UNIT" }, { prim: "EXEC" }]] }
];
var storage = "Unit";
var VIEW_LAMBDA = {
  code,
  storage
};
function compose(functioncomposer1, functioncomposer2) {
  return (contractAbstraction, context2) => functioncomposer2(functioncomposer1(contractAbstraction, context2), context2);
}
var SaplingStateAbstraction = class {
  constructor(id, provider) {
    this.id = id;
    this.provider = provider;
  }
  /**
   *
   * @description Fetch the sapling state
   *
   * @param block optional block level to fetch the values from (head will be use by default)
   * @returns Return a json object of the sapling_state
   *
   */
  getSaplingDiff(block) {
    return __awaiter4(this, void 0, void 0, function* () {
      return this.provider.getSaplingDiffByID(this.id.toString(), block);
    });
  }
  getId() {
    return this.id.toString();
  }
};
var _counters;
var mergeLimits = (userDefinedLimit, defaultLimits) => {
  var _a3, _b, _c;
  return {
    fee: (_a3 = userDefinedLimit.fee) !== null && _a3 !== void 0 ? _a3 : defaultLimits.fee,
    gasLimit: (_b = userDefinedLimit.gasLimit) !== null && _b !== void 0 ? _b : defaultLimits.gasLimit,
    storageLimit: (_c = userDefinedLimit.storageLimit) !== null && _c !== void 0 ? _c : defaultLimits.storageLimit
  };
};
var PrepareProvider = class extends Provider {
  constructor(context2) {
    super(context2);
    this.context = context2;
    _counters.set(this, void 0);
    __classPrivateFieldSet(this, _counters, {});
  }
  getBlockHash(block) {
    return __awaiter4(this, void 0, void 0, function* () {
      return this.context.readProvider.getBlockHash(block !== null && block !== void 0 ? block : "head~2");
    });
  }
  getProtocolHash() {
    return __awaiter4(this, void 0, void 0, function* () {
      return this.context.readProvider.getNextProtocol("head");
    });
  }
  getHeadCounter(pkh) {
    var _a3;
    return __awaiter4(this, void 0, void 0, function* () {
      return (_a3 = this.context.readProvider.getCounter(pkh, "head")) !== null && _a3 !== void 0 ? _a3 : "0";
    });
  }
  adjustGasForBatchOperation(gasLimitBlock, gaslimitOp, numberOfOps) {
    return bignumber_default.min(gaslimitOp, gasLimitBlock.div(numberOfOps + 1));
  }
  getAccountLimits(pkh, constants, numberOfOps) {
    return __awaiter4(this, void 0, void 0, function* () {
      const balance = yield this.context.readProvider.getBalance(pkh, "head");
      const { hard_gas_limit_per_operation, hard_gas_limit_per_block, hard_storage_limit_per_operation, cost_per_byte } = constants;
      return {
        fee: 0,
        gasLimit: numberOfOps ? Math.floor(this.adjustGasForBatchOperation(hard_gas_limit_per_block, hard_gas_limit_per_operation, numberOfOps).toNumber()) : hard_gas_limit_per_operation.toNumber(),
        storageLimit: Math.floor(bignumber_default.min(balance.dividedBy(cost_per_byte), hard_storage_limit_per_operation).toNumber())
      };
    });
  }
  getFee(op, pkh, headCounter) {
    if (!__classPrivateFieldGet(this, _counters)[pkh] || __classPrivateFieldGet(this, _counters)[pkh] < headCounter) {
      __classPrivateFieldGet(this, _counters)[pkh] = headCounter;
    }
    const opCounter = ++__classPrivateFieldGet(this, _counters)[pkh];
    return {
      counter: `${opCounter}`,
      fee: typeof op.fee === "undefined" ? "0" : `${op.fee}`,
      gas_limit: typeof op.gas_limit === "undefined" ? "0" : `${op.gas_limit}`,
      storage_limit: typeof op.storage_limit === "undefined" ? "0" : `${op.storage_limit}`
    };
  }
  getSource(op, pkh, source) {
    return { source: typeof op.source === "undefined" ? source || pkh : op.source };
  }
  addRevealOperationIfNeeded(operation, publicKeyHash) {
    return __awaiter4(this, void 0, void 0, function* () {
      if (isOpRequireReveal(operation)) {
        const ops = [operation];
        const { publicKey, pkh } = yield this.getKeys();
        if (yield this.isAccountRevealRequired(publicKeyHash)) {
          if (!publicKey) {
            throw new PublicKeyNotFoundError(pkh);
          }
          ops.unshift(yield createRevealOperation({
            fee: DEFAULT_FEE.REVEAL,
            storageLimit: DEFAULT_STORAGE_LIMIT.REVEAL,
            gasLimit: getRevealGasLimit(pkh)
          }, publicKeyHash, publicKey));
          return ops;
        }
      }
      return operation;
    });
  }
  getKeys() {
    return __awaiter4(this, void 0, void 0, function* () {
      const isSignerConfigured = this.context.isAnySignerConfigured();
      return {
        pkh: isSignerConfigured ? yield this.signer.publicKeyHash() : yield this.context.walletProvider.getPKH(),
        publicKey: isSignerConfigured ? yield this.signer.publicKey() : void 0
      };
    });
  }
  convertIntoArray(op) {
    if (Array.isArray(op)) {
      return [...op];
    } else {
      return [op];
    }
  }
  constructOpContents(ops, headCounter, pkh, source, currentVotingPeriod) {
    return ops.map((op) => {
      switch (op.kind) {
        case OpKind.ACTIVATION:
        case OpKind.DRAIN_DELEGATE:
          return Object.assign({}, op);
        case OpKind.ORIGINATION:
          return Object.assign(Object.assign(Object.assign(Object.assign({}, op), { balance: typeof op.balance !== "undefined" ? `${op.balance}` : "0" }), this.getSource(op, pkh, source)), this.getFee(op, pkh, headCounter));
        case OpKind.TRANSACTION: {
          const cops = Object.assign(Object.assign(Object.assign(Object.assign({}, op), { amount: typeof op.amount !== "undefined" ? `${op.amount}` : "0" }), this.getSource(op, pkh, source)), this.getFee(op, pkh, headCounter));
          if (cops.source.toLowerCase().startsWith("kt1")) {
            throw new DeprecationError(`KT1 addresses are not supported as source since ${Protocols.PsBabyM1}`);
          }
          return cops;
        }
        case OpKind.REVEAL:
        case OpKind.DELEGATION:
        case OpKind.REGISTER_GLOBAL_CONSTANT:
        case OpKind.UPDATE_CONSENSUS_KEY:
        case OpKind.SMART_ROLLUP_ADD_MESSAGES:
        case OpKind.SMART_ROLLUP_ORIGINATE:
          return Object.assign(Object.assign(Object.assign({}, op), this.getSource(op, pkh, source)), this.getFee(op, pkh, headCounter));
        case OpKind.TRANSFER_TICKET:
          return Object.assign(Object.assign(Object.assign(Object.assign({}, op), { ticket_amount: `${op.ticket_amount}` }), this.getSource(op, pkh, source)), this.getFee(op, pkh, headCounter));
        case OpKind.INCREASE_PAID_STORAGE:
          return Object.assign(Object.assign(Object.assign(Object.assign({}, op), { amount: `${op.amount}` }), this.getSource(op, pkh, source)), this.getFee(op, pkh, headCounter));
        case OpKind.BALLOT:
          if (currentVotingPeriod === void 0) {
            throw new RPCResponseError(`Failed to get the current voting period index`);
          }
          return Object.assign(Object.assign({}, op), { period: currentVotingPeriod === null || currentVotingPeriod === void 0 ? void 0 : currentVotingPeriod.voting_period.index });
        case OpKind.PROPOSALS:
          if (currentVotingPeriod === void 0) {
            throw new RPCResponseError(`Failed to get the current voting period index`);
          }
          return Object.assign(Object.assign({}, op), { period: currentVotingPeriod === null || currentVotingPeriod === void 0 ? void 0 : currentVotingPeriod.voting_period.index });
        default:
          throw new InvalidOperationKindError(op.kind);
      }
    });
  }
  /**
   *
   * @description Method to prepare an activation operation
   * @param operation RPCOperation object or RPCOperation array
   * @param source string or undefined source pkh
   * @returns a PreparedOperation object
   */
  activate({ pkh, secret }) {
    return __awaiter4(this, void 0, void 0, function* () {
      const op = yield createActivationOperation({
        pkh,
        secret
      });
      const ops = this.convertIntoArray(op);
      const hash2 = yield this.getBlockHash();
      const protocol = yield this.getProtocolHash();
      __classPrivateFieldSet(this, _counters, {});
      const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
      const contents = this.constructOpContents(ops, headCounter, pkh);
      return {
        opOb: {
          branch: hash2,
          contents,
          protocol
        },
        counter: headCounter
      };
    });
  }
  /**
   *
   * @description Method to prepare a reveal operation
   * @param operation RPCOperation object or RPCOperation array
   * @param source string or undefined source pkh
   * @returns a PreparedOperation object
   */
  reveal({ fee, gasLimit, storageLimit }) {
    return __awaiter4(this, void 0, void 0, function* () {
      const { pkh, publicKey } = yield this.getKeys();
      if (!publicKey) {
        throw new PublicKeyNotFoundError(pkh);
      }
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
      const mergedEstimates = mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS);
      const op = yield createRevealOperation({
        fee: mergedEstimates.fee,
        gasLimit: mergedEstimates.gasLimit,
        storageLimit: mergedEstimates.storageLimit
      }, pkh, publicKey);
      const ops = this.convertIntoArray(op);
      const hash2 = yield this.getBlockHash();
      const protocol = yield this.getProtocolHash();
      __classPrivateFieldSet(this, _counters, {});
      const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
      const contents = this.constructOpContents(ops, headCounter, pkh);
      return {
        opOb: {
          branch: hash2,
          contents,
          protocol
        },
        counter: headCounter
      };
    });
  }
  /**
   *
   * @description Method to prepare an origination operation
   * @param operation RPCOperation object or RPCOperation array
   * @param source string or undefined source pkh
   * @returns a PreparedOperation object
   */
  originate(_a3, source) {
    var { fee, storageLimit, gasLimit } = _a3, rest = __rest2(_a3, ["fee", "storageLimit", "gasLimit"]);
    return __awaiter4(this, void 0, void 0, function* () {
      const { pkh } = yield this.getKeys();
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
      const op = yield createOriginationOperation(yield this.context.parser.prepareCodeOrigination(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS))));
      const operation = yield this.addRevealOperationIfNeeded(op, pkh);
      const ops = this.convertIntoArray(operation);
      const hash2 = yield this.getBlockHash();
      const protocol = yield this.getProtocolHash();
      __classPrivateFieldSet(this, _counters, {});
      const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
      const contents = this.constructOpContents(ops, headCounter, pkh, source);
      return {
        opOb: {
          branch: hash2,
          contents,
          protocol
        },
        counter: headCounter
      };
    });
  }
  /**
   *
   * @description Method to prepare a transaction operation
   * @param operation RPCOperation object or RPCOperation array
   * @param source string or undefined source pkh
   * @returns a PreparedOperation object
   */
  transaction(_a3) {
    var { fee, storageLimit, gasLimit } = _a3, rest = __rest2(_a3, ["fee", "storageLimit", "gasLimit"]);
    return __awaiter4(this, void 0, void 0, function* () {
      const { pkh } = yield this.getKeys();
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
      const op = yield createTransferOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
      const operation = yield this.addRevealOperationIfNeeded(op, pkh);
      const ops = this.convertIntoArray(operation);
      const hash2 = yield this.getBlockHash();
      const protocol = yield this.getProtocolHash();
      __classPrivateFieldSet(this, _counters, {});
      const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
      const contents = this.constructOpContents(ops, headCounter, pkh, rest.source);
      return {
        opOb: {
          branch: hash2,
          contents,
          protocol
        },
        counter: headCounter
      };
    });
  }
  /**
   *
   * @description Method to prepare a delegation operation
   * @param operation RPCOperation object or RPCOperation array
   * @param source string or undefined source pkh
   * @returns a PreparedOperation object
   */
  delegation(_a3) {
    var { fee, storageLimit, gasLimit } = _a3, rest = __rest2(_a3, ["fee", "storageLimit", "gasLimit"]);
    return __awaiter4(this, void 0, void 0, function* () {
      const { pkh } = yield this.getKeys();
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
      const op = yield createSetDelegateOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
      const operation = yield this.addRevealOperationIfNeeded(op, pkh);
      const ops = this.convertIntoArray(operation);
      const hash2 = yield this.getBlockHash();
      const protocol = yield this.getProtocolHash();
      __classPrivateFieldSet(this, _counters, {});
      const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
      const contents = this.constructOpContents(ops, headCounter, pkh, rest.source);
      return {
        opOb: {
          branch: hash2,
          contents,
          protocol
        },
        counter: headCounter
      };
    });
  }
  /**
   *
   * @description Method to prepare a register delegate operation
   * @param operation RPCOperation object or RPCOperation array
   * @param source string or undefined source pkh
   * @returns a PreparedOperation object
   */
  registerDelegate({ fee, storageLimit, gasLimit }, source) {
    return __awaiter4(this, void 0, void 0, function* () {
      const { pkh } = yield this.getKeys();
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
      const mergedEstimates = mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS);
      const op = yield createRegisterDelegateOperation({
        fee: mergedEstimates.fee,
        storageLimit: mergedEstimates.storageLimit,
        gasLimit: mergedEstimates.gasLimit
      }, pkh);
      const operation = yield this.addRevealOperationIfNeeded(op, pkh);
      const ops = this.convertIntoArray(operation);
      const hash2 = yield this.getBlockHash();
      const protocol = yield this.getProtocolHash();
      __classPrivateFieldSet(this, _counters, {});
      const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
      const contents = this.constructOpContents(ops, headCounter, pkh, source);
      return {
        opOb: {
          branch: hash2,
          contents,
          protocol
        },
        counter: headCounter
      };
    });
  }
  /**
   *
   * @description Method to prepare a register_global_constant operation
   * @param operation RPCOperation object or RPCOperation array
   * @param source string or undefined source pkh
   * @returns a PreparedOperation object
   */
  registerGlobalConstant(_a3) {
    var { fee, storageLimit, gasLimit } = _a3, rest = __rest2(_a3, ["fee", "storageLimit", "gasLimit"]);
    return __awaiter4(this, void 0, void 0, function* () {
      const { pkh } = yield this.getKeys();
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
      const op = yield createRegisterGlobalConstantOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
      const operation = yield this.addRevealOperationIfNeeded(op, pkh);
      const ops = this.convertIntoArray(operation);
      const hash2 = yield this.getBlockHash();
      const protocol = yield this.getProtocolHash();
      __classPrivateFieldSet(this, _counters, {});
      const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
      const contents = this.constructOpContents(ops, headCounter, pkh, rest.source);
      return {
        opOb: {
          branch: hash2,
          contents,
          protocol
        },
        counter: headCounter
      };
    });
  }
  /**
   *
   * @description Method to prepare an update_consensus_key operation
   * @param operation RPCOperation object or RPCOperation array
   * @param source string or undefined source pkh
   * @returns a PreparedOperation object
   */
  updateConsensusKey(_a3, source) {
    var { fee, storageLimit, gasLimit } = _a3, rest = __rest2(_a3, ["fee", "storageLimit", "gasLimit"]);
    return __awaiter4(this, void 0, void 0, function* () {
      const { pkh } = yield this.getKeys();
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
      const op = yield createUpdateConsensusKeyOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
      const operation = yield this.addRevealOperationIfNeeded(op, pkh);
      const ops = this.convertIntoArray(operation);
      const hash2 = yield this.getBlockHash();
      const protocol = yield this.getProtocolHash();
      __classPrivateFieldSet(this, _counters, {});
      const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
      const contents = this.constructOpContents(ops, headCounter, pkh, source);
      return {
        opOb: {
          branch: hash2,
          contents,
          protocol
        },
        counter: headCounter
      };
    });
  }
  /**
   *
   * @description Method to prepare an increase_paid_storage operation
   * @param operation RPCOperation object or RPCOperation array
   * @param source string or undefined source pkh
   * @returns a PreparedOperation object
   */
  increasePaidStorage(_a3) {
    var { fee, storageLimit, gasLimit } = _a3, rest = __rest2(_a3, ["fee", "storageLimit", "gasLimit"]);
    return __awaiter4(this, void 0, void 0, function* () {
      const { pkh } = yield this.getKeys();
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
      const op = yield createIncreasePaidStorageOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
      const operation = yield this.addRevealOperationIfNeeded(op, pkh);
      const ops = this.convertIntoArray(operation);
      const hash2 = yield this.getBlockHash();
      const protocol = yield this.getProtocolHash();
      __classPrivateFieldSet(this, _counters, {});
      const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
      const contents = this.constructOpContents(ops, headCounter, pkh, rest.source);
      return {
        opOb: {
          branch: hash2,
          contents,
          protocol
        },
        counter: headCounter
      };
    });
  }
  /**
   *
   * @description Method to prepare a ballot operation
   * @param operation RPCOperation object or RPCOperation array
   * @returns a PreparedOperation object
   */
  ballot(params) {
    return __awaiter4(this, void 0, void 0, function* () {
      const { pkh } = yield this.getKeys();
      const op = yield createBallotOperation(Object.assign({}, params));
      const ops = this.convertIntoArray(op);
      const hash2 = yield this.getBlockHash();
      const protocol = yield this.getProtocolHash();
      __classPrivateFieldSet(this, _counters, {});
      const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
      let currentVotingPeriod;
      try {
        currentVotingPeriod = yield this.rpc.getCurrentPeriod();
      } catch (e) {
        throw new RPCResponseError("Failed to get the current voting period index");
      }
      const contents = this.constructOpContents(ops, headCounter, pkh, void 0, currentVotingPeriod);
      return {
        opOb: {
          branch: hash2,
          contents,
          protocol
        },
        counter: headCounter
      };
    });
  }
  /**
   *
   * @description Method to prepare a proposals operation
   * @param operation RPCOperation object or RPCOperation array
   * @returns a PreparedOperation object
   */
  proposals(params) {
    return __awaiter4(this, void 0, void 0, function* () {
      const { pkh } = yield this.getKeys();
      const op = yield createProposalsOperation(Object.assign({}, params));
      const ops = this.convertIntoArray(op);
      const hash2 = yield this.getBlockHash();
      const protocol = yield this.getProtocolHash();
      __classPrivateFieldSet(this, _counters, {});
      const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
      let currentVotingPeriod;
      try {
        currentVotingPeriod = yield this.rpc.getCurrentPeriod();
      } catch (e) {
        throw new RPCResponseError("Failed to get the current voting period index");
      }
      const contents = this.constructOpContents(ops, headCounter, pkh, void 0, currentVotingPeriod);
      return {
        opOb: {
          branch: hash2,
          contents,
          protocol
        },
        counter: headCounter
      };
    });
  }
  /**
   *
   * @description Method to prepare a drain_delegate operation
   * @param operation RPCOperation object or RPCOperation array
   * @returns a PreparedOperation object
   */
  drainDelegate(params, source) {
    return __awaiter4(this, void 0, void 0, function* () {
      const { pkh } = yield this.getKeys();
      const op = yield createDrainDelegateOperation(Object.assign({}, params));
      const ops = this.convertIntoArray(op);
      const hash2 = yield this.getBlockHash();
      const protocol = yield this.getProtocolHash();
      __classPrivateFieldSet(this, _counters, {});
      const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
      const contents = this.constructOpContents(ops, headCounter, pkh, source);
      return {
        opOb: {
          branch: hash2,
          contents,
          protocol
        },
        counter: headCounter
      };
    });
  }
  /**
   *
   * @description Method to prepare a transfer_ticket operation
   * @param operation RPCOperation object or RPCOperation array
   * @param source string or undefined source pkh
   * @returns a PreparedOperation object
   */
  transferTicket(_a3) {
    var { fee, storageLimit, gasLimit } = _a3, rest = __rest2(_a3, ["fee", "storageLimit", "gasLimit"]);
    return __awaiter4(this, void 0, void 0, function* () {
      const { pkh } = yield this.getKeys();
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
      const op = yield createTransferTicketOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
      const operation = yield this.addRevealOperationIfNeeded(op, pkh);
      const ops = this.convertIntoArray(operation);
      const hash2 = yield this.getBlockHash();
      const protocol = yield this.getProtocolHash();
      __classPrivateFieldSet(this, _counters, {});
      const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
      const contents = this.constructOpContents(ops, headCounter, pkh, rest.source);
      return {
        opOb: {
          branch: hash2,
          contents,
          protocol
        },
        counter: headCounter
      };
    });
  }
  /**
   *
   * @description Method to prepare a smart_rollup_add_messages operation
   * @param operation RPCOperation object or RPCOperation array
   * @param source string or undefined source pkh
   * @returns a PreparedOperation object
   */
  smartRollupAddMessages(_a3) {
    var { fee, storageLimit, gasLimit } = _a3, rest = __rest2(_a3, ["fee", "storageLimit", "gasLimit"]);
    return __awaiter4(this, void 0, void 0, function* () {
      const { pkh } = yield this.getKeys();
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
      const op = yield createSmartRollupAddMessagesOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
      const operation = yield this.addRevealOperationIfNeeded(op, pkh);
      const ops = this.convertIntoArray(operation);
      const hash2 = yield this.getBlockHash();
      const protocol = yield this.getProtocolHash();
      __classPrivateFieldSet(this, _counters, {});
      const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
      const contents = this.constructOpContents(ops, headCounter, pkh, rest.source);
      return {
        opOb: {
          branch: hash2,
          contents,
          protocol
        },
        counter: headCounter
      };
    });
  }
  /**
   *
   * @description Method to prepare a smart_rollup_originate operation
   * @param operation RPCOperation object or RPCOperation array
   * @returns a PreparedOperation object
   */
  smartRollupOriginate(_a3) {
    var { fee, storageLimit, gasLimit } = _a3, rest = __rest2(_a3, ["fee", "storageLimit", "gasLimit"]);
    return __awaiter4(this, void 0, void 0, function* () {
      const { pkh } = yield this.getKeys();
      const originationProof = yield this.rpc.getOriginationProof({
        kind: rest.pvmKind,
        kernel: rest.kernel
      });
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
      const op = yield createSmartRollupOriginateOperation(Object.assign(Object.assign(Object.assign({}, mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)), rest), { originationProof }));
      const operation = yield this.addRevealOperationIfNeeded(op, pkh);
      const ops = this.convertIntoArray(operation);
      const hash2 = yield this.getBlockHash();
      const protocol = yield this.getProtocolHash();
      __classPrivateFieldSet(this, _counters, {});
      const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
      const contents = this.constructOpContents(ops, headCounter, pkh, rest.source);
      return {
        opOb: {
          branch: hash2,
          contents,
          protocol
        },
        counter: headCounter
      };
    });
  }
  /**
   *
   * @description Method to prepare a batch operation
   * @param operation RPCOperation object or RPCOperation array
   * @returns a PreparedOperation object
   */
  batch(batchParams, estimates) {
    return __awaiter4(this, void 0, void 0, function* () {
      const { pkh, publicKey } = yield this.getKeys();
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants, batchParams.length);
      const revealNeeded = yield this.isRevealOpNeeded(batchParams, pkh);
      const ops = [];
      if (!estimates) {
        for (const op of batchParams) {
          if (isOpWithFee(op)) {
            const limits = mergeLimits(op, DEFAULT_PARAMS);
            ops.push(yield this.getRPCOp(Object.assign(Object.assign({}, op), limits)));
          } else {
            ops.push(Object.assign({}, op));
          }
        }
      } else {
        for (const op of batchParams) {
          if (isOpWithFee(op)) {
            const e = estimates.shift();
            const limits = mergeLimits(op, {
              fee: e.suggestedFeeMutez,
              storageLimit: e.storageLimit,
              gasLimit: e.gasLimit
            });
            ops.push(yield this.getRPCOp(Object.assign(Object.assign({}, op), limits)));
          } else {
            ops.push(Object.assign({}, op));
          }
        }
      }
      if (revealNeeded) {
        if (!publicKey) {
          throw new PublicKeyNotFoundError(pkh);
        }
        ops.unshift(yield createRevealOperation({
          fee: DEFAULT_FEE.REVEAL,
          storageLimit: DEFAULT_STORAGE_LIMIT.REVEAL,
          gasLimit: getRevealGasLimit(pkh)
        }, pkh, publicKey));
      }
      const hash2 = yield this.getBlockHash();
      const protocol = yield this.getProtocolHash();
      __classPrivateFieldSet(this, _counters, {});
      const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
      const contents = this.constructOpContents(ops, headCounter, pkh);
      return {
        opOb: {
          branch: hash2,
          contents,
          protocol
        },
        counter: headCounter
      };
    });
  }
  /**
   *
   * @description Method to prepare a batch operation
   * @param operation RPCOperation object or RPCOperation array
   * @returns a PreparedOperation object
   */
  contractCall(contractMethod) {
    var _a3, _b, _c;
    return __awaiter4(this, void 0, void 0, function* () {
      const hash2 = yield this.getBlockHash();
      const protocol = yield this.getProtocolHash();
      const { pkh } = yield this.getKeys();
      __classPrivateFieldSet(this, _counters, {});
      const headCounter = parseInt(yield this.getHeadCounter(pkh), 10);
      const params = contractMethod.toTransferParams();
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
      const estimateLimits = mergeLimits({
        fee: params.fee,
        storageLimit: params.storageLimit,
        gasLimit: params.gasLimit
      }, DEFAULT_PARAMS);
      const op = {
        kind: OpKind.TRANSACTION,
        fee: (_a3 = params.fee) !== null && _a3 !== void 0 ? _a3 : estimateLimits.fee,
        gas_limit: (_b = params.gasLimit) !== null && _b !== void 0 ? _b : estimateLimits.gasLimit,
        storage_limit: (_c = params.storageLimit) !== null && _c !== void 0 ? _c : estimateLimits.storageLimit,
        amount: String(params.amount),
        destination: params.to,
        parameters: params.parameter
      };
      const operation = yield this.addRevealOperationIfNeeded(op, pkh);
      const ops = this.convertIntoArray(operation);
      const contents = this.constructOpContents(ops, headCounter, pkh);
      return {
        opOb: {
          branch: hash2,
          contents,
          protocol
        },
        counter: headCounter
      };
    });
  }
  /**
   *
   * @description Method to convert a PreparedOperation to the params needed for the preapplyOperation method
   * @param prepared a Prepared Operation
   * @returns a PreapplyParams object
   */
  toPreapply(prepared) {
    return __awaiter4(this, void 0, void 0, function* () {
      const { opOb: { contents, branch, protocol } } = prepared;
      const forgeParams = this.toForge(prepared);
      const forged = yield this.context.forger.forge(forgeParams);
      const sig = yield this.context.signer.sign(forged, new Uint8Array([3]));
      return [{ contents, branch, protocol, signature: sig.prefixSig }];
    });
  }
  /**
   *
   * @description Method to convert a PreparedOperation to the params needed for forging
   * @param param a Prepared Operation
   * @returns a ForgeParams object
   */
  toForge({ opOb: { contents, branch } }) {
    return {
      branch,
      contents
    };
  }
};
_counters = /* @__PURE__ */ new WeakMap();
var BATCH_KINDS = [
  OpKind.ACTIVATION,
  OpKind.ORIGINATION,
  OpKind.TRANSACTION,
  OpKind.DELEGATION
];
var OperationBatch = class extends Provider {
  constructor(context2, estimator) {
    super(context2);
    this.estimator = estimator;
    this.operations = [];
    this.prepare = new PrepareProvider(this.context);
  }
  /**
   *
   * @description Add a transaction operation to the batch
   *
   * @param params Transfer operation parameter
   */
  withTransfer(params) {
    const toValidation = validateAddress(params.to);
    if (params.amount < 0) {
      throw new InvalidAmountError(params.amount.toString());
    }
    if (toValidation !== ValidationResult.VALID) {
      throw new InvalidAddressError(params.to, invalidDetail(toValidation));
    }
    this.operations.push(Object.assign({ kind: OpKind.TRANSACTION }, params));
    return this;
  }
  /**
   *
   * @description Transfer tickets from a Tezos address (tz1,tz2 or tz3) to a smart contract address( KT1)
   *
   * @param params Transfer operation parameter
   */
  withTransferTicket(params) {
    const destinationValidation = validateAddress(params.destination);
    if (destinationValidation !== ValidationResult.VALID) {
      throw new InvalidAddressError(params.destination, invalidDetail(destinationValidation));
    }
    this.operations.push(Object.assign({ kind: OpKind.TRANSFER_TICKET }, params));
    return this;
  }
  /**
   *
   * @description Add a contract call to the batch
   *
   * @param params Call a contract method
   * @param options Generic operation parameters
   */
  withContractCall(params, options = {}) {
    return this.withTransfer(params.toTransferParams(options));
  }
  /**
   *
   * @description Add a delegation operation to the batch
   *
   * @param params Delegation operation parameter
   */
  withDelegation(params) {
    var _a3;
    const sourceValidation = validateAddress(params.source);
    if (params.source && sourceValidation !== ValidationResult.VALID) {
      throw new InvalidAddressError(params.source, invalidDetail(sourceValidation));
    }
    const delegateValidation = validateAddress((_a3 = params.delegate) !== null && _a3 !== void 0 ? _a3 : "");
    if (params.delegate && delegateValidation !== ValidationResult.VALID) {
      throw new InvalidAddressError(params.delegate, invalidDetail(delegateValidation));
    }
    this.operations.push(Object.assign({ kind: OpKind.DELEGATION }, params));
    return this;
  }
  /**
   *
   * @description Add an activation operation to the batch
   *
   * @param params Activation operation parameter
   * @throws {@link InvalidKeyHashError}
   */
  withActivation({ pkh, secret }) {
    const pkhValidation = validateKeyHash(pkh);
    if (pkhValidation !== ValidationResult.VALID) {
      throw new InvalidKeyHashError(pkh, invalidDetail(pkhValidation));
    }
    this.operations.push({ kind: OpKind.ACTIVATION, pkh, secret });
    return this;
  }
  /**
   *
   * @description Add an origination operation to the batch
   *
   * @param params Origination operation parameter
   */
  withOrigination(params) {
    this.operations.push(Object.assign({ kind: OpKind.ORIGINATION }, params));
    return this;
  }
  /**
   *
   * @description Add a register a global constant operation to the batch
   *
   * @param params RegisterGlobalConstant operation parameter
   */
  withRegisterGlobalConstant(params) {
    this.operations.push(Object.assign({ kind: OpKind.REGISTER_GLOBAL_CONSTANT }, params));
    return this;
  }
  /**
   *
   * @description Add an increase paid storage operation to the batch
   *
   * @param params IncreasePaidStorage operation parameter
   */
  withIncreasePaidStorage(params) {
    this.operations.push(Object.assign({ kind: OpKind.INCREASE_PAID_STORAGE }, params));
    return this;
  }
  /**
   *
   * @description Add a smart rollup add messages operation to the batch
   *
   * @param params Rollup origination operation parameter
   */
  withSmartRollupAddMessages(params) {
    this.operations.push(Object.assign({ kind: OpKind.SMART_ROLLUP_ADD_MESSAGES }, params));
    return this;
  }
  /**
   *
   * @description Add a smart rollup originate operation to the batch
   *
   * @param params Smart Rollup Originate operation parameter
   */
  withSmartRollupOriginate(params) {
    this.operations.push(Object.assign({ kind: OpKind.SMART_ROLLUP_ORIGINATE }, params));
    return this;
  }
  getRPCOp(param) {
    return __awaiter4(this, void 0, void 0, function* () {
      switch (param.kind) {
        case OpKind.TRANSACTION:
          return createTransferOperation(Object.assign({}, param));
        case OpKind.ORIGINATION:
          return createOriginationOperation(yield this.context.parser.prepareCodeOrigination(Object.assign({}, param)));
        case OpKind.DELEGATION:
          return createSetDelegateOperation(Object.assign({}, param));
        case OpKind.REGISTER_GLOBAL_CONSTANT:
          return createRegisterGlobalConstantOperation(Object.assign({}, param));
        case OpKind.INCREASE_PAID_STORAGE:
          return createIncreasePaidStorageOperation(Object.assign({}, param));
        case OpKind.TRANSFER_TICKET:
          return createTransferTicketOperation(Object.assign({}, param));
        case OpKind.SMART_ROLLUP_ADD_MESSAGES:
          return createSmartRollupAddMessagesOperation(Object.assign({}, param));
        case OpKind.SMART_ROLLUP_ORIGINATE:
          return createSmartRollupOriginateOperation(Object.assign({}, param));
        default:
          throw new InvalidOperationKindError(JSON.stringify(param.kind));
      }
    });
  }
  /**
   *
   * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array
   *
   * @param params Operations parameter
   * @throws {@link InvalidOperationKindError}
   */
  with(params) {
    for (const param of params) {
      switch (param.kind) {
        case OpKind.TRANSACTION:
          this.withTransfer(param);
          break;
        case OpKind.ORIGINATION:
          this.withOrigination(param);
          break;
        case OpKind.DELEGATION:
          this.withDelegation(param);
          break;
        case OpKind.ACTIVATION:
          this.withActivation(param);
          break;
        case OpKind.REGISTER_GLOBAL_CONSTANT:
          this.withRegisterGlobalConstant(param);
          break;
        case OpKind.INCREASE_PAID_STORAGE:
          this.withIncreasePaidStorage(param);
          break;
        case OpKind.TRANSFER_TICKET:
          this.withTransferTicket(param);
          break;
        case OpKind.SMART_ROLLUP_ADD_MESSAGES:
          this.withSmartRollupAddMessages(param);
          break;
        case OpKind.SMART_ROLLUP_ORIGINATE:
          this.withSmartRollupOriginate(param);
          break;
        default:
          throw new InvalidOperationKindError(JSON.stringify(param.kind));
      }
    }
    return this;
  }
  /**
   *
   * @description Forge and Inject the operation batch
   *
   * @param params Optionally specify the source of the operation
   */
  send(params) {
    return __awaiter4(this, void 0, void 0, function* () {
      const publicKeyHash = yield this.signer.publicKeyHash();
      const source = params && params.source || publicKeyHash;
      const estimates = yield this.estimator.batch(this.operations);
      if (estimates.length !== this.operations.length) {
        estimates.shift();
      }
      const preparedOp = yield this.prepare.batch(this.operations, estimates);
      const opBytes = yield this.forge(preparedOp);
      const { hash: hash2, context: context2, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
      return new BatchOperation(hash2, preparedOp.opOb.contents, source, forgedBytes, opResponse, context2);
    });
  }
};
var RPCBatchProvider = class {
  constructor(context2, estimator) {
    this.context = context2;
    this.estimator = estimator;
  }
  /***
   *
   * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch
   *
   * @param params List of operation to batch together
   */
  batch(params) {
    const batch = new OperationBatch(this.context, this.estimator);
    if (Array.isArray(params)) {
      batch.with(params);
    }
    return batch;
  }
};
var BatchWalletOperation = class extends WalletOperation {
  constructor(opHash, context2, newHead$) {
    super(opHash, context2, newHead$);
    this.opHash = opHash;
    this.context = context2;
    this.getOriginatedContractAddresses = () => __awaiter4(this, void 0, void 0, function* () {
      const opResult = yield this.operationResults();
      if (!opResult) {
        throw new ObservableError("Unable to fetch operation results");
      } else {
        const originationOpResults = opResult.filter((x) => x.kind === "origination");
        let addresses = [];
        for (const res of originationOpResults) {
          if (res.metadata.operation_result.originated_contracts) {
            addresses = [...addresses, ...res.metadata.operation_result.originated_contracts];
          }
        }
        return addresses;
      }
    });
  }
  revealOperation() {
    return __awaiter4(this, void 0, void 0, function* () {
      const operationResult = yield this.operationResults();
      if (!operationResult) {
        throw new ObservableError("Unable to fetch operation results");
      } else {
        return operationResult.find((x) => x.kind === OpKind.REVEAL);
      }
    });
  }
  status() {
    return __awaiter4(this, void 0, void 0, function* () {
      if (!this._included) {
        return "pending";
      }
      const op = yield this.operationResults();
      if (op) {
        return op.filter((result) => BATCH_KINDS.indexOf(result.kind) !== -1).map((result) => {
          if (hasMetadataWithResult(result)) {
            const opResult = result.metadata.operation_result;
            return opResult.status;
          } else {
            return "unknown";
          }
        })[0] || "unknown";
      } else {
        throw new ObservableError("Unable to fetch operation results");
      }
    });
  }
};
var IncreasePaidStorageWalletOperation = class extends WalletOperation {
  constructor(opHash, context2, newHead$) {
    super(opHash, context2, newHead$);
    this.opHash = opHash;
    this.context = context2;
  }
  revealOperation() {
    return __awaiter4(this, void 0, void 0, function* () {
      const operationResult = yield this.operationResults();
      if (!operationResult) {
        throw new ObservableError("Unable to fetch operation result");
      } else {
        return operationResult.find((x) => x.kind === OpKind.REVEAL);
      }
    });
  }
  increasePaidStorageOperation() {
    return __awaiter4(this, void 0, void 0, function* () {
      const operationResult = yield this.operationResults();
      if (!operationResult) {
        throw new ObservableError("Unable to fetch operation result");
      } else {
        return operationResult.find((x) => x.kind === OpKind.INCREASE_PAID_STORAGE);
      }
    });
  }
  status() {
    return __awaiter4(this, void 0, void 0, function* () {
      if (!this._included) {
        return "pending";
      }
      const op = yield this.increasePaidStorageOperation();
      if (!op) {
        return "unknown";
      }
      return op.metadata.operation_result.status;
    });
  }
};
function timeoutAfter(timeoutMillisec) {
  return function inner(source) {
    return new BehaviorSubject(null).pipe(timeout({
      each: timeoutMillisec,
      with: () => throwError(() => new ConfirmationTimeoutError(`Confirmation polling timed out`))
    }), mergeMap(() => source));
  };
}
var createNewPollingBasedHeadObservable = (sharedHeadOb, context2, _scheduler) => {
  return sharedHeadOb.pipe(timeoutAfter(context2.config.confirmationPollingTimeoutSecond * 1e3), share({
    connector: () => new ReplaySubject(1),
    resetOnError: false,
    resetOnComplete: false,
    resetOnRefCountZero: false
  }));
};
var OperationFactory = class {
  constructor(context2) {
    this.context = context2;
    this.sharedHeadObs = defer(() => {
      return createObservableFromSubscription(this.context.stream.subscribeBlock("head"));
    });
  }
  createNewHeadObservable() {
    return __awaiter4(this, void 0, void 0, function* () {
      return createNewPollingBasedHeadObservable(this.sharedHeadObs, this.context);
    });
  }
  createPastBlockWalker(startBlock, count2 = 1) {
    return from(this.context.readProvider.getBlock(startBlock)).pipe(switchMap((block) => {
      if (count2 === 1) {
        return of(block);
      }
      return range(block.header.level, count2 - 1).pipe(startWith(block), concatMap((level) => __awaiter4(this, void 0, void 0, function* () {
        return this.context.readProvider.getBlock(typeof level === "number" ? level : level.header.level);
      })));
    }));
  }
  createHeadObservableFromConfig({ blockIdentifier }) {
    return __awaiter4(this, void 0, void 0, function* () {
      const observableSequence = [];
      if (blockIdentifier) {
        observableSequence.push(this.createPastBlockWalker(blockIdentifier));
      }
      observableSequence.push(yield this.createNewHeadObservable());
      return concat(...observableSequence);
    });
  }
  createOperation(hash2, config2 = {}) {
    return __awaiter4(this, void 0, void 0, function* () {
      return new WalletOperation(hash2, this.context.clone(), yield this.createHeadObservableFromConfig(config2));
    });
  }
  createBatchOperation(hash2, config2 = {}) {
    return __awaiter4(this, void 0, void 0, function* () {
      return new BatchWalletOperation(hash2, this.context.clone(), yield this.createHeadObservableFromConfig(config2));
    });
  }
  createTransactionOperation(hash2, config2 = {}) {
    return __awaiter4(this, void 0, void 0, function* () {
      return new TransactionWalletOperation(hash2, this.context.clone(), yield this.createHeadObservableFromConfig(config2));
    });
  }
  createDelegationOperation(hash2, config2 = {}) {
    return __awaiter4(this, void 0, void 0, function* () {
      return new DelegationWalletOperation(hash2, this.context.clone(), yield this.createHeadObservableFromConfig(config2));
    });
  }
  createOriginationOperation(hash2, config2 = {}) {
    return __awaiter4(this, void 0, void 0, function* () {
      return new OriginationWalletOperation(hash2, this.context.clone(), yield this.createHeadObservableFromConfig(config2));
    });
  }
  createIncreasePaidStorageOperation(hash2, config2 = {}) {
    return __awaiter4(this, void 0, void 0, function* () {
      return new IncreasePaidStorageWalletOperation(hash2, this.context.clone(), yield this.createHeadObservableFromConfig(config2));
    });
  }
};
var RpcTzProvider = class extends Provider {
  constructor(context2) {
    super(context2);
    this.prepare = new PrepareProvider(this.context);
  }
  getBalance(address) {
    return __awaiter4(this, void 0, void 0, function* () {
      const addressValidation = validateAddress(address);
      if (addressValidation !== ValidationResult.VALID) {
        throw new InvalidAddressError(address, invalidDetail(addressValidation));
      }
      return this.context.readProvider.getBalance(address, "head");
    });
  }
  getDelegate(address) {
    return __awaiter4(this, void 0, void 0, function* () {
      const addressValidation = validateAddress(address);
      if (addressValidation !== ValidationResult.VALID) {
        throw new InvalidAddressError(address, invalidDetail(addressValidation));
      }
      return this.context.readProvider.getDelegate(address, "head");
    });
  }
  activate(pkh, secret) {
    return __awaiter4(this, void 0, void 0, function* () {
      const pkhValidation = validateKeyHash(pkh);
      if (pkhValidation !== ValidationResult.VALID) {
        throw new InvalidKeyHashError(pkh, invalidDetail(pkhValidation));
      }
      const prepared = yield this.prepare.activate({ pkh, secret });
      const forgedBytes = yield this.forge(prepared);
      const bytes = `${forgedBytes.opbytes}00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`;
      return new Operation(yield this.rpc.injectOperation(bytes), Object.assign(Object.assign({}, forgedBytes), { opbytes: bytes }), [], this.context.clone());
    });
  }
};
var MINIMAL_FEE_MUTEZ = 100;
var MINIMAL_FEE_PER_BYTE_MUTEZ = 1;
var MINIMAL_FEE_PER_GAS_MUTEZ = 0.1;
var GAS_BUFFER = 100;
var Estimate = class _Estimate {
  constructor(_milligasLimit, _storageLimit, opSize, minimalFeePerStorageByteMutez, baseFeeMutez = MINIMAL_FEE_MUTEZ) {
    this._milligasLimit = _milligasLimit;
    this._storageLimit = _storageLimit;
    this.opSize = opSize;
    this.minimalFeePerStorageByteMutez = minimalFeePerStorageByteMutez;
    this.baseFeeMutez = baseFeeMutez;
  }
  /**
   * @description The number of Mutez that will be burned for the storage of the [operation](https://tezos.gitlab.io/user/glossary.html#operations). (Storage + Allocation fees)
   */
  get burnFeeMutez() {
    return this.roundUp(Number(this.storageLimit) * Number(this.minimalFeePerStorageByteMutez));
  }
  /**
   * @description  The limit on the amount of storage an [operation](https://tezos.gitlab.io/user/glossary.html#operations) can use.
   */
  get storageLimit() {
    const limit = Math.max(Number(this._storageLimit), 0);
    return limit > 0 ? limit : 0;
  }
  /**
   * @description The limit on the amount of [gas](https://tezos.gitlab.io/user/glossary.html#gas) a given operation can consume.
   */
  get gasLimit() {
    return this.roundUp(Number(this._milligasLimit) / 1e3 + GAS_BUFFER);
  }
  get operationFeeMutez() {
    return (Number(this._milligasLimit) / 1e3 + GAS_BUFFER) * MINIMAL_FEE_PER_GAS_MUTEZ + Number(this.opSize) * MINIMAL_FEE_PER_BYTE_MUTEZ;
  }
  roundUp(nanotez) {
    return Math.ceil(Number(nanotez));
  }
  /**
   * @description Minimum fees for the [operation](https://tezos.gitlab.io/user/glossary.html#operations) according to [baker](https://tezos.gitlab.io/user/glossary.html#baker) defaults.
   */
  get minimalFeeMutez() {
    return this.roundUp(MINIMAL_FEE_MUTEZ + this.operationFeeMutez);
  }
  /**
   * @description The suggested fee for the operation which includes minimal fees and a small buffer.
   */
  get suggestedFeeMutez() {
    return this.roundUp(this.operationFeeMutez + MINIMAL_FEE_MUTEZ * 2);
  }
  /**
   * @description Fees according to your specified base fee will ensure that at least minimum fees are used.
   */
  get usingBaseFeeMutez() {
    return Math.max(Number(this.baseFeeMutez), MINIMAL_FEE_MUTEZ) + this.roundUp(this.operationFeeMutez);
  }
  /**
   * @description The sum of `minimalFeeMutez` + `burnFeeMutez`.
   */
  get totalCost() {
    return this.minimalFeeMutez + this.burnFeeMutez;
  }
  /**
   * @description Since Delphinet, consumed gas is provided in milligas for more precision.
   * This function returns an estimation of the gas that operation will consume in milligas.
   */
  get consumedMilligas() {
    return Number(this._milligasLimit);
  }
  static createEstimateInstanceFromProperties(estimateProperties) {
    let milligasLimit = 0;
    let storageLimit = 0;
    let opSize = 0;
    let minimalFeePerStorageByteMutez = 0;
    let baseFeeMutez;
    estimateProperties.forEach((estimate) => {
      milligasLimit += estimate.milligasLimit;
      storageLimit += estimate.storageLimit;
      opSize += estimate.opSize;
      minimalFeePerStorageByteMutez = Math.max(estimate.minimalFeePerStorageByteMutez, minimalFeePerStorageByteMutez);
      if (estimate.baseFeeMutez) {
        baseFeeMutez = baseFeeMutez ? baseFeeMutez + estimate.baseFeeMutez : estimate.baseFeeMutez;
      }
    });
    return new _Estimate(milligasLimit, storageLimit, opSize, minimalFeePerStorageByteMutez, baseFeeMutez);
  }
  static createArrayEstimateInstancesFromProperties(estimateProperties) {
    return estimateProperties.map((x) => new _Estimate(x.milligasLimit, x.storageLimit, x.opSize, x.minimalFeePerStorageByteMutez, x.baseFeeMutez));
  }
};
var RevealEstimateError = class extends TaquitoError {
  constructor() {
    super();
    this.name = "RevealEstimateError";
    this.message = "Public key is unknown, unable to estimate the reveal operation in Wallet API.";
  }
};
var RPCEstimateProvider = class extends Provider {
  constructor() {
    super(...arguments);
    this.ALLOCATION_STORAGE = 257;
    this.ORIGINATION_STORAGE = 257;
    this.OP_SIZE_REVEAL = 128;
    this.prepare = new PrepareProvider(this.context);
  }
  getKeys() {
    return __awaiter4(this, void 0, void 0, function* () {
      const isSignerConfigured = this.context.isAnySignerConfigured();
      return {
        publicKeyHash: isSignerConfigured ? yield this.signer.publicKeyHash() : yield this.context.walletProvider.getPKH(),
        publicKey: isSignerConfigured ? yield this.signer.publicKey() : void 0
      };
    });
  }
  getEstimationPropertiesFromOperationContent(content, size, costPerByte) {
    const operationResults = flattenOperationResult({ contents: [content] });
    let totalMilligas = 0;
    let totalStorage = 0;
    operationResults.forEach((result) => {
      totalStorage += "originated_contracts" in result && typeof result.originated_contracts !== "undefined" ? result.originated_contracts.length * this.ORIGINATION_STORAGE : 0;
      totalStorage += "allocated_destination_contract" in result ? this.ALLOCATION_STORAGE : 0;
      totalMilligas += Number(result.consumed_milligas) || 0;
      totalStorage += "paid_storage_size_diff" in result ? Number(result.paid_storage_size_diff) || 0 : 0;
      totalStorage += "storage_size" in result && "global_address" in result ? Number(result.storage_size) || 0 : 0;
      totalStorage += "genesis_commitment_hash" in result ? Number(result.size) : 0;
    });
    if (isOpWithFee(content)) {
      return {
        milligasLimit: totalMilligas || 0,
        storageLimit: Number(totalStorage || 0),
        opSize: size,
        minimalFeePerStorageByteMutez: costPerByte.toNumber()
      };
    } else {
      return {
        milligasLimit: 0,
        storageLimit: 0,
        opSize: size,
        minimalFeePerStorageByteMutez: costPerByte.toNumber(),
        baseFeeMutez: 0
      };
    }
  }
  calculateEstimates(op, constants) {
    return __awaiter4(this, void 0, void 0, function* () {
      const { opbytes, opOb: { branch, contents } } = yield this.forge(op);
      const operation = {
        operation: { branch, contents },
        chain_id: yield this.context.readProvider.getChainId()
      };
      const { opResponse } = yield this.simulate(operation);
      const { cost_per_byte } = constants;
      const errors = [...flattenErrors(opResponse, "backtracked"), ...flattenErrors(opResponse)];
      if (errors.length) {
        throw new TezosOperationError(errors, "Error occurred during estimation");
      }
      let numberOfOps = 1;
      if (Array.isArray(op.opOb.contents) && op.opOb.contents.length > 1) {
        numberOfOps = opResponse.contents[0].kind === "reveal" ? op.opOb.contents.length - 1 : op.opOb.contents.length;
      }
      return opResponse.contents.map((x) => {
        return this.getEstimationPropertiesFromOperationContent(
          x,
          // TODO: Calculate a specific opSize for each operation.
          x.kind === "reveal" ? this.OP_SIZE_REVEAL / 2 : opbytes.length / 2 / numberOfOps,
          cost_per_byte
        );
      });
    });
  }
  /**
   *
   * @description Estimate gasLimit, storageLimit and fees for an origination operation
   *
   * @returns An estimation of gasLimit, storageLimit and fees for the operation
   *
   * @param OriginationOperation Originate operation parameter
   */
  originate(params) {
    return __awaiter4(this, void 0, void 0, function* () {
      const preparedOperation = yield this.prepare.originate(params);
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);
      if (preparedOperation.opOb.contents[0].kind === "reveal") {
        estimateProperties.shift();
      }
      return Estimate.createEstimateInstanceFromProperties(estimateProperties);
    });
  }
  /**
   *
   * @description Estimate gasLimit, storageLimit and fees for an transfer operation
   *
   * @returns An estimation of gasLimit, storageLimit and fees for the operation
   *
   * @param TransferOperation Originate operation parameter
   */
  transfer(_a3) {
    var _b;
    var { fee, storageLimit, gasLimit } = _a3, rest = __rest2(_a3, ["fee", "storageLimit", "gasLimit"]);
    return __awaiter4(this, void 0, void 0, function* () {
      const toValidation = validateAddress(rest.to);
      if (toValidation !== ValidationResult.VALID) {
        throw new InvalidAddressError(rest.to, invalidDetail(toValidation));
      }
      const srouceValidation = validateAddress((_b = rest.source) !== null && _b !== void 0 ? _b : "");
      if (rest.source && srouceValidation !== ValidationResult.VALID) {
        throw new InvalidAddressError(rest.source, invalidDetail(srouceValidation));
      }
      if (rest.amount < 0) {
        throw new InvalidAmountError(rest.amount.toString());
      }
      const preparedOperation = yield this.prepare.transaction(Object.assign({
        fee,
        storageLimit,
        gasLimit
      }, rest));
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);
      if (preparedOperation.opOb.contents[0].kind === "reveal") {
        estimateProperties.shift();
      }
      return Estimate.createEstimateInstanceFromProperties(estimateProperties);
    });
  }
  /**
   *
   * @description Estimate gasLimit, storageLimit and fees for a transferTicket operation
   *
   * @returns An estimation of gasLimit, storageLimit and fees for the operation
   *
   * @param TransferTicketParams operation parameter
   */
  transferTicket(_a3) {
    var _b;
    var { fee, storageLimit, gasLimit } = _a3, rest = __rest2(_a3, ["fee", "storageLimit", "gasLimit"]);
    return __awaiter4(this, void 0, void 0, function* () {
      const destinationValidation = validateAddress(rest.destination);
      if (destinationValidation !== ValidationResult.VALID) {
        throw new InvalidAddressError(rest.destination, invalidDetail(destinationValidation));
      }
      const sourceValidation = validateAddress((_b = rest.source) !== null && _b !== void 0 ? _b : "");
      if (rest.source && sourceValidation !== ValidationResult.VALID) {
        throw new InvalidAddressError(rest.source, invalidDetail(sourceValidation));
      }
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const preparedOperation = yield this.prepare.transferTicket(Object.assign({
        fee,
        storageLimit,
        gasLimit
      }, rest));
      const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);
      if (preparedOperation.opOb.contents[0].kind === "reveal") {
        estimateProperties.shift();
      }
      return Estimate.createEstimateInstanceFromProperties(estimateProperties);
    });
  }
  /**
   *
   * @description Estimate gasLimit, storageLimit and fees for a delegate operation
   *
   * @returns An estimation of gasLimit, storageLimit and fees for the operation
   *
   * @param Estimate
   */
  setDelegate(_a3) {
    var _b;
    var { fee, gasLimit, storageLimit } = _a3, rest = __rest2(_a3, ["fee", "gasLimit", "storageLimit"]);
    return __awaiter4(this, void 0, void 0, function* () {
      const sourceValidation = validateAddress(rest.source);
      if (rest.source && sourceValidation !== ValidationResult.VALID) {
        throw new InvalidAddressError(rest.source, invalidDetail(sourceValidation));
      }
      const delegateValidation = validateAddress((_b = rest.delegate) !== null && _b !== void 0 ? _b : "");
      if (rest.delegate && delegateValidation !== ValidationResult.VALID) {
        throw new InvalidAddressError(rest.delegate, invalidDetail(delegateValidation));
      }
      const preparedOperation = yield this.prepare.delegation(Object.assign({
        fee,
        storageLimit,
        gasLimit
      }, rest));
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);
      if (preparedOperation.opOb.contents[0].kind === "reveal") {
        estimateProperties.shift();
      }
      return Estimate.createEstimateInstanceFromProperties(estimateProperties);
    });
  }
  /**
   *
   * @description Estimate gasLimit, storageLimit and fees for a each operation in the batch
   *
   * @returns An array of Estimate objects. If a reveal operation is needed, the first element of the array is the Estimate for the reveal operation.
   */
  batch(params) {
    return __awaiter4(this, void 0, void 0, function* () {
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const preparedOperations = yield this.prepare.batch(params);
      const estimateProperties = yield this.calculateEstimates(preparedOperations, protocolConstants);
      return Estimate.createArrayEstimateInstancesFromProperties(estimateProperties);
    });
  }
  /**
   *
   * @description Estimate gasLimit, storageLimit and fees for a delegate operation
   *
   * @returns An estimation of gasLimit, storageLimit and fees for the operation
   *
   * @param Estimate
   */
  registerDelegate(_a3, source) {
    var { fee, storageLimit, gasLimit } = _a3, rest = __rest2(_a3, ["fee", "storageLimit", "gasLimit"]);
    return __awaiter4(this, void 0, void 0, function* () {
      const pkh = (yield this.getKeys()).publicKeyHash;
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const checkSource = source || pkh;
      const preparedOperation = yield this.prepare.registerDelegate(Object.assign({ fee, storageLimit, gasLimit }, rest), checkSource);
      const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);
      if (preparedOperation.opOb.contents[0].kind === "reveal") {
        estimateProperties.shift();
      }
      return Estimate.createEstimateInstanceFromProperties(estimateProperties);
    });
  }
  /**
   *
   * @description Estimate gasLimit, storageLimit and fees to reveal the current account
   *
   * @returns An estimation of gasLimit, storageLimit and fees for the operation or undefined if the account is already revealed
   *
   * @param Estimate
   */
  reveal(params) {
    return __awaiter4(this, void 0, void 0, function* () {
      const { publicKeyHash, publicKey } = yield this.getKeys();
      if (!publicKey) {
        throw new RevealEstimateError();
      }
      if (yield this.isAccountRevealRequired(publicKeyHash)) {
        const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
        const preparedOperation = params ? yield this.prepare.reveal(params) : yield this.prepare.reveal({});
        const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);
        return Estimate.createEstimateInstanceFromProperties(estimateProperties);
      }
    });
  }
  /**
   *
   * @description Estimate gasLimit, storageLimit and fees for an registerGlobalConstant operation
   *
   * @returns An estimation of gasLimit, storageLimit and fees for the operation
   *
   * @param params registerGlobalConstant operation parameter
   */
  registerGlobalConstant(_a3) {
    var { fee, storageLimit, gasLimit } = _a3, rest = __rest2(_a3, ["fee", "storageLimit", "gasLimit"]);
    return __awaiter4(this, void 0, void 0, function* () {
      const preparedOperation = yield this.prepare.registerGlobalConstant(Object.assign({
        fee,
        storageLimit,
        gasLimit
      }, rest));
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);
      if (preparedOperation.opOb.contents[0].kind === "reveal") {
        estimateProperties.shift();
      }
      return Estimate.createEstimateInstanceFromProperties(estimateProperties);
    });
  }
  /**
   *
   * @description Estimate gasLimit, storageLimit, and fees for an increasePaidStorage operation
   *
   * @returns An estimation of gasLimit, storageLimit, and fees for the operation
   *
   * @param params increasePaidStorage operation parameters
   */
  increasePaidStorage(_a3) {
    var { fee, storageLimit, gasLimit } = _a3, rest = __rest2(_a3, ["fee", "storageLimit", "gasLimit"]);
    return __awaiter4(this, void 0, void 0, function* () {
      if (rest.amount < 0) {
        throw new InvalidAmountError(rest.amount.toString());
      }
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const preparedOperation = yield this.prepare.increasePaidStorage(Object.assign({
        fee,
        storageLimit,
        gasLimit
      }, rest));
      const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);
      if (preparedOperation.opOb.contents[0].kind === "reveal") {
        estimateProperties.shift();
      }
      return Estimate.createEstimateInstanceFromProperties(estimateProperties);
    });
  }
  /**
   *
   * @description Estimate gasLimit, storageLimit and fees for an Update Consensus Key operation
   *
   * @returns An estimation of gasLimit, storageLimit and fees for the operation
   *
   * @param Estimate
   */
  updateConsensusKey(params) {
    return __awaiter4(this, void 0, void 0, function* () {
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const preparedOperation = yield this.prepare.updateConsensusKey(params);
      const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);
      if (preparedOperation.opOb.contents[0].kind === "reveal") {
        estimateProperties.shift();
      }
      return Estimate.createEstimateInstanceFromProperties(estimateProperties);
    });
  }
  /**
   *
   * @description Estimate gasLimit, storageLimit and fees for a smart_rollup_add_messages operation
   *
   * @returns An estimation of gasLimit, storageLimit and fees for the operation
   *
   * @param Estimate
   */
  smartRollupAddMessages(params) {
    return __awaiter4(this, void 0, void 0, function* () {
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const preparedOperation = yield this.prepare.smartRollupAddMessages(params);
      const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);
      if (preparedOperation.opOb.contents[0].kind === "reveal") {
        estimateProperties.shift();
      }
      return Estimate.createEstimateInstanceFromProperties(estimateProperties);
    });
  }
  /**
   *
   * @description Estimate gasLimit, storageLimit and fees for an Smart Rollup Originate operation
   *
   * @returns An estimation of gasLimit, storageLimit and fees for the operation
   *
   * @param SmartRollupOriginateParams
   */
  smartRollupOriginate(params) {
    return __awaiter4(this, void 0, void 0, function* () {
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const preparedOperation = yield this.prepare.smartRollupOriginate(params);
      const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);
      if (preparedOperation.opOb.contents[0].kind === "reveal") {
        estimateProperties.shift();
      }
      return Estimate.createEstimateInstanceFromProperties(estimateProperties);
    });
  }
  /**
   *
   * @description Estimate gasLimit, storageLimit and fees for contract call
   *
   * @returns An estimation of gasLimit, storageLimit and fees for the contract call
   *
   * @param Estimate
   */
  contractCall(contractMethod) {
    return __awaiter4(this, void 0, void 0, function* () {
      const protocolConstants = yield this.context.readProvider.getProtocolConstants("head");
      const preparedOperation = yield this.prepare.contractCall(contractMethod);
      const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);
      if (preparedOperation.opOb.contents[0].kind === "reveal") {
        estimateProperties.shift();
      }
      return Estimate.createEstimateInstanceFromProperties(estimateProperties);
    });
  }
};
var DelegateOperation = class extends Operation {
  constructor(hash2, params, source, raw, results, context2) {
    super(hash2, raw, results, context2);
    this.params = params;
    this.source = source;
  }
  get operationResults() {
    const delegationOp = Array.isArray(this.results) && this.results.find((op) => op.kind === "delegation");
    const result = delegationOp && delegationOp.metadata && delegationOp.metadata.operation_result;
    return result ? result : void 0;
  }
  get status() {
    var _a3, _b;
    return (_b = (_a3 = this.operationResults) === null || _a3 === void 0 ? void 0 : _a3.status) !== null && _b !== void 0 ? _b : "unknown";
  }
  get delegate() {
    return this.params.delegate;
  }
  get isRegisterOperation() {
    return this.delegate === this.source;
  }
  get fee() {
    return Number(this.params.fee);
  }
  get gasLimit() {
    return Number(this.params.gas_limit);
  }
  get storageLimit() {
    return Number(this.params.storage_limit);
  }
  get consumedGas() {
    BigNumber.config({ DECIMAL_PLACES: 0, ROUNDING_MODE: BigNumber.ROUND_UP });
    return this.consumedMilliGas ? new BigNumber(this.consumedMilliGas).dividedBy(1e3).toString() : void 0;
  }
  get consumedMilliGas() {
    var _a3;
    return (_a3 = this.operationResults) === null || _a3 === void 0 ? void 0 : _a3.consumed_milligas;
  }
  get errors() {
    var _a3;
    return (_a3 = this.operationResults) === null || _a3 === void 0 ? void 0 : _a3.errors;
  }
};
var OriginationOperation = class extends Operation {
  constructor(hash2, params, raw, results, context2, contractProvider) {
    super(hash2, raw, results, context2);
    this.params = params;
    this.contractProvider = contractProvider;
    const originatedContracts = this.operationResults && this.operationResults.originated_contracts;
    if (Array.isArray(originatedContracts)) {
      this.contractAddress = originatedContracts[0];
    }
  }
  get status() {
    var _a3, _b;
    return (_b = (_a3 = this.operationResults) === null || _a3 === void 0 ? void 0 : _a3.status) !== null && _b !== void 0 ? _b : "unknown";
  }
  get operationResults() {
    const originationOp = Array.isArray(this.results) && this.results.find((op) => op.kind === "origination");
    const result = originationOp && hasMetadataWithResult(originationOp) && originationOp.metadata.operation_result;
    return result ? result : void 0;
  }
  get fee() {
    return Number(this.params.fee);
  }
  get gasLimit() {
    return Number(this.params.gas_limit);
  }
  get storageLimit() {
    return Number(this.params.storage_limit);
  }
  get consumedGas() {
    BigNumber.config({ DECIMAL_PLACES: 0, ROUNDING_MODE: BigNumber.ROUND_UP });
    return this.consumedMilliGas ? new BigNumber(this.consumedMilliGas).dividedBy(1e3).toString() : void 0;
  }
  get consumedMilliGas() {
    var _a3;
    return (_a3 = this.operationResults) === null || _a3 === void 0 ? void 0 : _a3.consumed_milligas;
  }
  get storageDiff() {
    const storageDiff = this.operationResults && this.operationResults.paid_storage_size_diff;
    return storageDiff ? storageDiff : void 0;
  }
  get storageSize() {
    const storageSize = this.operationResults && this.operationResults.storage_size;
    return storageSize ? storageSize : void 0;
  }
  get errors() {
    var _a3;
    return (_a3 = this.operationResults) === null || _a3 === void 0 ? void 0 : _a3.errors;
  }
  /**
   * @description Provide the contract abstract of the newly originated contract
   * @throws {@link OriginationOperationError}
   */
  contract(confirmations, timeout2) {
    return __awaiter4(this, void 0, void 0, function* () {
      if (!this.contractAddress) {
        throw new OriginationOperationError("No contract was originated in this operation");
      }
      yield this.confirmation(confirmations, timeout2);
      return this.contractProvider.at(this.contractAddress);
    });
  }
};
var RegisterGlobalConstantOperation = class extends Operation {
  constructor(hash2, params, source, raw, results, context2) {
    super(hash2, raw, results, context2);
    this.params = params;
    this.source = source;
    this.globalConstantHash = this.operationResults && this.operationResults.global_address;
  }
  get operationResults() {
    const registerGlobalConstantOp = Array.isArray(this.results) && this.results.find((op) => op.kind === "register_global_constant");
    const result = registerGlobalConstantOp && registerGlobalConstantOp.metadata && registerGlobalConstantOp.metadata.operation_result;
    return result ? result : void 0;
  }
  get status() {
    var _a3, _b;
    return (_b = (_a3 = this.operationResults) === null || _a3 === void 0 ? void 0 : _a3.status) !== null && _b !== void 0 ? _b : "unknown";
  }
  get registeredExpression() {
    return this.params.value;
  }
  get fee() {
    return Number(this.params.fee);
  }
  get gasLimit() {
    return Number(this.params.gas_limit);
  }
  get storageLimit() {
    return Number(this.params.storage_limit);
  }
  get errors() {
    var _a3;
    return (_a3 = this.operationResults) === null || _a3 === void 0 ? void 0 : _a3.errors;
  }
  get consumedGas() {
    BigNumber.config({ DECIMAL_PLACES: 0, ROUNDING_MODE: BigNumber.ROUND_UP });
    return this.consumedMilliGas ? new BigNumber(this.consumedMilliGas).dividedBy(1e3).toString() : void 0;
  }
  get consumedMilliGas() {
    var _a3;
    return (_a3 = this.operationResults) === null || _a3 === void 0 ? void 0 : _a3.consumed_milligas;
  }
};
var RevealOperation = class extends Operation {
  constructor(hash2, params, source, raw, results, context2) {
    super(hash2, raw, results, context2);
    this.params = params;
    this.source = source;
  }
  get operationResults() {
    const revealOp = Array.isArray(this.results) && this.results.find((op) => op.kind === "reveal");
    return revealOp ? [revealOp] : [];
  }
  get status() {
    const operationResults = this.operationResults;
    const txResult = operationResults[0];
    if (txResult) {
      return txResult.metadata.operation_result.status;
    } else {
      return "unknown";
    }
  }
  get fee() {
    return Number(this.params.fee);
  }
  get gasLimit() {
    return Number(this.params.gas_limit);
  }
  get storageLimit() {
    return Number(this.params.storage_limit);
  }
  get publicKey() {
    return this.params.public_key;
  }
  sumProp(arr, prop) {
    return arr.reduce((prev, current) => {
      return prop in current ? Number(current[prop]) + prev : prev;
    }, 0);
  }
  get consumedGas() {
    BigNumber.config({ DECIMAL_PLACES: 0, ROUNDING_MODE: BigNumber.ROUND_UP });
    return new BigNumber(this.consumedMilliGas).dividedBy(1e3).toString();
  }
  get consumedMilliGas() {
    return String(this.sumProp(flattenOperationResult({ contents: this.operationResults }), "consumed_milligas"));
  }
  get storageDiff() {
    return String(this.sumProp(flattenOperationResult({ contents: this.operationResults }), "paid_storage_size_diff"));
  }
  get storageSize() {
    return String(this.sumProp(flattenOperationResult({ contents: this.operationResults }), "storage_size"));
  }
  get errors() {
    return flattenErrors({ contents: this.operationResults });
  }
};
var TransactionOperation = class extends Operation {
  constructor(hash2, params, source, raw, results, context2) {
    super(hash2, raw, results, context2);
    this.params = params;
    this.source = source;
  }
  get operationResults() {
    const transactionOp = Array.isArray(this.results) && this.results.find((op) => op.kind === "transaction");
    return transactionOp ? [transactionOp] : [];
  }
  get status() {
    const operationResults = this.operationResults;
    const txResult = operationResults[0];
    if (txResult) {
      return txResult.metadata.operation_result.status;
    } else {
      return "unknown";
    }
  }
  get amount() {
    return new bignumber_default(this.params.amount);
  }
  get destination() {
    return this.params.destination;
  }
  get fee() {
    return Number(this.params.fee);
  }
  get gasLimit() {
    return Number(this.params.gas_limit);
  }
  get storageLimit() {
    return Number(this.params.storage_limit);
  }
  sumProp(arr, prop) {
    return arr.reduce((prev, current) => {
      return prop in current ? Number(current[prop]) + prev : prev;
    }, 0);
  }
  get consumedGas() {
    bignumber_default.config({ DECIMAL_PLACES: 0, ROUNDING_MODE: bignumber_default.ROUND_UP });
    return new bignumber_default(this.consumedMilliGas).dividedBy(1e3).toString();
  }
  get consumedMilliGas() {
    return String(this.sumProp(flattenOperationResult({ contents: this.operationResults }), "consumed_milligas"));
  }
  get storageDiff() {
    return String(this.sumProp(flattenOperationResult({ contents: this.operationResults }), "paid_storage_size_diff"));
  }
  get storageSize() {
    return String(this.sumProp(flattenOperationResult({ contents: this.operationResults }), "storage_size"));
  }
  get errors() {
    return flattenErrors({ contents: this.operationResults });
  }
};
var BigMapAbstraction = class {
  constructor(id, schema, provider) {
    this.id = id;
    this.schema = schema;
    this.provider = provider;
  }
  /**
   *
   * @description Fetch one value in a big map
   *
   * @param keysToEncode Key to query (will be encoded properly according to the schema)
   * @param block optional block level to fetch the values from (head will be use by default)
   * @returns Return a well formatted json object of a big map value or undefined if the key is not found in the big map
   *
   */
  get(keyToEncode, block) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        const id = yield this.provider.getBigMapKeyByID(this.id.toString(), keyToEncode, this.schema, block);
        return id;
      } catch (e) {
        if (e instanceof HttpResponseError && e.status === STATUS_CODE.NOT_FOUND) {
          return void 0;
        } else {
          throw e;
        }
      }
    });
  }
  /**
   *
   * @description Fetch multiple values in a big map
   * All values will be fetched on the same block level. If a block is specified in the request, the values will be fetched at it.
   * Otherwise, a first request will be done to the node to fetch the level of the head and all values will be fetched at this level.
   * If one of the keys does not exist in the big map, its value will be set to undefined.
   *
   * @param keysToEncode Array of keys to query (will be encoded properly according to the schema)
   * @param block optional block level to fetch the values from
   * @param batchSize optional batch size representing the number of requests to execute in parallel
   * @returns A MichelsonMap containing the keys queried in the big map and their value in a well-formatted JSON object format
   *
   */
  getMultipleValues(keysToEncode, block, batchSize = 5) {
    return __awaiter4(this, void 0, void 0, function* () {
      return this.provider.getBigMapKeysByID(this.id.toString(), keysToEncode, this.schema, block, batchSize);
    });
  }
  toJSON() {
    return this.id.toString();
  }
  toString() {
    return this.id.toString();
  }
};
var smartContractAbstractionSemantic = (provider) => ({
  // Provide a specific abstraction for BigMaps
  big_map: (val, code2) => {
    if (!val || !("int" in val) || val.int === void 0) {
      return {};
    } else {
      const schema = new Schema(code2);
      return new BigMapAbstraction(new bignumber_default(val.int), schema, provider);
    }
  },
  sapling_state: (val) => {
    if (!val || !("int" in val) || val.int === void 0) {
      return {};
    } else {
      return new SaplingStateAbstraction(new bignumber_default(val.int), provider);
    }
  }
  /*
  // TODO: embed useful other abstractions
  'contract':  () => {},
  'address':  () => {}
  */
});
var BallotOperation = class extends Operation {
  constructor(hash2, params, source, raw, results, context2) {
    super(hash2, raw, results, context2);
    this.params = params;
    this.source = source;
  }
  get operationResults() {
    const ballotOp = Array.isArray(this.results) && this.results.find((op) => op.kind === "ballot");
    const result = ballotOp;
    return result ? result : void 0;
  }
  get period() {
    var _a3;
    return (_a3 = this.operationResults) === null || _a3 === void 0 ? void 0 : _a3.period;
  }
  get proposal() {
    return this.params.proposal;
  }
  get ballot() {
    return this.params.ballot;
  }
};
var DrainDelegateOperation = class extends Operation {
  constructor(hash2, params, raw, results, context2) {
    super(hash2, raw, results, context2);
    this.params = params;
  }
  get operationResults() {
    const drainDelegateOp = Array.isArray(this.results) && this.results.find((op) => op.kind === "drain_delegate");
    const result = drainDelegateOp && drainDelegateOp.metadata && drainDelegateOp.metadata.balance_updates;
    return result ? result : void 0;
  }
  get consensusKey() {
    return this.params.consensus_key;
  }
  get delegate() {
    return this.params.delegate;
  }
  get destination() {
    return this.params.destination;
  }
};
var TransferTicketOperation = class extends Operation {
  constructor(hash2, params, source, raw, results, context2) {
    super(hash2, raw, results, context2);
    this.params = params;
    this.source = source;
  }
  get operationResults() {
    const transferOp = Array.isArray(this.results) && this.results.find((op) => op.kind === OpKind.TRANSFER_TICKET);
    const result = transferOp && transferOp.metadata && transferOp.metadata.operation_result;
    return result ? result : void 0;
  }
  get status() {
    var _a3, _b;
    return (_b = (_a3 = this.operationResults) === null || _a3 === void 0 ? void 0 : _a3.status) !== null && _b !== void 0 ? _b : "unknown";
  }
  get fee() {
    return Number(this.params.fee);
  }
  get gasLimit() {
    return Number(this.params.gas_limit);
  }
  get storageLimit() {
    return Number(this.params.storage_limit);
  }
  get consumedGas() {
    BigNumber.config({ DECIMAL_PLACES: 0, ROUNDING_MODE: BigNumber.ROUND_UP });
    return this.consumedMilliGas ? new BigNumber(this.consumedMilliGas).dividedBy(1e3).toString() : void 0;
  }
  get consumedMilliGas() {
    var _a3;
    return (_a3 = this.operationResults) === null || _a3 === void 0 ? void 0 : _a3.consumed_milligas;
  }
};
var IncreasePaidStorageOperation = class extends Operation {
  constructor(hash2, params, source, raw, results, context2) {
    super(hash2, raw, results, context2);
    this.params = params;
    this.source = source;
  }
  get operationResults() {
    const increasePaidStorageOp = Array.isArray(this.results) && this.results.find((op) => op.kind === "increase_paid_storage");
    const result = increasePaidStorageOp && increasePaidStorageOp.metadata && increasePaidStorageOp.metadata.operation_result;
    return result ? result : void 0;
  }
  get status() {
    var _a3, _b;
    return (_b = (_a3 = this.operationResults) === null || _a3 === void 0 ? void 0 : _a3.status) !== null && _b !== void 0 ? _b : "unknown";
  }
  get fee() {
    return Number(this.params.fee);
  }
  get gasLimit() {
    return Number(this.params.gas_limit);
  }
  get storageLimit() {
    return Number(this.params.storage_limit);
  }
  get errors() {
    var _a3;
    return (_a3 = this.operationResults) === null || _a3 === void 0 ? void 0 : _a3.errors;
  }
  get consumedMilliGas() {
    var _a3;
    return (_a3 = this.operationResults) === null || _a3 === void 0 ? void 0 : _a3.consumed_milligas;
  }
  get amount() {
    return this.params.amount;
  }
  get destination() {
    return this.params.destination;
  }
};
var ProposalsOperation = class extends Operation {
  constructor(hash2, params, source, raw, results, context2) {
    super(hash2, raw, results, context2);
    this.params = params;
    this.source = source;
  }
  get operationResults() {
    const proposalsOp = Array.isArray(this.results) && this.results.find((op) => op.kind === "proposals");
    const result = proposalsOp;
    return result ? result : void 0;
  }
  get proposals() {
    return this.params.proposals;
  }
  get period() {
    var _a3;
    return (_a3 = this.operationResults) === null || _a3 === void 0 ? void 0 : _a3.period;
  }
};
var UpdateConsensusKeyOperation = class extends Operation {
  constructor(hash2, params, source, raw, results, context2) {
    super(hash2, raw, results, context2);
    this.params = params;
    this.source = source;
  }
  get operationResults() {
    const updateConsensusKeyOp = Array.isArray(this.results) && this.results.find((op) => op.kind === "update_consensus_key");
    const result = updateConsensusKeyOp && updateConsensusKeyOp.metadata && updateConsensusKeyOp.metadata.operation_result;
    return result ? result : void 0;
  }
  get status() {
    var _a3, _b;
    return (_b = (_a3 = this.operationResults) === null || _a3 === void 0 ? void 0 : _a3.status) !== null && _b !== void 0 ? _b : "unknown";
  }
  get fee() {
    return Number(this.params.fee);
  }
  get gasLimit() {
    return Number(this.params.gas_limit);
  }
  get storageLimit() {
    return Number(this.params.storage_limit);
  }
  get pk() {
    return this.params.pk;
  }
  get consumedMilliGas() {
    var _a3;
    return (_a3 = this.operationResults) === null || _a3 === void 0 ? void 0 : _a3.consumed_milligas;
  }
  get errors() {
    var _a3;
    return (_a3 = this.operationResults) === null || _a3 === void 0 ? void 0 : _a3.errors;
  }
};
var SmartRollupAddMessagesOperation = class extends Operation {
  constructor(hash2, params, source, raw, results, context2) {
    super(hash2, raw, results, context2);
    this.params = params;
    this.source = source;
  }
  get operationResults() {
    const smartRollupAddMessagesOp = Array.isArray(this.results) && this.results.find((op) => op.kind === "smart_rollup_add_messages");
    const result = smartRollupAddMessagesOp && smartRollupAddMessagesOp.metadata && smartRollupAddMessagesOp.metadata.operation_result;
    return result ? result : void 0;
  }
  get status() {
    var _a3, _b;
    return (_b = (_a3 = this.operationResults) === null || _a3 === void 0 ? void 0 : _a3.status) !== null && _b !== void 0 ? _b : "unknown";
  }
  get message() {
    return this.params.message;
  }
  get fee() {
    return Number(this.params.fee);
  }
  get gasLimit() {
    return Number(this.params.gas_limit);
  }
  get storageLimit() {
    return Number(this.params.storage_limit);
  }
  get consumedMilliGas() {
    var _a3;
    return (_a3 = this.operationResults) === null || _a3 === void 0 ? void 0 : _a3.consumed_milligas;
  }
  get errors() {
    var _a3;
    return (_a3 = this.operationResults) === null || _a3 === void 0 ? void 0 : _a3.errors;
  }
};
var SmartRollupOriginateOperation = class extends Operation {
  constructor(hash2, params, source, raw, results, context2) {
    super(hash2, raw, results, context2);
    this.params = params;
    this.source = source;
  }
  get operationResults() {
    const smartRollupOriginateOp = Array.isArray(this.results) && this.results.find((op) => op.kind === OpKind.SMART_ROLLUP_ORIGINATE);
    const result = smartRollupOriginateOp && smartRollupOriginateOp.metadata && smartRollupOriginateOp.metadata.operation_result;
    return result ? result : void 0;
  }
  get status() {
    var _a3, _b;
    return (_b = (_a3 = this.operationResults) === null || _a3 === void 0 ? void 0 : _a3.status) !== null && _b !== void 0 ? _b : "unknown";
  }
  get fee() {
    return Number(this.params.fee);
  }
  get gasLimit() {
    return Number(this.params.gas_limit);
  }
  get storageLimit() {
    return Number(this.params.storage_limit);
  }
  get consumedMilliGas() {
    var _a3;
    return (_a3 = this.operationResults) === null || _a3 === void 0 ? void 0 : _a3.consumed_milligas;
  }
  get pvmKind() {
    return this.params.pvm_kind;
  }
  get kernel() {
    return this.params.kernel;
  }
  get originationProof() {
    return this.params.origination_proof;
  }
  get errors() {
    var _a3;
    return (_a3 = this.operationResults) === null || _a3 === void 0 ? void 0 : _a3.errors;
  }
};
var RpcContractProvider = class extends Provider {
  constructor(context2, estimator) {
    super(context2);
    this.estimator = estimator;
    this.contractProviderTypeSymbol = Symbol.for("taquito-contract-provider-type-symbol");
    this.prepare = new PrepareProvider(this.context);
  }
  /**
   *
   * @description Return a well formatted json object of the contract storage
   *
   * @param contract contract address you want to get the storage from
   * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema
   * @throws {@link InvalidContractAddressError}
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script
   */
  getStorage(contract, schema) {
    return __awaiter4(this, void 0, void 0, function* () {
      const contractValidation = validateContractAddress(contract);
      if (contractValidation !== ValidationResult.VALID) {
        throw new InvalidContractAddressError(contract, invalidDetail(contractValidation));
      }
      const script = yield this.context.readProvider.getScript(contract, "head");
      if (!schema) {
        schema = script;
      }
      let contractSchema;
      if (Schema.isSchema(schema)) {
        contractSchema = schema;
      } else {
        contractSchema = Schema.fromRPCResponse({ script: schema });
      }
      return contractSchema.Execute(script.storage, smartContractAbstractionSemantic(this));
    });
  }
  /**
   *
   * @description Return a well formatted json object of the contract big map storage
   *
   * @param contract contract address you want to get the storage from
   * @param key contract big map key to fetch value from
   * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema
   * @throws {@link InvalidContractAddressError}
   * @deprecated Deprecated in favor of getBigMapKeyByID
   *
   * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get
   */
  getBigMapKey(contract, key, schema) {
    return __awaiter4(this, void 0, void 0, function* () {
      const contractValidation = validateContractAddress(contract);
      if (contractValidation !== ValidationResult.VALID) {
        throw new InvalidContractAddressError(contract, invalidDetail(contractValidation));
      }
      if (!schema) {
        schema = (yield this.rpc.getContract(contract)).script;
      }
      let contractSchema;
      if (Schema.isSchema(schema)) {
        contractSchema = schema;
      } else {
        contractSchema = Schema.fromRPCResponse({ script: schema });
      }
      const encodedKey = contractSchema.EncodeBigMapKey(key);
      const val = yield this.rpc.getBigMapKey(contract, encodedKey);
      return contractSchema.ExecuteOnBigMapValue(val);
    });
  }
  /**
   *
   * @description Return a well formatted json object of a big map value
   *
   * @param id Big Map ID
   * @param keyToEncode key to query (will be encoded properly according to the schema)
   * @param schema Big Map schema (can be determined using your contract type)
   * @param block optional block level to fetch the values from
   *
   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr
   */
  getBigMapKeyByID(id, keyToEncode, schema, block) {
    return __awaiter4(this, void 0, void 0, function* () {
      const { key, type } = schema.EncodeBigMapKey(keyToEncode);
      const { packed } = yield this.context.packer.packData({ data: key, type });
      const encodedExpr = encodeExpr(packed);
      const bigMapValue = block ? yield this.context.readProvider.getBigMapValue({ id: id.toString(), expr: encodedExpr }, block) : yield this.context.readProvider.getBigMapValue({ id: id.toString(), expr: encodedExpr }, "head");
      return schema.ExecuteOnBigMapValue(bigMapValue, smartContractAbstractionSemantic(this));
    });
  }
  /**
   *
   * @description Fetch multiple values in a big map
   * All values will be fetched on the same block level. If a block is specified in the request, the values will be fetched at it.
   * Otherwise, a first request will be done to the node to fetch the level of the head and all values will be fetched at this level.
   * If one of the keys does not exist in the big map, its value will be set to undefined.
   *
   * @param id Big Map ID
   * @param keys Array of keys to query (will be encoded properly according to the schema)
   * @param schema Big Map schema (can be determined using your contract type)
   * @param block optional block level to fetch the values from
   * @param batchSize optional batch size representing the number of requests to execute in parallel
   * @returns A MichelsonMap containing the keys queried in the big map and their value in a well-formatted JSON object format
   *
   */
  getBigMapKeysByID(id, keys, schema, block, batchSize = 5) {
    return __awaiter4(this, void 0, void 0, function* () {
      const level = yield this.getBlockForRequest(keys, block);
      const bigMapValues = new MichelsonMap();
      let position = 0;
      let results = [];
      while (position < keys.length) {
        const keysBatch = keys.slice(position, position + batchSize);
        const batch = keysBatch.map((keyToEncode) => this.getBigMapValueOrUndefined(keyToEncode, id, schema, level));
        results = [...results, ...yield Promise.all(batch)];
        position += batchSize;
      }
      for (let i = 0; i < results.length; i++) {
        bigMapValues.set(keys[i], results[i]);
      }
      return bigMapValues;
    });
  }
  getBlockForRequest(keys, block) {
    return __awaiter4(this, void 0, void 0, function* () {
      return keys.length === 1 || typeof block !== "undefined" ? block : yield this.context.readProvider.getBlockLevel("head");
    });
  }
  getBigMapValueOrUndefined(keyToEncode, id, schema, level) {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        return yield this.getBigMapKeyByID(id, keyToEncode, schema, level);
      } catch (ex) {
        if (ex instanceof HttpResponseError && ex.status === STATUS_CODE.NOT_FOUND) {
          return;
        } else {
          throw ex;
        }
      }
    });
  }
  /**
   *
   * @description Return a well formatted json object of a sapling state
   *
   * @param id Sapling state ID
   * @param block optional block level to fetch the value from
   *
   */
  getSaplingDiffByID(id, block) {
    return __awaiter4(this, void 0, void 0, function* () {
      const saplingState = block ? yield this.context.readProvider.getSaplingDiffById({ id: id.toString() }, block) : yield this.context.readProvider.getSaplingDiffById({ id: id.toString() }, "head");
      return saplingState;
    });
  }
  /**
   *
   * @description Originate a new contract according to the script in parameters. Will sign and inject an operation using the current context
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @warn You cannot specify storage and init at the same time (use init to pass the raw michelson representation of storage)
   *
   * @param OriginationOperation Originate operation parameter
   */
  originate(params) {
    return __awaiter4(this, void 0, void 0, function* () {
      const estimate = yield this.estimate(params, this.estimator.originate.bind(this.estimator));
      const preparedOrigination = yield this.prepare.originate(Object.assign(Object.assign({}, params), estimate));
      const content = preparedOrigination.opOb.contents.find((op) => op.kind === OpKind.ORIGINATION);
      const forgedOrigination = yield this.forge(preparedOrigination);
      const { hash: hash2, context: context2, forgedBytes, opResponse } = yield this.signAndInject(forgedOrigination);
      return new OriginationOperation(hash2, content, forgedBytes, opResponse, context2, this);
    });
  }
  /**
   *
   * @description Set the delegate for a contract. Will sign and inject an operation using the current context
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @param SetDelegate operation parameter
   */
  setDelegate(params) {
    var _a3;
    return __awaiter4(this, void 0, void 0, function* () {
      const sourceValidation = validateAddress(params.source);
      if (params.source && sourceValidation !== ValidationResult.VALID) {
        throw new InvalidAddressError(params.source, invalidDetail(sourceValidation));
      }
      const delegateValidation = validateAddress((_a3 = params.delegate) !== null && _a3 !== void 0 ? _a3 : "");
      if (params.delegate && delegateValidation !== ValidationResult.VALID) {
        throw new InvalidAddressError(params.delegate, invalidDetail(delegateValidation));
      }
      if (/kt1/i.test(params.source)) {
        throw new InvalidDelegationSource(params.source);
      }
      const publicKeyHash = yield this.signer.publicKeyHash();
      const sourceOrDefault = params.source || publicKeyHash;
      const estimate = yield this.estimate(params, this.estimator.setDelegate.bind(this.estimator));
      const preparedDelegation = yield this.prepare.delegation(Object.assign(Object.assign({}, params), estimate));
      const content = preparedDelegation.opOb.contents.find((op) => op.kind === OpKind.DELEGATION);
      const opBytes = yield this.forge(preparedDelegation);
      const { hash: hash2, context: context2, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
      return new DelegateOperation(hash2, content, sourceOrDefault, forgedBytes, opResponse, context2);
    });
  }
  /**
   *
   * @description Register the current address as delegate. Will sign and inject an operation using the current context
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @param RegisterDelegate operation parameter
   */
  registerDelegate(params) {
    return __awaiter4(this, void 0, void 0, function* () {
      const estimate = yield this.estimate(params, this.estimator.registerDelegate.bind(this.estimator));
      const source = yield this.signer.publicKeyHash();
      const prepared = yield this.prepare.registerDelegate(Object.assign(Object.assign({}, params), estimate));
      const content = prepared.opOb.contents.find((op) => op.kind === OpKind.DELEGATION);
      const opBytes = yield this.forge(prepared);
      const { hash: hash2, context: context2, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
      return new DelegateOperation(hash2, content, source, forgedBytes, opResponse, context2);
    });
  }
  /**
   *
   * @description Transfer tz from current address to a specific address. Will sign and inject an operation using the current context
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @param Transfer operation parameter
   */
  transfer(params) {
    var _a3;
    return __awaiter4(this, void 0, void 0, function* () {
      const toValidation = validateAddress(params.to);
      if (toValidation !== ValidationResult.VALID) {
        throw new InvalidAddressError(params.to, invalidDetail(toValidation));
      }
      const sourceValidation = validateAddress((_a3 = params.source) !== null && _a3 !== void 0 ? _a3 : "");
      if (params.source && sourceValidation !== ValidationResult.VALID) {
        throw new InvalidAddressError(params.source, invalidDetail(sourceValidation));
      }
      if (params.amount < 0) {
        throw new InvalidAmountError(params.amount.toString());
      }
      const publicKeyHash = yield this.signer.publicKeyHash();
      const estimate = yield this.estimate(params, this.estimator.transfer.bind(this.estimator));
      const source = params.source || publicKeyHash;
      const prepared = yield this.prepare.transaction(Object.assign(Object.assign({}, params), estimate));
      const content = prepared.opOb.contents.find((op) => op.kind === OpKind.TRANSACTION);
      const opBytes = yield this.forge(prepared);
      const { hash: hash2, context: context2, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
      return new TransactionOperation(hash2, content, source, forgedBytes, opResponse, context2);
    });
  }
  /**
   *
   * @description Transfer Tickets to a smart contract address
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @param TransferTicketParams operation parameter
   */
  transferTicket(params) {
    var _a3, _b;
    return __awaiter4(this, void 0, void 0, function* () {
      const destinationValidation = validateAddress(params.destination);
      if (destinationValidation !== ValidationResult.VALID) {
        throw new InvalidAddressError(params.destination, invalidDetail(destinationValidation));
      }
      const sourceValidation = validateAddress((_a3 = params.source) !== null && _a3 !== void 0 ? _a3 : "");
      if (params.source && sourceValidation !== ValidationResult.VALID) {
        throw new InvalidAddressError(params.source, invalidDetail(sourceValidation));
      }
      const publicKeyHash = yield this.signer.publicKeyHash();
      const source = (_b = params.source) !== null && _b !== void 0 ? _b : publicKeyHash;
      const estimate = yield this.estimate(params, this.estimator.transferTicket.bind(this.estimator));
      const prepared = yield this.prepare.transferTicket(Object.assign(Object.assign({}, params), estimate));
      const content = prepared.opOb.contents.find((op) => op.kind === OpKind.TRANSFER_TICKET);
      const opBytes = yield this.forge(prepared);
      const { hash: hash2, context: context2, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
      return new TransferTicketOperation(hash2, content, source, forgedBytes, opResponse, context2);
    });
  }
  /**
   *
   * @description Reveal the current address. Will throw an error if the address is already revealed.
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @param RevealParams operation parameter
   */
  reveal(params) {
    return __awaiter4(this, void 0, void 0, function* () {
      const publicKeyHash = yield this.signer.publicKeyHash();
      const estimateReveal = yield this.estimator.reveal(params);
      if (estimateReveal) {
        const estimated = yield this.estimate(params, () => __awaiter4(this, void 0, void 0, function* () {
          return estimateReveal;
        }));
        const prepared = yield this.prepare.reveal(Object.assign(Object.assign({}, params), estimated));
        const content = prepared.opOb.contents.find((op) => op.kind === OpKind.REVEAL);
        const opBytes = yield this.forge(prepared);
        const { hash: hash2, context: context2, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
        return new RevealOperation(hash2, content, publicKeyHash, forgedBytes, opResponse, context2);
      } else {
        throw new RevealOperationError(`The publicKeyHash '${publicKeyHash}' has already been revealed.`);
      }
    });
  }
  /**
   *
   * @description Register a Micheline expression in a global table of constants. Will sign and inject an operation using the current context
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @param params registerGlobalConstant operation parameter
   */
  registerGlobalConstant(params) {
    return __awaiter4(this, void 0, void 0, function* () {
      const publicKeyHash = yield this.signer.publicKeyHash();
      const estimate = yield this.estimate(params, this.estimator.registerGlobalConstant.bind(this.estimator));
      const prepared = yield this.prepare.registerGlobalConstant(Object.assign(Object.assign({}, params), estimate));
      const content = prepared.opOb.contents.find((op) => op.kind === OpKind.REGISTER_GLOBAL_CONSTANT);
      const opBytes = yield this.forge(prepared);
      const { hash: hash2, context: context2, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
      return new RegisterGlobalConstantOperation(hash2, content, publicKeyHash, forgedBytes, opResponse, context2);
    });
  }
  /**
   *
   * @description Increase the paid storage of a smart contract
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @param params increasePaidStorage operation parameter
   */
  increasePaidStorage(params) {
    return __awaiter4(this, void 0, void 0, function* () {
      if (params.amount < 0) {
        throw new InvalidAmountError(params.amount.toString());
      }
      const publicKeyHash = yield this.signer.publicKeyHash();
      const estimate = yield this.estimate(params, this.estimator.increasePaidStorage.bind(this.estimator));
      const prepared = yield this.prepare.increasePaidStorage(Object.assign(Object.assign({}, params), estimate));
      const content = prepared.opOb.contents.find((op) => op.kind === OpKind.INCREASE_PAID_STORAGE);
      const opBytes = yield this.forge(prepared);
      const { hash: hash2, context: context2, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
      return new IncreasePaidStorageOperation(hash2, content, publicKeyHash, forgedBytes, opResponse, context2);
    });
  }
  /**
   *
   * @description Transfers the spendable balance of the delegate to destination when consensus_key is the active consensus key of delegate
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @param params drainDelegate operation parameter
   */
  drainDelegate(params) {
    return __awaiter4(this, void 0, void 0, function* () {
      const prepared = yield this.prepare.drainDelegate(params);
      const content = prepared.opOb.contents.find((op) => op.kind === OpKind.DRAIN_DELEGATE);
      const opBytes = yield this.forge(prepared);
      const { hash: hash2, context: context2, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
      return new DrainDelegateOperation(hash2, content, forgedBytes, opResponse, context2);
    });
  }
  /**
   *
   * @description Submit a ballot vote to a specified proposal
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @param BallotParams Ballot operation parameter
   */
  ballot(params) {
    var _a3, _b;
    return __awaiter4(this, void 0, void 0, function* () {
      const publicKeyHash = yield this.signer.publicKeyHash();
      const sourceValidation = validateAddress((_a3 = params.source) !== null && _a3 !== void 0 ? _a3 : "");
      if (params.source && sourceValidation !== ValidationResult.VALID) {
        throw new InvalidAddressError(params.source, invalidDetail(sourceValidation));
      }
      const source = (_b = params.source) !== null && _b !== void 0 ? _b : publicKeyHash;
      const prepared = yield this.prepare.ballot(Object.assign(Object.assign({}, params), { source }));
      const content = prepared.opOb.contents.find((op) => op.kind === OpKind.BALLOT);
      const opBytes = yield this.forge(prepared);
      const { hash: hash2, context: context2, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
      return new BallotOperation(hash2, content, publicKeyHash, forgedBytes, opResponse, context2);
    });
  }
  /**
   *
   * @description Submit or upvote a proposal during the Proposal period
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @param ProposalsParams Proposals operation parameter
   */
  proposals(params) {
    var _a3, _b;
    return __awaiter4(this, void 0, void 0, function* () {
      const publicKeyHash = yield this.signer.publicKeyHash();
      const sourceValidation = validateAddress((_a3 = params.source) !== null && _a3 !== void 0 ? _a3 : "");
      if (params.source && sourceValidation !== ValidationResult.VALID) {
        throw new InvalidAddressError(params.source, invalidDetail(sourceValidation));
      }
      const source = (_b = params.source) !== null && _b !== void 0 ? _b : publicKeyHash;
      const prepared = yield this.prepare.proposals(Object.assign(Object.assign({}, params), { source }));
      const content = prepared.opOb.contents.find((op) => op.kind === OpKind.PROPOSALS);
      const opBytes = yield this.forge(prepared);
      const { hash: hash2, context: context2, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
      return new ProposalsOperation(hash2, content, publicKeyHash, forgedBytes, opResponse, context2);
    });
  }
  /**
   *
   * @description Updates the consensus key of the baker to public_key starting from the current cycle plus PRESERVED_CYCLES + 1
   *
   * @returns An operation handle with the result from the rpc node
   *
   * @param UpdateConsensusKeyParams
   */
  updateConsensusKey(params) {
    return __awaiter4(this, void 0, void 0, function* () {
      const publicKeyHash = yield this.signer.publicKeyHash();
      const estimate = yield this.estimate(params, this.estimator.updateConsensusKey.bind(this.estimator));
      const prepared = yield this.prepare.updateConsensusKey(Object.assign(Object.assign({}, params), estimate));
      const content = prepared.opOb.contents.find((op) => op.kind === OpKind.UPDATE_CONSENSUS_KEY);
      const opBytes = yield this.forge(prepared);
      const { hash: hash2, context: context2, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
      return new UpdateConsensusKeyOperation(hash2, content, publicKeyHash, forgedBytes, opResponse, context2);
    });
  }
  /**
   * @description Adds messages to the rollup inbox that can be executed/claimed after it gets cemented
   * @param SmartRollupAddMessagesParams
   * @returns An operation handle with results from the RPC node
   */
  smartRollupAddMessages(params) {
    return __awaiter4(this, void 0, void 0, function* () {
      const publicKeyHash = yield this.signer.publicKeyHash();
      const estimate = yield this.estimate(params, this.estimator.smartRollupAddMessages.bind(this.estimator));
      const prepared = yield this.prepare.smartRollupAddMessages(Object.assign(Object.assign({}, params), estimate));
      const content = prepared.opOb.contents.find((op) => op.kind === OpKind.SMART_ROLLUP_ADD_MESSAGES);
      const opBytes = yield this.forge(prepared);
      const { hash: hash2, context: context2, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
      return new SmartRollupAddMessagesOperation(hash2, content, publicKeyHash, forgedBytes, opResponse, context2);
    });
  }
  /**
   * @description Creates a smart rollup originate operation
   * @param SmartRollupOriginateParams
   * @returns An operation handle with results from the RPC node
   */
  smartRollupOriginate(params) {
    return __awaiter4(this, void 0, void 0, function* () {
      const publicKeyHash = yield this.signer.publicKeyHash();
      const estimate = yield this.estimate(params, this.estimator.smartRollupOriginate.bind(this.estimator));
      const originationProof = yield this.rpc.getOriginationProof({
        kind: params.pvmKind,
        kernel: params.kernel
      });
      const completeParams = Object.assign(Object.assign({}, params), { originationProof });
      const prepared = yield this.prepare.smartRollupOriginate(Object.assign(Object.assign({}, completeParams), estimate));
      const content = prepared.opOb.contents.find((op) => op.kind === OpKind.SMART_ROLLUP_ORIGINATE);
      const opBytes = yield this.forge(prepared);
      const { hash: hash2, context: context2, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
      return new SmartRollupOriginateOperation(hash2, content, publicKeyHash, forgedBytes, opResponse, context2);
    });
  }
  /**
   *
   * @description A failing_noop operation that is guaranteed to fail.
   *
   * @returns A FailingNoopOperation object representing the signed failing_noop operation
   *
   * @param params failingNoop operation parameter
   */
  failingNoop(params) {
    return __awaiter4(this, void 0, void 0, function* () {
      const op = {
        kind: OpKind.FAILING_NOOP,
        arbitrary: params.arbitrary
      };
      const hash2 = yield this.context.readProvider.getBlockHash(params.basedOnBlock);
      const forged = yield this.context.forger.forge({
        branch: hash2,
        contents: [op]
      });
      const { prefixSig } = yield this.signer.sign(forged, new Uint8Array([3]));
      return {
        signature: prefixSig,
        bytes: forged,
        signedContent: {
          branch: hash2,
          contents: [
            {
              kind: OpKind.FAILING_NOOP,
              arbitrary: params.arbitrary
            }
          ]
        }
      };
    });
  }
  /**
   *
   * @description Create an smart contract abstraction for the address specified.
   *
   * @param address Smart contract address
   * @throws {@link InvalidContractAddressError}
   */
  at(address, contractAbstractionComposer = (x) => x) {
    return __awaiter4(this, void 0, void 0, function* () {
      const addressValidation = validateContractAddress(address);
      if (addressValidation !== ValidationResult.VALID) {
        throw new InvalidContractAddressError(address, invalidDetail(addressValidation));
      }
      const rpc = this.context.withExtensions().rpc;
      const readProvider = this.context.withExtensions().readProvider;
      const script = yield readProvider.getScript(address, "head");
      const entrypoints = yield readProvider.getEntrypoints(address);
      const abs = new ContractAbstraction(address, script, this, this, entrypoints, rpc, readProvider);
      return contractAbstractionComposer(abs, this.context);
    });
  }
  /**
   *
   * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch
   *
   * @returns A batch object from which we can add more operation or send a command to execute the batch
   *
   * @param params List of operation to batch together
   */
  batch(params) {
    const batch = new OperationBatch(this.context, this.estimator);
    if (Array.isArray(params)) {
      batch.with(params);
    }
    return batch;
  }
};
var MichelCodecParser = class {
  constructor(context2) {
    this.context = context2;
  }
  getNextProto() {
    return __awaiter4(this, void 0, void 0, function* () {
      if (!this.context.proto) {
        const nextProto = yield this.context.readProvider.getNextProtocol("head");
        this.context.proto = nextProto;
      }
      return this.context.proto;
    });
  }
  parseScript(src) {
    return __awaiter4(this, void 0, void 0, function* () {
      const parser = new Parser({ protocol: yield this.getNextProto() });
      return parser.parseScript(src);
    });
  }
  parseMichelineExpression(src) {
    return __awaiter4(this, void 0, void 0, function* () {
      const parser = new Parser({ protocol: yield this.getNextProto() });
      return parser.parseMichelineExpression(src);
    });
  }
  parseJSON(src) {
    return __awaiter4(this, void 0, void 0, function* () {
      const parser = new Parser({ protocol: yield this.getNextProto() });
      return parser.parseJSON(src);
    });
  }
  prepareCodeOrigination(params) {
    return __awaiter4(this, void 0, void 0, function* () {
      const parsedParams = params;
      parsedParams.code = yield this.formatCodeParam(params.code);
      if (params.init) {
        parsedParams.init = yield this.formatInitParam(params.init);
      } else if (params.storage) {
        const storageType = parsedParams.code.find((p) => "prim" in p && p.prim === "storage");
        if (!(storageType === null || storageType === void 0 ? void 0 : storageType.args)) {
          throw new InvalidCodeParameter("The storage section is missing from the script", params.code);
        }
        const schema = new Schema(storageType.args[0]);
        const globalconstantsHashAndValue = yield this.findGlobalConstantsHashAndValue(schema);
        if (Object.keys(globalconstantsHashAndValue).length !== 0) {
          const p = new Parser({ expandGlobalConstant: globalconstantsHashAndValue });
          const storageTypeNoGlobalConst = p.parseJSON(storageType.args[0]);
          const schemaNoGlobalConst = new Schema(storageTypeNoGlobalConst);
          parsedParams.init = schemaNoGlobalConst.Encode(params.storage);
        } else {
          parsedParams.init = schema.Encode(params.storage);
        }
        delete parsedParams.storage;
      }
      return parsedParams;
    });
  }
  formatCodeParam(code2) {
    return __awaiter4(this, void 0, void 0, function* () {
      let parsedCode;
      if (typeof code2 === "string") {
        const c = yield this.parseScript(code2);
        if (c === null) {
          throw new InvalidCodeParameter("Unable to parse", code2);
        }
        parsedCode = c;
      } else {
        const c = yield this.parseJSON(code2);
        const order = ["parameter", "storage", "code"];
        parsedCode = c.sort((a, b) => order.indexOf(a.prim) - order.indexOf(b.prim));
      }
      return parsedCode;
    });
  }
  formatInitParam(init) {
    return __awaiter4(this, void 0, void 0, function* () {
      let parsedInit;
      if (typeof init === "string") {
        const c = yield this.parseMichelineExpression(init);
        if (c === null) {
          throw new InvalidInitParameter("Invalid init parameter", init);
        }
        parsedInit = c;
      } else {
        parsedInit = yield this.parseJSON(init);
      }
      return parsedInit;
    });
  }
  findGlobalConstantsHashAndValue(schema) {
    return __awaiter4(this, void 0, void 0, function* () {
      const globalConstantTokens = schema.findToken("constant");
      const globalConstantsHashAndValue = {};
      if (globalConstantTokens.length !== 0) {
        for (const token of globalConstantTokens) {
          const tokenArgs = token.tokenVal.args;
          if (tokenArgs) {
            const expression = tokenArgs[0];
            if (expression.string) {
              const hash2 = expression.string;
              const michelineValue = yield this.context.globalConstantsProvider.getGlobalConstantByHash(hash2);
              Object.assign(globalConstantsHashAndValue, {
                [hash2]: michelineValue
              });
            }
          }
        }
      }
      return globalConstantsHashAndValue;
    });
  }
};
var RpcPacker = class {
  constructor(context2) {
    this.context = context2;
  }
  packData(data) {
    return __awaiter4(this, void 0, void 0, function* () {
      return this.context.rpc.packData(data);
    });
  }
};
var GlobalConstantNotFound = class extends TaquitoError {
  constructor(hash2) {
    super();
    this.hash = hash2;
    this.name = "GlobalConstantNotFound";
    this.message = `Please load the value associated with the constant ${hash2} using the loadGlobalConstant method of the DefaultGlobalConstantsProvider.`;
  }
};
var UnconfiguredGlobalConstantsProviderError = class extends TezosToolkitConfigError {
  constructor() {
    super();
    this.name = "UnconfiguredGlobalConstantsProviderError";
    this.message = "No global constants provider has been configured. Please configure one by calling setGlobalConstantsProvider({globalConstantsProvider}) on your TezosToolkit instance.";
  }
};
var NoopGlobalConstantsProvider = class {
  getGlobalConstantByHash(_hash) {
    return __awaiter4(this, void 0, void 0, function* () {
      throw new UnconfiguredGlobalConstantsProviderError();
    });
  }
};
var RpcReadAdapter = class {
  constructor(rpc) {
    this.rpc = rpc;
  }
  /**
   * @description Access the balance of a contract.
   * @param address address from which we want to retrieve the balance
   * @param block from which we want to retrieve the balance
   * @returns the balance in mutez
   */
  getBalance(address, block) {
    return __awaiter4(this, void 0, void 0, function* () {
      return this.rpc.getBalance(address, { block: String(block) });
    });
  }
  /**
   * @description Access the delegate of a contract, if any.
   * @param address contract address from which we want to retrieve the delegate (baker)
   * @param block from which we want to retrieve the delegate
   * @returns the public key hash of the delegate or null if no delegate
   */
  getDelegate(address, block) {
    return __awaiter4(this, void 0, void 0, function* () {
      return this.rpc.getDelegate(address, { block: String(block) });
    });
  }
  /**
   * @description Access the next protocol hash
   * @param block from which we want to retrieve the next protocol hash
   */
  getNextProtocol(block) {
    return __awaiter4(this, void 0, void 0, function* () {
      const protocols2 = yield this.rpc.getProtocols({ block: String(block) });
      return protocols2.next_protocol;
    });
  }
  /**
   * @description Access protocol constants used in Taquito
   * @param block from which we want to retrieve the constants
   */
  getProtocolConstants(block) {
    return __awaiter4(this, void 0, void 0, function* () {
      const { time_between_blocks, minimal_block_delay, hard_gas_limit_per_operation, hard_gas_limit_per_block, hard_storage_limit_per_operation, cost_per_byte, tx_rollup_origination_size, smart_rollup_origination_size } = yield this.rpc.getConstants({ block: String(block) });
      return {
        time_between_blocks,
        minimal_block_delay,
        hard_gas_limit_per_operation,
        hard_gas_limit_per_block,
        hard_storage_limit_per_operation,
        cost_per_byte,
        tx_rollup_origination_size,
        smart_rollup_origination_size
      };
    });
  }
  /**
   * @description Access the script (code and storage) of a smart contract
   * @param contract contract address from which we want to retrieve the script
   * @param block from which we want to retrieve the storage value
   * @returns Note: The code must be in the JSON format and not contain global constant
   */
  getScript(contract, block) {
    return __awaiter4(this, void 0, void 0, function* () {
      const { script } = yield this.rpc.getContract(contract, { block: String(block) });
      return script;
    });
  }
  /**
   * @description Access the storage value of a contract
   * @param contract contract address from which we want to retrieve the storage
   * @param block from which we want to retrieve the storage value
   */
  getStorage(contract, block) {
    return __awaiter4(this, void 0, void 0, function* () {
      return this.rpc.getStorage(contract, { block: String(block) });
    });
  }
  /**
   * @description Access the block hash
   */
  getBlockHash(block) {
    return __awaiter4(this, void 0, void 0, function* () {
      const { hash: hash2 } = yield this.rpc.getBlockHeader({ block: String(block) });
      return hash2;
    });
  }
  /**
   * @description Access the block level
   */
  getBlockLevel(block) {
    return __awaiter4(this, void 0, void 0, function* () {
      const { level } = yield this.rpc.getBlockHeader({ block: String(block) });
      return level;
    });
  }
  /**
   * @description Access the counter of an address
   * @param pkh from which we want to retrieve the counter
   * @param block from which we want to retrieve the counter
   */
  getCounter(pkh, block) {
    return __awaiter4(this, void 0, void 0, function* () {
      const { counter } = yield this.rpc.getContract(pkh, { block: String(block) });
      return counter || "0";
    });
  }
  /**
   * @description Access the timestamp of a block
   * @param block from which we want to retrieve the timestamp
   * @returns date ISO format zero UTC offset ("2022-01-19T22:37:07Z")
   */
  getBlockTimestamp(block) {
    return __awaiter4(this, void 0, void 0, function* () {
      const { timestamp: timestamp2 } = yield this.rpc.getBlockHeader({ block: String(block) });
      return timestamp2;
    });
  }
  /**
   * @description Access the value associated with a key in a big map.
   * @param bigMapQuery Big Map ID and Expression hash to query (A b58check encoded Blake2b hash of the expression)
   * @param block from which we want to retrieve the big map value
   */
  getBigMapValue(bigMapQuery, block) {
    return __awaiter4(this, void 0, void 0, function* () {
      return this.rpc.getBigMapExpr(bigMapQuery.id, bigMapQuery.expr, {
        block: String(block)
      });
    });
  }
  /**
   * @description Access the value associated with a sapling state ID.
   * @param id Sapling state ID
   * @param block from which we want to retrieve the sapling state
   */
  getSaplingDiffById(saplingStateQuery, block) {
    return __awaiter4(this, void 0, void 0, function* () {
      return this.rpc.getSaplingDiffById(saplingStateQuery.id, { block: String(block) });
    });
  }
  /**
   * @description Access the sapling state of a smart contract.
   * @param contractAddress The address of the smart contract
   * @param block The block you want to retrieve the sapling state from
   */
  getSaplingDiffByContract(contractAddress, block) {
    return __awaiter4(this, void 0, void 0, function* () {
      return this.rpc.getSaplingDiffByContract(contractAddress, { block: String(block) });
    });
  }
  /**
   * @description Return the list of entrypoints of the contract
   * @param contract address of the contract we want to get the entrypoints of
   */
  getEntrypoints(contract) {
    return __awaiter4(this, void 0, void 0, function* () {
      return this.rpc.getEntrypoints(contract);
    });
  }
  /**
   * @description Access the chain id
   */
  getChainId() {
    return __awaiter4(this, void 0, void 0, function* () {
      return this.rpc.getChainId();
    });
  }
  /**
   * @description Indicate if an account is revealed
   * @param publicKeyHash of the account
   * @param block from which we want to know if the account is revealed
   */
  isAccountRevealed(publicKeyHash, block) {
    return __awaiter4(this, void 0, void 0, function* () {
      const manager = yield this.rpc.getManagerKey(publicKeyHash, { block: String(block) });
      const haveManager = manager && typeof manager === "object" ? !!manager.key : !!manager;
      return haveManager;
    });
  }
  /**
   * @description Return all the information about a block
   * @param block from which we want to retrieve the information
   */
  getBlock(block) {
    return __awaiter4(this, void 0, void 0, function* () {
      return this.rpc.getBlock({ block: String(block) });
    });
  }
  /**
   * @description Return a list of the ancestors of the given block which, if referred to as the branch in an operation header, are recent enough for that operation to be included in the current block.
   * @param block from which we want to retrieve the information
   */
  getLiveBlocks(block) {
    return this.rpc.getLiveBlocks({ block: String(block) });
  }
};
var UnsupportedEventError = class extends ParameterValidationError {
  constructor(type) {
    super();
    this.type = type;
    this.name = "UnsupportedEventError";
    this.message = `Unsupported event type "${type}" expecting one of the "data", "error", or "close".`;
  }
};
var InvalidFilterExpressionError = class extends ParameterValidationError {
  constructor(invalidExpression) {
    super();
    this.invalidExpression = invalidExpression;
    this.name = "InvalidFilterExpressionError";
    this.message = `Invalid filter expression expecting the object to contain either and/or property`;
  }
};
var opHashFilter = (op, filter2) => op.hash === filter2.opHash;
var sourceFilter = (x, filter2) => {
  switch (x.kind) {
    case "endorsement":
      return "metadata" in x && x.metadata.delegate === filter2.source;
    case "activate_account":
      return "metadata" in x && x.pkh === filter2.source;
    default:
      return "source" in x && x.source === filter2.source;
  }
};
var kindFilter = (x, filter2) => "kind" in x && x.kind === filter2.kind;
var destinationFilter = (x, filter2) => {
  switch (x.kind) {
    case "delegation":
      return x.delegate === filter2.destination;
    case "origination":
      if ("metadata" in x && "operation_result" in x.metadata && "originated_contracts" in x.metadata.operation_result && Array.isArray(x.metadata.operation_result.originated_contracts)) {
        return x.metadata.operation_result.originated_contracts.some((contract) => contract === filter2.destination);
      }
      break;
    case "transaction":
      return x.destination === filter2.destination;
    default:
      return false;
  }
};
var eventFilter = (result, address, tag, excludeFailedOperations) => {
  if (result.kind !== "event") {
    return false;
  }
  if (tag && result.tag !== tag) {
    return false;
  }
  if (address && result.source !== address) {
    return false;
  }
  if (excludeFailedOperations && result.result.status !== "applied") {
    return false;
  }
  return true;
};
var evaluateOpFilter = (op, filter2) => {
  if ("opHash" in filter2) {
    return opHashFilter(op, filter2);
  } else if ("source" in filter2) {
    return sourceFilter(op, filter2);
  } else if ("kind" in filter2) {
    return kindFilter(op, filter2);
  } else if ("destination" in filter2) {
    return destinationFilter(op, filter2);
  }
  return false;
};
var evaluateExpression = (op, exp) => {
  if (Array.isArray(exp.and)) {
    return exp.and.every((x) => evaluateFilter(op, x));
  } else if (Array.isArray(exp.or)) {
    return exp.or.some((x) => evaluateFilter(op, x));
  } else {
    throw new InvalidFilterExpressionError(exp);
  }
};
var evaluateFilter = (op, filter2) => {
  const filters = [];
  if (!Array.isArray(filter2)) {
    filters.push(filter2);
  } else {
    filters.push(...filter2);
  }
  return filters.every((filterOrExp) => {
    if ("and" in filterOrExp || "or" in filterOrExp) {
      return evaluateExpression(op, filterOrExp);
    } else {
      return evaluateOpFilter(op, filterOrExp);
    }
  });
};
var ObservableSubscription = class {
  constructor(obs, shouldRetry = false, operatorFunction = retry()) {
    this.shouldRetry = shouldRetry;
    this.operatorFunction = operatorFunction;
    this.errorListeners = [];
    this.messageListeners = [];
    this.closeListeners = [];
    this.completed$ = new Subject();
    obs.pipe(takeUntil(this.completed$), tap((data) => {
      this.call(this.messageListeners, data);
    }, (error) => {
      this.call(this.errorListeners, error);
    }, () => {
      this.call(this.closeListeners);
    }), this.shouldRetry ? operatorFunction : tap(), catchError(() => NEVER)).subscribe();
  }
  call(listeners, value) {
    for (const l of listeners) {
      try {
        l(value);
      } catch (ex) {
        console.error(ex);
      }
    }
  }
  remove(listeners, value) {
    const idx = listeners.indexOf(value);
    if (idx !== -1) {
      listeners.splice(idx, 1);
    }
  }
  on(type, cb) {
    switch (type) {
      case "data":
        this.messageListeners.push(cb);
        break;
      case "error":
        this.errorListeners.push(cb);
        break;
      case "close":
        this.closeListeners.push(cb);
        break;
      default:
        throw new UnsupportedEventError(type);
    }
  }
  off(type, cb) {
    switch (type) {
      case "data":
        this.remove(this.messageListeners, cb);
        break;
      case "error":
        this.remove(this.errorListeners, cb);
        break;
      case "close":
        this.remove(this.closeListeners, cb);
        break;
      default:
        throw new UnsupportedEventError(type);
    }
  }
  close() {
    this.completed$.next();
  }
};
var defaultConfigStreamer = {
  shouldObservableSubscriptionRetry: false,
  observableSubscriptionRetryFunction: retry()
};
var getLastBlock = (context2) => {
  return from(context2.rpc.getBlock()).pipe(first());
};
var applyFilter = (filter2) => concatMap((block) => {
  return new Observable((sub) => {
    for (const ops of block.operations) {
      for (const op of ops) {
        for (const content of op.contents) {
          if (evaluateFilter(Object.assign({ hash: op.hash }, content), filter2)) {
            sub.next(Object.assign({ hash: op.hash }, content));
          }
        }
      }
    }
    sub.complete();
  });
});
var applyEventFilter = (filter2) => concatMap((block) => {
  return new Observable((sub) => {
    for (const ops of block.operations) {
      for (const op of ops) {
        for (const content of op.contents) {
          const tx = content;
          const internalOpResults = tx.metadata.internal_operation_results;
          if (internalOpResults) {
            for (const event of internalOpResults) {
              if (eventFilter(event, filter2 === null || filter2 === void 0 ? void 0 : filter2.address, filter2 === null || filter2 === void 0 ? void 0 : filter2.tag, filter2 === null || filter2 === void 0 ? void 0 : filter2.excludeFailedOperations)) {
                sub.next(Object.assign({ opHash: op.hash, blockHash: block.hash, level: block.header.level }, event));
              }
            }
          }
        }
      }
    }
    sub.complete();
  });
});
var PollingSubscribeProvider = class {
  constructor(context2, config2 = {}) {
    this.context = context2;
    this._config$ = new BehaviorSubject(Object.assign(Object.assign({}, defaultConfigStreamer), config2));
    this.timer$ = this._config$.pipe(pluck("pollingIntervalMilliseconds"), switchMap((pollingIntervalMilliseconds) => {
      if (!pollingIntervalMilliseconds) {
        return from(this.getConfirmationPollingInterval()).pipe(switchMap((interval2) => {
          return timer(0, interval2);
        }));
      } else {
        return timer(0, pollingIntervalMilliseconds);
      }
    }));
    this.newBlock$ = this.timer$.pipe(switchMap(() => getLastBlock(this.context)), distinctUntilKeyChanged("hash"), publish(), refCount());
  }
  get config() {
    return this._config$.getValue();
  }
  getConfirmationPollingInterval() {
    return __awaiter4(this, void 0, void 0, function* () {
      if (!this.config.pollingIntervalMilliseconds) {
        const defaultIntervalTestnetsMainnet = 5e3;
        const defaultIntervalSandbox = 1e3;
        try {
          const constants = yield this.context.readProvider.getProtocolConstants("head");
          const blockTime = constants.minimal_block_delay ? constants.minimal_block_delay.multipliedBy(1e3) : constants.time_between_blocks ? constants.time_between_blocks[0].multipliedBy(1e3) : new bignumber_default(defaultIntervalTestnetsMainnet);
          const confirmationPollingInterval = blockTime.dividedBy(3);
          this.config.pollingIntervalMilliseconds = confirmationPollingInterval.toNumber() === 0 ? defaultIntervalSandbox : confirmationPollingInterval.toNumber();
        } catch (exception) {
          return defaultIntervalTestnetsMainnet;
        }
      }
      return this.config.pollingIntervalMilliseconds;
    });
  }
  subscribeBlock(_filter) {
    return new ObservableSubscription(this.newBlock$, this.config.shouldObservableSubscriptionRetry, this.config.observableSubscriptionRetryFunction);
  }
  subscribe(_filter) {
    return new ObservableSubscription(this.newBlock$.pipe(pluck("hash")), this.config.shouldObservableSubscriptionRetry, this.config.observableSubscriptionRetryFunction);
  }
  subscribeOperation(filter2) {
    return new ObservableSubscription(this.newBlock$.pipe(applyFilter(filter2)), this.config.shouldObservableSubscriptionRetry, this.config.observableSubscriptionRetryFunction);
  }
  subscribeEvent(eventFilter2) {
    return new ObservableSubscription(this.newBlock$.pipe(applyEventFilter(eventFilter2)), this.config.shouldObservableSubscriptionRetry, this.config.observableSubscriptionRetryFunction);
  }
};
var TaquitoLocalForger = class {
  constructor(context2) {
    this.context = context2;
  }
  getNextProto() {
    return __awaiter4(this, void 0, void 0, function* () {
      if (!this.context.proto) {
        const nextProto = yield this.context.readProvider.getNextProtocol("head");
        this.context.proto = nextProto;
      }
      return this.context.proto;
    });
  }
  forge({ branch, contents }) {
    return __awaiter4(this, void 0, void 0, function* () {
      const forger = new LocalForger(yield this.getNextProto());
      return forger.forge({ branch, contents });
    });
  }
};
var defaultConfigConfirmation = {
  defaultConfirmationCount: 1,
  confirmationPollingTimeoutSecond: 180
};
var Context = class _Context {
  constructor(_rpc, _signer = new NoopSigner(), _proto, _config = new BehaviorSubject(Object.assign({}, defaultConfigConfirmation)), forger, injector, packer, wallet, parser, globalConstantsProvider, readProvider, stream) {
    this._rpc = _rpc;
    this._signer = _signer;
    this._proto = _proto;
    this._config = _config;
    this.providerDecorator = [];
    this.tz = new RpcTzProvider(this);
    this.estimate = new RPCEstimateProvider(this);
    this.contract = new RpcContractProvider(this, this.estimate);
    this.prepare = new PrepareProvider(this);
    this.batch = new RPCBatchProvider(this, this.estimate);
    this.wallet = new Wallet(this);
    this.withExtensions = () => {
      let clonedContext = this.clone();
      this.providerDecorator.forEach((decorator) => {
        clonedContext = decorator(clonedContext);
      });
      return clonedContext;
    };
    if (typeof this._rpc === "string") {
      this._rpcClient = new RpcClient(this._rpc);
    } else {
      this._rpcClient = this._rpc;
    }
    this._forger = forger ? forger : new TaquitoLocalForger(this);
    this._injector = injector ? injector : new RpcInjector(this);
    this.operationFactory = new OperationFactory(this);
    this._walletProvider = wallet ? wallet : new LegacyWalletProvider(this);
    this._parser = parser ? parser : new MichelCodecParser(this);
    this._packer = packer ? packer : new RpcPacker(this);
    this._globalConstantsProvider = globalConstantsProvider ? globalConstantsProvider : new NoopGlobalConstantsProvider();
    this._readProvider = readProvider ? readProvider : new RpcReadAdapter(this._rpcClient);
    this._stream = stream ? stream : new PollingSubscribeProvider(this);
  }
  get config() {
    return this._config.getValue();
  }
  set config(value) {
    this._config.next(Object.assign({}, value));
  }
  setPartialConfig(value) {
    this._config.next(Object.assign(Object.assign({}, this._config.getValue()), value));
  }
  get rpc() {
    return this._rpcClient;
  }
  set rpc(value) {
    this._rpcClient = value;
  }
  get injector() {
    return this._injector;
  }
  set injector(value) {
    this._injector = value;
  }
  get forger() {
    return this._forger;
  }
  set forger(value) {
    this._forger = value;
  }
  get signer() {
    return this._signer;
  }
  set signer(value) {
    this._signer = value;
  }
  get walletProvider() {
    return this._walletProvider;
  }
  set walletProvider(value) {
    this._walletProvider = value;
  }
  set proto(value) {
    this._proto = value;
  }
  get proto() {
    return this._proto;
  }
  get parser() {
    return this._parser;
  }
  set parser(value) {
    this._parser = value;
  }
  get packer() {
    return this._packer;
  }
  set packer(value) {
    this._packer = value;
  }
  get globalConstantsProvider() {
    return this._globalConstantsProvider;
  }
  set globalConstantsProvider(value) {
    this._globalConstantsProvider = value;
  }
  get readProvider() {
    return this._readProvider;
  }
  set readProvider(value) {
    this._readProvider = value;
  }
  get stream() {
    return this._stream;
  }
  set stream(value) {
    this._stream = value;
  }
  isAnyProtocolActive(protocol = []) {
    return __awaiter4(this, void 0, void 0, function* () {
      if (this._proto) {
        return protocol.includes(this._proto);
      } else {
        const next_protocol = yield this.readProvider.getNextProtocol("head");
        return protocol.includes(next_protocol);
      }
    });
  }
  isAnySignerConfigured() {
    return !(this.signer instanceof NoopSigner);
  }
  /**
   * @description Create a copy of the current context. Useful when you have long running operation and you do not want a context change to affect the operation
   */
  clone() {
    return new _Context(this.rpc, this.signer, this.proto, this._config, this.forger, this._injector, this.packer, this._walletProvider, this._parser, this._globalConstantsProvider, this._readProvider, this._stream);
  }
  /**
   * @description Allows extensions set on the TezosToolkit to inject logic into the context
   */
  registerProviderDecorator(fx) {
    this.providerDecorator.push(fx);
  }
};
var VERSION = {
  "commitHash": "b85fc404e34545a518215e449b3f1253f4520eec",
  "version": "17.2.0"
};
var ForgingMismatchError = class extends TaquitoError {
  constructor(results) {
    super();
    this.results = results;
    this.name = "ForgingMismatchError";
    this.message = `Forging mismatch error`;
  }
};
var UnspecifiedForgerError = class extends TezosToolkitConfigError {
  constructor() {
    super();
    this.name = "UnspecifiedForgerError";
    this.message = "No forger has been configured. Please configure new CompositeForger([rpcForger, localForger]) with your TezosToolkit instance.";
  }
};
var CompositeForger = class {
  constructor(forgers) {
    this.forgers = forgers;
    if (forgers.length === 0) {
      throw new UnspecifiedForgerError();
    }
  }
  forge({ branch, contents }) {
    return __awaiter4(this, void 0, void 0, function* () {
      const results = yield Promise.all(this.forgers.map((forger) => {
        return forger.forge({ branch, contents });
      }));
      if (results.length === 0) {
        throw new UnspecifiedForgerError();
      }
      let lastResult = results.pop();
      while (results.length) {
        const currentResult = results.pop();
        if (currentResult !== lastResult) {
          throw new ForgingMismatchError([lastResult, currentResult]);
        }
        lastResult = currentResult;
      }
      return lastResult;
    });
  }
};
var RpcForger = class {
  constructor(context2) {
    this.context = context2;
  }
  forge({ branch, contents }) {
    return this.context.rpc.forgeOperations({ branch, contents });
  }
};
var NoopParser = class {
  prepareCodeOrigination(params) {
    return __awaiter4(this, void 0, void 0, function* () {
      return params;
    });
  }
};
var MichelCodecPacker = class {
  packData(data) {
    return __awaiter4(this, void 0, void 0, function* () {
      const { bytes } = packDataBytes(data.data, data.type);
      return { packed: bytes };
    });
  }
};
var DefaultGlobalConstantsProvider = class {
  constructor() {
    this._globalConstantsLibrary = {};
  }
  /**
   *
   * @description Allows to load global constant hashes and their corresponding Michelson JSON values
   */
  loadGlobalConstant(globalConstant) {
    for (const hash2 in globalConstant) {
      Object.assign(this._globalConstantsLibrary, {
        [hash2]: globalConstant[hash2]
      });
    }
  }
  /**
   *
   * @description Retrieve the Michelson value of a global constant based on its hash
   *
   * @param hash a string representing the global constant hash
   * @returns Expr, the JSON Michelson value
   */
  getGlobalConstantByHash(hash2) {
    return __awaiter4(this, void 0, void 0, function* () {
      const value = this._globalConstantsLibrary[hash2];
      if (!value) {
        throw new GlobalConstantNotFound(hash2);
      }
      return value;
    });
  }
};
var TezosToolkit = class {
  constructor(_rpc) {
    this._rpc = _rpc;
    this._options = {};
    this.format = format;
    if (typeof this._rpc === "string") {
      this._rpcClient = new RpcClient(this._rpc);
    } else {
      this._rpcClient = this._rpc;
    }
    this._context = new Context(_rpc);
    this._wallet = new Wallet(this._context);
    this.setProvider({ rpc: this._rpcClient });
    this.batch = this._context.batch.batch.bind(this._context.batch);
  }
  /**
   * @description Sets configuration on the Tezos Taquito instance. Allows user to choose which signer, rpc client, rpc url, forger and so forth
   *
   * @param options rpc url or rpcClient to use to interact with the Tezos network
   *
   * @example Tezos.setProvider({rpc: 'https://mainnet.api.tez.ie/', signer: new InMemorySigner.fromSecretKey(edsk...)})
   * @example Tezos.setProvider({ config: { confirmationPollingTimeoutSecond: 300 }})
   *
   */
  setProvider({ rpc, stream, signer, protocol, config: config2, forger, wallet, packer, globalConstantsProvider, readProvider, parserProvider, injectorProvider }) {
    this.setRpcProvider(rpc);
    this.setStreamProvider(stream);
    this.setSignerProvider(signer);
    this.setForgerProvider(forger);
    this.setWalletProvider(wallet);
    this.setPackerProvider(packer);
    this.setGlobalConstantsProvider(globalConstantsProvider);
    this.setReadProvider(readProvider);
    this.setParserProvider(parserProvider);
    this.setInjectorProvider(injectorProvider);
    this._context.proto = protocol;
    if (config2) {
      this._context.setPartialConfig(config2);
    }
  }
  /**
   * @description Sets signer provider on the Tezos Taquito instance.
   *
   * @param options signer to use to interact with the Tezos network
   *
   * @example Tezos.setSignerProvider(new InMemorySigner.fromSecretKey('edsk...'))
   *
   */
  setSignerProvider(signer) {
    if (!this._options.signer && typeof signer === "undefined") {
      this._context.signer = new NoopSigner();
      this._options.signer = signer;
    } else if (typeof signer !== "undefined") {
      this._context.signer = signer;
      this._options.signer = signer;
    }
  }
  /**
   * @description Sets rpc provider on the Tezos Taquito instance
   *
   * @param options rpc url or rpcClient to use to interact with the Tezos network
   *
   * @example Tezos.setRpcProvider('https://mainnet.api.tez.ie/')
   *
   */
  setRpcProvider(rpc) {
    if (typeof rpc === "string") {
      this._rpcClient = new RpcClient(rpc);
    } else if (rpc === void 0)
      ;
    else {
      this._rpcClient = rpc;
    }
    this._options.rpc = this._rpcClient;
    this._context.rpc = this._rpcClient;
  }
  /**
   * @description Sets forger provider on the Tezos Taquito instance
   * The `LocalForger` from `@taquito/local-forging` is set by default.
   *
   * @param options forger to use to interact with the Tezos network
   *
   * @example Tezos.setForgerProvider(this.getFactory(RpcForger)())
   *
   */
  setForgerProvider(forger) {
    if (typeof forger !== "undefined") {
      this._options.forger = forger;
      this._context.forger = forger;
    } else if (this._options.forger === void 0) {
      const f = this.getFactory(TaquitoLocalForger)();
      this._options.forger = f;
      this._context.forger = f;
    }
  }
  /**
   * @description Sets stream provider on the Tezos Taquito instance
   *
   * @param options stream to use to interact with the Tezos network
   *
   * @example Tezos.setStreamProvider(...)
   *
   */
  setStreamProvider(stream) {
    if (typeof stream === "string") {
      const s = new PollingSubscribeProvider(new Context(new RpcClient(stream)));
      this._options.stream = s;
      this._context.stream = s;
    } else if (typeof stream !== "undefined") {
      this._options.stream = stream;
      this._context.stream = stream;
    } else if (this._options.stream === void 0) {
      const s = this.getFactory(PollingSubscribeProvider)();
      this._options.stream = s;
      this._context.stream = s;
    }
  }
  /**
   * @description Sets wallet provider on the Tezos Taquito instance
   *
   * @param options wallet to use to interact with the Tezos network
   *
   * @example Tezos.setWalletProvider(...)
   *
   */
  setWalletProvider(wallet) {
    if (!this._options.wallet && typeof wallet === "undefined") {
      const w = this.getFactory(LegacyWalletProvider)();
      this._options.wallet = w;
      this._context.walletProvider = w;
    } else if (typeof wallet !== "undefined") {
      this._options.wallet = wallet;
      this._context.walletProvider = wallet;
    }
  }
  /**
   * @description Sets Packer provider on the Tezos Taquito instance
   *
   * @param options packer to use to interact with the Tezos network
   *
   * @example Tezos.setPackerProvider(new MichelCodecPacker())
   *
   */
  setPackerProvider(packer) {
    if (!this._options.packer && typeof packer === "undefined") {
      const p = this.getFactory(RpcPacker)();
      this._context.packer = p;
      this._options.packer = p;
    } else if (typeof packer !== "undefined") {
      this._context.packer = packer;
      this._options.packer = packer;
    }
  }
  /**
   * @description Sets global constants provider on the Tezos Taquito instance
   *
   * @param options globalConstantsProvider to use to interact with the Tezos network
   *
   * @example
   * ```
   * const globalConst = new DefaultGlobalConstantsProvider();
   * globalConst.loadGlobalConstant({
   *  "expruu5BTdW7ajqJ9XPTF3kgcV78pRiaBW3Gq31mgp3WSYjjUBYxre": { prim: "int" },
   *  // ...
   * })
   * Tezos.setGlobalConstantsProvider(globalConst);
   * ```
   *
   */
  setGlobalConstantsProvider(globalConstantsProvider) {
    if (!this._options.globalConstantsProvider && typeof globalConstantsProvider === "undefined") {
      const g = new NoopGlobalConstantsProvider();
      this._context.globalConstantsProvider = g;
      this._options.globalConstantsProvider = g;
    } else if (typeof globalConstantsProvider !== "undefined") {
      this._context.globalConstantsProvider = globalConstantsProvider;
      this._options.globalConstantsProvider = globalConstantsProvider;
    }
  }
  /**
   * @description Sets read provider on the Tezos Taquito instance
   * By default reads are done from the RPC usign the RpcReadAdapter class, this can be overridden to read from an indexer that implements the TzReadProvider interface
   *
   * @param options TzReadProvider to use to interact with the Tezos network
   *
   */
  setReadProvider(readProvider) {
    const readP = readProvider ? readProvider : new RpcReadAdapter(this._context.rpc);
    this._options.readProvider = readP;
    this._context.readProvider = readP;
  }
  /**
   * @description Sets parser provider on the Tezos Taquito instance
   *
   * @param options parserProvider to use to interact with the Tezos network
   *
   */
  setParserProvider(parserProvider) {
    if (!this._options.parserProvider && typeof parserProvider === "undefined") {
      const p = new MichelCodecParser(this._context);
      this._context.parser = p;
      this._options.parserProvider = p;
    } else if (typeof parserProvider !== "undefined") {
      this._context.parser = parserProvider;
      this._options.parserProvider = parserProvider;
    }
  }
  /**
   * @description Sets injector provider on the Tezos Taquito instance
   *
   * @param options Injector to use to interact with the Tezos network by default RpcInjector
   *
   */
  setInjectorProvider(injectorProvider) {
    if (!this._options.injectorProvider && typeof injectorProvider === "undefined") {
      const i = new RpcInjector(this._context);
      this._context.injector = i;
      this._options.injectorProvider = i;
    } else if (typeof injectorProvider !== "undefined") {
      this._context.injector = injectorProvider;
      this._options.injectorProvider = injectorProvider;
    }
  }
  /**
   * @description Provide access to tezos account management
   */
  get tz() {
    return this._context.tz;
  }
  /**
   * @description Provide access to smart contract utilities
   */
  get contract() {
    return this._context.contract;
  }
  /**
   * @description Provide access to tezos operation preparation utilities
   */
  get prepare() {
    return this._context.prepare;
  }
  get wallet() {
    return this._wallet;
  }
  get operation() {
    return this._context.operationFactory;
  }
  /**
   * @description Provide access to operation estimation utilities
   */
  get estimate() {
    return this._context.estimate;
  }
  /**
   * @description Provide access to streaming utilities backed by an streamer implementation
   */
  get stream() {
    return this._context.stream;
  }
  /**
   * @description Provide access to the currently used rpc client
   */
  get rpc() {
    return this._context.rpc;
  }
  /**
   * @description Provide access to the currently used signer
   */
  get signer() {
    return this._context.signer;
  }
  /**
   * @description Provide access to the currently used globalConstantsProvider
   */
  get globalConstants() {
    return this._context.globalConstantsProvider;
  }
  /**
   * @description Allow to add a module to the TezosToolkit instance. This method adds the appropriate Providers(s) required by the module to the internal context.
   *
   * @param module extension to add to the TezosToolkit instance
   *
   * @example Tezos.addExtension(new Tzip16Module());
   */
  addExtension(module) {
    if (Array.isArray(module)) {
      module.forEach((extension) => extension.configureContext(this._context));
    } else {
      module.configureContext(this._context);
    }
  }
  getFactory(ctor) {
    return (...args) => {
      return new ctor(this._context, ...args);
    };
  }
  /**
   * @description Gets an object containing the version of Taquito library and git sha of the commit this library is compiled from
   */
  getVersionInfo() {
    return VERSION;
  }
};

export {
  require_typedarray_to_buffer,
  HttpBackend,
  hex2buf,
  mergebuf,
  buf2hex,
  char2Bytes,
  bytes2Char,
  OpKind,
  MichelsonMap,
  Schema,
  ParameterSchema,
  UnitValue,
  RpcInjector,
  DEFAULT_GAS_LIMIT,
  DEFAULT_FEE,
  DEFAULT_STORAGE_LIMIT,
  COST_PER_BYTE,
  Protocols,
  protocols,
  ChainIds,
  getRevealGasLimit,
  InvalidParameterError,
  InvalidDelegationSource,
  InvalidCodeParameter,
  InvalidInitParameter,
  ViewSimulationError,
  validateAndExtractFailwith,
  InvalidViewSimulationContext,
  RevealOperationError,
  OriginationParameterError,
  InvalidBalanceError,
  createActivationOperation,
  createOriginationOperation,
  createTransferOperation,
  createSetDelegateOperation,
  createRegisterDelegateOperation,
  createRevealOperation,
  createRegisterGlobalConstantOperation,
  createTransferTicketOperation,
  createIncreasePaidStorageOperation,
  createDrainDelegateOperation,
  createBallotOperation,
  createProposalsOperation,
  createUpdateConsensusKeyOperation,
  createSmartRollupAddMessagesOperation,
  createSmartRollupOriginateOperation,
  TezosOperationError,
  TezosPreapplyFailureError,
  InvalidEstimateValueError,
  Operation,
  BatchOperation,
  WalletOperationBatch,
  Wallet,
  WalletOperation,
  TransactionWalletOperation,
  OriginationWalletOperation,
  DelegationWalletOperation,
  LegacyWalletProvider,
  ContractMethodObject,
  ContractMethod,
  DEFAULT_SMART_CONTRACT_METHOD_NAME,
  ContractView,
  ContractAbstraction,
  MANAGER_LAMBDA,
  VIEW_LAMBDA,
  compose,
  SaplingStateAbstraction,
  PrepareProvider,
  OperationBatch,
  Estimate,
  RevealEstimateError,
  RPCEstimateProvider,
  DelegateOperation,
  OriginationOperation,
  TransactionOperation,
  BigMapAbstraction,
  BallotOperation,
  DrainDelegateOperation,
  MichelCodecParser,
  RpcPacker,
  GlobalConstantNotFound,
  UnconfiguredGlobalConstantsProviderError,
  RpcReadAdapter,
  ObservableSubscription,
  PollingSubscribeProvider,
  TaquitoLocalForger,
  defaultConfigConfirmation,
  Context,
  CompositeForger,
  RpcForger,
  NoopParser,
  MichelCodecPacker,
  DefaultGlobalConstantsProvider,
  TezosToolkit
};
/*! Bundled license information:

typedarray-to-buffer/index.js:
  (*! typedarray-to-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=chunk-4L2B3TSL.js.map
