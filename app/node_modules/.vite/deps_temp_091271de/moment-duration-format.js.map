{
  "version": 3,
  "sources": ["../../moment-duration-format/lib/moment-duration-format.js"],
  "sourcesContent": ["/*! Moment Duration Format v2.2.2\n *  https://github.com/jsmreese/moment-duration-format\n *  Date: 2018-02-16\n *\n *  Duration format plugin function for the Moment.js library\n *  http://momentjs.com/\n *\n *  Copyright 2018 John Madhavan-Reese\n *  Released under the MIT license\n */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['moment'], factory);\n    } else if (typeof exports === 'object') {\n        // Node. Does not work with strict CommonJS, but only CommonJS-like\n        // enviroments that support module.exports, like Node.\n        try {\n            module.exports = factory(require('moment'));\n        } catch (e) {\n            // If moment is not available, leave the setup up to the user.\n            // Like when using moment-timezone or similar moment-based package.\n            module.exports = factory;\n        }\n    }\n\n    if (root) {\n        // Globals.\n        root.momentDurationFormatSetup = root.moment ? factory(root.moment) : factory;\n    }\n})(this, function (moment) {\n    // `Number#tolocaleString` is tested on plugin initialization.\n    // If the feature test passes, `toLocaleStringWorks` will be set to `true` and the\n    // native function will be used to generate formatted output. If the feature\n    // test fails, the fallback format function internal to this plugin will be\n    // used.\n    var toLocaleStringWorks = false;\n\n    // `Number#toLocaleString` rounds incorrectly for select numbers in Microsoft\n    // environments (Edge, IE11, Windows Phone) and possibly other environments.\n    // If the rounding test fails and `toLocaleString` will be used for formatting,\n    // the plugin will \"pre-round\" number values using the fallback number format\n    // function before passing them to `toLocaleString` for final formatting.\n    var toLocaleStringRoundingWorks = false;\n\n    // `Intl.NumberFormat#format` is tested on plugin initialization.\n    // If the feature test passes, `intlNumberFormatRoundingWorks` will be set to\n    // `true` and the native function will be used to generate formatted output.\n    // If the feature test fails, either `Number#tolocaleString` (if\n    // `toLocaleStringWorks` is `true`), or the fallback format function internal\n    //  to this plugin will be used.\n    var intlNumberFormatWorks = false;\n\n    // `Intl.NumberFormat#format` rounds incorrectly for select numbers in Microsoft\n    // environments (Edge, IE11, Windows Phone) and possibly other environments.\n    // If the rounding test fails and `Intl.NumberFormat#format` will be used for\n    // formatting, the plugin will \"pre-round\" number values using the fallback number\n    // format function before passing them to `Intl.NumberFormat#format` for final\n    // formatting.\n    var intlNumberFormatRoundingWorks = false;\n\n    // Token type names in order of descending magnitude.\n    var types = \"escape years months weeks days hours minutes seconds milliseconds general\".split(\" \");\n\n    var bubbles = [\n        {\n            type: \"seconds\",\n            targets: [\n                { type: \"minutes\", value: 60 },\n                { type: \"hours\", value: 3600 },\n                { type: \"days\", value: 86400 },\n                { type: \"weeks\", value: 604800 },\n                { type: \"months\", value: 2678400 },\n                { type: \"years\", value: 31536000 }\n            ]\n        },\n        {\n            type: \"minutes\",\n            targets: [\n                { type: \"hours\", value: 60 },\n                { type: \"days\", value: 1440 },\n                { type: \"weeks\", value: 10080 },\n                { type: \"months\", value: 44640 },\n                { type: \"years\", value: 525600 }\n            ]\n        },\n        {\n            type: \"hours\",\n            targets: [\n                { type: \"days\", value: 24 },\n                { type: \"weeks\", value: 168 },\n                { type: \"months\", value: 744 },\n                { type: \"years\", value: 8760 }\n            ]\n        },\n        {\n            type: \"days\",\n            targets: [\n                { type: \"weeks\", value: 7 },\n                { type: \"months\", value: 31 },\n                { type: \"years\", value: 365 }\n            ]\n        },\n        {\n            type: \"months\",\n            targets: [\n                { type: \"years\", value: 12 }\n            ]\n        }\n    ];\n\n    // stringIncludes\n    function stringIncludes(str, search) {\n        if (search.length > str.length) {\n          return false;\n        }\n\n        return str.indexOf(search) !== -1;\n    }\n\n    // repeatZero(qty)\n    // Returns \"0\" repeated `qty` times.\n    // `qty` must be a integer >= 0.\n    function repeatZero(qty) {\n        var result = \"\";\n\n        while (qty) {\n            result += \"0\";\n            qty -= 1;\n        }\n\n        return result;\n    }\n\n    function stringRound(digits) {\n        var digitsArray = digits.split(\"\").reverse();\n        var i = 0;\n        var carry = true;\n\n        while (carry && i < digitsArray.length) {\n            if (i) {\n                if (digitsArray[i] === \"9\") {\n                    digitsArray[i] = \"0\";\n                } else {\n                    digitsArray[i] = (parseInt(digitsArray[i], 10) + 1).toString();\n                    carry = false;\n                }\n            } else {\n                if (parseInt(digitsArray[i], 10) < 5) {\n                    carry = false;\n                }\n\n                digitsArray[i] = \"0\";\n            }\n\n            i += 1;\n        }\n\n        if (carry) {\n            digitsArray.push(\"1\");\n        }\n\n        return digitsArray.reverse().join(\"\");\n    }\n\n    // cachedNumberFormat\n    // Returns an `Intl.NumberFormat` instance for the given locale and configuration.\n    // On first use of a particular configuration, the instance is cached for fast\n    // repeat access.\n    function cachedNumberFormat(locale, options) {\n        // Create a sorted, stringified version of `options`\n        // for use as part of the cache key\n        var optionsString = map(\n            keys(options).sort(),\n            function(key) {\n                return key + ':' + options[key];\n            }\n        ).join(',');\n\n        // Set our cache key\n        var cacheKey = locale + '+' + optionsString;\n\n        // If we don't have this configuration cached, configure and cache it\n        if (!cachedNumberFormat.cache[cacheKey]) {\n            cachedNumberFormat.cache[cacheKey] = Intl.NumberFormat(locale, options);\n        }\n\n        // Return the cached version of this configuration\n        return cachedNumberFormat.cache[cacheKey];\n    }\n    cachedNumberFormat.cache = {};\n\n    // formatNumber\n    // Formats any number greater than or equal to zero using these options:\n    // - userLocale\n    // - useToLocaleString\n    // - useGrouping\n    // - grouping\n    // - maximumSignificantDigits\n    // - minimumIntegerDigits\n    // - fractionDigits\n    // - groupingSeparator\n    // - decimalSeparator\n    //\n    // `useToLocaleString` will use `Intl.NumberFormat` or `toLocaleString` for formatting.\n    // `userLocale` option is passed through to the formatting function.\n    // `fractionDigits` is passed through to `maximumFractionDigits` and `minimumFractionDigits`\n    // Using `maximumSignificantDigits` will override `minimumIntegerDigits` and `fractionDigits`.\n    function formatNumber(number, options, userLocale) {\n        var useToLocaleString = options.useToLocaleString;\n        var useGrouping = options.useGrouping;\n        var grouping = useGrouping && options.grouping.slice();\n        var maximumSignificantDigits = options.maximumSignificantDigits;\n        var minimumIntegerDigits = options.minimumIntegerDigits || 1;\n        var fractionDigits = options.fractionDigits || 0;\n        var groupingSeparator = options.groupingSeparator;\n        var decimalSeparator = options.decimalSeparator;\n\n        if (useToLocaleString && userLocale) {\n            var localeStringOptions = {\n                minimumIntegerDigits: minimumIntegerDigits,\n                useGrouping: useGrouping\n            };\n\n            if (fractionDigits) {\n                localeStringOptions.maximumFractionDigits = fractionDigits;\n                localeStringOptions.minimumFractionDigits = fractionDigits;\n            }\n\n            // toLocaleString output is \"0.0\" instead of \"0\" for HTC browsers\n            // when maximumSignificantDigits is set. See #96.\n            if (maximumSignificantDigits && number > 0) {\n                localeStringOptions.maximumSignificantDigits = maximumSignificantDigits;\n            }\n\n            if (intlNumberFormatWorks) {\n                if (!intlNumberFormatRoundingWorks) {\n                    var roundingOptions = extend({}, options);\n                    roundingOptions.useGrouping = false;\n                    roundingOptions.decimalSeparator = \".\";\n                    number = parseFloat(formatNumber(number, roundingOptions), 10);\n                }\n\n                return cachedNumberFormat(userLocale, localeStringOptions).format(number);\n            } else {\n                if (!toLocaleStringRoundingWorks) {\n                    var roundingOptions = extend({}, options);\n                    roundingOptions.useGrouping = false;\n                    roundingOptions.decimalSeparator = \".\";\n                    number = parseFloat(formatNumber(number, roundingOptions), 10);\n                }\n\n                return number.toLocaleString(userLocale, localeStringOptions);\n            }\n        }\n\n        var numberString;\n\n        // Add 1 to digit output length for floating point errors workaround. See below.\n        if (maximumSignificantDigits) {\n            numberString = number.toPrecision(maximumSignificantDigits + 1);\n        } else {\n            numberString = number.toFixed(fractionDigits + 1);\n        }\n\n        var integerString;\n        var fractionString;\n        var exponentString;\n\n        var temp = numberString.split(\"e\");\n\n        exponentString = temp[1] || \"\";\n\n        temp = temp[0].split(\".\");\n\n        fractionString = temp[1] || \"\";\n        integerString = temp[0] || \"\";\n\n        // Workaround for floating point errors in `toFixed` and `toPrecision`.\n        // (3.55).toFixed(1); --> \"3.5\"\n        // (123.55 - 120).toPrecision(2); --> \"3.5\"\n        // (123.55 - 120); --> 3.549999999999997\n        // (123.55 - 120).toFixed(2); --> \"3.55\"\n        // Round by examing the string output of the next digit.\n\n        // *************** Implement String Rounding here ***********************\n        // Check integerString + fractionString length of toPrecision before rounding.\n        // Check length of fractionString from toFixed output before rounding.\n        var integerLength = integerString.length;\n        var fractionLength = fractionString.length;\n        var digitCount = integerLength + fractionLength;\n        var digits = integerString + fractionString;\n\n        if (maximumSignificantDigits && digitCount === (maximumSignificantDigits + 1) || !maximumSignificantDigits && fractionLength === (fractionDigits + 1)) {\n            // Round digits.\n            digits = stringRound(digits);\n\n            if (digits.length === digitCount + 1) {\n                integerLength = integerLength + 1;\n            }\n\n            // Discard final fractionDigit.\n            if (fractionLength) {\n                digits = digits.slice(0, -1);\n            }\n\n            // Separate integer and fraction.\n            integerString = digits.slice(0, integerLength);\n            fractionString = digits.slice(integerLength);\n        }\n\n        // Trim trailing zeroes from fractionString because toPrecision outputs\n        // precision, not significant digits.\n        if (maximumSignificantDigits) {\n            fractionString = fractionString.replace(/0*$/, \"\");\n        }\n\n        // Handle exponent.\n        var exponent = parseInt(exponentString, 10);\n\n        if (exponent > 0) {\n            if (fractionString.length <= exponent) {\n                fractionString = fractionString + repeatZero(exponent - fractionString.length);\n\n                integerString = integerString + fractionString;\n                fractionString = \"\";\n            } else {\n                integerString = integerString + fractionString.slice(0, exponent);\n                fractionString = fractionString.slice(exponent);\n            }\n        } else if (exponent < 0) {\n            fractionString = (repeatZero(Math.abs(exponent) - integerString.length) + integerString + fractionString);\n\n            integerString = \"0\";\n        }\n\n        if (!maximumSignificantDigits) {\n            // Trim or pad fraction when not using maximumSignificantDigits.\n            fractionString = fractionString.slice(0, fractionDigits);\n\n            if (fractionString.length < fractionDigits) {\n                fractionString = fractionString + repeatZero(fractionDigits - fractionString.length);\n            }\n\n            // Pad integer when using minimumIntegerDigits\n            // and not using maximumSignificantDigits.\n            if (integerString.length < minimumIntegerDigits) {\n                integerString = repeatZero(minimumIntegerDigits - integerString.length) + integerString;\n            }\n        }\n\n        var formattedString = \"\";\n\n        // Handle grouping.\n        if (useGrouping) {\n            temp = integerString;\n            var group;\n\n            while (temp.length) {\n                if (grouping.length) {\n                    group = grouping.shift();\n                }\n\n                if (formattedString) {\n                    formattedString = groupingSeparator + formattedString;\n                }\n\n                formattedString = temp.slice(-group) + formattedString;\n\n                temp = temp.slice(0, -group);\n            }\n        } else {\n            formattedString = integerString;\n        }\n\n        // Add decimalSeparator and fraction.\n        if (fractionString) {\n            formattedString = formattedString + decimalSeparator + fractionString;\n        }\n\n        return formattedString;\n    }\n\n    // durationLabelCompare\n    function durationLabelCompare(a, b) {\n        if (a.label.length > b.label.length) {\n            return -1;\n        }\n\n        if (a.label.length < b.label.length) {\n            return 1;\n        }\n\n        // a must be equal to b\n        return 0;\n    }\n\n    // durationGetLabels\n    function durationGetLabels(token, localeData) {\n        var labels = [];\n\n        each(keys(localeData), function (localeDataKey) {\n            if (localeDataKey.slice(0, 15) !== \"_durationLabels\") {\n                return;\n            }\n\n            var labelType = localeDataKey.slice(15).toLowerCase();\n\n            each(keys(localeData[localeDataKey]), function (labelKey) {\n                if (labelKey.slice(0, 1) === token) {\n                    labels.push({\n                        type: labelType,\n                        key: labelKey,\n                        label: localeData[localeDataKey][labelKey]\n                    });\n                }\n            });\n        });\n\n        return labels;\n    }\n\n    // durationPluralKey\n    function durationPluralKey(token, integerValue, decimalValue) {\n        // Singular for a value of `1`, but not for `1.0`.\n        if (integerValue === 1 && decimalValue === null) {\n            return token;\n        }\n\n        return token + token;\n    }\n\n    var engLocale = {\n        durationLabelsStandard: {\n            S: 'millisecond',\n            SS: 'milliseconds',\n            s: 'second',\n            ss: 'seconds',\n            m: 'minute',\n            mm: 'minutes',\n            h: 'hour',\n            hh: 'hours',\n            d: 'day',\n            dd: 'days',\n            w: 'week',\n            ww: 'weeks',\n            M: 'month',\n            MM: 'months',\n            y: 'year',\n            yy: 'years'\n        },\n        durationLabelsShort: {\n            S: 'msec',\n            SS: 'msecs',\n            s: 'sec',\n            ss: 'secs',\n            m: 'min',\n            mm: 'mins',\n            h: 'hr',\n            hh: 'hrs',\n            d: 'dy',\n            dd: 'dys',\n            w: 'wk',\n            ww: 'wks',\n            M: 'mo',\n            MM: 'mos',\n            y: 'yr',\n            yy: 'yrs'\n        },\n        durationTimeTemplates: {\n            HMS: 'h:mm:ss',\n            HM: 'h:mm',\n            MS: 'm:ss'\n        },\n        durationLabelTypes: [\n            { type: \"standard\", string: \"__\" },\n            { type: \"short\", string: \"_\" }\n        ],\n        durationPluralKey: durationPluralKey\n    };\n\n    // isArray\n    function isArray(array) {\n        return Object.prototype.toString.call(array) === \"[object Array]\";\n    }\n\n    // isObject\n    function isObject(obj) {\n        return Object.prototype.toString.call(obj) === \"[object Object]\";\n    }\n\n    // findLast\n    function findLast(array, callback) {\n        var index = array.length;\n\n        while (index -= 1) {\n            if (callback(array[index])) { return array[index]; }\n        }\n    }\n\n    // find\n    function find(array, callback) {\n        var index = 0;\n\n        var max = array && array.length || 0;\n\n        var match;\n\n        if (typeof callback !== \"function\") {\n            match = callback;\n            callback = function (item) {\n                return item === match;\n            };\n        }\n\n        while (index < max) {\n            if (callback(array[index])) { return array[index]; }\n            index += 1;\n        }\n    }\n\n    // each\n    function each(array, callback) {\n        var index = 0,\n            max = array.length;\n\n        if (!array || !max) { return; }\n\n        while (index < max) {\n            if (callback(array[index], index) === false) { return; }\n            index += 1;\n        }\n    }\n\n    // map\n    function map(array, callback) {\n        var index = 0,\n            max = array.length,\n            ret = [];\n\n        if (!array || !max) { return ret; }\n\n        while (index < max) {\n            ret[index] = callback(array[index], index);\n            index += 1;\n        }\n\n        return ret;\n    }\n\n    // pluck\n    function pluck(array, prop) {\n        return map(array, function (item) {\n            return item[prop];\n        });\n    }\n\n    // compact\n    function compact(array) {\n        var ret = [];\n\n        each(array, function (item) {\n            if (item) { ret.push(item); }\n        });\n\n        return ret;\n    }\n\n    // unique\n    function unique(array) {\n        var ret = [];\n\n        each(array, function (_a) {\n            if (!find(ret, _a)) { ret.push(_a); }\n        });\n\n        return ret;\n    }\n\n    // intersection\n    function intersection(a, b) {\n        var ret = [];\n\n        each(a, function (_a) {\n            each(b, function (_b) {\n                if (_a === _b) { ret.push(_a); }\n            });\n        });\n\n        return unique(ret);\n    }\n\n    // rest\n    function rest(array, callback) {\n        var ret = [];\n\n        each(array, function (item, index) {\n            if (!callback(item)) {\n                ret = array.slice(index);\n                return false;\n            }\n        });\n\n        return ret;\n    }\n\n    // initial\n    function initial(array, callback) {\n        var reversed = array.slice().reverse();\n\n        return rest(reversed, callback).reverse();\n    }\n\n    // extend\n    function extend(a, b) {\n        for (var key in b) {\n            if (b.hasOwnProperty(key)) { a[key] = b[key]; }\n        }\n\n        return a;\n    }\n\n    // keys\n    function keys(a) {\n        var ret = [];\n\n        for (var key in a) {\n            if (a.hasOwnProperty(key)) { ret.push(key); }\n        }\n\n        return ret;\n    }\n\n    // any\n    function any(array, callback) {\n        var index = 0,\n            max = array.length;\n\n        if (!array || !max) { return false; }\n\n        while (index < max) {\n            if (callback(array[index], index) === true) { return true; }\n            index += 1;\n        }\n\n        return false;\n    }\n\n    // flatten\n    function flatten(array) {\n        var ret = [];\n\n        each(array, function(child) {\n            ret = ret.concat(child);\n        });\n\n        return ret;\n    }\n\n    function toLocaleStringSupportsLocales() {\n        var number = 0;\n        try {\n            number.toLocaleString('i');\n        } catch (e) {\n            return e.name === 'RangeError';\n        }\n        return false;\n    }\n\n    function featureTestFormatterRounding(formatter) {\n        return formatter(3.55, \"en\", {\n            useGrouping: false,\n            minimumIntegerDigits: 1,\n            minimumFractionDigits: 1,\n            maximumFractionDigits: 1\n        }) === \"3.6\";\n    }\n\n    function featureTestFormatter(formatter) {\n        var passed = true;\n\n        // Test minimumIntegerDigits.\n        passed = passed && formatter(1, \"en\", { minimumIntegerDigits: 1 }) === \"1\";\n        passed = passed && formatter(1, \"en\", { minimumIntegerDigits: 2 }) === \"01\";\n        passed = passed && formatter(1, \"en\", { minimumIntegerDigits: 3 }) === \"001\";\n        if (!passed) { return false; }\n\n        // Test maximumFractionDigits and minimumFractionDigits.\n        passed = passed && formatter(99.99, \"en\", { maximumFractionDigits: 0, minimumFractionDigits: 0 }) === \"100\";\n        passed = passed && formatter(99.99, \"en\", { maximumFractionDigits: 1, minimumFractionDigits: 1 }) === \"100.0\";\n        passed = passed && formatter(99.99, \"en\", { maximumFractionDigits: 2, minimumFractionDigits: 2 }) === \"99.99\";\n        passed = passed && formatter(99.99, \"en\", { maximumFractionDigits: 3, minimumFractionDigits: 3 }) === \"99.990\";\n        if (!passed) { return false; }\n\n        // Test maximumSignificantDigits.\n        passed = passed && formatter(99.99, \"en\", { maximumSignificantDigits: 1 }) === \"100\";\n        passed = passed && formatter(99.99, \"en\", { maximumSignificantDigits: 2 }) === \"100\";\n        passed = passed && formatter(99.99, \"en\", { maximumSignificantDigits: 3 }) === \"100\";\n        passed = passed && formatter(99.99, \"en\", { maximumSignificantDigits: 4 }) === \"99.99\";\n        passed = passed && formatter(99.99, \"en\", { maximumSignificantDigits: 5 }) === \"99.99\";\n        if (!passed) { return false; }\n\n        // Test grouping.\n        passed = passed && formatter(1000, \"en\", { useGrouping: true }) === \"1,000\";\n        passed = passed && formatter(1000, \"en\", { useGrouping: false }) === \"1000\";\n        if (!passed) { return false; }\n\n        return true;\n    }\n\n    // durationsFormat(durations [, template] [, precision] [, settings])\n    function durationsFormat() {\n        var args = [].slice.call(arguments);\n        var settings = {};\n        var durations;\n\n        // Parse arguments.\n        each(args, function (arg, index) {\n            if (!index) {\n                if (!isArray(arg)) {\n                    throw \"Expected array as the first argument to durationsFormat.\";\n                }\n\n                durations = arg;\n            }\n\n            if (typeof arg === \"string\" || typeof arg === \"function\") {\n                settings.template = arg;\n                return;\n            }\n\n            if (typeof arg === \"number\") {\n                settings.precision = arg;\n                return;\n            }\n\n            if (isObject(arg)) {\n                extend(settings, arg);\n            }\n        });\n\n        if (!durations || !durations.length) {\n            return [];\n        }\n\n        settings.returnMomentTypes = true;\n\n        var formattedDurations = map(durations, function (dur) {\n            return dur.format(settings);\n        });\n\n        // Merge token types from all durations.\n        var outputTypes = intersection(types, unique(pluck(flatten(formattedDurations), \"type\")));\n\n        var largest = settings.largest;\n\n        if (largest) {\n            outputTypes = outputTypes.slice(0, largest);\n        }\n\n        settings.returnMomentTypes = false;\n        settings.outputTypes = outputTypes;\n\n        return map(durations, function (dur) {\n            return dur.format(settings);\n        });\n    }\n\n    // durationFormat([template] [, precision] [, settings])\n    function durationFormat() {\n\n        var args = [].slice.call(arguments);\n        var settings = extend({}, this.format.defaults);\n\n        // Keep a shadow copy of this moment for calculating remainders.\n        // Perform all calculations on positive duration value, handle negative\n        // sign at the very end.\n        var asMilliseconds = this.asMilliseconds();\n        var asMonths = this.asMonths();\n\n        // Treat invalid durations as having a value of 0 milliseconds.\n        if (typeof this.isValid === \"function\" && this.isValid() === false) {\n            asMilliseconds = 0;\n            asMonths = 0;\n        }\n\n        var isNegative = asMilliseconds < 0;\n\n        // Two shadow copies are needed because of the way moment.js handles\n        // duration arithmetic for years/months and for weeks/days/hours/minutes/seconds.\n        var remainder = moment.duration(Math.abs(asMilliseconds), \"milliseconds\");\n        var remainderMonths = moment.duration(Math.abs(asMonths), \"months\");\n\n        // Parse arguments.\n        each(args, function (arg) {\n            if (typeof arg === \"string\" || typeof arg === \"function\") {\n                settings.template = arg;\n                return;\n            }\n\n            if (typeof arg === \"number\") {\n                settings.precision = arg;\n                return;\n            }\n\n            if (isObject(arg)) {\n                extend(settings, arg);\n            }\n        });\n\n        var momentTokens = {\n            years: \"y\",\n            months: \"M\",\n            weeks: \"w\",\n            days: \"d\",\n            hours: \"h\",\n            minutes: \"m\",\n            seconds: \"s\",\n            milliseconds: \"S\"\n        };\n\n        var tokenDefs = {\n            escape: /\\[(.+?)\\]/,\n            years: /\\*?[Yy]+/,\n            months: /\\*?M+/,\n            weeks: /\\*?[Ww]+/,\n            days: /\\*?[Dd]+/,\n            hours: /\\*?[Hh]+/,\n            minutes: /\\*?m+/,\n            seconds: /\\*?s+/,\n            milliseconds: /\\*?S+/,\n            general: /.+?/\n        };\n\n        // Types array is available in the template function.\n        settings.types = types;\n\n        var typeMap = function (token) {\n            return find(types, function (type) {\n                return tokenDefs[type].test(token);\n            });\n        };\n\n        var tokenizer = new RegExp(map(types, function (type) {\n            return tokenDefs[type].source;\n        }).join(\"|\"), \"g\");\n\n        // Current duration object is available in the template function.\n        settings.duration = this;\n\n        // Eval template function and cache template string.\n        var template = typeof settings.template === \"function\" ? settings.template.apply(settings) : settings.template;\n\n        // outputTypes and returnMomentTypes are settings to support durationsFormat().\n\n        // outputTypes is an array of moment token types that determines\n        // the tokens returned in formatted output. This option overrides\n        // trim, largest, stopTrim, etc.\n        var outputTypes = settings.outputTypes;\n\n        // returnMomentTypes is a boolean that sets durationFormat to return\n        // the processed momentTypes instead of formatted output.\n        var returnMomentTypes = settings.returnMomentTypes;\n\n        var largest = settings.largest;\n\n        // Setup stopTrim array of token types.\n        var stopTrim = [];\n\n        if (!outputTypes) {\n            if (isArray(settings.stopTrim)) {\n                settings.stopTrim = settings.stopTrim.join(\"\");\n            }\n\n            // Parse stopTrim string to create token types array.\n            if (settings.stopTrim) {\n                each(settings.stopTrim.match(tokenizer), function (token) {\n                    var type = typeMap(token);\n\n                    if (type === \"escape\" || type === \"general\") {\n                        return;\n                    }\n\n                    stopTrim.push(type);\n                });\n            }\n        }\n\n        // Cache moment's locale data.\n        var localeData = moment.localeData();\n\n        if (!localeData) {\n            localeData = {};\n        }\n\n        // Fall back to this plugin's `eng` extension.\n        each(keys(engLocale), function (key) {\n            if (typeof engLocale[key] === \"function\") {\n                if (!localeData[key]) {\n                    localeData[key] = engLocale[key];\n                }\n\n                return;\n            }\n\n            if (!localeData[\"_\" + key]) {\n                localeData[\"_\" + key] = engLocale[key];\n            }\n        });\n\n        // Replace Duration Time Template strings.\n        // For locale `eng`: `_HMS_`, `_HM_`, and `_MS_`.\n        each(keys(localeData._durationTimeTemplates), function (item) {\n            template = template.replace(\"_\" + item + \"_\", localeData._durationTimeTemplates[item]);\n        });\n\n        // Determine user's locale.\n        var userLocale = settings.userLocale || moment.locale();\n\n        var useLeftUnits = settings.useLeftUnits;\n        var usePlural = settings.usePlural;\n        var precision = settings.precision;\n        var forceLength = settings.forceLength;\n        var useGrouping = settings.useGrouping;\n        var trunc = settings.trunc;\n\n        // Use significant digits only when precision is greater than 0.\n        var useSignificantDigits = settings.useSignificantDigits && precision > 0;\n        var significantDigits = useSignificantDigits ? settings.precision : 0;\n        var significantDigitsCache = significantDigits;\n\n        var minValue = settings.minValue;\n        var isMinValue = false;\n\n        var maxValue = settings.maxValue;\n        var isMaxValue = false;\n\n        // formatNumber fallback options.\n        var useToLocaleString = settings.useToLocaleString;\n        var groupingSeparator = settings.groupingSeparator;\n        var decimalSeparator = settings.decimalSeparator;\n        var grouping = settings.grouping;\n\n        useToLocaleString = useToLocaleString && (toLocaleStringWorks || intlNumberFormatWorks);\n\n        // Trim options.\n        var trim = settings.trim;\n\n        if (isArray(trim)) {\n            trim = trim.join(\" \");\n        }\n\n        if (trim === null && (largest || maxValue || useSignificantDigits)) {\n            trim = \"all\";\n        }\n\n        if (trim === null || trim === true || trim === \"left\" || trim === \"right\") {\n            trim = \"large\";\n        }\n\n        if (trim === false) {\n            trim = \"\";\n        }\n\n        var trimIncludes = function (item) {\n            return item.test(trim);\n        };\n\n        var rLarge = /large/;\n        var rSmall = /small/;\n        var rBoth = /both/;\n        var rMid = /mid/;\n        var rAll = /^all|[^sm]all/;\n        var rFinal = /final/;\n\n        var trimLarge = largest > 0 || any([rLarge, rBoth, rAll], trimIncludes);\n        var trimSmall = any([rSmall, rBoth, rAll], trimIncludes);\n        var trimMid = any([rMid, rAll], trimIncludes);\n        var trimFinal = any([rFinal, rAll], trimIncludes);\n\n        // Parse format string to create raw tokens array.\n        var rawTokens = map(template.match(tokenizer), function (token, index) {\n            var type = typeMap(token);\n\n            if (token.slice(0, 1) === \"*\") {\n                token = token.slice(1);\n\n                if (type !== \"escape\" && type !== \"general\") {\n                    stopTrim.push(type);\n                }\n            }\n\n            return {\n                index: index,\n                length: token.length,\n                text: \"\",\n\n                // Replace escaped tokens with the non-escaped token text.\n                token: (type === \"escape\" ? token.replace(tokenDefs.escape, \"$1\") : token),\n\n                // Ignore type on non-moment tokens.\n                type: ((type === \"escape\" || type === \"general\") ? null : type)\n            };\n        });\n\n        // Associate text tokens with moment tokens.\n        var currentToken = {\n            index: 0,\n            length: 0,\n            token: \"\",\n            text: \"\",\n            type: null\n        };\n\n        var tokens = [];\n\n        if (useLeftUnits) {\n            rawTokens.reverse();\n        }\n\n        each(rawTokens, function (token) {\n            if (token.type) {\n                if (currentToken.type || currentToken.text) {\n                    tokens.push(currentToken);\n                }\n\n                currentToken = token;\n\n                return;\n            }\n\n            if (useLeftUnits) {\n                currentToken.text = token.token + currentToken.text;\n            } else {\n                currentToken.text += token.token;\n            }\n        });\n\n        if (currentToken.type || currentToken.text) {\n            tokens.push(currentToken);\n        }\n\n        if (useLeftUnits) {\n            tokens.reverse();\n        }\n\n        // Find unique moment token types in the template in order of\n        // descending magnitude.\n        var momentTypes = intersection(types, unique(compact(pluck(tokens, \"type\"))));\n\n        // Exit early if there are no moment token types.\n        if (!momentTypes.length) {\n            return pluck(tokens, \"text\").join(\"\");\n        }\n\n        // Calculate values for each moment type in the template.\n        // For processing the settings, values are associated with moment types.\n        // Values will be assigned to tokens at the last step in order to\n        // assume nothing about frequency or order of tokens in the template.\n        momentTypes = map(momentTypes, function (momentType, index) {\n            // Is this the least-magnitude moment token found?\n            var isSmallest = ((index + 1) === momentTypes.length);\n\n            // Is this the greatest-magnitude moment token found?\n            var isLargest = (!index);\n\n            // Get the raw value in the current units.\n            var rawValue;\n\n            if (momentType === \"years\" || momentType === \"months\") {\n                rawValue = remainderMonths.as(momentType);\n            } else {\n                rawValue = remainder.as(momentType);\n            }\n\n            var wholeValue = Math.floor(rawValue);\n            var decimalValue = rawValue - wholeValue;\n\n            var token = find(tokens, function (token) {\n                return momentType === token.type;\n            });\n\n            if (isLargest && maxValue && rawValue > maxValue) {\n                isMaxValue = true;\n            }\n\n            if (isSmallest && minValue && Math.abs(settings.duration.as(momentType)) < minValue) {\n                isMinValue = true;\n            }\n\n            // Note the length of the largest-magnitude moment token:\n            // if it is greater than one and forceLength is not set,\n            // then default forceLength to `true`.\n            //\n            // Rationale is this: If the template is \"h:mm:ss\" and the\n            // moment value is 5 minutes, the user-friendly output is\n            // \"5:00\", not \"05:00\". We shouldn't pad the `minutes` token\n            // even though it has length of two if the template is \"h:mm:ss\";\n            //\n            // If the minutes output should always include the leading zero\n            // even when the hour is trimmed then set `{ forceLength: true }`\n            // to output \"05:00\". If the template is \"hh:mm:ss\", the user\n            // clearly wanted everything padded so we should output \"05:00\";\n            //\n            // If the user wants the full padded output, they can use\n            // template \"hh:mm:ss\" and set `{ trim: false }` to output\n            // \"00:05:00\".\n            if (isLargest && forceLength === null && token.length > 1) {\n                forceLength = true;\n            }\n\n            // Update remainder.\n            remainder.subtract(wholeValue, momentType);\n            remainderMonths.subtract(wholeValue, momentType);\n\n            return {\n                rawValue: rawValue,\n                wholeValue: wholeValue,\n                // Decimal value is only retained for the least-magnitude\n                // moment type in the format template.\n                decimalValue: isSmallest ? decimalValue : 0,\n                isSmallest: isSmallest,\n                isLargest: isLargest,\n                type: momentType,\n                // Tokens can appear multiple times in a template string,\n                // but all instances must share the same length.\n                tokenLength: token.length\n            };\n        });\n\n        var truncMethod = trunc ? Math.floor : Math.round;\n        var truncate = function (value, places) {\n            var factor = Math.pow(10, places);\n            return truncMethod(value * factor) / factor;\n        };\n\n        var foundFirst = false;\n        var bubbled = false;\n\n        var formatValue = function (momentType, index) {\n            var formatOptions = {\n                useGrouping: useGrouping,\n                groupingSeparator: groupingSeparator,\n                decimalSeparator: decimalSeparator,\n                grouping: grouping,\n                useToLocaleString: useToLocaleString\n            };\n\n            if (useSignificantDigits) {\n                if (significantDigits <= 0) {\n                    momentType.rawValue = 0;\n                    momentType.wholeValue = 0;\n                    momentType.decimalValue = 0;\n                } else {\n                    formatOptions.maximumSignificantDigits = significantDigits;\n                    momentType.significantDigits = significantDigits;\n                }\n            }\n\n            if (isMaxValue && !bubbled) {\n                if (momentType.isLargest) {\n                    momentType.wholeValue = maxValue;\n                    momentType.decimalValue = 0;\n                } else {\n                    momentType.wholeValue = 0;\n                    momentType.decimalValue = 0;\n                }\n            }\n\n            if (isMinValue && !bubbled) {\n                if (momentType.isSmallest) {\n                    momentType.wholeValue = minValue;\n                    momentType.decimalValue = 0;\n                } else {\n                    momentType.wholeValue = 0;\n                    momentType.decimalValue = 0;\n                }\n            }\n\n            if (momentType.isSmallest || momentType.significantDigits && momentType.significantDigits - momentType.wholeValue.toString().length <= 0) {\n                // Apply precision to least significant token value.\n                if (precision < 0) {\n                    momentType.value = truncate(momentType.wholeValue, precision);\n                } else if (precision === 0) {\n                    momentType.value = truncMethod(momentType.wholeValue + momentType.decimalValue);\n                } else { // precision > 0\n                    if (useSignificantDigits) {\n                        if (trunc) {\n                            momentType.value = truncate(momentType.rawValue, significantDigits - momentType.wholeValue.toString().length);\n                        } else {\n                            momentType.value = momentType.rawValue;\n                        }\n\n                        if (momentType.wholeValue) {\n                            significantDigits -= momentType.wholeValue.toString().length;\n                        }\n                    } else {\n                        formatOptions.fractionDigits = precision;\n\n                        if (trunc) {\n                            momentType.value = momentType.wholeValue + truncate(momentType.decimalValue, precision);\n                        } else {\n                            momentType.value = momentType.wholeValue + momentType.decimalValue;\n                        }\n                    }\n                }\n            } else {\n                if (useSignificantDigits && momentType.wholeValue) {\n                    // Outer Math.round required here to handle floating point errors.\n                    momentType.value = Math.round(truncate(momentType.wholeValue, momentType.significantDigits - momentType.wholeValue.toString().length));\n\n                    significantDigits -= momentType.wholeValue.toString().length;\n                } else {\n                    momentType.value = momentType.wholeValue;\n                }\n            }\n\n            if (momentType.tokenLength > 1 && (forceLength || foundFirst)) {\n                formatOptions.minimumIntegerDigits = momentType.tokenLength;\n\n                if (bubbled && formatOptions.maximumSignificantDigits < momentType.tokenLength) {\n                    delete formatOptions.maximumSignificantDigits;\n                }\n            }\n\n            if (!foundFirst && (momentType.value > 0 || trim === \"\" /* trim: false */ || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n                foundFirst = true;\n            }\n\n            momentType.formattedValue = formatNumber(momentType.value, formatOptions, userLocale);\n\n            formatOptions.useGrouping = false;\n            formatOptions.decimalSeparator = \".\";\n            momentType.formattedValueEn = formatNumber(momentType.value, formatOptions, \"en\");\n\n            if (momentType.tokenLength === 2 && momentType.type === \"milliseconds\") {\n                momentType.formattedValueMS = formatNumber(momentType.value, {\n                    minimumIntegerDigits: 3,\n                    useGrouping: false\n                }, \"en\").slice(0, 2);\n            }\n\n            return momentType;\n        };\n\n        // Calculate formatted values.\n        momentTypes = map(momentTypes, formatValue);\n        momentTypes = compact(momentTypes);\n\n        // Bubble rounded values.\n        if (momentTypes.length > 1) {\n            var findType = function (type) {\n                return find(momentTypes, function (momentType) {\n                    return momentType.type === type;\n                });\n            };\n\n            var bubbleTypes = function (bubble) {\n                var bubbleMomentType = findType(bubble.type);\n\n                if (!bubbleMomentType) {\n                    return;\n                }\n\n                each(bubble.targets, function (target) {\n                    var targetMomentType = findType(target.type);\n\n                    if (!targetMomentType) {\n                        return;\n                    }\n\n                    if (parseInt(bubbleMomentType.formattedValueEn, 10) === target.value) {\n                        bubbleMomentType.rawValue = 0;\n                        bubbleMomentType.wholeValue = 0;\n                        bubbleMomentType.decimalValue = 0;\n                        targetMomentType.rawValue += 1;\n                        targetMomentType.wholeValue += 1;\n                        targetMomentType.decimalValue = 0;\n                        targetMomentType.formattedValueEn = targetMomentType.wholeValue.toString();\n                        bubbled = true;\n                    }\n                });\n            };\n\n            each(bubbles, bubbleTypes);\n        }\n\n        // Recalculate formatted values.\n        if (bubbled) {\n            foundFirst = false;\n            significantDigits = significantDigitsCache;\n            momentTypes = map(momentTypes, formatValue);\n            momentTypes = compact(momentTypes);\n        }\n\n        if (outputTypes && !(isMaxValue && !settings.trim)) {\n            momentTypes = map(momentTypes, function (momentType) {\n                if (find(outputTypes, function (outputType) {\n                    return momentType.type === outputType;\n                })) {\n                    return momentType;\n                }\n\n                return null;\n            });\n\n            momentTypes = compact(momentTypes);\n        } else {\n            // Trim Large.\n            if (trimLarge) {\n                momentTypes = rest(momentTypes, function (momentType) {\n                    // Stop trimming on:\n                    // - the smallest moment type\n                    // - a type marked for stopTrim\n                    // - a type that has a whole value\n                    return !momentType.isSmallest && !momentType.wholeValue && !find(stopTrim, momentType.type);\n                });\n            }\n\n            // Largest.\n            if (largest && momentTypes.length) {\n                momentTypes = momentTypes.slice(0, largest);\n            }\n\n            // Trim Small.\n            if (trimSmall && momentTypes.length > 1) {\n                momentTypes = initial(momentTypes, function (momentType) {\n                    // Stop trimming on:\n                    // - a type marked for stopTrim\n                    // - a type that has a whole value\n                    // - the largest momentType\n                    return !momentType.wholeValue && !find(stopTrim, momentType.type) && !momentType.isLargest;\n                });\n            }\n\n            // Trim Mid.\n            if (trimMid) {\n                momentTypes = map(momentTypes, function (momentType, index) {\n                    if (index > 0 && index < momentTypes.length - 1 && !momentType.wholeValue) {\n                        return null;\n                    }\n\n                    return momentType;\n                });\n\n                momentTypes = compact(momentTypes);\n            }\n\n            // Trim Final.\n            if (trimFinal && momentTypes.length === 1 && !momentTypes[0].wholeValue && !(!trunc && momentTypes[0].isSmallest && momentTypes[0].rawValue < minValue)) {\n                momentTypes = [];\n            }\n        }\n\n        if (returnMomentTypes) {\n            return momentTypes;\n        }\n\n        // Localize and pluralize unit labels.\n        each(tokens, function (token) {\n            var key = momentTokens[token.type];\n\n            var momentType = find(momentTypes, function (momentType) {\n                return momentType.type === token.type;\n            });\n\n            if (!key || !momentType) {\n                return;\n            }\n\n            var values = momentType.formattedValueEn.split(\".\");\n\n            values[0] = parseInt(values[0], 10);\n\n            if (values[1]) {\n                values[1] = parseFloat(\"0.\" + values[1], 10);\n            } else {\n                values[1] = null;\n            }\n\n            var pluralKey = localeData.durationPluralKey(key, values[0], values[1]);\n\n            var labels = durationGetLabels(key, localeData);\n\n            var autoLocalized = false;\n\n            var pluralizedLabels = {};\n\n            // Auto-Localized unit labels.\n            each(localeData._durationLabelTypes, function (labelType) {\n                var label = find(labels, function (label) {\n                    return label.type === labelType.type && label.key === pluralKey;\n                });\n\n                if (label) {\n                    pluralizedLabels[label.type] = label.label;\n\n                    if (stringIncludes(token.text, labelType.string)) {\n                        token.text = token.text.replace(labelType.string, label.label);\n                        autoLocalized = true;\n                    }\n                }\n            });\n\n            // Auto-pluralized unit labels.\n            if (usePlural && !autoLocalized) {\n                labels.sort(durationLabelCompare);\n\n                each(labels, function (label) {\n                    if (pluralizedLabels[label.type] === label.label) {\n                        if (stringIncludes(token.text, label.label)) {\n                            // Stop checking this token if its label is already\n                            // correctly pluralized.\n                            return false;\n                        }\n\n                        // Skip this label if it is correct, but not present in\n                        // the token's text.\n                        return;\n                    }\n\n                    if (stringIncludes(token.text, label.label)) {\n                        // Replece this token's label and stop checking.\n                        token.text = token.text.replace(label.label, pluralizedLabels[label.type]);\n                        return false;\n                    }\n                });\n            }\n        });\n\n        // Build ouptut.\n        tokens = map(tokens, function (token) {\n            if (!token.type) {\n                return token.text;\n            }\n\n            var momentType = find(momentTypes, function (momentType) {\n                return momentType.type === token.type;\n            });\n\n            if (!momentType) {\n                return \"\";\n            }\n\n            var out = \"\";\n\n            if (useLeftUnits) {\n                out += token.text;\n            }\n\n            if (isNegative && isMaxValue || !isNegative && isMinValue) {\n                out += \"< \";\n                isMaxValue = false;\n                isMinValue = false;\n            }\n\n            if (isNegative && isMinValue || !isNegative && isMaxValue) {\n                out += \"> \";\n                isMaxValue = false;\n                isMinValue = false;\n            }\n\n            if (isNegative && (momentType.value > 0 || trim === \"\" || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n                out += \"-\";\n                isNegative = false;\n            }\n\n            if (token.type === \"milliseconds\" && momentType.formattedValueMS) {\n                out += momentType.formattedValueMS;\n            } else {\n                out += momentType.formattedValue;\n            }\n\n            if (!useLeftUnits) {\n                out += token.text;\n            }\n\n            return out;\n        });\n\n        // Trim leading and trailing comma, space, colon, and dot.\n        return tokens.join(\"\").replace(/(,| |:|\\.)*$/, \"\").replace(/^(,| |:|\\.)*/, \"\");\n    }\n\n    // defaultFormatTemplate\n    function defaultFormatTemplate() {\n        var dur = this.duration;\n\n        var findType = function findType(type) {\n            return dur._data[type];\n        };\n\n        var firstType = find(this.types, findType);\n\n        var lastType = findLast(this.types, findType);\n\n        // Default template strings for each duration dimension type.\n        switch (firstType) {\n            case \"milliseconds\":\n                return \"S __\";\n            case \"seconds\": // Fallthrough.\n            case \"minutes\":\n                return \"*_MS_\";\n            case \"hours\":\n                return \"_HMS_\";\n            case \"days\": // Possible Fallthrough.\n                if (firstType === lastType) {\n                    return \"d __\";\n                }\n            case \"weeks\":\n                if (firstType === lastType) {\n                    return \"w __\";\n                }\n\n                if (this.trim === null) {\n                    this.trim = \"both\";\n                }\n\n                return \"w __, d __, h __\";\n            case \"months\": // Possible Fallthrough.\n                if (firstType === lastType) {\n                    return \"M __\";\n                }\n            case \"years\":\n                if (firstType === lastType) {\n                    return \"y __\";\n                }\n\n                if (this.trim === null) {\n                    this.trim = \"both\";\n                }\n\n                return \"y __, M __, d __\";\n            default:\n                if (this.trim === null) {\n                    this.trim = \"both\";\n                }\n\n                return \"y __, d __, h __, m __, s __\";\n        }\n    }\n\n    // init\n    function init(context) {\n        if (!context) {\n            throw \"Moment Duration Format init cannot find moment instance.\";\n        }\n\n        context.duration.format = durationsFormat;\n        context.duration.fn.format = durationFormat;\n\n        context.duration.fn.format.defaults = {\n            // Many options are defaulted to `null` to distinguish between\n            // 'not set' and 'set to `false`'\n\n            // trim\n            // Can be a string, a delimited list of strings, an array of strings,\n            // or a boolean.\n            // \"large\" - will trim largest-magnitude zero-value tokens until\n            // finding a token with a value, a token identified as 'stopTrim', or\n            // the final token of the format string.\n            // \"small\" - will trim smallest-magnitude zero-value tokens until\n            // finding a token with a value, a token identified as 'stopTrim', or\n            // the final token of the format string.\n            // \"both\" - will execute \"large\" trim then \"small\" trim.\n            // \"mid\" - will trim any zero-value tokens that are not the first or\n            // last tokens. Usually used in conjunction with \"large\" or \"both\".\n            // e.g. \"large mid\" or \"both mid\".\n            // \"final\" - will trim the final token if it is zero-value. Use this\n            // option with \"large\" or \"both\" to output an empty string when\n            // formatting a zero-value duration. e.g. \"large final\" or \"both final\".\n            // \"all\" - Will trim all zero-value tokens. Shorthand for \"both mid final\".\n            // \"left\" - maps to \"large\" to support plugin's version 1 API.\n            // \"right\" - maps to \"large\" to support plugin's version 1 API.\n            // `false` - template tokens are not trimmed.\n            // `true` - treated as \"large\".\n            // `null` - treated as \"large\".\n            trim: null,\n\n            // stopTrim\n            // A moment token string, a delimited set of moment token strings,\n            // or an array of moment token strings. Trimming will stop when a token\n            // listed in this option is reached. A \"*\" character in the format\n            // template string will also mark a moment token as stopTrim.\n            // e.g. \"d [days] *h:mm:ss\" will always stop trimming at the 'hours' token.\n            stopTrim: null,\n\n            // largest\n            // Set to a positive integer to output only the \"n\" largest-magnitude\n            // moment tokens that have a value. All lesser-magnitude moment tokens\n            // will be ignored. This option takes effect even if `trim` is set\n            // to `false`.\n            largest: null,\n\n            // maxValue\n            // Use `maxValue` to render generalized output for large duration values,\n            // e.g. `\"> 60 days\"`. `maxValue` must be a positive integer and is\n            /// applied to the greatest-magnitude moment token in the format template.\n            maxValue: null,\n\n            // minValue\n            // Use `minValue` to render generalized output for small duration values,\n            // e.g. `\"< 5 minutes\"`. `minValue` must be a positive integer and is\n            // applied to the least-magnitude moment token in the format template.\n            minValue: null,\n\n            // precision\n            // If a positive integer, number of decimal fraction digits to render.\n            // If a negative integer, number of integer place digits to truncate to 0.\n            // If `useSignificantDigits` is set to `true` and `precision` is a positive\n            // integer, sets the maximum number of significant digits used in the\n            // formatted output.\n            precision: 0,\n\n            // trunc\n            // Default behavior rounds final token value. Set to `true` to\n            // truncate final token value, which was the default behavior in\n            // version 1 of this plugin.\n            trunc: false,\n\n            // forceLength\n            // Force first moment token with a value to render at full length\n            // even when template is trimmed and first moment token has length of 1.\n            forceLength: null,\n\n            // userLocale\n            // Formatted numerical output is rendered using `toLocaleString`\n            // and the locale of the user's environment. Set this option to render\n            // numerical output using a different locale. Unit names are rendered\n            // and detected using the locale set in moment.js, which can be different\n            // from the locale of user's environment.\n            userLocale: null,\n\n            // usePlural\n            // Will automatically singularize or pluralize unit names when they\n            // appear in the text associated with each moment token. Standard and\n            // short unit labels are singularized and pluralized, based on locale.\n            // e.g. in english, \"1 second\" or \"1 sec\" would be rendered instead\n            // of \"1 seconds\" or \"1 secs\". The default pluralization function\n            // renders a plural label for a value with decimal precision.\n            // e.g. \"1.0 seconds\" is never rendered as \"1.0 second\".\n            // Label types and pluralization function are configurable in the\n            // localeData extensions.\n            usePlural: true,\n\n            // useLeftUnits\n            // The text to the right of each moment token in a format string\n            // is treated as that token's units for the purposes of trimming,\n            // singularizing, and auto-localizing.\n            // e.g. \"h [hours], m [minutes], s [seconds]\".\n            // To properly singularize or localize a format string such as\n            // \"[hours] h, [minutes] m, [seconds] s\", where the units appear\n            // to the left of each moment token, set useLeftUnits to `true`.\n            // This plugin is not tested in the context of rtl text.\n            useLeftUnits: false,\n\n            // useGrouping\n            // Enables locale-based digit grouping in the formatted output. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n            useGrouping: true,\n\n            // useSignificantDigits\n            // Treat the `precision` option as the maximum significant digits\n            // to be rendered. Precision must be a positive integer. Significant\n            // digits extend across unit types,\n            // e.g. \"6 hours 37.5 minutes\" represents 4 significant digits.\n            // Enabling this option causes token length to be ignored. See  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n            useSignificantDigits: false,\n\n            // template\n            // The template string used to format the duration. May be a function\n            // or a string. Template functions are executed with the `this` binding\n            // of the settings object so that template strings may be dynamically\n            // generated based on the duration object (accessible via `this.duration`)\n            // or any of the other settings. Leading and trailing space, comma,\n            // period, and colon characters are trimmed from the resulting string.\n            template: defaultFormatTemplate,\n\n            // useToLocaleString\n            // Set this option to `false` to ignore the `toLocaleString` feature\n            // test and force the use of the `formatNumber` fallback function\n            // included in this plugin.\n            useToLocaleString: true,\n\n            // formatNumber fallback options.\n            // When `toLocaleString` is detected and passes the feature test, the\n            // following options will have no effect: `toLocaleString` will be used\n            // for formatting and the grouping separator, decimal separator, and\n            // integer digit grouping will be determined by the user locale.\n\n            // groupingSeparator\n            // The integer digit grouping separator used when using the fallback\n            // formatNumber function.\n            groupingSeparator: \",\",\n\n            // decimalSeparator\n            // The decimal separator used when using the fallback formatNumber\n            // function.\n            decimalSeparator: \".\",\n\n            // grouping\n            // The integer digit grouping used when using the fallback formatNumber\n            // function. Must be an array. The default value of `[3]` gives the\n            // standard 3-digit thousand/million/billion digit groupings for the\n            // \"en\" locale. Setting this option to `[3, 2]` would generate the\n            // thousand/lakh/crore digit groupings used in the \"en-IN\" locale.\n            grouping: [3]\n        };\n\n        context.updateLocale('en', engLocale);\n    }\n\n    // Run feature tests for `Number#toLocaleString`.\n    var toLocaleStringFormatter = function(number, locale, options) {\n        return number.toLocaleString(locale, options);\n    };\n\n    toLocaleStringWorks = toLocaleStringSupportsLocales() && featureTestFormatter(toLocaleStringFormatter);\n    toLocaleStringRoundingWorks = toLocaleStringWorks && featureTestFormatterRounding(toLocaleStringFormatter);\n\n    // Run feature tests for `Intl.NumberFormat#format`.\n    var intlNumberFormatFormatter = function(number, locale, options) {\n        if (typeof window !== 'undefined' && window && window.Intl && window.Intl.NumberFormat) {\n            return window.Intl.NumberFormat(locale, options).format(number);\n        }\n    };\n\n    intlNumberFormatWorks = featureTestFormatter(intlNumberFormatFormatter);\n    intlNumberFormatRoundingWorks = intlNumberFormatWorks && featureTestFormatterRounding(intlNumberFormatFormatter);\n\n    // Initialize duration format on the global moment instance.\n    init(moment);\n\n    // Return the init function so that duration format can be\n    // initialized on other moment instances.\n    return init;\n});\n"],
  "mappings": ";;;;;;;;;;AAAA;AAAA;AAWA,KAAC,SAAU,MAAM,SAAS;AACtB,UAAI,OAAO,WAAW,cAAc,OAAO,KAAK;AAE5C,eAAO,CAAC,QAAQ,GAAG,OAAO;AAAA,MAC9B,WAAW,OAAO,YAAY,UAAU;AAGpC,YAAI;AACA,iBAAO,UAAU,QAAQ,6CAAiB;AAAA,QAC9C,SAAS,GAAG;AAGR,iBAAO,UAAU;AAAA,QACrB;AAAA,MACJ;AAEA,UAAI,MAAM;AAEN,aAAK,4BAA4B,KAAK,SAAS,QAAQ,KAAK,MAAM,IAAI;AAAA,MAC1E;AAAA,IACJ,GAAG,SAAM,SAAU,QAAQ;AAMvB,UAAI,sBAAsB;AAO1B,UAAI,8BAA8B;AAQlC,UAAI,wBAAwB;AAQ5B,UAAI,gCAAgC;AAGpC,UAAI,QAAQ,4EAA4E,MAAM,GAAG;AAEjG,UAAI,UAAU;AAAA,QACV;AAAA,UACI,MAAM;AAAA,UACN,SAAS;AAAA,YACL,EAAE,MAAM,WAAW,OAAO,GAAG;AAAA,YAC7B,EAAE,MAAM,SAAS,OAAO,KAAK;AAAA,YAC7B,EAAE,MAAM,QAAQ,OAAO,MAAM;AAAA,YAC7B,EAAE,MAAM,SAAS,OAAO,OAAO;AAAA,YAC/B,EAAE,MAAM,UAAU,OAAO,QAAQ;AAAA,YACjC,EAAE,MAAM,SAAS,OAAO,QAAS;AAAA,UACrC;AAAA,QACJ;AAAA,QACA;AAAA,UACI,MAAM;AAAA,UACN,SAAS;AAAA,YACL,EAAE,MAAM,SAAS,OAAO,GAAG;AAAA,YAC3B,EAAE,MAAM,QAAQ,OAAO,KAAK;AAAA,YAC5B,EAAE,MAAM,SAAS,OAAO,MAAM;AAAA,YAC9B,EAAE,MAAM,UAAU,OAAO,MAAM;AAAA,YAC/B,EAAE,MAAM,SAAS,OAAO,OAAO;AAAA,UACnC;AAAA,QACJ;AAAA,QACA;AAAA,UACI,MAAM;AAAA,UACN,SAAS;AAAA,YACL,EAAE,MAAM,QAAQ,OAAO,GAAG;AAAA,YAC1B,EAAE,MAAM,SAAS,OAAO,IAAI;AAAA,YAC5B,EAAE,MAAM,UAAU,OAAO,IAAI;AAAA,YAC7B,EAAE,MAAM,SAAS,OAAO,KAAK;AAAA,UACjC;AAAA,QACJ;AAAA,QACA;AAAA,UACI,MAAM;AAAA,UACN,SAAS;AAAA,YACL,EAAE,MAAM,SAAS,OAAO,EAAE;AAAA,YAC1B,EAAE,MAAM,UAAU,OAAO,GAAG;AAAA,YAC5B,EAAE,MAAM,SAAS,OAAO,IAAI;AAAA,UAChC;AAAA,QACJ;AAAA,QACA;AAAA,UACI,MAAM;AAAA,UACN,SAAS;AAAA,YACL,EAAE,MAAM,SAAS,OAAO,GAAG;AAAA,UAC/B;AAAA,QACJ;AAAA,MACJ;AAGA,eAAS,eAAe,KAAK,QAAQ;AACjC,YAAI,OAAO,SAAS,IAAI,QAAQ;AAC9B,iBAAO;AAAA,QACT;AAEA,eAAO,IAAI,QAAQ,MAAM,MAAM;AAAA,MACnC;AAKA,eAAS,WAAW,KAAK;AACrB,YAAI,SAAS;AAEb,eAAO,KAAK;AACR,oBAAU;AACV,iBAAO;AAAA,QACX;AAEA,eAAO;AAAA,MACX;AAEA,eAAS,YAAY,QAAQ;AACzB,YAAI,cAAc,OAAO,MAAM,EAAE,EAAE,QAAQ;AAC3C,YAAI,IAAI;AACR,YAAI,QAAQ;AAEZ,eAAO,SAAS,IAAI,YAAY,QAAQ;AACpC,cAAI,GAAG;AACH,gBAAI,YAAY,CAAC,MAAM,KAAK;AACxB,0BAAY,CAAC,IAAI;AAAA,YACrB,OAAO;AACH,0BAAY,CAAC,KAAK,SAAS,YAAY,CAAC,GAAG,EAAE,IAAI,GAAG,SAAS;AAC7D,sBAAQ;AAAA,YACZ;AAAA,UACJ,OAAO;AACH,gBAAI,SAAS,YAAY,CAAC,GAAG,EAAE,IAAI,GAAG;AAClC,sBAAQ;AAAA,YACZ;AAEA,wBAAY,CAAC,IAAI;AAAA,UACrB;AAEA,eAAK;AAAA,QACT;AAEA,YAAI,OAAO;AACP,sBAAY,KAAK,GAAG;AAAA,QACxB;AAEA,eAAO,YAAY,QAAQ,EAAE,KAAK,EAAE;AAAA,MACxC;AAMA,eAAS,mBAAmB,QAAQ,SAAS;AAGzC,YAAI,gBAAgB;AAAA,UAChB,KAAK,OAAO,EAAE,KAAK;AAAA,UACnB,SAAS,KAAK;AACV,mBAAO,MAAM,MAAM,QAAQ,GAAG;AAAA,UAClC;AAAA,QACJ,EAAE,KAAK,GAAG;AAGV,YAAI,WAAW,SAAS,MAAM;AAG9B,YAAI,CAAC,mBAAmB,MAAM,QAAQ,GAAG;AACrC,6BAAmB,MAAM,QAAQ,IAAI,KAAK,aAAa,QAAQ,OAAO;AAAA,QAC1E;AAGA,eAAO,mBAAmB,MAAM,QAAQ;AAAA,MAC5C;AACA,yBAAmB,QAAQ,CAAC;AAkB5B,eAAS,aAAa,QAAQ,SAAS,YAAY;AAC/C,YAAI,oBAAoB,QAAQ;AAChC,YAAI,cAAc,QAAQ;AAC1B,YAAI,WAAW,eAAe,QAAQ,SAAS,MAAM;AACrD,YAAI,2BAA2B,QAAQ;AACvC,YAAI,uBAAuB,QAAQ,wBAAwB;AAC3D,YAAI,iBAAiB,QAAQ,kBAAkB;AAC/C,YAAI,oBAAoB,QAAQ;AAChC,YAAI,mBAAmB,QAAQ;AAE/B,YAAI,qBAAqB,YAAY;AACjC,cAAI,sBAAsB;AAAA,YACtB;AAAA,YACA;AAAA,UACJ;AAEA,cAAI,gBAAgB;AAChB,gCAAoB,wBAAwB;AAC5C,gCAAoB,wBAAwB;AAAA,UAChD;AAIA,cAAI,4BAA4B,SAAS,GAAG;AACxC,gCAAoB,2BAA2B;AAAA,UACnD;AAEA,cAAI,uBAAuB;AACvB,gBAAI,CAAC,+BAA+B;AAChC,kBAAI,kBAAkB,OAAO,CAAC,GAAG,OAAO;AACxC,8BAAgB,cAAc;AAC9B,8BAAgB,mBAAmB;AACnC,uBAAS,WAAW,aAAa,QAAQ,eAAe,GAAG,EAAE;AAAA,YACjE;AAEA,mBAAO,mBAAmB,YAAY,mBAAmB,EAAE,OAAO,MAAM;AAAA,UAC5E,OAAO;AACH,gBAAI,CAAC,6BAA6B;AAC9B,kBAAI,kBAAkB,OAAO,CAAC,GAAG,OAAO;AACxC,8BAAgB,cAAc;AAC9B,8BAAgB,mBAAmB;AACnC,uBAAS,WAAW,aAAa,QAAQ,eAAe,GAAG,EAAE;AAAA,YACjE;AAEA,mBAAO,OAAO,eAAe,YAAY,mBAAmB;AAAA,UAChE;AAAA,QACJ;AAEA,YAAI;AAGJ,YAAI,0BAA0B;AAC1B,yBAAe,OAAO,YAAY,2BAA2B,CAAC;AAAA,QAClE,OAAO;AACH,yBAAe,OAAO,QAAQ,iBAAiB,CAAC;AAAA,QACpD;AAEA,YAAI;AACJ,YAAI;AACJ,YAAI;AAEJ,YAAI,OAAO,aAAa,MAAM,GAAG;AAEjC,yBAAiB,KAAK,CAAC,KAAK;AAE5B,eAAO,KAAK,CAAC,EAAE,MAAM,GAAG;AAExB,yBAAiB,KAAK,CAAC,KAAK;AAC5B,wBAAgB,KAAK,CAAC,KAAK;AAY3B,YAAI,gBAAgB,cAAc;AAClC,YAAI,iBAAiB,eAAe;AACpC,YAAI,aAAa,gBAAgB;AACjC,YAAI,SAAS,gBAAgB;AAE7B,YAAI,4BAA4B,eAAgB,2BAA2B,KAAM,CAAC,4BAA4B,mBAAoB,iBAAiB,GAAI;AAEnJ,mBAAS,YAAY,MAAM;AAE3B,cAAI,OAAO,WAAW,aAAa,GAAG;AAClC,4BAAgB,gBAAgB;AAAA,UACpC;AAGA,cAAI,gBAAgB;AAChB,qBAAS,OAAO,MAAM,GAAG,EAAE;AAAA,UAC/B;AAGA,0BAAgB,OAAO,MAAM,GAAG,aAAa;AAC7C,2BAAiB,OAAO,MAAM,aAAa;AAAA,QAC/C;AAIA,YAAI,0BAA0B;AAC1B,2BAAiB,eAAe,QAAQ,OAAO,EAAE;AAAA,QACrD;AAGA,YAAI,WAAW,SAAS,gBAAgB,EAAE;AAE1C,YAAI,WAAW,GAAG;AACd,cAAI,eAAe,UAAU,UAAU;AACnC,6BAAiB,iBAAiB,WAAW,WAAW,eAAe,MAAM;AAE7E,4BAAgB,gBAAgB;AAChC,6BAAiB;AAAA,UACrB,OAAO;AACH,4BAAgB,gBAAgB,eAAe,MAAM,GAAG,QAAQ;AAChE,6BAAiB,eAAe,MAAM,QAAQ;AAAA,UAClD;AAAA,QACJ,WAAW,WAAW,GAAG;AACrB,2BAAkB,WAAW,KAAK,IAAI,QAAQ,IAAI,cAAc,MAAM,IAAI,gBAAgB;AAE1F,0BAAgB;AAAA,QACpB;AAEA,YAAI,CAAC,0BAA0B;AAE3B,2BAAiB,eAAe,MAAM,GAAG,cAAc;AAEvD,cAAI,eAAe,SAAS,gBAAgB;AACxC,6BAAiB,iBAAiB,WAAW,iBAAiB,eAAe,MAAM;AAAA,UACvF;AAIA,cAAI,cAAc,SAAS,sBAAsB;AAC7C,4BAAgB,WAAW,uBAAuB,cAAc,MAAM,IAAI;AAAA,UAC9E;AAAA,QACJ;AAEA,YAAI,kBAAkB;AAGtB,YAAI,aAAa;AACb,iBAAO;AACP,cAAI;AAEJ,iBAAO,KAAK,QAAQ;AAChB,gBAAI,SAAS,QAAQ;AACjB,sBAAQ,SAAS,MAAM;AAAA,YAC3B;AAEA,gBAAI,iBAAiB;AACjB,gCAAkB,oBAAoB;AAAA,YAC1C;AAEA,8BAAkB,KAAK,MAAM,CAAC,KAAK,IAAI;AAEvC,mBAAO,KAAK,MAAM,GAAG,CAAC,KAAK;AAAA,UAC/B;AAAA,QACJ,OAAO;AACH,4BAAkB;AAAA,QACtB;AAGA,YAAI,gBAAgB;AAChB,4BAAkB,kBAAkB,mBAAmB;AAAA,QAC3D;AAEA,eAAO;AAAA,MACX;AAGA,eAAS,qBAAqB,GAAG,GAAG;AAChC,YAAI,EAAE,MAAM,SAAS,EAAE,MAAM,QAAQ;AACjC,iBAAO;AAAA,QACX;AAEA,YAAI,EAAE,MAAM,SAAS,EAAE,MAAM,QAAQ;AACjC,iBAAO;AAAA,QACX;AAGA,eAAO;AAAA,MACX;AAGA,eAAS,kBAAkB,OAAO,YAAY;AAC1C,YAAI,SAAS,CAAC;AAEd,aAAK,KAAK,UAAU,GAAG,SAAU,eAAe;AAC5C,cAAI,cAAc,MAAM,GAAG,EAAE,MAAM,mBAAmB;AAClD;AAAA,UACJ;AAEA,cAAI,YAAY,cAAc,MAAM,EAAE,EAAE,YAAY;AAEpD,eAAK,KAAK,WAAW,aAAa,CAAC,GAAG,SAAU,UAAU;AACtD,gBAAI,SAAS,MAAM,GAAG,CAAC,MAAM,OAAO;AAChC,qBAAO,KAAK;AAAA,gBACR,MAAM;AAAA,gBACN,KAAK;AAAA,gBACL,OAAO,WAAW,aAAa,EAAE,QAAQ;AAAA,cAC7C,CAAC;AAAA,YACL;AAAA,UACJ,CAAC;AAAA,QACL,CAAC;AAED,eAAO;AAAA,MACX;AAGA,eAAS,kBAAkB,OAAO,cAAc,cAAc;AAE1D,YAAI,iBAAiB,KAAK,iBAAiB,MAAM;AAC7C,iBAAO;AAAA,QACX;AAEA,eAAO,QAAQ;AAAA,MACnB;AAEA,UAAI,YAAY;AAAA,QACZ,wBAAwB;AAAA,UACpB,GAAG;AAAA,UACH,IAAI;AAAA,UACJ,GAAG;AAAA,UACH,IAAI;AAAA,UACJ,GAAG;AAAA,UACH,IAAI;AAAA,UACJ,GAAG;AAAA,UACH,IAAI;AAAA,UACJ,GAAG;AAAA,UACH,IAAI;AAAA,UACJ,GAAG;AAAA,UACH,IAAI;AAAA,UACJ,GAAG;AAAA,UACH,IAAI;AAAA,UACJ,GAAG;AAAA,UACH,IAAI;AAAA,QACR;AAAA,QACA,qBAAqB;AAAA,UACjB,GAAG;AAAA,UACH,IAAI;AAAA,UACJ,GAAG;AAAA,UACH,IAAI;AAAA,UACJ,GAAG;AAAA,UACH,IAAI;AAAA,UACJ,GAAG;AAAA,UACH,IAAI;AAAA,UACJ,GAAG;AAAA,UACH,IAAI;AAAA,UACJ,GAAG;AAAA,UACH,IAAI;AAAA,UACJ,GAAG;AAAA,UACH,IAAI;AAAA,UACJ,GAAG;AAAA,UACH,IAAI;AAAA,QACR;AAAA,QACA,uBAAuB;AAAA,UACnB,KAAK;AAAA,UACL,IAAI;AAAA,UACJ,IAAI;AAAA,QACR;AAAA,QACA,oBAAoB;AAAA,UAChB,EAAE,MAAM,YAAY,QAAQ,KAAK;AAAA,UACjC,EAAE,MAAM,SAAS,QAAQ,IAAI;AAAA,QACjC;AAAA,QACA;AAAA,MACJ;AAGA,eAAS,QAAQ,OAAO;AACpB,eAAO,OAAO,UAAU,SAAS,KAAK,KAAK,MAAM;AAAA,MACrD;AAGA,eAAS,SAAS,KAAK;AACnB,eAAO,OAAO,UAAU,SAAS,KAAK,GAAG,MAAM;AAAA,MACnD;AAGA,eAAS,SAAS,OAAO,UAAU;AAC/B,YAAI,QAAQ,MAAM;AAElB,eAAO,SAAS,GAAG;AACf,cAAI,SAAS,MAAM,KAAK,CAAC,GAAG;AAAE,mBAAO,MAAM,KAAK;AAAA,UAAG;AAAA,QACvD;AAAA,MACJ;AAGA,eAAS,KAAK,OAAO,UAAU;AAC3B,YAAI,QAAQ;AAEZ,YAAI,MAAM,SAAS,MAAM,UAAU;AAEnC,YAAI;AAEJ,YAAI,OAAO,aAAa,YAAY;AAChC,kBAAQ;AACR,qBAAW,SAAU,MAAM;AACvB,mBAAO,SAAS;AAAA,UACpB;AAAA,QACJ;AAEA,eAAO,QAAQ,KAAK;AAChB,cAAI,SAAS,MAAM,KAAK,CAAC,GAAG;AAAE,mBAAO,MAAM,KAAK;AAAA,UAAG;AACnD,mBAAS;AAAA,QACb;AAAA,MACJ;AAGA,eAAS,KAAK,OAAO,UAAU;AAC3B,YAAI,QAAQ,GACR,MAAM,MAAM;AAEhB,YAAI,CAAC,SAAS,CAAC,KAAK;AAAE;AAAA,QAAQ;AAE9B,eAAO,QAAQ,KAAK;AAChB,cAAI,SAAS,MAAM,KAAK,GAAG,KAAK,MAAM,OAAO;AAAE;AAAA,UAAQ;AACvD,mBAAS;AAAA,QACb;AAAA,MACJ;AAGA,eAAS,IAAI,OAAO,UAAU;AAC1B,YAAI,QAAQ,GACR,MAAM,MAAM,QACZ,MAAM,CAAC;AAEX,YAAI,CAAC,SAAS,CAAC,KAAK;AAAE,iBAAO;AAAA,QAAK;AAElC,eAAO,QAAQ,KAAK;AAChB,cAAI,KAAK,IAAI,SAAS,MAAM,KAAK,GAAG,KAAK;AACzC,mBAAS;AAAA,QACb;AAEA,eAAO;AAAA,MACX;AAGA,eAAS,MAAM,OAAO,MAAM;AACxB,eAAO,IAAI,OAAO,SAAU,MAAM;AAC9B,iBAAO,KAAK,IAAI;AAAA,QACpB,CAAC;AAAA,MACL;AAGA,eAAS,QAAQ,OAAO;AACpB,YAAI,MAAM,CAAC;AAEX,aAAK,OAAO,SAAU,MAAM;AACxB,cAAI,MAAM;AAAE,gBAAI,KAAK,IAAI;AAAA,UAAG;AAAA,QAChC,CAAC;AAED,eAAO;AAAA,MACX;AAGA,eAAS,OAAO,OAAO;AACnB,YAAI,MAAM,CAAC;AAEX,aAAK,OAAO,SAAU,IAAI;AACtB,cAAI,CAAC,KAAK,KAAK,EAAE,GAAG;AAAE,gBAAI,KAAK,EAAE;AAAA,UAAG;AAAA,QACxC,CAAC;AAED,eAAO;AAAA,MACX;AAGA,eAAS,aAAa,GAAG,GAAG;AACxB,YAAI,MAAM,CAAC;AAEX,aAAK,GAAG,SAAU,IAAI;AAClB,eAAK,GAAG,SAAU,IAAI;AAClB,gBAAI,OAAO,IAAI;AAAE,kBAAI,KAAK,EAAE;AAAA,YAAG;AAAA,UACnC,CAAC;AAAA,QACL,CAAC;AAED,eAAO,OAAO,GAAG;AAAA,MACrB;AAGA,eAAS,KAAK,OAAO,UAAU;AAC3B,YAAI,MAAM,CAAC;AAEX,aAAK,OAAO,SAAU,MAAM,OAAO;AAC/B,cAAI,CAAC,SAAS,IAAI,GAAG;AACjB,kBAAM,MAAM,MAAM,KAAK;AACvB,mBAAO;AAAA,UACX;AAAA,QACJ,CAAC;AAED,eAAO;AAAA,MACX;AAGA,eAAS,QAAQ,OAAO,UAAU;AAC9B,YAAI,WAAW,MAAM,MAAM,EAAE,QAAQ;AAErC,eAAO,KAAK,UAAU,QAAQ,EAAE,QAAQ;AAAA,MAC5C;AAGA,eAAS,OAAO,GAAG,GAAG;AAClB,iBAAS,OAAO,GAAG;AACf,cAAI,EAAE,eAAe,GAAG,GAAG;AAAE,cAAE,GAAG,IAAI,EAAE,GAAG;AAAA,UAAG;AAAA,QAClD;AAEA,eAAO;AAAA,MACX;AAGA,eAAS,KAAK,GAAG;AACb,YAAI,MAAM,CAAC;AAEX,iBAAS,OAAO,GAAG;AACf,cAAI,EAAE,eAAe,GAAG,GAAG;AAAE,gBAAI,KAAK,GAAG;AAAA,UAAG;AAAA,QAChD;AAEA,eAAO;AAAA,MACX;AAGA,eAAS,IAAI,OAAO,UAAU;AAC1B,YAAI,QAAQ,GACR,MAAM,MAAM;AAEhB,YAAI,CAAC,SAAS,CAAC,KAAK;AAAE,iBAAO;AAAA,QAAO;AAEpC,eAAO,QAAQ,KAAK;AAChB,cAAI,SAAS,MAAM,KAAK,GAAG,KAAK,MAAM,MAAM;AAAE,mBAAO;AAAA,UAAM;AAC3D,mBAAS;AAAA,QACb;AAEA,eAAO;AAAA,MACX;AAGA,eAAS,QAAQ,OAAO;AACpB,YAAI,MAAM,CAAC;AAEX,aAAK,OAAO,SAAS,OAAO;AACxB,gBAAM,IAAI,OAAO,KAAK;AAAA,QAC1B,CAAC;AAED,eAAO;AAAA,MACX;AAEA,eAAS,gCAAgC;AACrC,YAAI,SAAS;AACb,YAAI;AACA,iBAAO,eAAe,GAAG;AAAA,QAC7B,SAAS,GAAG;AACR,iBAAO,EAAE,SAAS;AAAA,QACtB;AACA,eAAO;AAAA,MACX;AAEA,eAAS,6BAA6B,WAAW;AAC7C,eAAO,UAAU,MAAM,MAAM;AAAA,UACzB,aAAa;AAAA,UACb,sBAAsB;AAAA,UACtB,uBAAuB;AAAA,UACvB,uBAAuB;AAAA,QAC3B,CAAC,MAAM;AAAA,MACX;AAEA,eAAS,qBAAqB,WAAW;AACrC,YAAI,SAAS;AAGb,iBAAS,UAAU,UAAU,GAAG,MAAM,EAAE,sBAAsB,EAAE,CAAC,MAAM;AACvE,iBAAS,UAAU,UAAU,GAAG,MAAM,EAAE,sBAAsB,EAAE,CAAC,MAAM;AACvE,iBAAS,UAAU,UAAU,GAAG,MAAM,EAAE,sBAAsB,EAAE,CAAC,MAAM;AACvE,YAAI,CAAC,QAAQ;AAAE,iBAAO;AAAA,QAAO;AAG7B,iBAAS,UAAU,UAAU,OAAO,MAAM,EAAE,uBAAuB,GAAG,uBAAuB,EAAE,CAAC,MAAM;AACtG,iBAAS,UAAU,UAAU,OAAO,MAAM,EAAE,uBAAuB,GAAG,uBAAuB,EAAE,CAAC,MAAM;AACtG,iBAAS,UAAU,UAAU,OAAO,MAAM,EAAE,uBAAuB,GAAG,uBAAuB,EAAE,CAAC,MAAM;AACtG,iBAAS,UAAU,UAAU,OAAO,MAAM,EAAE,uBAAuB,GAAG,uBAAuB,EAAE,CAAC,MAAM;AACtG,YAAI,CAAC,QAAQ;AAAE,iBAAO;AAAA,QAAO;AAG7B,iBAAS,UAAU,UAAU,OAAO,MAAM,EAAE,0BAA0B,EAAE,CAAC,MAAM;AAC/E,iBAAS,UAAU,UAAU,OAAO,MAAM,EAAE,0BAA0B,EAAE,CAAC,MAAM;AAC/E,iBAAS,UAAU,UAAU,OAAO,MAAM,EAAE,0BAA0B,EAAE,CAAC,MAAM;AAC/E,iBAAS,UAAU,UAAU,OAAO,MAAM,EAAE,0BAA0B,EAAE,CAAC,MAAM;AAC/E,iBAAS,UAAU,UAAU,OAAO,MAAM,EAAE,0BAA0B,EAAE,CAAC,MAAM;AAC/E,YAAI,CAAC,QAAQ;AAAE,iBAAO;AAAA,QAAO;AAG7B,iBAAS,UAAU,UAAU,KAAM,MAAM,EAAE,aAAa,KAAK,CAAC,MAAM;AACpE,iBAAS,UAAU,UAAU,KAAM,MAAM,EAAE,aAAa,MAAM,CAAC,MAAM;AACrE,YAAI,CAAC,QAAQ;AAAE,iBAAO;AAAA,QAAO;AAE7B,eAAO;AAAA,MACX;AAGA,eAAS,kBAAkB;AACvB,YAAI,OAAO,CAAC,EAAE,MAAM,KAAK,SAAS;AAClC,YAAI,WAAW,CAAC;AAChB,YAAI;AAGJ,aAAK,MAAM,SAAU,KAAK,OAAO;AAC7B,cAAI,CAAC,OAAO;AACR,gBAAI,CAAC,QAAQ,GAAG,GAAG;AACf,oBAAM;AAAA,YACV;AAEA,wBAAY;AAAA,UAChB;AAEA,cAAI,OAAO,QAAQ,YAAY,OAAO,QAAQ,YAAY;AACtD,qBAAS,WAAW;AACpB;AAAA,UACJ;AAEA,cAAI,OAAO,QAAQ,UAAU;AACzB,qBAAS,YAAY;AACrB;AAAA,UACJ;AAEA,cAAI,SAAS,GAAG,GAAG;AACf,mBAAO,UAAU,GAAG;AAAA,UACxB;AAAA,QACJ,CAAC;AAED,YAAI,CAAC,aAAa,CAAC,UAAU,QAAQ;AACjC,iBAAO,CAAC;AAAA,QACZ;AAEA,iBAAS,oBAAoB;AAE7B,YAAI,qBAAqB,IAAI,WAAW,SAAU,KAAK;AACnD,iBAAO,IAAI,OAAO,QAAQ;AAAA,QAC9B,CAAC;AAGD,YAAI,cAAc,aAAa,OAAO,OAAO,MAAM,QAAQ,kBAAkB,GAAG,MAAM,CAAC,CAAC;AAExF,YAAI,UAAU,SAAS;AAEvB,YAAI,SAAS;AACT,wBAAc,YAAY,MAAM,GAAG,OAAO;AAAA,QAC9C;AAEA,iBAAS,oBAAoB;AAC7B,iBAAS,cAAc;AAEvB,eAAO,IAAI,WAAW,SAAU,KAAK;AACjC,iBAAO,IAAI,OAAO,QAAQ;AAAA,QAC9B,CAAC;AAAA,MACL;AAGA,eAAS,iBAAiB;AAEtB,YAAI,OAAO,CAAC,EAAE,MAAM,KAAK,SAAS;AAClC,YAAI,WAAW,OAAO,CAAC,GAAG,KAAK,OAAO,QAAQ;AAK9C,YAAI,iBAAiB,KAAK,eAAe;AACzC,YAAI,WAAW,KAAK,SAAS;AAG7B,YAAI,OAAO,KAAK,YAAY,cAAc,KAAK,QAAQ,MAAM,OAAO;AAChE,2BAAiB;AACjB,qBAAW;AAAA,QACf;AAEA,YAAI,aAAa,iBAAiB;AAIlC,YAAI,YAAY,OAAO,SAAS,KAAK,IAAI,cAAc,GAAG,cAAc;AACxE,YAAI,kBAAkB,OAAO,SAAS,KAAK,IAAI,QAAQ,GAAG,QAAQ;AAGlE,aAAK,MAAM,SAAU,KAAK;AACtB,cAAI,OAAO,QAAQ,YAAY,OAAO,QAAQ,YAAY;AACtD,qBAAS,WAAW;AACpB;AAAA,UACJ;AAEA,cAAI,OAAO,QAAQ,UAAU;AACzB,qBAAS,YAAY;AACrB;AAAA,UACJ;AAEA,cAAI,SAAS,GAAG,GAAG;AACf,mBAAO,UAAU,GAAG;AAAA,UACxB;AAAA,QACJ,CAAC;AAED,YAAI,eAAe;AAAA,UACf,OAAO;AAAA,UACP,QAAQ;AAAA,UACR,OAAO;AAAA,UACP,MAAM;AAAA,UACN,OAAO;AAAA,UACP,SAAS;AAAA,UACT,SAAS;AAAA,UACT,cAAc;AAAA,QAClB;AAEA,YAAI,YAAY;AAAA,UACZ,QAAQ;AAAA,UACR,OAAO;AAAA,UACP,QAAQ;AAAA,UACR,OAAO;AAAA,UACP,MAAM;AAAA,UACN,OAAO;AAAA,UACP,SAAS;AAAA,UACT,SAAS;AAAA,UACT,cAAc;AAAA,UACd,SAAS;AAAA,QACb;AAGA,iBAAS,QAAQ;AAEjB,YAAI,UAAU,SAAU,OAAO;AAC3B,iBAAO,KAAK,OAAO,SAAU,MAAM;AAC/B,mBAAO,UAAU,IAAI,EAAE,KAAK,KAAK;AAAA,UACrC,CAAC;AAAA,QACL;AAEA,YAAI,YAAY,IAAI,OAAO,IAAI,OAAO,SAAU,MAAM;AAClD,iBAAO,UAAU,IAAI,EAAE;AAAA,QAC3B,CAAC,EAAE,KAAK,GAAG,GAAG,GAAG;AAGjB,iBAAS,WAAW;AAGpB,YAAI,WAAW,OAAO,SAAS,aAAa,aAAa,SAAS,SAAS,MAAM,QAAQ,IAAI,SAAS;AAOtG,YAAI,cAAc,SAAS;AAI3B,YAAI,oBAAoB,SAAS;AAEjC,YAAI,UAAU,SAAS;AAGvB,YAAI,WAAW,CAAC;AAEhB,YAAI,CAAC,aAAa;AACd,cAAI,QAAQ,SAAS,QAAQ,GAAG;AAC5B,qBAAS,WAAW,SAAS,SAAS,KAAK,EAAE;AAAA,UACjD;AAGA,cAAI,SAAS,UAAU;AACnB,iBAAK,SAAS,SAAS,MAAM,SAAS,GAAG,SAAU,OAAO;AACtD,kBAAI,OAAO,QAAQ,KAAK;AAExB,kBAAI,SAAS,YAAY,SAAS,WAAW;AACzC;AAAA,cACJ;AAEA,uBAAS,KAAK,IAAI;AAAA,YACtB,CAAC;AAAA,UACL;AAAA,QACJ;AAGA,YAAI,aAAa,OAAO,WAAW;AAEnC,YAAI,CAAC,YAAY;AACb,uBAAa,CAAC;AAAA,QAClB;AAGA,aAAK,KAAK,SAAS,GAAG,SAAU,KAAK;AACjC,cAAI,OAAO,UAAU,GAAG,MAAM,YAAY;AACtC,gBAAI,CAAC,WAAW,GAAG,GAAG;AAClB,yBAAW,GAAG,IAAI,UAAU,GAAG;AAAA,YACnC;AAEA;AAAA,UACJ;AAEA,cAAI,CAAC,WAAW,MAAM,GAAG,GAAG;AACxB,uBAAW,MAAM,GAAG,IAAI,UAAU,GAAG;AAAA,UACzC;AAAA,QACJ,CAAC;AAID,aAAK,KAAK,WAAW,sBAAsB,GAAG,SAAU,MAAM;AAC1D,qBAAW,SAAS,QAAQ,MAAM,OAAO,KAAK,WAAW,uBAAuB,IAAI,CAAC;AAAA,QACzF,CAAC;AAGD,YAAI,aAAa,SAAS,cAAc,OAAO,OAAO;AAEtD,YAAI,eAAe,SAAS;AAC5B,YAAI,YAAY,SAAS;AACzB,YAAI,YAAY,SAAS;AACzB,YAAI,cAAc,SAAS;AAC3B,YAAI,cAAc,SAAS;AAC3B,YAAI,QAAQ,SAAS;AAGrB,YAAI,uBAAuB,SAAS,wBAAwB,YAAY;AACxE,YAAI,oBAAoB,uBAAuB,SAAS,YAAY;AACpE,YAAI,yBAAyB;AAE7B,YAAI,WAAW,SAAS;AACxB,YAAI,aAAa;AAEjB,YAAI,WAAW,SAAS;AACxB,YAAI,aAAa;AAGjB,YAAI,oBAAoB,SAAS;AACjC,YAAI,oBAAoB,SAAS;AACjC,YAAI,mBAAmB,SAAS;AAChC,YAAI,WAAW,SAAS;AAExB,4BAAoB,sBAAsB,uBAAuB;AAGjE,YAAI,OAAO,SAAS;AAEpB,YAAI,QAAQ,IAAI,GAAG;AACf,iBAAO,KAAK,KAAK,GAAG;AAAA,QACxB;AAEA,YAAI,SAAS,SAAS,WAAW,YAAY,uBAAuB;AAChE,iBAAO;AAAA,QACX;AAEA,YAAI,SAAS,QAAQ,SAAS,QAAQ,SAAS,UAAU,SAAS,SAAS;AACvE,iBAAO;AAAA,QACX;AAEA,YAAI,SAAS,OAAO;AAChB,iBAAO;AAAA,QACX;AAEA,YAAI,eAAe,SAAU,MAAM;AAC/B,iBAAO,KAAK,KAAK,IAAI;AAAA,QACzB;AAEA,YAAI,SAAS;AACb,YAAI,SAAS;AACb,YAAI,QAAQ;AACZ,YAAI,OAAO;AACX,YAAI,OAAO;AACX,YAAI,SAAS;AAEb,YAAI,YAAY,UAAU,KAAK,IAAI,CAAC,QAAQ,OAAO,IAAI,GAAG,YAAY;AACtE,YAAI,YAAY,IAAI,CAAC,QAAQ,OAAO,IAAI,GAAG,YAAY;AACvD,YAAI,UAAU,IAAI,CAAC,MAAM,IAAI,GAAG,YAAY;AAC5C,YAAI,YAAY,IAAI,CAAC,QAAQ,IAAI,GAAG,YAAY;AAGhD,YAAI,YAAY,IAAI,SAAS,MAAM,SAAS,GAAG,SAAU,OAAO,OAAO;AACnE,cAAI,OAAO,QAAQ,KAAK;AAExB,cAAI,MAAM,MAAM,GAAG,CAAC,MAAM,KAAK;AAC3B,oBAAQ,MAAM,MAAM,CAAC;AAErB,gBAAI,SAAS,YAAY,SAAS,WAAW;AACzC,uBAAS,KAAK,IAAI;AAAA,YACtB;AAAA,UACJ;AAEA,iBAAO;AAAA,YACH;AAAA,YACA,QAAQ,MAAM;AAAA,YACd,MAAM;AAAA;AAAA,YAGN,OAAQ,SAAS,WAAW,MAAM,QAAQ,UAAU,QAAQ,IAAI,IAAI;AAAA;AAAA,YAGpE,MAAQ,SAAS,YAAY,SAAS,YAAa,OAAO;AAAA,UAC9D;AAAA,QACJ,CAAC;AAGD,YAAI,eAAe;AAAA,UACf,OAAO;AAAA,UACP,QAAQ;AAAA,UACR,OAAO;AAAA,UACP,MAAM;AAAA,UACN,MAAM;AAAA,QACV;AAEA,YAAI,SAAS,CAAC;AAEd,YAAI,cAAc;AACd,oBAAU,QAAQ;AAAA,QACtB;AAEA,aAAK,WAAW,SAAU,OAAO;AAC7B,cAAI,MAAM,MAAM;AACZ,gBAAI,aAAa,QAAQ,aAAa,MAAM;AACxC,qBAAO,KAAK,YAAY;AAAA,YAC5B;AAEA,2BAAe;AAEf;AAAA,UACJ;AAEA,cAAI,cAAc;AACd,yBAAa,OAAO,MAAM,QAAQ,aAAa;AAAA,UACnD,OAAO;AACH,yBAAa,QAAQ,MAAM;AAAA,UAC/B;AAAA,QACJ,CAAC;AAED,YAAI,aAAa,QAAQ,aAAa,MAAM;AACxC,iBAAO,KAAK,YAAY;AAAA,QAC5B;AAEA,YAAI,cAAc;AACd,iBAAO,QAAQ;AAAA,QACnB;AAIA,YAAI,cAAc,aAAa,OAAO,OAAO,QAAQ,MAAM,QAAQ,MAAM,CAAC,CAAC,CAAC;AAG5E,YAAI,CAAC,YAAY,QAAQ;AACrB,iBAAO,MAAM,QAAQ,MAAM,EAAE,KAAK,EAAE;AAAA,QACxC;AAMA,sBAAc,IAAI,aAAa,SAAU,YAAY,OAAO;AAExD,cAAI,aAAe,QAAQ,MAAO,YAAY;AAG9C,cAAI,YAAa,CAAC;AAGlB,cAAI;AAEJ,cAAI,eAAe,WAAW,eAAe,UAAU;AACnD,uBAAW,gBAAgB,GAAG,UAAU;AAAA,UAC5C,OAAO;AACH,uBAAW,UAAU,GAAG,UAAU;AAAA,UACtC;AAEA,cAAI,aAAa,KAAK,MAAM,QAAQ;AACpC,cAAI,eAAe,WAAW;AAE9B,cAAI,QAAQ,KAAK,QAAQ,SAAUA,QAAO;AACtC,mBAAO,eAAeA,OAAM;AAAA,UAChC,CAAC;AAED,cAAI,aAAa,YAAY,WAAW,UAAU;AAC9C,yBAAa;AAAA,UACjB;AAEA,cAAI,cAAc,YAAY,KAAK,IAAI,SAAS,SAAS,GAAG,UAAU,CAAC,IAAI,UAAU;AACjF,yBAAa;AAAA,UACjB;AAmBA,cAAI,aAAa,gBAAgB,QAAQ,MAAM,SAAS,GAAG;AACvD,0BAAc;AAAA,UAClB;AAGA,oBAAU,SAAS,YAAY,UAAU;AACzC,0BAAgB,SAAS,YAAY,UAAU;AAE/C,iBAAO;AAAA,YACH;AAAA,YACA;AAAA;AAAA;AAAA,YAGA,cAAc,aAAa,eAAe;AAAA,YAC1C;AAAA,YACA;AAAA,YACA,MAAM;AAAA;AAAA;AAAA,YAGN,aAAa,MAAM;AAAA,UACvB;AAAA,QACJ,CAAC;AAED,YAAI,cAAc,QAAQ,KAAK,QAAQ,KAAK;AAC5C,YAAI,WAAW,SAAU,OAAO,QAAQ;AACpC,cAAI,SAAS,KAAK,IAAI,IAAI,MAAM;AAChC,iBAAO,YAAY,QAAQ,MAAM,IAAI;AAAA,QACzC;AAEA,YAAI,aAAa;AACjB,YAAI,UAAU;AAEd,YAAI,cAAc,SAAU,YAAY,OAAO;AAC3C,cAAI,gBAAgB;AAAA,YAChB;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACJ;AAEA,cAAI,sBAAsB;AACtB,gBAAI,qBAAqB,GAAG;AACxB,yBAAW,WAAW;AACtB,yBAAW,aAAa;AACxB,yBAAW,eAAe;AAAA,YAC9B,OAAO;AACH,4BAAc,2BAA2B;AACzC,yBAAW,oBAAoB;AAAA,YACnC;AAAA,UACJ;AAEA,cAAI,cAAc,CAAC,SAAS;AACxB,gBAAI,WAAW,WAAW;AACtB,yBAAW,aAAa;AACxB,yBAAW,eAAe;AAAA,YAC9B,OAAO;AACH,yBAAW,aAAa;AACxB,yBAAW,eAAe;AAAA,YAC9B;AAAA,UACJ;AAEA,cAAI,cAAc,CAAC,SAAS;AACxB,gBAAI,WAAW,YAAY;AACvB,yBAAW,aAAa;AACxB,yBAAW,eAAe;AAAA,YAC9B,OAAO;AACH,yBAAW,aAAa;AACxB,yBAAW,eAAe;AAAA,YAC9B;AAAA,UACJ;AAEA,cAAI,WAAW,cAAc,WAAW,qBAAqB,WAAW,oBAAoB,WAAW,WAAW,SAAS,EAAE,UAAU,GAAG;AAEtI,gBAAI,YAAY,GAAG;AACf,yBAAW,QAAQ,SAAS,WAAW,YAAY,SAAS;AAAA,YAChE,WAAW,cAAc,GAAG;AACxB,yBAAW,QAAQ,YAAY,WAAW,aAAa,WAAW,YAAY;AAAA,YAClF,OAAO;AACH,kBAAI,sBAAsB;AACtB,oBAAI,OAAO;AACP,6BAAW,QAAQ,SAAS,WAAW,UAAU,oBAAoB,WAAW,WAAW,SAAS,EAAE,MAAM;AAAA,gBAChH,OAAO;AACH,6BAAW,QAAQ,WAAW;AAAA,gBAClC;AAEA,oBAAI,WAAW,YAAY;AACvB,uCAAqB,WAAW,WAAW,SAAS,EAAE;AAAA,gBAC1D;AAAA,cACJ,OAAO;AACH,8BAAc,iBAAiB;AAE/B,oBAAI,OAAO;AACP,6BAAW,QAAQ,WAAW,aAAa,SAAS,WAAW,cAAc,SAAS;AAAA,gBAC1F,OAAO;AACH,6BAAW,QAAQ,WAAW,aAAa,WAAW;AAAA,gBAC1D;AAAA,cACJ;AAAA,YACJ;AAAA,UACJ,OAAO;AACH,gBAAI,wBAAwB,WAAW,YAAY;AAE/C,yBAAW,QAAQ,KAAK,MAAM,SAAS,WAAW,YAAY,WAAW,oBAAoB,WAAW,WAAW,SAAS,EAAE,MAAM,CAAC;AAErI,mCAAqB,WAAW,WAAW,SAAS,EAAE;AAAA,YAC1D,OAAO;AACH,yBAAW,QAAQ,WAAW;AAAA,YAClC;AAAA,UACJ;AAEA,cAAI,WAAW,cAAc,MAAM,eAAe,aAAa;AAC3D,0BAAc,uBAAuB,WAAW;AAEhD,gBAAI,WAAW,cAAc,2BAA2B,WAAW,aAAa;AAC5E,qBAAO,cAAc;AAAA,YACzB;AAAA,UACJ;AAEA,cAAI,CAAC,eAAe,WAAW,QAAQ,KAAK,SAAS,MAAwB,KAAK,UAAU,WAAW,IAAI,KAAK,KAAK,aAAa,WAAW,IAAI,IAAI;AACjJ,yBAAa;AAAA,UACjB;AAEA,qBAAW,iBAAiB,aAAa,WAAW,OAAO,eAAe,UAAU;AAEpF,wBAAc,cAAc;AAC5B,wBAAc,mBAAmB;AACjC,qBAAW,mBAAmB,aAAa,WAAW,OAAO,eAAe,IAAI;AAEhF,cAAI,WAAW,gBAAgB,KAAK,WAAW,SAAS,gBAAgB;AACpE,uBAAW,mBAAmB,aAAa,WAAW,OAAO;AAAA,cACzD,sBAAsB;AAAA,cACtB,aAAa;AAAA,YACjB,GAAG,IAAI,EAAE,MAAM,GAAG,CAAC;AAAA,UACvB;AAEA,iBAAO;AAAA,QACX;AAGA,sBAAc,IAAI,aAAa,WAAW;AAC1C,sBAAc,QAAQ,WAAW;AAGjC,YAAI,YAAY,SAAS,GAAG;AACxB,cAAI,WAAW,SAAU,MAAM;AAC3B,mBAAO,KAAK,aAAa,SAAU,YAAY;AAC3C,qBAAO,WAAW,SAAS;AAAA,YAC/B,CAAC;AAAA,UACL;AAEA,cAAI,cAAc,SAAU,QAAQ;AAChC,gBAAI,mBAAmB,SAAS,OAAO,IAAI;AAE3C,gBAAI,CAAC,kBAAkB;AACnB;AAAA,YACJ;AAEA,iBAAK,OAAO,SAAS,SAAU,QAAQ;AACnC,kBAAI,mBAAmB,SAAS,OAAO,IAAI;AAE3C,kBAAI,CAAC,kBAAkB;AACnB;AAAA,cACJ;AAEA,kBAAI,SAAS,iBAAiB,kBAAkB,EAAE,MAAM,OAAO,OAAO;AAClE,iCAAiB,WAAW;AAC5B,iCAAiB,aAAa;AAC9B,iCAAiB,eAAe;AAChC,iCAAiB,YAAY;AAC7B,iCAAiB,cAAc;AAC/B,iCAAiB,eAAe;AAChC,iCAAiB,mBAAmB,iBAAiB,WAAW,SAAS;AACzE,0BAAU;AAAA,cACd;AAAA,YACJ,CAAC;AAAA,UACL;AAEA,eAAK,SAAS,WAAW;AAAA,QAC7B;AAGA,YAAI,SAAS;AACT,uBAAa;AACb,8BAAoB;AACpB,wBAAc,IAAI,aAAa,WAAW;AAC1C,wBAAc,QAAQ,WAAW;AAAA,QACrC;AAEA,YAAI,eAAe,EAAE,cAAc,CAAC,SAAS,OAAO;AAChD,wBAAc,IAAI,aAAa,SAAU,YAAY;AACjD,gBAAI,KAAK,aAAa,SAAU,YAAY;AACxC,qBAAO,WAAW,SAAS;AAAA,YAC/B,CAAC,GAAG;AACA,qBAAO;AAAA,YACX;AAEA,mBAAO;AAAA,UACX,CAAC;AAED,wBAAc,QAAQ,WAAW;AAAA,QACrC,OAAO;AAEH,cAAI,WAAW;AACX,0BAAc,KAAK,aAAa,SAAU,YAAY;AAKlD,qBAAO,CAAC,WAAW,cAAc,CAAC,WAAW,cAAc,CAAC,KAAK,UAAU,WAAW,IAAI;AAAA,YAC9F,CAAC;AAAA,UACL;AAGA,cAAI,WAAW,YAAY,QAAQ;AAC/B,0BAAc,YAAY,MAAM,GAAG,OAAO;AAAA,UAC9C;AAGA,cAAI,aAAa,YAAY,SAAS,GAAG;AACrC,0BAAc,QAAQ,aAAa,SAAU,YAAY;AAKrD,qBAAO,CAAC,WAAW,cAAc,CAAC,KAAK,UAAU,WAAW,IAAI,KAAK,CAAC,WAAW;AAAA,YACrF,CAAC;AAAA,UACL;AAGA,cAAI,SAAS;AACT,0BAAc,IAAI,aAAa,SAAU,YAAY,OAAO;AACxD,kBAAI,QAAQ,KAAK,QAAQ,YAAY,SAAS,KAAK,CAAC,WAAW,YAAY;AACvE,uBAAO;AAAA,cACX;AAEA,qBAAO;AAAA,YACX,CAAC;AAED,0BAAc,QAAQ,WAAW;AAAA,UACrC;AAGA,cAAI,aAAa,YAAY,WAAW,KAAK,CAAC,YAAY,CAAC,EAAE,cAAc,EAAE,CAAC,SAAS,YAAY,CAAC,EAAE,cAAc,YAAY,CAAC,EAAE,WAAW,WAAW;AACrJ,0BAAc,CAAC;AAAA,UACnB;AAAA,QACJ;AAEA,YAAI,mBAAmB;AACnB,iBAAO;AAAA,QACX;AAGA,aAAK,QAAQ,SAAU,OAAO;AAC1B,cAAI,MAAM,aAAa,MAAM,IAAI;AAEjC,cAAI,aAAa,KAAK,aAAa,SAAUC,aAAY;AACrD,mBAAOA,YAAW,SAAS,MAAM;AAAA,UACrC,CAAC;AAED,cAAI,CAAC,OAAO,CAAC,YAAY;AACrB;AAAA,UACJ;AAEA,cAAI,SAAS,WAAW,iBAAiB,MAAM,GAAG;AAElD,iBAAO,CAAC,IAAI,SAAS,OAAO,CAAC,GAAG,EAAE;AAElC,cAAI,OAAO,CAAC,GAAG;AACX,mBAAO,CAAC,IAAI,WAAW,OAAO,OAAO,CAAC,GAAG,EAAE;AAAA,UAC/C,OAAO;AACH,mBAAO,CAAC,IAAI;AAAA,UAChB;AAEA,cAAI,YAAY,WAAW,kBAAkB,KAAK,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC;AAEtE,cAAI,SAAS,kBAAkB,KAAK,UAAU;AAE9C,cAAI,gBAAgB;AAEpB,cAAI,mBAAmB,CAAC;AAGxB,eAAK,WAAW,qBAAqB,SAAU,WAAW;AACtD,gBAAI,QAAQ,KAAK,QAAQ,SAAUC,QAAO;AACtC,qBAAOA,OAAM,SAAS,UAAU,QAAQA,OAAM,QAAQ;AAAA,YAC1D,CAAC;AAED,gBAAI,OAAO;AACP,+BAAiB,MAAM,IAAI,IAAI,MAAM;AAErC,kBAAI,eAAe,MAAM,MAAM,UAAU,MAAM,GAAG;AAC9C,sBAAM,OAAO,MAAM,KAAK,QAAQ,UAAU,QAAQ,MAAM,KAAK;AAC7D,gCAAgB;AAAA,cACpB;AAAA,YACJ;AAAA,UACJ,CAAC;AAGD,cAAI,aAAa,CAAC,eAAe;AAC7B,mBAAO,KAAK,oBAAoB;AAEhC,iBAAK,QAAQ,SAAU,OAAO;AAC1B,kBAAI,iBAAiB,MAAM,IAAI,MAAM,MAAM,OAAO;AAC9C,oBAAI,eAAe,MAAM,MAAM,MAAM,KAAK,GAAG;AAGzC,yBAAO;AAAA,gBACX;AAIA;AAAA,cACJ;AAEA,kBAAI,eAAe,MAAM,MAAM,MAAM,KAAK,GAAG;AAEzC,sBAAM,OAAO,MAAM,KAAK,QAAQ,MAAM,OAAO,iBAAiB,MAAM,IAAI,CAAC;AACzE,uBAAO;AAAA,cACX;AAAA,YACJ,CAAC;AAAA,UACL;AAAA,QACJ,CAAC;AAGD,iBAAS,IAAI,QAAQ,SAAU,OAAO;AAClC,cAAI,CAAC,MAAM,MAAM;AACb,mBAAO,MAAM;AAAA,UACjB;AAEA,cAAI,aAAa,KAAK,aAAa,SAAUD,aAAY;AACrD,mBAAOA,YAAW,SAAS,MAAM;AAAA,UACrC,CAAC;AAED,cAAI,CAAC,YAAY;AACb,mBAAO;AAAA,UACX;AAEA,cAAI,MAAM;AAEV,cAAI,cAAc;AACd,mBAAO,MAAM;AAAA,UACjB;AAEA,cAAI,cAAc,cAAc,CAAC,cAAc,YAAY;AACvD,mBAAO;AACP,yBAAa;AACb,yBAAa;AAAA,UACjB;AAEA,cAAI,cAAc,cAAc,CAAC,cAAc,YAAY;AACvD,mBAAO;AACP,yBAAa;AACb,yBAAa;AAAA,UACjB;AAEA,cAAI,eAAe,WAAW,QAAQ,KAAK,SAAS,MAAM,KAAK,UAAU,WAAW,IAAI,KAAK,KAAK,aAAa,WAAW,IAAI,IAAI;AAC9H,mBAAO;AACP,yBAAa;AAAA,UACjB;AAEA,cAAI,MAAM,SAAS,kBAAkB,WAAW,kBAAkB;AAC9D,mBAAO,WAAW;AAAA,UACtB,OAAO;AACH,mBAAO,WAAW;AAAA,UACtB;AAEA,cAAI,CAAC,cAAc;AACf,mBAAO,MAAM;AAAA,UACjB;AAEA,iBAAO;AAAA,QACX,CAAC;AAGD,eAAO,OAAO,KAAK,EAAE,EAAE,QAAQ,gBAAgB,EAAE,EAAE,QAAQ,gBAAgB,EAAE;AAAA,MACjF;AAGA,eAAS,wBAAwB;AAC7B,YAAI,MAAM,KAAK;AAEf,YAAI,WAAW,SAASE,UAAS,MAAM;AACnC,iBAAO,IAAI,MAAM,IAAI;AAAA,QACzB;AAEA,YAAI,YAAY,KAAK,KAAK,OAAO,QAAQ;AAEzC,YAAI,WAAW,SAAS,KAAK,OAAO,QAAQ;AAG5C,gBAAQ,WAAW;AAAA,UACf,KAAK;AACD,mBAAO;AAAA,UACX,KAAK;AAAA,UACL,KAAK;AACD,mBAAO;AAAA,UACX,KAAK;AACD,mBAAO;AAAA,UACX,KAAK;AACD,gBAAI,cAAc,UAAU;AACxB,qBAAO;AAAA,YACX;AAAA,UACJ,KAAK;AACD,gBAAI,cAAc,UAAU;AACxB,qBAAO;AAAA,YACX;AAEA,gBAAI,KAAK,SAAS,MAAM;AACpB,mBAAK,OAAO;AAAA,YAChB;AAEA,mBAAO;AAAA,UACX,KAAK;AACD,gBAAI,cAAc,UAAU;AACxB,qBAAO;AAAA,YACX;AAAA,UACJ,KAAK;AACD,gBAAI,cAAc,UAAU;AACxB,qBAAO;AAAA,YACX;AAEA,gBAAI,KAAK,SAAS,MAAM;AACpB,mBAAK,OAAO;AAAA,YAChB;AAEA,mBAAO;AAAA,UACX;AACI,gBAAI,KAAK,SAAS,MAAM;AACpB,mBAAK,OAAO;AAAA,YAChB;AAEA,mBAAO;AAAA,QACf;AAAA,MACJ;AAGA,eAAS,KAAK,SAAS;AACnB,YAAI,CAAC,SAAS;AACV,gBAAM;AAAA,QACV;AAEA,gBAAQ,SAAS,SAAS;AAC1B,gBAAQ,SAAS,GAAG,SAAS;AAE7B,gBAAQ,SAAS,GAAG,OAAO,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UA0BlC,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAQN,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAOV,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA,UAMT,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA,UAMV,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAQV,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA,UAMX,OAAO;AAAA;AAAA;AAAA;AAAA,UAKP,aAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAQb,YAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAYZ,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAWX,cAAc;AAAA;AAAA;AAAA,UAId,aAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAQb,sBAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAStB,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA,UAMV,mBAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAWnB,mBAAmB;AAAA;AAAA;AAAA;AAAA,UAKnB,kBAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAQlB,UAAU,CAAC,CAAC;AAAA,QAChB;AAEA,gBAAQ,aAAa,MAAM,SAAS;AAAA,MACxC;AAGA,UAAI,0BAA0B,SAAS,QAAQ,QAAQ,SAAS;AAC5D,eAAO,OAAO,eAAe,QAAQ,OAAO;AAAA,MAChD;AAEA,4BAAsB,8BAA8B,KAAK,qBAAqB,uBAAuB;AACrG,oCAA8B,uBAAuB,6BAA6B,uBAAuB;AAGzG,UAAI,4BAA4B,SAAS,QAAQ,QAAQ,SAAS;AAC9D,YAAI,OAAO,WAAW,eAAe,UAAU,OAAO,QAAQ,OAAO,KAAK,cAAc;AACpF,iBAAO,OAAO,KAAK,aAAa,QAAQ,OAAO,EAAE,OAAO,MAAM;AAAA,QAClE;AAAA,MACJ;AAEA,8BAAwB,qBAAqB,yBAAyB;AACtE,sCAAgC,yBAAyB,6BAA6B,yBAAyB;AAG/G,WAAK,MAAM;AAIX,aAAO;AAAA,IACX,CAAC;AAAA;AAAA;",
  "names": ["token", "momentType", "label", "findType"]
}
