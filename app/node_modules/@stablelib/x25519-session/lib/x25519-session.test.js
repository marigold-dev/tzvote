"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
const hex_1 = require("@stablelib/hex");
const keyagreement_1 = require("./keyagreement");
// For testing with generated test vectors, instead of proper PRNG
// use the deterministic generator that generates byte sequences
// of 0, 1, 2, 3, ... that was used to create vectors.
class BadSource {
    constructor(v = 0) {
        this.v = v;
        this.isAvailable = true;
    }
    randomBytes(length) {
        const out = new Uint8Array(length);
        for (let i = 0; i < out.length; i++) {
            out[i] = this.v;
            this.v = (this.v + 1) & 0xff;
        }
        return out;
    }
}
const testVector = {
    offerMsg: "8F40C5ADB68F25624AE5B214EA767A6EC94D829D3D7B5E1AD1BA6F3E2138285F",
    acceptMsg: "79A631EEDE1BF9C98F12032CDEADD0E7A079398FC786B88CC846EC89AF85A51A",
    sharedKey: "6D54CC9C397E31691401110F58DA1E182A635D7E44C21DC2D7BE93624652AB15"
};
describe("X25519Session", () => {
    it("should establish a shared secret and session keys", () => {
        for (let i = 0; i < 5; i++) {
            const server = new keyagreement_1.X25519Session();
            const offerMsg = server.offer();
            const client = new keyagreement_1.X25519Session();
            const acceptMsg = client.accept(offerMsg);
            server.finish(acceptMsg);
            const serverKey = server.getSharedKey();
            const clientKey = client.getSharedKey();
            expect((0, hex_1.encode)(serverKey)).toEqual((0, hex_1.encode)(clientKey));
            const serverSessionKeys = server.getSessionKeys();
            const clientSessionKeys = client.getSessionKeys();
            expect((0, hex_1.encode)(serverSessionKeys.send)).not.toEqual((0, hex_1.encode)(serverSessionKeys.receive));
            expect((0, hex_1.encode)(serverSessionKeys.send)).toEqual((0, hex_1.encode)(clientSessionKeys.receive));
            expect((0, hex_1.encode)(serverSessionKeys.receive)).toEqual((0, hex_1.encode)(clientSessionKeys.send));
        }
    });
    it("should match test vector", () => {
        const serverPrng = new BadSource(0);
        const server = new keyagreement_1.X25519Session(undefined, serverPrng);
        const offerMsg = server.offer();
        expect("offerMsg: " + (0, hex_1.encode)(offerMsg))
            .toEqual("offerMsg: " + testVector.offerMsg);
        const clientPrng = new BadSource(64);
        const client = new keyagreement_1.X25519Session(undefined, clientPrng);
        const acceptMsg = client.accept(offerMsg);
        expect("acceptMsg: " + (0, hex_1.encode)(acceptMsg))
            .toEqual("acceptMsg: " + testVector.acceptMsg);
        server.finish(acceptMsg);
        expect((0, hex_1.encode)(server.getSharedKey())).toEqual(testVector.sharedKey);
        expect((0, hex_1.encode)(client.getSharedKey())).toEqual(testVector.sharedKey);
    });
});
//# sourceMappingURL=x25519-session.test.js.map